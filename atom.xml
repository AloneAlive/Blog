<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunwengang blog</title>
  
  <subtitle>wizzie</subtitle>
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://alonealive.github.io/Blog/"/>
  <updated>2020-10-15T12:44:00.005Z</updated>
  <id>https://alonealive.github.io/Blog/</id>
  
  <author>
    <name>sunwengang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Q SurfaceFlinger合成（一）</title>
    <link href="https://alonealive.github.io/Blog/2020/10/15/2020/201015_android_SurfaceFlinger1/"/>
    <id>https://alonealive.github.io/Blog/2020/10/15/2020/201015_android_SurfaceFlinger1/</id>
    <published>2020-10-15T12:52:00.000Z</published>
    <updated>2020-10-15T12:44:00.005Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在HWUI渲染完成后，Buffer会在<code>frameworks/native/libs/gui/BufferQueueProducer.cpp</code>中通过queueBuffer放入BufferQueue，在该函数中调用<code>frameAvailableListener-&gt;onFrameAvailable(item)</code>通知consumer消费者，从而触发SurfaceFlinger合成。</p></blockquote><a id="more"></a><h2 id="onFrameAvailable触发合成"><a href="#onFrameAvailable触发合成" class="headerlink" title="onFrameAvailable触发合成"></a>onFrameAvailable触发合成</h2><ol><li>上面的frameAvailableListener对象类型是<code>sp&lt;IConsumerListener&gt; frameAvailableListener;</code></li></ol><p>参考<a href="https://wizzie.top/Blog/2020/07/30/2020/200730_android_GraphicsFramework/" target="_blank" rel="noopener">Android 图形显示框架</a>中的《Surface创建流程》，在该流程中会创建BufferQueue，调用<code>BufferQueue::createBufferQueue</code>函数。</p><ol start="2"><li>而<code>class ProxyConsumerListener : public BnConsumerListener...</code>是IConsumerListener接口的Bn端，所以会调用到下面代码：</li></ol><p>BufferQueue中的frameAvailableListener，是一个IConsumerListener的接口，对应的Binder的Bn端实现为ProxyConsumerListener。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/BufferQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件中</span></span><br><span class="line">wp&lt;ConsumerListener&gt; mConsumerListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BufferQueue::ProxyConsumerListener::onFrameAvailable(</span><br><span class="line">        <span class="keyword">const</span> BufferItem&amp; item) &#123;</span><br><span class="line">    <span class="function">sp&lt;ConsumerListener&gt; <span class="title">listener</span><span class="params">(mConsumerListener.promote())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        listener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在ConsumerBase.h中该类继承ConsumerListener。所以此处的mConsumerListener是ConsumerBase中的实现。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/include/gui/ConsumerBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerBase</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase,</span><br><span class="line">        <span class="keyword">protected</span> ConsumerListener &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/ConsumerBase.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerBase::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    CB_LOGV(<span class="string">"onFrameAvailable"</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;FrameAvailableListener&gt; listener;</span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameAvailableMutex)</span></span>;</span><br><span class="line">        listener = mFrameAvailableListener.promote();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CB_LOGV(<span class="string">"actually calling onFrameAvailable"</span>);</span><br><span class="line">        listener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在BufferQueueLayer中，<code>class BufferQueueLayer : public BufferLayer, public BufferLayerConsumer::ContentsChangedListener{......}</code>。</li></ol><p>而<code>class BufferLayerConsumer : public ConsumerBase...</code></p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferQueueLayer::onFrameAvailable</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        <span class="keyword">if</span> (mFlinger-&gt;mUseSmart90ForVideo) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> presentTime = item.mIsAutoTimestamp ? <span class="number">0</span> : item.mTimestamp;</span><br><span class="line">            mFlinger-&gt;mScheduler-&gt;addLayerPresentTimeAndHDR(mSchedulerLayerHandle, presentTime,</span><br><span class="line">                                                            item.mHdrMetadata.validTypes != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mQueueItemLock)</span></span>;</span><br><span class="line">        <span class="comment">// FrameNumber被重置时，同时重置mLastFrameNumberReceived</span></span><br><span class="line">        <span class="keyword">if</span> (item.mFrameNumber == <span class="number">1</span>) &#123;</span><br><span class="line">            mLastFrameNumberReceived = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//确保mFrameNumber的顺序</span></span><br><span class="line">        <span class="keyword">while</span> (item.mFrameNumber != mLastFrameNumberReceived + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> result = mQueueItemCondition.waitRelative(mQueueItemLock, ms2ns(<span class="number">500</span>));</span><br><span class="line">            <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">                ALOGE(<span class="string">"[%s] Timed out waiting on callback"</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将新的buffer放入Layer队列中，同时对mQueuedFrames+1操作</span></span><br><span class="line">        mQueueItems.push_back(item);</span><br><span class="line">        mQueuedFrames++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">        mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">        mQueueItemCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//buffer属性保存到mInterceptor中</span></span><br><span class="line">    mFlinger-&gt;mInterceptor-&gt;saveBufferUpdate(<span class="keyword">this</span>, item.mGraphicBuffer-&gt;getWidth(),</span><br><span class="line">                                             item.mGraphicBuffer-&gt;getHeight(), item.mFrameNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRemovedFromCurrentState()) &#123;</span><br><span class="line">        fakeVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//触发LayerUpdate</span></span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">    mConsumer-&gt;onBufferAvailable(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ol><li>BufferQueueLayer有专门的Consumer，即BufferLayerConsumer。BufferLayerConsumer继承ConsumerBase。ConsumerBase通过IGraphicBufferConsumer和BufferQueue进行通信。  </li><li>BufferQueue中的frameAvailableListener，是一个IConsumerListener的接口，对应的Binder的Bn端实现为<code>ProxyConsumerListener</code>。</li><li>BufferQueueLayer实现了ContentsChangedListener，ContentsChangedListener继承FrameAvailableListener。BufferQueueLayer的Listener实现，被传给了ConsumerBase。  </li><li><code>ConsumerBase实现ConsumerListener接口，构建ConsumerBase时，会创建ProxyConsumerListener</code>，将ConsumerBase实现的Listener接口传给ProxyConsumerListener。</li><li>BufferQueue中Listener回调时，会回调到ConsumerBase中。ConsumerBase中再通过BufferQueueLayer实现的，传下来的Listener回调到BufferLayer中。</li></ol><p><img src="SF-%E6%B6%88%E8%B4%B9%E8%80%85onFrameAvailable.png" alt="消费者onFrameAvailable触发类图"></p><hr><h2 id="MessageQueue消息队列"><a href="#MessageQueue消息队列" class="headerlink" title="MessageQueue消息队列"></a>MessageQueue消息队列</h2><blockquote><p>Android的消息处理机制请参考：<a href="https://wizzie.top/Blog/2019/09/22/2019/190922-android-handler-cpp/#SurfaceFlinger%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Android Handler消息循环处理机制(例ActivityThread)</a></p></blockquote><p>在SurfaceFlinger模块有单独的MessageQueue处理流程。在SF创建的时候，构造函数会创建<code>meventqueue</code>对象。在其onFirstRef函数中调用<code>mEventQueue-&gt;init(this);</code>进行初始化。</p><p>MessageQueue初始化时，创建了一个Looper和Handler。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::init</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger)</span> </span>&#123;</span><br><span class="line">    mFlinger = flinger;</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">true</span>);</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setEventThread变更"><a href="#setEventThread变更" class="headerlink" title="setEventThread变更"></a>setEventThread变更</h3><p>在Android Q中，EventThread的<code>setEventThread</code>操作具体在<code>SurfaceFlinger::enableVSyncInjections</code>中进行。</p><p>而非之前的是在SurfaceFlinger的init初始化函数中。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="comment">//mEventQueue是MessageQueue的一个栈对象</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;MessageQueue&gt; mEventQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::enableVSyncInjections</span><span class="params">(<span class="keyword">bool</span> enable)</span> </span>&#123;</span><br><span class="line">    postMessageSync(<span class="keyword">new</span> LambdaMessage([&amp;] &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(b/128863962): Part of the Injector should be refactored, so that it</span></span><br><span class="line">        <span class="comment">// can be passed to Scheduler.</span></span><br><span class="line">        <span class="keyword">if</span> (enable) &#123;</span><br><span class="line">            ALOGV(<span class="string">"VSync Injections enabled"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mVSyncInjector.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                mVSyncInjector = <span class="built_in">std</span>::make_unique&lt;InjectVSyncSource&gt;();</span><br><span class="line">                mInjectorEventThread = <span class="built_in">std</span>::make_unique&lt;</span><br><span class="line">                        impl::EventThread&gt;(mVSyncInjector.get(),</span><br><span class="line">                                           impl::EventThread::InterceptVSyncsCallback(),</span><br><span class="line">                                           <span class="string">"injEventThread"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mEventQueue-&gt;setEventThread(mInjectorEventThread.get(), <span class="built_in">std</span>::move(resyncCallback));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"VSync Injections disabled"</span>);</span><br><span class="line">            mEventQueue-&gt;setEventThread(mScheduler-&gt;getEventThread(mSfConnectionHandle),</span><br><span class="line">                                        <span class="built_in">std</span>::move(resyncCallback));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mInjectVSyncs = enable;</span><br><span class="line">    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setEventThread函数做了两件事：</p><ol><li>创建一个BitTube对象mEventTube</li><li>创建一个EventConnection</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件，是BitTube对象</span></span><br><span class="line">gui::BitTube mEventTube;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::setEventThread</span><span class="params">(android::EventThread* eventThread,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ResyncCallback resyncCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mEventThread == eventThread) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEventTube.getFd() &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLooper-&gt;removeFd(mEventTube.getFd());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mEventThread = eventThread;</span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection(<span class="built_in">std</span>::move(resyncCallback));</span><br><span class="line">    <span class="comment">//将mEventTube和EventConnection关联</span></span><br><span class="line">    mEvents-&gt;stealReceiveChannel(&amp;mEventTube);</span><br><span class="line">    <span class="comment">//将fd添加到MessageQueue的Looper中</span></span><br><span class="line">    <span class="comment">//Looper的callback（入参）为MessageQueue::cb_eventReceiver</span></span><br><span class="line">    <span class="comment">//一旦有数据到来就会调用cb_eventReceiver</span></span><br><span class="line">    mLooper-&gt;addFd(mEventTube.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver,</span><br><span class="line">                   <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//data为MessageQueue本身有数据到来就会调用，作用是负责处理EventThread发送过来的信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建connection</span></span><br><span class="line"><span class="function">sp&lt;EventThreadConnection&gt; <span class="title">EventThread::createEventConnection</span><span class="params">(ResyncCallback resyncCallback)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventThreadConnection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>), <span class="built_in">std</span>::move(resyncCallback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Connection创建的时候先调用OnFirstRef进行注册</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThreadConnection::onFirstRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> mEventThread doesn't hold a strong reference on us</span></span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册，将Connection将会被添加到mDisplayEventConnections 中</span></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventThread::registerDisplayEventConnection</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this should never happen</span></span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">std</span>::find(mDisplayEventConnections.cbegin(),</span><br><span class="line">            mDisplayEventConnections.cend(), connection);</span><br><span class="line">    <span class="keyword">if</span> (it != mDisplayEventConnections.cend()) &#123;</span><br><span class="line">        ALOGW(<span class="string">"DisplayEventConnection %p already exists"</span>, connection.get());</span><br><span class="line">        mCondition.notify_all();</span><br><span class="line">        <span class="keyword">return</span> ALREADY_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayEventConnections.push_back(connection); <span class="comment">//添加</span></span><br><span class="line">    mCondition.notify_all();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建BitTube对象，构造函数会调用init函数：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/BitTube.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> DEFAULT_SOCKET_BUFFER_SIZE = <span class="number">4</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">BitTube::BitTube(<span class="keyword">size_t</span> bufsize) &#123;</span><br><span class="line">    init(bufsize, bufsize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认创建一个4k的BitTube，BitTube封装的是一对socket，一个发送，一个接收，可传输的Buffer大小为4K</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BitTube::init</span><span class="params">(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// since we don't use the "return channel", we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd.reset(sockets[<span class="number">0</span>]);</span><br><span class="line">        mSendFd.reset(sockets[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd.reset();</span><br><span class="line">        ALOGE(<span class="string">"BitTube: pipe creation failed (%s)"</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BitTube::getFd</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mReceiveFd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="signalLayerUpdate通知Layer更新信息"><a href="#signalLayerUpdate通知Layer更新信息" class="headerlink" title="signalLayerUpdate通知Layer更新信息"></a>signalLayerUpdate通知Layer更新信息</h2><p>接着上面第一部分的流程，触发SF的合成从signalLayerUpdate开始。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalLayerUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mScheduler-&gt;resetIdleTimer();</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到MessageQueue的invalidate函数。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求下一个Vsync（垂直同步机制），主要作用是通知Vsync机制在下一个SF的Vsync到来的时候唤醒SF进行工作，从而进行合成处理。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThreadConnection::requestNextVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"requestNextVsync"</span>);</span><br><span class="line">    mEventThread-&gt;requestNextVsync(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::requestNextVsync</span><span class="params">(<span class="keyword">const</span> sp&lt;EventThreadConnection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;resyncCallback) &#123;</span><br><span class="line">        connection-&gt;resyncCallback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="comment">//如果为空，则赋值，并且触发notify</span></span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;vsyncRequest == VSyncRequest::None) &#123;</span><br><span class="line">        connection-&gt;vsyncRequest = VSyncRequest::Single;</span><br><span class="line">        mCondition.notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">VSyncRequest</span> &#123;</span></span><br><span class="line">    None = <span class="number">-1</span>,</span><br><span class="line">    Single = <span class="number">0</span>,</span><br><span class="line">    Periodic = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// Subsequent values are periods.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后会触发threadmain函数，这个和Android P上的threadloop流程是不同的。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::threadMain</span><span class="params">(<span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;&amp; lock)</span> </span>&#123;</span><br><span class="line">    DisplayEventConsumers consumers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mState != State::Quit) &#123;</span><br><span class="line">        <span class="built_in">std</span>::optional&lt;DisplayEventReceiver::Event&gt; event;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Determine next event to dispatch.</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingEvents.empty()) &#123;</span><br><span class="line">            event = mPendingEvents.front();</span><br><span class="line">            mPendingEvents.pop_front();</span><br><span class="line">            <span class="comment">//event处理两种事件：</span></span><br><span class="line">            <span class="comment">//1. 热插拔事件</span></span><br><span class="line">            <span class="comment">//2. vsync事件</span></span><br><span class="line">            <span class="keyword">switch</span> (event-&gt;header.type) &#123;</span><br><span class="line">                <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                    <span class="keyword">if</span> (event-&gt;hotplug.connected &amp;&amp; !mVSyncState) &#123;</span><br><span class="line">                        mVSyncState.emplace(event-&gt;header.displayId);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!event-&gt;hotplug.connected &amp;&amp; mVSyncState &amp;&amp;</span><br><span class="line">                               mVSyncState-&gt;displayId == event-&gt;header.displayId) &#123;</span><br><span class="line">                        mVSyncState.reset();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                    <span class="keyword">if</span> (mInterceptVSyncsCallback) &#123;</span><br><span class="line">                        <span class="comment">//有vsync事件要分发</span></span><br><span class="line">                        mInterceptVSyncsCallback(event-&gt;header.timestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> vsyncRequested = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find connections that should consume this event.</span></span><br><span class="line">        <span class="keyword">auto</span> it = mDisplayEventConnections.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mDisplayEventConnections.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> connection = it-&gt;promote()) &#123;</span><br><span class="line">                vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (event &amp;&amp; shouldConsumeEvent(*event, connection)) &#123;</span><br><span class="line">                    consumers.push_back(connection);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++it;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it = mDisplayEventConnections.erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!consumers.empty()) &#123;</span><br><span class="line">            <span class="comment">//分发事件</span></span><br><span class="line">            dispatchEvent(*event, consumers);</span><br><span class="line">            consumers.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        State nextState;</span><br><span class="line">        <span class="keyword">if</span> (mVSyncState &amp;&amp; vsyncRequested) &#123;</span><br><span class="line">            nextState = mVSyncState-&gt;synthetic ? State::SyntheticVSync : State::VSync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGW_IF(!mVSyncState, <span class="string">"Ignoring VSYNC request while display is disconnected"</span>);</span><br><span class="line">            nextState = State::Idle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mState != nextState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mState == State::VSync) &#123;</span><br><span class="line">                mVSyncSource-&gt;setVSyncEnabled(<span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextState == State::VSync) &#123;</span><br><span class="line">                mVSyncSource-&gt;setVSyncEnabled(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mState = nextState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Wait for event or client registration/request.</span></span><br><span class="line">        <span class="keyword">if</span> (mState == State::Idle) &#123;</span><br><span class="line">            mCondition.wait(lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate a fake VSYNC after a long timeout in case the driver stalls. When the</span></span><br><span class="line">            <span class="comment">// display is off, keep feeding clients at 60 Hz.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> timeout = mState == State::SyntheticVSync ? <span class="number">16</span>ms : <span class="number">1000</span>ms;</span><br><span class="line">            <span class="keyword">if</span> (mCondition.wait_for(lock, timeout) == <span class="built_in">std</span>::cv_status::timeout) &#123;</span><br><span class="line">                ALOGW_IF(mState == State::VSync, <span class="string">"Faking VSYNC due to driver stall"</span>);</span><br><span class="line"></span><br><span class="line">                LOG_FATAL_IF(!mVSyncState);</span><br><span class="line">                mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId,</span><br><span class="line">                                                   systemTime(SYSTEM_TIME_MONOTONIC),</span><br><span class="line">                                                   ++mVSyncState-&gt;count));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line">    <span class="comment">// State machine for event loop.</span></span><br><span class="line">    <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">        Idle,</span><br><span class="line">        Quit,</span><br><span class="line">        SyntheticVSync,</span><br><span class="line">        VSync,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="VSYNC事件到来"><a href="#VSYNC事件到来" class="headerlink" title="VSYNC事件到来"></a>VSYNC事件到来</h3><p>将会回调onVSyncEvent：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onVSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    LOG_FATAL_IF(!mVSyncState);</span><br><span class="line">    mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count));</span><br><span class="line">    mCondition.notify_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hotplug事件到来"><a href="#Hotplug事件到来" class="headerlink" title="Hotplug事件到来"></a>Hotplug事件到来</h3><p>将会回调onHotplugReceived：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::onHotplugReceived</span><span class="params">(PhysicalDisplayId displayId, <span class="keyword">bool</span> connected)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">    mPendingEvents.push_back(makeHotplug(displayId, systemTime(), connected));</span><br><span class="line">    mCondition.notify_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="dispatchEvent分发事件"><a href="#dispatchEvent分发事件" class="headerlink" title="dispatchEvent分发事件"></a>dispatchEvent分发事件</h3><p>从上面的threadMain函数会调用dispatchEvent函数分发事件：</p><p>Connection通过postEvent将Event抛出来后，通过sendEvents将事件发出去。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EventThread::dispatchEvent</span><span class="params">(<span class="keyword">const</span> DisplayEventReceiver::Event&amp; event,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> DisplayEventConsumers&amp; consumers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; consumer : consumers) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">switch</span> (consumer-&gt;postEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">case</span> NO_ERROR:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> -EAGAIN:</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Try again if pipe is full.</span></span><br><span class="line">                ALOGW(<span class="string">"Failed dispatching %s for %s"</span>, toString(event).c_str(),</span><br><span class="line">                      toString(*consumer).c_str());</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// Treat EPIPE and other errors as fatal.</span></span><br><span class="line">                removeDisplayEventConnectionLocked(consumer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">EventThreadConnection::postEvent</span><span class="params">(<span class="keyword">const</span> DisplayEventReceiver::Event&amp; event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayEventReceiver中是通过BitTube将事件发出去，sendObjects注意这里的参数:</p><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/DisplayEventReceiver.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">DisplayEventReceiver::sendEvents</span><span class="params">(gui::BitTube* dataChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gui::BitTube::sendObjects(dataChannel, events, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MessageQueue处理Message"><a href="#MessageQueue处理Message" class="headerlink" title="MessageQueue处理Message"></a>MessageQueue处理Message</h3><p>SF的线程run时，有一个死循环，循环等待事件：</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        waitForEvent();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::waitForEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mEventQueue-&gt;waitMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MessageQueue中，会有looper一直循环等待消息。</p><p>waitMessage，通过采用一个死循环，处理Looper的pollOnce。Looper内部的主要是采用epoll_wait对fd进行监听，BitTube发送Event对象后，epoll_wait结束，调用callback，处理事件。</p><p>可参考Handler文章：<a href="https://wizzie.top/Blog/2019/09/22/2019/190922-android-handler-cpp/#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81" target="_blank" rel="noopener">Android Handler消息循环处理机制</a></p><figure class="highlight cpp"><figcaption><span>MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::waitMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">        <span class="keyword">int32_t</span> ret = mLooper-&gt;pollOnce(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> Looper::POLL_WAKE:</span><br><span class="line">            <span class="keyword">case</span> Looper::POLL_CALLBACK:</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> Looper::POLL_ERROR:</span><br><span class="line">                ALOGE(<span class="string">"Looper::POLL_ERROR"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> Looper::POLL_TIMEOUT:</span><br><span class="line">                <span class="comment">// timeout (should not happen)</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// should not happen</span></span><br><span class="line">                ALOGE(<span class="string">"Looper::pollOnce() returned unknown status %d"</span>, ret);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue对应的callback为cb_eventReceiver：</p><figure class="highlight cpp"><figcaption><span>MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        INVALIDATE = <span class="number">0</span>,</span><br><span class="line">        REFRESH = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::cb_eventReceiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue*&gt;(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MessageQueue::eventReceiver</span><span class="params">(<span class="keyword">int</span> <span class="comment">/*fd*/</span>, <span class="keyword">int</span> <span class="comment">/*events*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                mHandler-&gt;dispatchInvalidate();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sendMessage</code>在Handler.java中调用到MessageQueue.java的<code>enqueueMessage</code>函数，然后调用JNI函数nativeWake，唤醒Looper.java的loop函数。</p><p>调用其中的dispatchMessage处理消息。</p><p>dispatchMessage函数会调用handleMessage函数，开始处理消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="onMessageReceived处理INVALIDATE消息"><a href="#onMessageReceived处理INVALIDATE消息" class="headerlink" title="onMessageReceived处理INVALIDATE消息"></a>onMessageReceived处理INVALIDATE消息</h2><p>MessageQueue触发Handler消息处理机制，开始触发INVALIDATE消息合成。</p><p><strong>大体分成两部分：</strong></p><ol><li>SF更新合成相关的信息（即handleMessageTransaction）</li><li>SF执行合成相关的操作并显示</li></ol><figure class="highlight cpp"><figcaption><span>SurfaceFlinger.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="comment">//systrace抓取</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            <span class="comment">//丢帧处理</span></span><br><span class="line">            <span class="keyword">bool</span> frameMissed = previousFrameMissed();</span><br><span class="line">            <span class="keyword">bool</span> hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed;</span><br><span class="line">            <span class="keyword">bool</span> gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed;</span><br><span class="line">            ATRACE_INT(<span class="string">"FrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">            ATRACE_INT(<span class="string">"HwcFrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(hwcFrameMissed));</span><br><span class="line">            ATRACE_INT(<span class="string">"GpuFrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(gpuFrameMissed));</span><br><span class="line">            <span class="keyword">if</span> (frameMissed) &#123;</span><br><span class="line">                mFrameMissedCount++;</span><br><span class="line">                mTimeStats-&gt;incrementMissedFrames();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hwcFrameMissed) &#123;</span><br><span class="line">                mHwcFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (gpuFrameMissed) &#123;</span><br><span class="line">                mGpuFrameMissedCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mUseSmart90ForVideo) &#123;</span><br><span class="line">                <span class="comment">// This call is made each time SF wakes up and creates a new frame. It is part</span></span><br><span class="line">                <span class="comment">// of video detection feature.</span></span><br><span class="line">                mScheduler-&gt;updateFpsBasedOnContent();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (performSetActiveConfig()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (frameMissed &amp;&amp; mPropagateBackpressure) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) ||</span><br><span class="line">                    mPropagateBackpressureClientComposition) &#123;</span><br><span class="line">                    signalLayerUpdate();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新VR</span></span><br><span class="line">            updateVrFlinger();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理Transition，在合成前更新Layer的信息</span></span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line"></span><br><span class="line">            updateCursorAsync();</span><br><span class="line">            updateInputFlinger();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">//如果Transaction事务修改了窗口状态，则发出刷新信号</span></span><br><span class="line">                <span class="comment">//一个新的buffer将被请求</span></span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一、丢帧处理frameMissed"><a href="#一、丢帧处理frameMissed" class="headerlink" title="一、丢帧处理frameMissed"></a>一、丢帧处理frameMissed</h3><p>如果丢帧，则<code>mPropagateBackpressure</code>为true。</p><p>该变量是在SurfaceFlinger的构造函数中，由<code>debug.sf.disable_backpressure</code>属性控制。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">property_get(<span class="string">"debug.sf.disable_backpressure"</span>, value, <span class="string">"0"</span>);</span><br><span class="line"> mPropagateBackpressure = !atoi(value);</span><br><span class="line"> ALOGI_IF(!mPropagateBackpressure, <span class="string">"Disabling backpressure propagation"</span>);</span><br><span class="line"></span><br><span class="line"> property_get(<span class="string">"debug.sf.enable_gl_backpressure"</span>, value, <span class="string">"0"</span>);</span><br><span class="line"> mPropagateBackpressureClientComposition = atoi(value);</span><br><span class="line"> ALOGI_IF(mPropagateBackpressureClientComposition,</span><br><span class="line">          <span class="string">"Enabling backpressure propagation for Client Composition"</span>);</span><br></pre></td></tr></table></figure><p>例如我的一加六 Android Q设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell getprop debug.sf.disable_backpressure</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="二、handleMessageTransaction处理Transaction"><a href="#二、handleMessageTransaction处理Transaction" class="headerlink" title="二、handleMessageTransaction处理Transaction"></a>二、handleMessageTransaction处理Transaction</h3><p>Vsync到来后，触发INVALIDATE消息时会先处理Transition。</p><p>如上代码先调用<code>handleMessageTransaction</code>。这个过程就是处理应用传过来的各种Transaction。</p><p><strong>大致函数调用流程：</strong></p><p><strong>handleMessageTransaction -&gt; handleTransaction -&gt; <code>handleTransactionLocked</code> -&gt; (processDisplayChangesLocked) -&gt; commitTransaction()</strong></p><p>handleMessageTransaction主要处理Layer属性变化，显示设备变化等情况，最终将变化的信息mCurrentState提交到mDrawingState, 等待合成处理.</p><p>即最终<code>commitTransaction</code>函数会有个状态更替，将mCurrentState赋值给了mDrawingState。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::commitTransaction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">     withTracingLock([&amp;]() &#123;</span><br><span class="line">        mDrawingState = mCurrentState;</span><br><span class="line">        <span class="comment">// clear the "changed" flags in current state</span></span><br><span class="line">        mCurrentState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            layer-&gt;commitChildList();</span><br><span class="line">            <span class="keyword">if</span> (mOffscreenLayers.count(layer)) &#123;</span><br><span class="line">                mOffscreenLayers.erase(layer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        commitOffscreenLayers();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    mTransactionPending = <span class="literal">false</span>;</span><br><span class="line">    mAnimTransactionPending = <span class="literal">false</span>;</span><br><span class="line">    mTransactionCV.broadcast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mCurrentState和mDrawingState"><a href="#mCurrentState和mDrawingState" class="headerlink" title="mCurrentState和mDrawingState"></a>mCurrentState和mDrawingState</h4><blockquote><p>可参考：<a href="https://wizzie.top/Blog/2019/12/22/2019/191222_android_HWC2/#mCurrentState%E5%92%8CmDrawingState" target="_blank" rel="noopener">Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState</a></p></blockquote><ul><li>mCurrentState状态：准备数据，应用传过来的数据保存在mCurrentState中。</li><li>mDrawingState状态：进程合成状态，需要进行合成的数据保存在mDrawingState中。</li></ul><p>即每次合成时，先更新一下状态数据。每一层Layer也需要去更新状态数据。</p><h3 id="handleTransactionLocked"><a href="#handleTransactionLocked" class="headerlink" title="handleTransactionLocked"></a>handleTransactionLocked</h3><h4 id="1-检查mCurrentState的Layer的可见区域"><a href="#1-检查mCurrentState的Layer的可见区域" class="headerlink" title="1. 检查mCurrentState的Layer的可见区域"></a>1. 检查mCurrentState的Layer的可见区域</h4><p><strong>该函数第一部分就是遍历mCurrentState的Layer，并检查Layer的可见区域VisableRegion是否发生变化。</strong></p><ul><li>如果没发生变化则不需要检查layer</li><li>如果发生变化，则对比该Layer的显示区域和原来的显示区域是否发生变化，若变化则设置mVisibleRegionsDirty为true</li></ul><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    <span class="comment">// Notify all layers of available frames</span></span><br><span class="line">    mCurrentState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;notifyAvailableFrames();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历mCurrentState中的所有的layer</span></span><br><span class="line">    <span class="keyword">if</span> ((transactionFlags &amp; eTraversalNeeded) || mTraversalNeededMainThread) &#123;</span><br><span class="line">        mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="comment">//根据eTransactionNeeded判断Layer是否发生变化（如果Layer发生变化则会设置这个flag）</span></span><br><span class="line">            <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">            <span class="keyword">if</span> (!trFlags) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//对发生变化的layer执行doTransaction函数，对比Layer旧的状态和新的状态是否发生变化</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//判断Layer的可见区域是否发生变化</span></span><br><span class="line">            <span class="comment">//当Layer的可见区域大小发生变化之后，设置mVisibleRegionsDirty为true</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eInputInfoChanged) &#123;</span><br><span class="line">                mInputInfoChanged = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mTraversalNeededMainThread = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-检查显示设备是否变化"><a href="#2-检查显示设备是否变化" class="headerlink" title="2. 检查显示设备是否变化"></a>2. 检查显示设备是否变化</h4><p><strong>该函数第二部分先调用<code>processDisplayChangesLocked</code>函数。</strong></p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//第一部分</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="comment">//如果需要，执行显示自己的事务</span></span><br><span class="line">    <span class="comment">//遍历并检查所有的显示设备，检查显示设备是否发生了增加或者减少.并做相应的处理</span></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">        processDisplayChangesLocked();</span><br><span class="line">        processDisplayHotplugEventsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eDisplayLayerStackChanged|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ...&#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::processDisplayChangesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义两个列表保存上次合成时显示设备的信息和当前显示设备的信息</span></span><br><span class="line">    <span class="comment">//当前显示设备的信息</span></span><br><span class="line">    const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    <span class="comment">//上次合成时的显示设备的信息（上次合成的mDrawingState信息，本地还未开始正式合成操作）</span></span><br><span class="line">    const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前和上次的设备信息是否发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">        <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到被删除的显示设备(在draw状态而不是current状态的列表中，说明有设备删除)</span></span><br><span class="line">        <span class="comment">//处理发生变化的设备（两个列表都存在该设备）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; dc;) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 1. 删除显示设备：in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> display = getDisplayDeviceLocked(draw.keyAt(i))) &#123;</span><br><span class="line">                    <span class="comment">// 断开前保存设备ID（Save display ID before disconnecting.）</span></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">                    display-&gt;disconnect();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!display-&gt;isVirtual()) &#123;</span><br><span class="line">                        LOG_ALWAYS_FATAL_IF(!displayId);</span><br><span class="line">                        dispatchDisplayHotplugEvent(displayId-&gt;value, <span class="literal">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mDisplays.erase(draw.keyAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//设备在两个列表都存在，但是有信息发生变化</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; displayToken = curr.keyAt(j);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> display = getDisplayDeviceLocked(displayToken)) &#123;</span><br><span class="line">                        display-&gt;disconnect();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.erase(displayToken);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新显示设备信息</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> display = getDisplayDeviceLocked(displayToken)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;   <span class="comment">//Layer栈</span></span><br><span class="line">                        display-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation) || </span><br><span class="line">                        (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123;  <span class="comment">//旋转状态、viewport、frame帧</span></span><br><span class="line">                        display-&gt;setProjection(state.orientation, state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;  <span class="comment">//宽高</span></span><br><span class="line">                        display-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到新添加的Display设备（在current状态列表，而不再draw列表中）</span></span><br><span class="line">        <span class="comment">//即创建主屏对应的DisplayDevice</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; cc; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;compositionengine::DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                getFactory().createBufferQueue(&amp;bqProducer, &amp;bqConsumer, <span class="literal">false</span>);   <span class="comment">//创建BufferQueue</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">std</span>::optional&lt;DisplayId&gt; displayId;</span><br><span class="line">                <span class="comment">//虚拟显示设备</span></span><br><span class="line">                <span class="keyword">if</span> (state.isVirtual()) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface != <span class="literal">nullptr</span>,</span><br><span class="line">                             <span class="string">"adding a supported display, but rendering "</span></span><br><span class="line">                             <span class="string">"surface is provided (%p), ignoring it"</span>,</span><br><span class="line">                             state.surface.get());</span><br><span class="line">                    <span class="comment">//给新的显示设备添加Display id，并且创建framebufferSurface消费者</span></span><br><span class="line">                    displayId = state.displayId;</span><br><span class="line">                    LOG_ALWAYS_FATAL_IF(!displayId);</span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(getHwComposer(), *displayId, bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; displayToken = curr.keyAt(i);</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    mDisplays.emplace(displayToken,</span><br><span class="line">                                      setupNewDisplayDeviceInternal(displayToken, displayId, state,</span><br><span class="line">                                                                    dispSurface, producer));</span><br><span class="line">                    <span class="keyword">if</span> (!state.isVirtual()) &#123;</span><br><span class="line">                        LOG_ALWAYS_FATAL_IF(!displayId);</span><br><span class="line">                        dispatchDisplayHotplugEvent(displayId-&gt;value, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.displays = mCurrentState.displays;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-更新mCurrentState中Layer的transform-hint信息"><a href="#3-更新mCurrentState中Layer的transform-hint信息" class="headerlink" title="3. 更新mCurrentState中Layer的transform hint信息"></a>3. 更新mCurrentState中Layer的transform hint信息</h4><p><strong>第三部分：继续执行<code>handleTransactionLocked</code>函数，更新transform hint相关信息</strong></p><h4 id="4-更新Layer信息"><a href="#4-更新Layer信息" class="headerlink" title="4. 更新Layer信息"></a>4. 更新Layer信息</h4><p><strong>第四部分：更新Layer信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    <span class="comment">//当显示设备发生变化或者Layer发生变化，需要修改layer的transform hint，使得Layer视图的矩阵变化</span></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eDisplayLayerStackChanged|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//遍历mCurrentState所有layer</span></span><br><span class="line">        mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!hintDisplay) &#123;</span><br><span class="line">                <span class="comment">//如果显示在过个显示设备上，则使用默认显示设备</span></span><br><span class="line">                hintDisplay = getDefaultDisplayDeviceLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hintDisplay) &#123;</span><br><span class="line">                <span class="comment">//更新layer的transform hint</span></span><br><span class="line">                layer-&gt;updateTransformHint(hintDisplay);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mLayersAdded) &#123;</span><br><span class="line">        mLayersAdded = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// Layers have been added.</span></span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//=============================</span></span><br><span class="line">    <span class="comment">//第四部分：更新Layer信息</span></span><br><span class="line">    <span class="comment">//如果有Layer移除， 该Layer原先的显示区域就是需要更新显示区域</span></span><br><span class="line">    <span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">        mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLayersPendingRemoval.indexOf(layer) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">                Region visibleReg;</span><br><span class="line">                visibleReg.<span class="built_in">set</span>(layer-&gt;getScreenBounds());</span><br><span class="line">                invalidateLayerStack(layer, visibleReg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    commitInputWindowCommands();</span><br><span class="line">    <span class="comment">//所有变化的信息更新完成后，mCurrentState提交到mDrawingState中</span></span><br><span class="line">    commitTransaction();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-信息更新完成，mCurrentState提交到mDrawingState"><a href="#5-信息更新完成，mCurrentState提交到mDrawingState" class="headerlink" title="5. 信息更新完成，mCurrentState提交到mDrawingState"></a>5. 信息更新完成，mCurrentState提交到mDrawingState</h4><p>执行到commitTransaction函数就代表所有Layer信息更新完成，下一步开始合成显示这些变化后的内容（mDrawingState）</p><hr><h3 id="三、handleMessageInvalidate"><a href="#三、handleMessageInvalidate" class="headerlink" title="三、handleMessageInvalidate"></a>三、handleMessageInvalidate</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handleMessageInvalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">//调用handlePageFlip，见下一小节的流程，该函数会从BufferQueue中获取Buffer</span></span><br><span class="line">    <span class="keyword">bool</span> refreshNeeded = handlePageFlip();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersPendingRefresh) &#123;</span><br><span class="line">        Region visibleReg;</span><br><span class="line">        visibleReg.<span class="built_in">set</span>(layer-&gt;getScreenBounds());</span><br><span class="line">        <span class="comment">//见下</span></span><br><span class="line">        invalidateLayerStack(layer, visibleReg);</span><br><span class="line">    &#125;</span><br><span class="line">    mLayersPendingRefresh.clear();</span><br><span class="line">    <span class="keyword">return</span> refreshNeeded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Android支持多个屏幕，layer可以定制化的只显示到某个显示屏幕上。其中就是靠layerStack(Layer栈)来实现的</span></span><br><span class="line"><span class="comment">//Layer的stack值如果和DisplayDevice的stack值一样，说明这个layer是属于这个显示屏幕的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::invalidateLayerStack</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> Layer&gt;&amp; layer, <span class="keyword">const</span> Region&amp; dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">if</span> (display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123;</span><br><span class="line">            display-&gt;editState().dirtyRegion.orSelf(dirty);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="handlePageFlip"><a href="#handlePageFlip" class="headerlink" title="handlePageFlip"></a>handlePageFlip</h4><p>mLayersWithQueuedFrames用于标记有Frame的Layer，详细处理查看上面对<code>BufferQueueLayer::onFrameAvailable</code>函数的注解。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::handlePageFlip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"handlePageFlip"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> latchTime = systemTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> newDataLatched = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历mDrawingState的Layer，将需要合成的layer添加到mLayersWithQueuedFrames列表中</span></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;hasReadyFrame()) &#123;</span><br><span class="line">            frameQueued = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">nsecs_t</span> expectedPresentTime;</span><br><span class="line">            expectedPresentTime = mScheduler-&gt;expectedPresentTime();</span><br><span class="line">            <span class="comment">//frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp:BufferQueueLayer::shouldPresentNow()</span></span><br><span class="line">            <span class="comment">//此处shouldPresentNow的判断逻辑：</span></span><br><span class="line">            <span class="comment">//1. 计算期望显示的时间，然后看Buffer的时间戳和期望显示的时间。</span></span><br><span class="line">            <span class="comment">//如果Buffer的时间还没到，且和期望显示的时间差不到1秒，则该shouldPresentNow逻辑成立</span></span><br><span class="line">            <span class="comment">//否则使用空的DamageRegion</span></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;shouldPresentNow(expectedPresentTime)) &#123;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                mLayersWithQueuedFrames.push_back(layer);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ATRACE_NAME(<span class="string">"!layer-&gt;shouldPresentNow()"</span>);</span><br><span class="line">                layer-&gt;useEmptyDamage();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mLayersWithQueuedFrames.empty()) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">        <span class="comment">//遍历mLayersWithQueuedFrames中的Layer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">            <span class="comment">//latchBuffer是从BufferQueue中获取Buffer，并将其绑定到Layer对应的纹理中</span></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;latchBuffer(visibleRegions, latchTime)) &#123;</span><br><span class="line">                <span class="comment">//添加到mLayersPendingRefresh列表中</span></span><br><span class="line">                mLayersPendingRefresh.push_back(layer);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//更新Surface的Damage</span></span><br><span class="line">            layer-&gt;useSurfaceDamage();</span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;isBufferLatched()) &#123;</span><br><span class="line">                newDataLatched = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有BufferQueue过来，但是还没有到显示时间（mLayersWithQueuedFrames为空），或者没有获取到Buffer，则重新触发一次更新</span></span><br><span class="line">    <span class="keyword">if</span> (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enter boot animation on first buffer latch</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Enter boot animation"</span>);</span><br><span class="line">        mBootStage = BootStage::BOOTANIMATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>注意，所有的mLayersWithQueuedFrames都会走上面和下面的流程，每个Layer有自己的BufferLayerConsumer和BufferQueue。</p><h4 id="latchBuffer-gt-updateTexImage-gt-acquireBuffer"><a href="#latchBuffer-gt-updateTexImage-gt-acquireBuffer" class="headerlink" title="latchBuffer-&gt;updateTexImage-&gt;acquireBuffer"></a>latchBuffer-&gt;updateTexImage-&gt;acquireBuffer</h4><blockquote><p>详细流程可参考：<a href="https://wizzie.top/Blog/2020/07/30/2020/200730_android_GraphicsFramework/#BufferQueue" target="_blank" rel="noopener">Android 图形显示框架之BufferQueue-acquire&amp;release</a></p></blockquote><p>该函数中调用<code>updateTexImage</code>，而这个关键函数回去获取Buffer。</p><p>拿到Buffer后，将Buffer保存在<code>mSlots[slot].mGraphicBuffer</code>中。同时更新mFrameNumber和mFence。</p><p>该函数<code>updateTexImage</code>有几种返回处理结果：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferQueueLayer::updateTexImage</span><span class="params">(<span class="keyword">bool</span>&amp; recomputeVisibleRegions, <span class="keyword">nsecs_t</span> latchTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">status_t</span> updateResult = mConsumer-&gt;updateTexImage(&amp;r, expectedPresentTime, &amp;mAutoRefresh,</span><br><span class="line">                                                      &amp;queuedBuffer, maxFrameNumberToAcquire);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PRESENT_LATER：稍后显示，暂时不显示，并且触发SurfaceFlinger刷新（更新Layer数据）</span></span><br><span class="line">    <span class="keyword">if</span> (updateResult == BufferQueue::PRESENT_LATER) &#123;</span><br><span class="line">        mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    <span class="comment">//BUFFER_REJECTED：Buffer被Reject掉，这一帧数据不再显示，从mQueueItems中删除这一帧，同时mQueuedFrames减一</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult == BufferLayerConsumer::BUFFER_REJECTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (queuedBuffer) &#123;</span><br><span class="line">            Mutex::Autolock lock(mQueueItemLock);</span><br><span class="line">            mFlinger-&gt;mTimeStats-&gt;removeTimeRecord(layerID, mQueueItems[<span class="number">0</span>].mFrameNumber);</span><br><span class="line">            mQueueItems.removeAt(<span class="number">0</span>);</span><br><span class="line">            mQueuedFrames--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    <span class="comment">//更新失败或出错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (updateResult != NO_ERROR || mUpdateTexImageFailed) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用BufferLayerConsumer的updateTexImage，在acquireBufferLocked请求Buffer后，释放上一个Buffer，更新Buffer</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateTexImage</span><span class="params">(BufferRejecter* rejecter, <span class="keyword">nsecs_t</span> expectedPresentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">bool</span>* autoRefresh, <span class="keyword">bool</span>* queuedBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, expectedPresentTime, maxFrameNumber);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//释放上一个Buffer， 更新Buffer</span></span><br><span class="line">    err = updateAndReleaseLocked(item, &amp;mPendingRelease);</span><br><span class="line">    ...</span><br><span class="line">                                             &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BufferLayerConsumer::updateAndReleaseLocked</span><span class="params">(<span class="keyword">const</span> BufferItem&amp; item,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     PendingRelease* pendingRelease)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slot = item.mSlot;                                                        </span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//释放旧的Buffer - release old buffer</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingRelease == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> status =</span><br><span class="line">                    releaseBufferLocked(mCurrentTexture, mCurrentTextureBuffer-&gt;graphicBuffer());</span><br><span class="line">            <span class="keyword">if</span> (status &lt; NO_ERROR) &#123;</span><br><span class="line">                BLC_LOGE(<span class="string">"updateAndRelease: failed to release buffer: %s (%d)"</span>, strerror(-status),</span><br><span class="line">                         status);</span><br><span class="line">                err = status;</span><br><span class="line">                <span class="comment">// keep going, with error raised [?]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pendingRelease-&gt;currentTexture = mCurrentTexture;</span><br><span class="line">            pendingRelease-&gt;graphicBuffer = mCurrentTextureBuffer-&gt;graphicBuffer();</span><br><span class="line">            pendingRelease-&gt;isPending = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Buffer - Update the BufferLayerConsumer state.</span></span><br><span class="line">    mCurrentTexture = slot;</span><br><span class="line">    mCurrentTextureBuffer = nextTextureBuffer;</span><br><span class="line">    mCurrentCrop = item.mCrop;</span><br><span class="line">    mCurrentTransform = item.mTransform;</span><br><span class="line">    mCurrentScalingMode = item.mScalingMode;</span><br><span class="line">    mCurrentTimestamp = item.mTimestamp;</span><br><span class="line">    mCurrentDataSpace = <span class="keyword">static_cast</span>&lt;ui::Dataspace&gt;(item.mDataSpace);</span><br><span class="line">    mCurrentHdrMetadata = item.mHdrMetadata;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line">    mCurrentFenceTime = item.mFenceTime;</span><br><span class="line">    mCurrentFrameNumber = item.mFrameNumber;</span><br><span class="line">    mCurrentTransformToDisplayInverse = item.mTransformToDisplayInverse;</span><br><span class="line">    mCurrentSurfaceDamage = item.mSurfaceDamage;</span><br><span class="line">    mCurrentApi = item.mApi;</span><br><span class="line"></span><br><span class="line">    computeCurrentTransformMatrixLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br></pre></td></tr></table></figure><p>然后将通过消费者<code>acquireBufferLocked</code>函数请求Buffer。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/ConsumerBase.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">ConsumerBase::acquireBufferLocked</span><span class="params">(BufferItem *item,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> presentWhen, <span class="keyword">uint64_t</span> maxFrameNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAbandoned) &#123;</span><br><span class="line">        CB_LOGE(<span class="string">"acquireBufferLocked: ConsumerBase is abandoned!"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="四、Invalidate流程小结（正式合成刷新前的准备工作）"><a href="#四、Invalidate流程小结（正式合成刷新前的准备工作）" class="headerlink" title="四、Invalidate流程小结（正式合成刷新前的准备工作）"></a>四、Invalidate流程小结（正式合成刷新前的准备工作）</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    <span class="comment">//systrace抓取</span></span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//处理Transition，在合成前更新Layer的信息</span></span><br><span class="line">            <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            refreshNeeded |= handleMessageInvalidate();</span><br><span class="line"></span><br><span class="line">            updateCursorAsync();</span><br><span class="line">            updateInputFlinger();</span><br><span class="line"></span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">//如果Transaction事务修改了窗口状态，则发出刷新信号</span></span><br><span class="line">                <span class="comment">//一个新的buffer将被请求</span></span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的分析就是INVALIDATE的基本流程，该过程主要处理SurfaceFlinger距上次合成后的一些变化信息：</p><ol><li>handleMessageTransaction处理Layer属性变化、显示设备变化、更新显示设备的transform hint信息、处理Layer移除和增加等相关的信息等情况，将变化信息mCurrentState提交到mDrawingState，等待合成处理</li><li>handleMessageInvalidate更新了Layer的Buffer内容（通过LatchBuffer函数从BufferQueue中获取）到Layer的纹理</li><li>mRepaintEverything表示HWC硬件要求强制刷新</li></ol><hr><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.jianshu.com/p/fa115146949f" target="_blank" rel="noopener">SurfaceFlinger合成流程(一)</a></li><li><a href="https://www.jianshu.com/p/fd16dcb4dfb6" target="_blank" rel="noopener">SurfaceFlinger合成流程(二)</a></li><li><a href="https://wizzie.top/Blog/2019/09/22/2019/190922-android-handler-cpp/#SurfaceFlinger%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Android Handler消息循环处理机制</a></li><li><a href="https://wizzie.top/Blog/2020/07/30/2020/200730_android_GraphicsFramework/" target="_blank" rel="noopener">Android 图形显示框架</a></li><li><a href="https://blog.csdn.net/u013686019/article/details/51614774" target="_blank" rel="noopener">Android BitTube</a></li><li><a href="https://blog.csdn.net/dabenxiong666/article/details/80629316" target="_blank" rel="noopener">Android之BitTube</a></li><li><a href="https://blog.csdn.net/weixin_41054077/article/details/105735639" target="_blank" rel="noopener">基于Android Q分析SurfaceFlinger启动过程</a></li><li><a href="https://wizzie.top/Blog/2019/12/22/2019/191222_android_HWC2/#mCurrentState%E5%92%8CmDrawingState" target="_blank" rel="noopener">Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState</a></li><li><a href="https://www.jianshu.com/p/b0928eaaeb1c" target="_blank" rel="noopener">SurfaceFlinger图像合成[1]</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在HWUI渲染完成后，Buffer会在&lt;code&gt;frameworks/native/libs/gui/BufferQueueProducer.cpp&lt;/code&gt;中通过queueBuffer放入BufferQueue，在该函数中调用&lt;code&gt;frameAvailableListener-&amp;gt;onFrameAvailable(item)&lt;/code&gt;通知consumer消费者，从而触发SurfaceFlinger合成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android protobuf(.proto文件)</title>
    <link href="https://alonealive.github.io/Blog/2020/08/15/2020/200815_android_protobuf/"/>
    <id>https://alonealive.github.io/Blog/2020/08/15/2020/200815_android_protobuf/</id>
    <published>2020-08-15T13:42:00.000Z</published>
    <updated>2020-08-16T11:49:53.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近碰到一个关于<code>frameworks/base/core/proto/android/providers/settings/secure.proto</code>文件中修改某个属性的问题，所以针对protobuf(.proto文件)进行一个学习了解。<br>Google Protocol Buffers，（简称Protobuf，协议缓冲区），类似json或XML，Google开源的支持多语言、跨平台的结构化数据序列化项目，但是比它们更小、更快、更简单。<br>Protobuf通过编写proto文件来定义消息格式或RPC服务定义。</p></blockquote><a id="more"></a><h2 id="proto模块介绍"><a href="#proto模块介绍" class="headerlink" title="proto模块介绍"></a>proto模块介绍</h2><p>在Framework模块中有个单独的模块：<code>frameworks/base/core/proto/</code></p><p>查看该模块下的README.md和OWNDER文件有简单介绍。OWNER劝告开发人员需要熟悉该功能，谨慎修改。</p><h3 id="README-md文件内容"><a href="#README-md文件内容" class="headerlink" title="README.md文件内容"></a>README.md文件内容</h3><ol><li>Android其他版本中，使用四个空格缩进，而非两个</li><li>基于Java文件的protos文件，使用该Java文件相同名称的包。例如<code>com.android.server.thing</code>代替<code>com.android.server.thing.proto</code></li><li>如果proto描述了dumpsys的顶级输出，他就应该包含dump。这样更容易理解他是作为某个服务的dump输出，而不是该服务的数据结构。例如<code>WindowManagerServiceDumpProto</code>和<code>WindowManagerServiceProto</code></li></ol><ul><li>含有poroto后缀的message名称，他的内嵌的message的名称不需要有proto后缀，例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">message FooProto &#123;</span><br><span class="line">    message Bar &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&amp;&amp;</span><br><span class="line"></span><br><span class="line">message FooProto &#123;</span><br><span class="line">    message BarProto &#123;  <span class="comment">//没必要有proto后缀</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果proto代表一个对象的结构，后缀应该要有<code>proto</code>。并且还请包含该原是对象的完整包路径，来作为对这个proto message的注释。</p><ol start="4"><li><p>在字段中包含单位名字，例如：<code>screen_time_ms</code> VS <code>screen_time</code>, or <code>file_size_bytes</code> or <code>file_size_mebibytes</code> VS <code>file_size</code></p></li><li><p>保留字段号50000-100000，供原始设备制造商使用。</p></li></ol><hr><h2 id="编写proto文件"><a href="#编写proto文件" class="headerlink" title="编写proto文件"></a>编写proto文件</h2><h3 id="范例helloworld-proto"><a href="#范例helloworld-proto" class="headerlink" title="范例helloworld.proto"></a>范例helloworld.proto</h3><blockquote><p>代码在<a href="https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto" target="_blank" rel="noopener">https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto</a></p></blockquote><figure class="highlight plain"><figcaption><span>helloworld.proto</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;版本号，默认版本是2</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">option java_multiple_files &#x3D; true;</span><br><span class="line">option java_package &#x3D; &quot;io.grpc.examples.helloworld&quot;;</span><br><span class="line">option java_outer_classname &#x3D; &quot;HelloWorldProto&quot;;</span><br><span class="line">option objc_class_prefix &#x3D; &quot;HLW&quot;;</span><br><span class="line"> </span><br><span class="line">package helloworld;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; The greeting service definition.</span><br><span class="line">service Greeter &#123;</span><br><span class="line">  &#x2F;&#x2F; Sends a greeting</span><br><span class="line">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; The request message containing the user&#39;s name.</span><br><span class="line">&#x2F;&#x2F; 一个message类型看上去像是Java class，由多个字段组成</span><br><span class="line">&#x2F;&#x2F;每一个字段都由类型、名称组成，位于等号右边的值不是字段默认值，而是字段编号，可以理解为字段身份的标识符，类似于数据库中的主键，不可重复</span><br><span class="line">&#x2F;&#x2F;标识符用于在编译后的二进制消息格式中对字段进行识别，一旦投入使用，字段的标识就不应该再改变。</span><br><span class="line">&#x2F;&#x2F;数字标签的范围是[1, 536870911]，其中19000～19999是保留数字。</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The response message containing the greetings</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query &#x3D; 1; </span><br><span class="line">  required int32 page_number &#x3D; 2;</span><br><span class="line">  optional int32 result_per_page &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="protobuf和其他编程语言的类型比较"><a href="#protobuf和其他编程语言的类型比较" class="headerlink" title="protobuf和其他编程语言的类型比较"></a>protobuf和其他编程语言的类型比较</h3><p><img src="protoType.png" alt="protobuf和其他编程语言的类型比较"></p><h3 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h3><p>字段编号是Protobuf的重要组成部分。它们用于标识二进制编码数据中的字段，这意味着它们不能从版本更改为服务版本。优点在于可以实现向后兼容性和向前兼容性。只要处理丢失值的可能性，客户端和服务就会忽略他们不知道的字段编号。</p><p>在二进制格式中，字段号与类型标识符组合在一起。1到15之间的字段编号可以使用其类型编码为单字节。从16到2047的数字需要2个字节。如果出于任何原因需要将超过2047个字段，则可以更高。字段号1到15的单字节标识符提供更好的性能，因此，你应将其用于最基本的常用字段。</p><h3 id="限定符说明"><a href="#限定符说明" class="headerlink" title="限定符说明"></a>限定符说明</h3><table><thead><tr><th align="center">限定符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">required</td><td align="center">必须字段，必须设置该字段的值</td></tr><tr><td align="center">optional</td><td align="center">可选字段，有选择性的设置或者不设置该字段的值</td></tr><tr><td align="center">repeated</td><td align="center">表示该字段可以被重复任意多次包含</td></tr></tbody></table><h3 id="包package"><a href="#包package" class="headerlink" title="包package"></a>包package</h3><p>可以用指定package以避免类型命名冲突：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>也可以用类型的全限定名来引用它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  ...</span><br><span class="line">  foo.bar.Open open &#x3D; 1;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>指定包名后，会对生成的代码产生影响，以Java为例，生成的类会以你指定的package作为包名。</p><h3 id="修改规则"><a href="#修改规则" class="headerlink" title="修改规则"></a>修改规则</h3><p>如果修改正在使用的proto文件，比如为类型增加一个字段，protobuf支持这种修改而不影响已有的服务，不过需要遵循一定的规则：</p><ol><li>不改变已有字段的字段编号 </li><li>当增加一个新的字段的时候，老系统序列化后的数据依然可以被新的格式所解析，只不过需要处理新加字段的缺省值。 </li><li>字段也可以被移除，但是建议<code>Reserved</code>这个字段，避免将来会使用这个字段 </li><li>int32, uint32, int64, uint64 和 bool类型都是兼容的 </li><li>sint32 和 sint64兼容，但是不和其它整数类型兼容 </li><li>string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes的话 </li><li>嵌入类型和bytes兼容，如果bytes包含一个消息的编码版本的话 </li><li>fixed32和sfixed32, fixed64和sfixed64 enum和int32, uint32, int64, uint64格式兼容</li></ol><h3 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h3><p>通过协议缓冲区（Protobuf）可以在其他消息中嵌套消息定义。 下面的示例演示如何创建嵌套消息类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Outer &#123;</span><br><span class="line">    message Inner &#123;</span><br><span class="line">        string text &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    Inner inner &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="repeated修饰符"><a href="#repeated修饰符" class="headerlink" title="repeated修饰符"></a>repeated修饰符</h3><p>如果一个字段被repeated修饰，则表示它是一个列表类型的字段，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  repeated string args &#x3D; 1 &#x2F;&#x2F; 等价于java中的List&lt;string&gt; args</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果希望可以预留一些数字标签或者字段可以使用reserved修饰符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">  &#x2F;&#x2F; string foo &#x3D; 3  &#x2F;&#x2F;编译报错，因为‘foo’已经被标为保留字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保留字段reserved"><a href="#保留字段reserved" class="headerlink" title="保留字段reserved"></a>保留字段reserved</h3><p>Protobuf中的向后兼容性保证依赖于始终表示相同数据项的字段编号。如果从服务新版本中的消息中删除了字段，则不应重复使用该字段编号。</p><p>可以使用reserved关键字强制执行此情况。</p><p>如果定义Stock的消息中删除某字段，则应保留其字段编号，如以下示例所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">syntax &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message Stock &#123;</span><br><span class="line"></span><br><span class="line">    reserved 3, 4;</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    string symbol &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以将reserved关键字用作将来可能添加的字段的占位符。 您可以使用<code>to</code>关键字将连续字段数表示为范围。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">syntax &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">message Info &#123;</span><br><span class="line"></span><br><span class="line">    reserved 2, 9 to 11, 15;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Any和OneOf字段"><a href="#Any和OneOf字段" class="headerlink" title="Any和OneOf字段"></a>Any和OneOf字段</h3><p>Protobuf提供了两个用于处理可能属于多个类型的值的更简单选项。</p><p>Any类型可以表示任何已知的Protobuf消息类型。</p><p>使用oneof关键字来指定在任何消息中只能设置一个字段范围中的一个字段。</p><ol><li>Any是Protobuf的”已知类型”：一系列有用的可重复使用的消息类型，具有所有支持语言的实现。若要使用Any类型，必须导入<code>google/protobuf/any.proto</code>定义</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">syntax &quot;proto3&quot;</span><br><span class="line"></span><br><span class="line">import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;</span><br><span class="line"></span><br><span class="line">message Stock &#123;</span><br><span class="line">    &#x2F;&#x2F; Stock-specific data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Currency &#123;</span><br><span class="line">    &#x2F;&#x2F; Currency-specific data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ChangeNotification &#123;</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    google.protobuf.Any instrument &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Oneof是一项语言功能：编译器在生成message类时处理oneof关键字。使用oneof指定ChangeNotification消息可能如下所示：</li></ol><p>在整个消息声明中，oneof集内的字段必须具有唯一的字段编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message Stock &#123;</span><br><span class="line">    &#x2F;&#x2F; Stock-specific data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Currency &#123;</span><br><span class="line">    &#x2F;&#x2F; Currency-specific data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ChangeNotification &#123;</span><br><span class="line">  int32 id &#x3D; 1;</span><br><span class="line">  oneof instrument &#123;</span><br><span class="line">    Stock stock &#x3D; 2;</span><br><span class="line">    Currency currency &#x3D; 3;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>设置属于oneof集一部分的任何字段都将自动清除该集中的任何其他字段。不能将repeated与oneof一起使用。相反，可以创建包含重复字段或oneof集的嵌套消息，以解决此限制。</li><li>oneof块中的字段不支持repeated。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>上面使用枚举来确定Oneof字段的类型。可以定义自己的枚举类型，Protobuf将它们编译为C#（或者其他语言）枚举类型。</p><p>由于Protobuf可以用于各种语言，因此枚举的命名约定与C#约定不同。</p><p>但是，代码生成器将名称转换为传统的C#大小写。如果字段名称的Pascal大小写以枚举名称开头，则将其删除。</p><p>例如，在下面的Protobuf枚举中，字段用预缀为ACCOUNT_STATUS。</p><p><strong>第一个枚举值的数值必须是0且至少有一个枚举值，否则编译报错。编译后编译器会为你生成对应语言的枚举类。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum AccountStatus &#123;</span><br><span class="line">  ACCOUNT_STATUS_UNKNOWN &#x3D; 0;</span><br><span class="line">  ACCOUNT_STATUS_PENDING &#x3D; 1;</span><br><span class="line">  ACCOUNT_STATUS_ACTIVE &#x3D; 2;</span><br><span class="line">  ACCOUNT_STATUS_SUSPENDED &#x3D; 3;</span><br><span class="line">  ACCOUNT_STATUS_CLOSED &#x3D; 4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编码原因，出于效率考虑，官方不推荐使用负数作为枚举值的数值。</p><h3 id="类型默认值"><a href="#类型默认值" class="headerlink" title="类型默认值"></a>类型默认值</h3><ol><li>string类型的默认值是空字符串</li><li>bytes类型的默认值是空字节</li><li>bool类型的默认值是false</li><li>数字类型的默认值是0</li><li>enum类型的默认值是第一个定义的枚举值</li><li>message类型的默认值与语言相关</li><li>repeated修饰的字段默认值是空列表</li></ol><h3 id="import-public的传递引用功能"><a href="#import-public的传递引用功能" class="headerlink" title="import public的传递引用功能"></a>import public的传递引用功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 文件：new.proto</span><br><span class="line">&#x2F;&#x2F; 原来在old.proto文件中的定义移到这里</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 文件：old.proto</span><br><span class="line">import public &quot;new.proto&quot;; &#x2F;&#x2F; 把引用传递给上层使用方</span><br><span class="line">import &quot;other.proto&quot;; &#x2F;&#x2F; 引用old.proto本身使用的定义</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 文件：client.proto</span><br><span class="line">import &quot;old.proto&quot;;</span><br><span class="line">&#x2F;&#x2F; 此处可以引用old.proto和new.proto中的定义，但不能使用other.proto中的定义</span><br></pre></td></tr></table></figure><p>从这个例子中可以看到<code>import</code>关键字导入的定义仅在当前文件有效，不能被上层使用方引用（client.proto无法使用other.proto中的定义）</p><p>而<code>import public</code>关键字导入的定义可以被上层使用方引用（client.proto可以使用new.proto中的定义），<code>import public</code>的功能可以看作是import的超集，在import的功能上还具有传递引用的作用。</p><h3 id="option选项"><a href="#option选项" class="headerlink" title="option选项"></a>option选项</h3><p>选项不对message的定义产生任何的效果，只会在一些特定的场景中起到作用：</p><ol><li><code>option java_package = &quot;com.example.foo&quot;;</code> 编译器为以此作为生成的Java类的包名，如果没有该选项，则会以pb的package作为包名。</li><li><code>option java_multiple_files = true;</code> 该选项为true时，生成的Java类将是包级别的，否则会在一个包装类中。</li><li><code>option optimize_for = CODE_SIZE;</code> 该选项会对生成的类产生影响，作用是根据指定的选项对代码进行不同方面的优化。</li><li><code>int32 old_field = 6 [deprecated=true];</code> 把字段标为过时的。</li></ol><hr><h2 id="protoBuf缺点"><a href="#protoBuf缺点" class="headerlink" title="protoBuf缺点"></a>protoBuf缺点</h2><p>Protbuf相比XML来说，主要优点是性能高。也有不足之处，功能简单，无法用来表示复杂的概念。</p><p>由于文本并不适合用来描述数据结构，所以Protobuf也不适合用来对基于文本的标记文档（如HTML建模。另外，由于XML具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上Protobuf以二进制的方式存储，除非有<code>.proto</code>定义，否则无法直接读出Protobuf的任何内容。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Google官方文档</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/overview" target="_blank" rel="noopener">Protobuf Github项目文档地址</a></li><li><a href="https://docs.microsoft.com/zh-cn/dotnet/architecture/grpc-for-wcf-developers/protobuf-reserved" target="_blank" rel="noopener">Protobuf 保留字段</a></li><li><a href="https://studygolang.com/articles/2540" target="_blank" rel="noopener">在Golang中安装使用Protobuf</a></li><li><a href="https://www.jianshu.com/p/ea656dc9b037" target="_blank" rel="noopener">Protobuf3学习笔记</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近碰到一个关于&lt;code&gt;frameworks/base/core/proto/android/providers/settings/secure.proto&lt;/code&gt;文件中修改某个属性的问题，所以针对protobuf(.proto文件)进行一个学习了解。&lt;br&gt;Google Protocol Buffers，（简称Protobuf，协议缓冲区），类似json或XML，Google开源的支持多语言、跨平台的结构化数据序列化项目，但是比它们更小、更快、更简单。&lt;br&gt;Protobuf通过编写proto文件来定义消息格式或RPC服务定义。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android ANR基本Log分析</title>
    <link href="https://alonealive.github.io/Blog/2020/08/06/2020/200806_android_ANR_BaseLog/"/>
    <id>https://alonealive.github.io/Blog/2020/08/06/2020/200806_android_ANR_BaseLog/</id>
    <published>2020-08-06T13:52:00.000Z</published>
    <updated>2020-08-07T13:40:32.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ANR（Application Not Responding），字面意思是应用无响应，即用户的一些操作无法从应用中获取反馈。关于发生ANR的trace.txt文件的请参考<a href="https://wizzie.top/Blog/2020/06/11/2020/200611_android_tracetxt/" target="_blank" rel="noopener">Android ANR traces.txt文件分析</a></p></blockquote><a id="more"></a><h2 id="触发原因"><a href="#触发原因" class="headerlink" title="触发原因"></a>触发原因</h2><p>Android系统中的应用被Activity Manager及Window Manager两个系统服务监控着，Android系统会在如下情况触发ANR：</p><ul><li>Input事件超过5s没有被处理完，即5秒内无法对输入事件（按键及触摸）做出响应</li><li>Service处理超时，前台20s，后台200s</li><li>BroadcastReceiver（广播接收器）处理超时，前台10S，后台60s</li><li>ContentProvider执行超时，比较少见</li></ul><p>出现ANR之后一个直观现象就是系统会展示出一个ANR弹框。</p><p>从发生的原因分：</p><ul><li>主线程有耗时操作，如有复杂的layout布局，IO操作等。</li><li>被Binder对端block</li><li>被子线程同步锁block</li><li>Binder被占满导致主线程无法和SystemServer通信</li><li>得不到系统资源（CPU/RAM/IO）</li></ul><p>从进程的角度分：</p><ul><li>问题出在当前进程:</li><li>主线程本身耗时, 或则主线程的消息队列存在耗时操作;</li><li>主线程被本进程的其他子线程所blocked;</li><li>问题出在远端进程(一般是binder call或socket等通信方式)</li></ul><h2 id="基本log解读"><a href="#基本log解读" class="headerlink" title="基本log解读"></a>基本log解读</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;进程是30970</span><br><span class="line">&#x2F;&#x2F;特殊情况下，如果PID是0，说明发生ANR之前，这个进程被LowMemoryKiller杀死了或者出现了Crash。这种情况下，是无法接收到系统的广播或者按键消息的，故而出现ANR</span><br><span class="line">&#x2F;&#x2F;ANR具体发生的包名</span><br><span class="line">08-01 19:17:05.155  1000  1304  1328 I am_anr  : [0,30970,com.android.systemui,551042573,Input dispatching timed out (StatusBar, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago.  Wait queue length: 54.  Wait queue head age: 9044.8ms.)]</span><br><span class="line">&#x2F;&#x2F;ANR具体发生的包名</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager: ANR in com.android.systemui</span><br><span class="line">&#x2F;&#x2F;ANR发生的原因是Input dispatching timed out</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager: PID: 30970</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager: Reason: Input dispatching timed out (StatusBar, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago.  Wait queue length: 54.  Wait queue head age: 9044.8ms.)</span><br><span class="line">&#x2F;&#x2F;三个数字分别是1分钟、5分钟、15分钟内系统的平均负荷</span><br><span class="line">&#x2F;&#x2F;当CPU完全空闲的时候，平均负荷为0；当CPU工作量饱和的时候，平均负荷为1，通过Load可以判断系统负荷是否过重</span><br><span class="line">&#x2F;&#x2F;大致可以这样区分：</span><br><span class="line">&#x2F;&#x2F;当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。</span><br><span class="line">&#x2F;&#x2F;当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。</span><br><span class="line">&#x2F;&#x2F;当系统负荷达到5.0，就表明你的系统有很严重的问题</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager: Load: 46.53 &#x2F; 37.82 &#x2F; 34.77</span><br><span class="line">&#x2F;&#x2F;ANR发生的时候，Top进程的Cpu占用情况，user代表是用户空间，kernel是内核空间</span><br><span class="line">&#x2F;&#x2F;查看每个CPU的使用频度：adb shell cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu1&#x2F;cpufreq&#x2F;stats&#x2F;time_in_state</span><br><span class="line">&#x2F;&#x2F;一般如下规律：</span><br><span class="line">&#x2F;&#x2F;1. kswapd0 cpu占用率偏高，系统整体运行会缓慢，从而引起各种ANR。把问题转给&quot;内存优化&quot;，请他们进行优化</span><br><span class="line">&#x2F;&#x2F;2. logd　CPU占用率偏高，也会引起系统卡顿和ANR，因为各个进程输出LOG的操作被阻塞从而执行的极为缓慢</span><br><span class="line">&#x2F;&#x2F;3. Vold占用CPU过高，会引起系统卡顿和ANR，请负责存储的同学先调查</span><br><span class="line">&#x2F;&#x2F;4. qcom.sensor CPU占用率过高，会引起卡顿，请系统同学调查</span><br><span class="line">&#x2F;&#x2F;5. 应用自身CPU占用率较高，高概率应用自身问题</span><br><span class="line">&#x2F;&#x2F;6. 应用处于D状态，发生ANR，如果最后的操作是refriger，那么是应用被冻结了，正常情况下是功耗优化引起的。</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager: CPU usage from 0ms to 23321ms later (2020-08-01 19:17:04.850 to 2020-08-01 19:17:28.171) with 99% awake:</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   36% 30970&#x2F;com.android.systemui: 25% user + 10% kernel &#x2F; faults: 11945 minor 24 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   35% 20903&#x2F;com.tencent.mobileqq:video: 28% user + 6.4% kernel &#x2F; faults: 6413 minor 23 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   28% 555&#x2F;surfaceflinger: 16% user + 12% kernel &#x2F; faults: 1846 minor 2 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   26% 498&#x2F;android.hardware.audio@5.0-service-***: 21% user + 4.9% kernel &#x2F; faults: 13 minor</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   18% 1304&#x2F;system_server: 9.5% user + 8.7% kernel &#x2F; faults: 9666 minor 329 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   17% 3919&#x2F;com.***.service: 10% user + 6.7% kernel &#x2F; faults: 8604 minor 30 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   16% 28827&#x2F;com.tencent.qqmusic: 9.2% user + 7.3% kernel &#x2F; faults: 9299 minor 18 major</span><br><span class="line">08-01 19:17:28.258  1000  1304  1328 E ActivityManager:   16% 142&#x2F;kswapd0: 0% user + 16% kernel</span><br><span class="line">...</span><br></pre></td></tr></table></figure><hr><h2 id="系统耗时分析方案"><a href="#系统耗时分析方案" class="headerlink" title="系统耗时分析方案"></a>系统耗时分析方案</h2><p>系统做一些耗时分析的操作会有一些Log标志：</p><ol><li><code>binder_sample</code>：</li></ol><ul><li>功能说明: 监控每个进程的主线程的binder transaction的耗时情况, 当超过阈值时,则输出相应的目标调用信息，默认1000ms打开。</li><li>log格式: <code>52004 binder_sample (descriptor|3),(method_num|1|5),(time|1|3),(blocking_package|3),(sample_percent|1|6)</code></li><li>log实例:</li></ul><p><code>2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5]</code></p><p>从上面的log中可以得出:</p><ul><li>主线程2754;</li><li>执行android.app.IActivityManager接口</li><li>所对应方法code =35(即STOP_SERVICE_TRANSACTION),</li><li>所花费时间为2900ms</li></ul><p>该block所在package为 android.process.media，最后一个参数是sample比例(没有太大价值)</p><ol start="2"><li><code>dvm_lock_sample</code></li></ol><ul><li>功能说明: 当某个线程等待lock的时间blocked超过阈值,则输出当前的持锁状态 ;</li><li>log格式: <code>20003 dvm_lock_sample (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6)</code></li></ul><p><code>进程名，主线程？线程名，锁等待时间，下个持有者文件名，行号，上个持有者文件名（如果和下个相同，则是-），行号，等待百分比</code></p><ul><li>log实例:</li></ul><p><code>dvm_lock_sample: [system_server,1,Binder_9,1500,ActivityManagerService.java,6403,-,1448,0]</code></p><p>意思是system_server: Binder_9,执行到ActivityManagerService.java的6403行代码,一直在等待AMS锁, 而该锁所同一文件的1448行代码所持有, 从而导致Binder_9线程被阻塞1500ms.</p><ol start="3"><li><code>binder starved</code></li></ol><ul><li>功能说明:当system_server等进程的线程池使用完, 无空闲线程时, 则binder通信都处于饥饿状态, 则饥饿状态超过一定阈值则输出信息;</li><li>云控参数: persist.sys.binder.starvation  (默认值16ms)</li><li>log实例:</li></ul><p><code>1232 1232 &quot;binder thread pool (16 threads) starved for 100 ms&quot;</code></p><p>解析: system_server进程的 线程池已满的持续长达100ms</p><hr><h2 id="kswapd0-CPU占用率很高"><a href="#kswapd0-CPU占用率很高" class="headerlink" title="kswapd0 CPU占用率很高"></a>kswapd0 CPU占用率很高</h2><p>如果出现kswapd0 cpu 占用率很高，可以先查看内存使用情况。</p><h3 id="proc-meminfo内存使用信息"><a href="#proc-meminfo内存使用信息" class="headerlink" title="/proc/meminfo内存使用信息"></a>/proc/meminfo内存使用信息</h3><p>例如以下，可用内存只有62MB。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">------ MEMORY INFO (&#x2F;proc&#x2F;meminfo) ------</span><br><span class="line">&#x2F;&#x2F;所有可用RAM大小 （即物理内存减去一些预留位和内核的二进制代码大小）</span><br><span class="line">&#x2F;&#x2F;可以认为是系统可供分配的内存总大小, 通常大小会比实际物理内存小</span><br><span class="line">MemTotal:        3844700 kB</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;LowFree与HighFree的总和</span><br><span class="line">&#x2F;&#x2F;当前系统空闲的内存大小，对应所有处于NR_FREE_PAGES状态的页框</span><br><span class="line">MemFree:           62100 kB</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;MemFree + Active(file) + Inactive(file) + SReclaimable 此外还考虑了内存压力水位(watermark)的情况，计算比较复杂，详细见 si_mem_available(). 这只是理论上系统可用的内存，即理论上可回收的内存，但是实际上能用的达不到这么多</span><br><span class="line">MemAvailable:     396584 kB</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用来给块设备做的缓冲大小（只记录文件系统的metadata以及 tracking in-flight pages，就是说 buffers是用来存储，目录里面有什么内容，权限等等。）</span><br><span class="line">Buffers:           10160 kB</span><br><span class="line">&#x2F;&#x2F;用来给文件做缓冲大小（直接用来记忆我们打开的文件）. 它不包括SwapCached</span><br><span class="line">Cached:           554704 kB</span><br><span class="line">&#x2F;&#x2F;已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I&#x2F;O端口</span><br><span class="line">SwapCached:        25312 kB</span><br><span class="line">&#x2F;&#x2F;最近经常被使用的内存，除非非常必要否则不会被移作他用</span><br><span class="line">Active:          1317228 kB</span><br><span class="line">&#x2F;&#x2F;最近不经常被使用的内存，非常用可能被用于其他途径</span><br><span class="line">Inactive:         659868 kB</span><br><span class="line">Active(anon):    1179772 kB</span><br><span class="line">Inactive(anon):   403532 kB</span><br><span class="line">Active(file):     137456 kB</span><br><span class="line">Inactive(file):   256336 kB</span><br><span class="line">Unevictable:      162512 kB</span><br><span class="line">Mlocked:          162512 kB</span><br><span class="line">&#x2F;&#x2F;交换空间的总和</span><br><span class="line">SwapTotal:       2113488 kB</span><br><span class="line">&#x2F;&#x2F;从RAM中被替换出暂时存在磁盘上的空间大小</span><br><span class="line">SwapFree:         405628 kB</span><br><span class="line">&#x2F;&#x2F;等待被写回到磁盘的内存大小</span><br><span class="line">Dirty:              1652 kB</span><br><span class="line">&#x2F;&#x2F;正在被写回到磁盘的内存大小</span><br><span class="line">Writeback:            20 kB</span><br><span class="line">AnonPages:       1571688 kB</span><br><span class="line">&#x2F;&#x2F;影射文件的大小</span><br><span class="line">Mapped:           340044 kB</span><br><span class="line">Shmem:              9360 kB</span><br><span class="line">&#x2F;&#x2F;内核数据结构缓存</span><br><span class="line">Slab:             233948 kB</span><br><span class="line">SReclaimable:      66952 kB</span><br><span class="line">SUnreclaim:       166996 kB</span><br><span class="line">KernelStack:       72480 kB</span><br><span class="line">PageTables:       109660 kB</span><br><span class="line">NFS_Unstable:          0 kB</span><br><span class="line">Bounce:                0 kB</span><br><span class="line">WritebackTmp:          0 kB</span><br><span class="line">CommitLimit:     4035836 kB</span><br><span class="line">Committed_AS:   125397000 kB</span><br><span class="line">&#x2F;&#x2F;vmalloc内存大小</span><br><span class="line">VmallocTotal:   263061440 kB</span><br><span class="line">&#x2F;&#x2F;已经被使用的虚拟内存大小</span><br><span class="line">VmallocUsed:           0 kB</span><br><span class="line">VmallocChunk:          0 kB</span><br><span class="line">CmaTotal:         344064 kB</span><br><span class="line">CmaFree:            2736 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="dumpsys-meminfo"><a href="#dumpsys-meminfo" class="headerlink" title="dumpsys meminfo"></a>dumpsys meminfo</h3><p>直接dumpsys meminfo，是查看整体的内存占用情况，具体的还是需要加上process name。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;对应上面MemTotal</span><br><span class="line">Total RAM: 3,844,700K (status normal)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;cached pss对应变量cachedPss的值。这部分进程占用的内存并没有被释放，而由于他们都已切换到后台，且adj较低，系统认为可以释放掉这部分内存。所以对于这部分进程，系统最好有机制能及时清理掉从而释放内存。</span><br><span class="line">&#x2F;&#x2F;cached kernel对应&quot;Buffers+Cached+SReclaimable-Mapped&quot;这部分的内存由于理论上是可以被Kernel回收的，所以这里也计算在free中，但是这是一个理论上的值，实际上很难做到全部回收。</span><br><span class="line">&#x2F;&#x2F;free对应MemFree</span><br><span class="line"> Free RAM: 1,003,024K (  400,796K cached pss +   509,892K cached kernel +     1,136K cached ion +    91,200K free)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;kernel对应&quot;Shmem+SUnreclaim+VmallocUsed+PageTables+KernelStack&quot;,其中VmallocUsed是统计&#x2F;proc&#x2F;vmallocinfo中除ioremap,map_lowmem,vm_map_ram之外的和</span><br><span class="line">&#x2F;&#x2F;详细见&quot;Debug.get_allocated_vmalloc_memory()&quot;这部分即是对kernel的内存占用的一个统计，如果要统计kernel的内存占用，这个稍微准确一些</span><br><span class="line"> Used RAM: 4,340,042K (3,862,614K used pss +   477,428K kernel)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;对应MemTotal - (totalPss - totalSwapPss) - MemFree - (cached kernel) - (kernel) - zramtotal</span><br><span class="line"> Lost RAM:   135,889K</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一个数 用变量zramtotal来代替，表示zram实际占用的物理内存，是从&#x2F;sys&#x2F;block&#x2F;zram0&#x2F;mm_stat中统计而来</span><br><span class="line">&#x2F;&#x2F;第二个数 对应 SwapTotal - SwapFree , 是已经在swap区的内存大小</span><br><span class="line">&#x2F;&#x2F;第三个数 对应 SwapTotal， 是整个swap区的大小</span><br><span class="line">     ZRAM:   528,592K physical used for 1,757,284K in swap (2,113,488K total swap)</span><br><span class="line">   Tuning: 384 (large 512), oom   645,120K, restore limit   107,520K (high-end-gfx)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.imooc.com/article/280763" target="_blank" rel="noopener">应用与系统稳定性第一篇—ANR问题分析的一般套路</a></li><li><a href="https://www.jianshu.com/p/30c1a5ad63a3" target="_blank" rel="noopener">Android应用ANR分析</a></li><li><a href="https://blog.csdn.net/shift_wwx/article/details/42490863" target="_blank" rel="noopener">android 查看内存使用情况</a></li><li><a href="https://zhuanlan.zhihu.com/p/90076117" target="_blank" rel="noopener">Android内存占用分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ANR（Application Not Responding），字面意思是应用无响应，即用户的一些操作无法从应用中获取反馈。关于发生ANR的trace.txt文件的请参考&lt;a href=&quot;https://wizzie.top/Blog/2020/06/11/2020/200611_android_tracetxt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Android ANR traces.txt文件分析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android 图形显示框架</title>
    <link href="https://alonealive.github.io/Blog/2020/07/30/2020/200730_android_GraphicsFramework/"/>
    <id>https://alonealive.github.io/Blog/2020/07/30/2020/200730_android_GraphicsFramework/</id>
    <published>2020-07-30T13:52:00.000Z</published>
    <updated>2020-07-30T09:15:39.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇对Android图形显示框架做一个概述，内容主要包含：SurfaceSession创建和销毁（添加/删除窗口），Surface创建和销毁，BufferQueue创建，以及BufferQueue的dequeueBuffer和queueBuffer、acquire和release大致流程梳理。</p></blockquote><a id="more"></a><h2 id="显示框架概述"><a href="#显示框架概述" class="headerlink" title="显示框架概述"></a>显示框架概述</h2><p>Android与用户进行图形界面的交互，例如各个应用程序，他们的对话框、按钮、菜单等图形窗口。这些窗口的管理都是由WindowManager负责，窗口管理位于Java层，真正的实现者是运行在System_server进程空间中的WindowManagerService。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/java/com/android/server/SystemServer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartWindowManagerService"</span>);</span><br><span class="line">        <span class="comment">// WMS needs sensor service ready</span></span><br><span class="line">        ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE);</span><br><span class="line">        mSensorServiceStart = <span class="keyword">null</span>;</span><br><span class="line">        wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore,</span><br><span class="line">                <span class="keyword">new</span> PhoneWindowManager(), mActivityManagerService.mActivityTaskManager);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm, <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>,</span><br><span class="line">                DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager,</span><br><span class="line">                <span class="comment">/* allowIsolated= */</span> <span class="keyword">false</span>, DUMP_FLAG_PRIORITY_CRITICAL);</span><br><span class="line">        traceEnd();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序负责修改绘制窗口中的内容，而WindowManager负责窗口的生命周期、几何属性、坐标变换信息、用户输入焦点、动画等功能。他还管理着窗口状态的变化，如窗口位置、大小、透明度以及Z-order（前后遮盖顺序）等一系列的逻辑判断。这些WindowManager功能由一系列接口或类构成，包括ViewManager、WindowManager、WindowManagerImpl、WindowManagerService等。</p><p>SurfaceFlinger负责分配应用程序所需的图形缓冲区，并对系统中的整个图形窗口进行composition（合成）。</p><p>最终，图形窗口会更新显示到Display显示器上。</p><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-0-%E6%A6%82%E8%BF%B0.png" alt="显示框架概述"></p><hr><h3 id="显示过程的三个进程"><a href="#显示过程的三个进程" class="headerlink" title="显示过程的三个进程"></a>显示过程的三个进程</h3><p>Android显示的整个过程由App进程、System_server进程、SurfaceFlinger进程一起配合完成。</p><ol><li><p>App进程： App需要将自己的内容显示在屏幕上，所以需要负责发起Surface创建的请求。同时触发对控件的测量、布局、绘制以及输入事件的派发处理，这些主要在ViewRootImpl中触发；</p></li><li><p>System_server进程： 主要是WindowManagerService，负责接收App请求，同时和SurfaceFlinger建立连接，向SurfaceFlinger发起具体请求创建Surface，并且创建Surace的辅助管理类SurfaceControl（和window一一对应）(AMS作用是统一调度所有App的Activity)；</p></li><li><p>SurfaceFlinger： 为App创建具体的Surface，在SurfaceFLinger对应成Layer，然后负责管理、合成所有图层，最终显示。</p></li></ol><p><img src="Android_GraphicsProcess.png" alt="显示过程的三个进程"></p><hr><h3 id="Activity、Window、PhoneWindow、DecorView、View的对应关系"><a href="#Activity、Window、PhoneWindow、DecorView、View的对应关系" class="headerlink" title="Activity、Window、PhoneWindow、DecorView、View的对应关系"></a>Activity、Window、PhoneWindow、DecorView、View的对应关系</h3><ol><li>Window：每一个Activity都包含一个Window对象（抽象类，提供了绘制窗口的一组通用API），通常由PhoneWindow实现。</li></ol><p>在Activity.java中定义：<code>private Window mWindow;</code></p><ul><li>一个Activity对应创建一个Surface</li></ul><ol start="2"><li>PhoneWindow:继承于Window，是Window类的具体实现。该类内部包含了一个DecorView对象，该DecorView对象是所有应用窗口（Activity界面）的根View。</li></ol><p>简而言之，PhoneWindow类是把一个FrameLayout类，即DecorView对象进行一定的包装，将他作为应用窗口的根View，并提供一组通用的窗口操作接口。</p><p>PhoneWindow是Android中最基本的窗口系统，每个Activity都会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。</p><p>在Activity.java的attach函数实例化：<code>mWindow = new PhoneWindow(this, window, activityConfigCallback);</code></p><ol start="3"><li>DecorView：PhoneWindow构造函数中定义，继承FrameLayout类，是所有应用窗口的根View。</li></ol><p>在PhoneWindow.java中定义，构造函数中初始化：<code>private DecorView mDecor;</code></p><p><strong>相关debug方法：</strong></p><ul><li>adb shell dumpsys activity</li><li>adb shell dumpsys window</li></ul><p>![window包含关系]](phonewindow.png)</p><hr><h3 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h3><blockquote><p>Activity onResume添加窗口</p></blockquote><p>onCreate方法中调用setContentView来设置布局，此时只是完成了View Tree的创建。<a href="https://wizzie.top/Blog/2020/07/07/2020/200707_android_HWUI_Draw/#%E7%BB%98%E5%88%B6%E5%BA%8F%E5%88%97%E5%9B%BE" target="_blank" rel="noopener">此处参考HWUI绘制文章</a></p><p>真正通知WMS添加窗口，是在回调onResume完成的。</p><p>调用onResume的方法在ActivityThread.java中是<code>handleResumeActivity</code>。之后调用到WMS.java的addWindow。</p><p><img src="ActivityLifecycle.png" alt="Activity生命周期"></p><hr><h4 id="App进程中完成添加窗口操作"><a href="#App进程中完成添加窗口操作" class="headerlink" title="App进程中完成添加窗口操作"></a>App进程中完成添加窗口操作</h4><ol><li>当一个新窗口(Window)被创建的时候，在ActivityThread.java的<code>handleResumeActivity</code>中调用addView(),然后调用到<code>WindowManagerImpl</code>的addView()函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>这个函数将实际操作委托给mGlobal成员完成，这个成员随着WindowManagerImpl的创建而被初始化：<code>private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</code></li></ol><p><strong>WindowManagerGlobal是一个单例模式，即一个进程中最多仅有一个WindowManagerGlobal实例。</strong></p><ol start="3"><li>调用mGlobal的addView函数后，将会创建一个ViewRootImpl对象，并且将窗口的控件、布局参数、ViewRootImpl对象入参到setView函数中，这个动作将导致<strong>ViewRootImpl向WMS添加新的窗口、申请Surface创建、绘制动作等</strong>。这才真正意义的完成了窗口的添加操作。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="窗口移除序列图（Activity-destroy）"><a href="#窗口移除序列图（Activity-destroy）" class="headerlink" title="窗口移除序列图（Activity destroy）"></a>窗口移除序列图（Activity destroy）</h4><p>窗口被删除，Activity执行了handleDestroyActivity函数：</p><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-1-3-Activity_Destroy.png" alt="Activity destroy"></p><h4 id="Surface-Destroy（Activity-pause或者stop状态）"><a href="#Surface-Destroy（Activity-pause或者stop状态）" class="headerlink" title="Surface Destroy（Activity pause或者stop状态）"></a>Surface Destroy（Activity pause或者stop状态）</h4><blockquote><p>可以结合以下<code>Surface创建部分</code>一起梳理，针对的情况是Surface被destroy，从framework/base到SurfaceFlinger模块Layer析构的流程。<br>但是就Activity而言，并没有被销毁，而是类似按了home键返回桌面，或者在后台运行的状态，具体可以通过日志观察。</p></blockquote><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-1-2-Surface_Destroy.png" alt="Surface Destroy"></p><hr><h2 id="SurfaceSession创建"><a href="#SurfaceSession创建" class="headerlink" title="SurfaceSession创建"></a>SurfaceSession创建</h2><blockquote><p>此处是接着上面添加窗口的流程，分为以下两部分。</p></blockquote><h3 id="mGlobal-addView中创建ViewRootImpl对象"><a href="#mGlobal-addView中创建ViewRootImpl对象" class="headerlink" title="mGlobal.addView中创建ViewRootImpl对象"></a>mGlobal.addView中创建ViewRootImpl对象</h3><ol><li>新建ViewRootImpl对象的时候，调用构造函数，会从WindowManagerGlobal中获取一个窗口session。</li></ol><p><code>mWindowSession = WindowManagerGlobal.getWindowSession();</code></p><ol start="2"><li>在WindowManagerGlobal中会通过Binder IPC跨进程创建一个session。</li></ol><p>Session主要用于进程间通信，其他应用程序想要和WMS通信就需要经过Session，每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (WindowManagerGlobal<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Emulate the legacy behavior.  The global instance of InputMethodManager</span></span><br><span class="line">                    <span class="comment">// was instantiated here.</span></span><br><span class="line">                    <span class="comment">// TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage</span></span><br><span class="line">                    InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary();</span><br><span class="line">                    <span class="comment">//获取WMS对象</span></span><br><span class="line">                    IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                    <span class="comment">//创建Session</span></span><br><span class="line">                    sWindowSession = windowManager.openSession(</span><br><span class="line">                            <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                    ValueAnimator.setDurationScale(scale);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sWindowSession;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>WMS继承IWindowManager.Stub，调用到openSessio函数，创建一个新的session对象, 返回值是IWindowSession类型。用于在APP进程和WMS之间建立联系。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mGlobal-addView中调用ViewRootImpl-setView"><a href="#mGlobal-addView中调用ViewRootImpl-setView" class="headerlink" title="mGlobal.addView中调用ViewRootImpl.setView"></a>mGlobal.addView中调用ViewRootImpl.setView</h3><p>在前面mGlobal创建ViewRootImpl对象之后，会调用ViewRootImpl对象的setView，然后通知到WMS创建一个SurfaceSession，建立WindowManagerService和Surfacelinger的连接。</p><p>一个SurfaceSession代表着一个到SurfaceFlinger的连接会话，在这个连接会话里，可以创建一个或多个surface，最后这些surface被合成送到Display上显示。</p><p>大致过程：（查看下面的序列图）</p><ol><li>在setView()中调用mWindowSession.addToDisplay, mWindowSession是IWindowSession接口类型，而Session.java实现了该接口；</li><li>Session.java 中调用mService.addWindow(…), mService是WMS类型；</li><li>WMS.java的addWindow()创建WindowState对象win，调用win.attach()</li><li>frameworks/base/services/core/java/com/android/server/wm/WindowState.java  调用attach</li><li>frameworks/base/services/core/java/com/android/server/wm/Session.java  调用windowAddedocked，创建SurfaceSession类型的mSurfaceSession</li><li>frameworks/base/core/java/android/view/SurfaceSession.java  构造函数调用JNI，然后在android_view_SurfaceSession.cpp中的nativeCreate创建SurfaceComposerClient, 调用Refase的incStrong然后实现onFirstRef,通过调用CreateConnection()建立和SF的连接;</li><li>SF.cpp  调用CreateConnection()返回SF的Client类的Binder代理BpSurfaceComposerClient;</li></ol><hr><h2 id="Surface创建"><a href="#Surface创建" class="headerlink" title="Surface创建"></a>Surface创建</h2><h3 id="App进程请求创建Surface"><a href="#App进程请求创建Surface" class="headerlink" title="App进程请求创建Surface"></a>App进程请求创建Surface</h3><p>Surface是Android图形系统的核心部分，图形界面上的一个窗口或对话框等都对应着一个Surface。</p><p>而这个Surface是一块绘制区域的抽象，它对应着Server服务端Surfacelinger中的一个图层Layer，这个图层的背后是一块图形缓冲区GraphicBuffer，Client客户端的应用程序的UI使用软件绘制、硬件绘制在Surface上各种渲染操作时，绘制操作的结果其实也就是在该图形缓冲区中。</p><p>这部分的内容是梳理Surface创建的过程。</p><ol><li>在ViewRootImpl对象中，<code>setView到requestLayout函数请求布局，到调用scheduleTraversals</code>，该函数里面在Choreographer.java层层调用到<code>Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</code></li></ol><p>此处的action即是新的线程启动。</p><ol start="2"><li>启动ViewRootImp中单独的线程TraversalRunnable，然后调用到关键函数<code>performTraversals()</code>。</li></ol><p>这个关键函数有两个主要的函数:</p><ul><li>relayoutWindow()   -&gt;布局窗口</li><li>performDraw()    -&gt;绘制渲染</li></ul><p>请求创建Surface就从relayoutWindow函数开始。</p><p>在这个方法中调用IWindowSession的relayout，会调用到Session.java，然后调用到WMS的relayoutWindow从而达到跨进程：（流程图查看下面单独章节的序列图）</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">//此处relayout会调用到WMS的relayoutWindow</span></span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>), viewVisibility,</span><br><span class="line">            insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>, frameNumber,</span><br><span class="line">            mTmpFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout,</span><br><span class="line">            mPendingMergedConfiguration, mSurfaceControl, mTempInsets);</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceControl.isValid()) &#123;</span><br><span class="line">        mSurface.copyFrom(mSurfaceControl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        destroySurface();</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><hr><h3 id="System-server进程-——-WMS"><a href="#System-server进程-——-WMS" class="headerlink" title="System_server进程 —— WMS"></a>System_server进程 —— WMS</h3><ol><li>跨进程到WMS后，从relayoutWindow函数调用到<code>createSurfaceControl(outSurfaceControl)</code>。</li></ol><p>（1）然后先是在WindowStateAnimator创建一个WindowSurfaceController对象，作为调用到WindowStateAnimator.java的<code>createSurfaceLocked</code>函数的返回值。</p><p>在createSurfaceLocked函数中，会new一个WindowSurfaceController对象，从而调用他的构造函数。</p><p>在他的构造函数中会创建一个SurfaceControl内部类Builder对象，调用该对象的build函数；</p><p>(2) WMS.java中调用WindowStateAnimator.java的<code>createSurfaceLocked</code>函数之后，会执行以下逻辑：</p><p>a. 如果surfaceController不为空，调用WindowSurfaceController的getSurfaceControl；</p><p>b. WindowSurfaceController.java调用getSurfaceControl, <code>outSurfaceControl.copyFrom(mSurfaceControl);</code>，而mSurfaceControl就是之前的构造函数创建的。此处的copyFrom会经过JNI调用到Native层, 然后读取SurfaeControl。</p><ol start="2"><li><p>在Builder内部类的build函数中<code>创建Java层的SurfaceControl对象</code>，在SurfaceControl的构造函数中调用JNI层的nativeCreate函数；</p></li><li><p>android_view_SurfaceControl.cpp的nativeCreate函数会调用SurfaceComposerClient.cpp的<code>createSurfaceChecked</code>函数，<code>创建一个surface（实际上是SurfaceControl）</code>，然后将surface返回。</p></li></ol><p><img src="WMS_CreateSurfaceControl.png" alt="创建Surface之Java层和Native层联系"></p><hr><h3 id="SurfaceFlinger进程"><a href="#SurfaceFlinger进程" class="headerlink" title="SurfaceFlinger进程"></a>SurfaceFlinger进程</h3><p>SurfaceComposerClinet.cpp位于frameworks/native/libs/gui模块。而<code>libgui库主要被JNI层中的代码调用，从而和Surfacelinger进程进行交互</code>，可以看做是Java层的Bn端，是SurfaceFlinger的Bp端。</p><p>比如此处的SurfaceComposerClinet通过Binder IPC（ISurfaceComposerClinet.cpp），跨进程到SurfaceFlinger进程。</p><ol><li>SurfaceComposerClinet作为Bp客户端调用：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/libs/gui/SurfaceComposerClient.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceComposerClient::createSurfaceChecked</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     sp&lt;SurfaceControl&gt;* outSurface, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     SurfaceControl* parent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                     LayerMetadata metadata)</span> </span>&#123;</span><br><span class="line">    sp&lt;SurfaceControl&gt; sur;</span><br><span class="line">    <span class="keyword">status_t</span> err = mStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; handle;</span><br><span class="line">        sp&lt;IBinder&gt; parentHandle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            parentHandle = parent-&gt;getHandle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, <span class="built_in">std</span>::move(metadata),</span><br><span class="line">                                     &amp;handle, &amp;gbp);</span><br><span class="line">        ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">        <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">            *outSurface = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp, <span class="literal">true</span> <span class="comment">/* owned */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Bn服务端是surfaceflinger模块的Client.cpp，此时跨进程到SurfaceFlinger进程，调用createSurface，从而请求到SurfaceFlinger创建Surface：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Client.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">Client::createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">uint32_t</span> flags, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; parentHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               LayerMetadata metadata, sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                               sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We rely on createLayer to check permissions.</span></span><br><span class="line">    <span class="keyword">return</span> mFlinger-&gt;createLayer(name, <span class="keyword">this</span>, w, h, format, flags, <span class="built_in">std</span>::move(metadata), handle, gbp,</span><br><span class="line">                                 parentHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在SurfaceFlinger::createLayer中创建Layer（创建surface的请求到SurfaceFlinger进程中就是创建Layer），创建的Layer有四种：</li></ol><p>（1）createBufferQueueLayer<br>（2）createBufferStateLayer<br>（3）createColorLayer<br>（4）createContainerLayer</p><p>通常情况下创建的是第一种Layer——BufferQueueLayer（在P中是BufferLayer），会创建一个<code>&lt;sp&gt;BufferQueueLayer强指针对象</code>。</p><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">SurfaceFlinger::createBufferQueueLayer</span><span class="params">(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client, <span class="keyword">const</span> String8&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                LayerMetadata metadata, PixelFormat&amp; format,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;IGraphicBufferProducer&gt;* gbp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                sp&lt;Layer&gt;* outLayer)</span> </span>&#123;</span><br><span class="line">.....</span><br><span class="line">    sp&lt;BufferQueueLayer&gt; layer = getFactory().createBufferQueueLayer(</span><br><span class="line">            LayerCreationArgs(<span class="keyword">this</span>, client, name, w, h, flags, <span class="built_in">std</span>::move(metadata)));</span><br><span class="line">    <span class="keyword">status_t</span> err = layer-&gt;setDefaultBufferProperties(w, h, format);</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        *handle = layer-&gt;getHandle();</span><br><span class="line">        *gbp = layer-&gt;getProducer();</span><br><span class="line">        *outLayer = layer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, <span class="string">"createBufferQueueLayer() failed (%s)"</span>, strerror(-err));</span><br><span class="line">                                                &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="序列图"><a href="#序列图" class="headerlink" title="序列图"></a>序列图</h2><blockquote><p>该序列图包含上面部分的流程，包含APP进程和WMS进程之间的Session创建、SurfaceSession创建、<strong>Surface创建</strong>。</p></blockquote><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-1-1-Surface%E5%88%9B%E5%BB%BA.png" alt="Surface创建"></p><hr><h2 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h2><blockquote><p>关于BufferQueue只大致梳理他的创建流程，以及在渲染过程中的dequeuebuffer和queuebuffer流程、在合成过程中的acquire和release流程。关于和GraphicsBuffer和再底层的逻辑，暂时不梳理。</p></blockquote><h3 id="BufferQueue概述"><a href="#BufferQueue概述" class="headerlink" title="BufferQueue概述"></a>BufferQueue概述</h3><p>创建BuffeQueueLayer对象的onFirstRef中会创建一个BufferQueue。BufferQueue是buffer流转的中转站。具体分成四个步骤：</p><ol><li>生产者dequeue一块buffer，buffer状态-&gt;DEQUEUED，持有者-&gt;Producer，之后生产者可以填充数据（渲染绘制）。在dequeueBuffer之前，buffer状态是free，持有者是BufferQueue；</li><li>生产者填充完数据后，进行queue操作，buffer-&gt;QUEUED，持有者-&gt;BufferQueue。操作后producer会回调BufferQueue的onFrameAvailable函数，通知消费者有可用的buffer;</li><li>消费者进行acquire取出Buffer，buffer-&gt;ACQUIRED，持有者-&gt;Consumer;</li><li>消费者消费完这块buffer（已经合成），进行release操作释放，归还给BufferQueue</li></ol><p><img src="BufferQueue.png" alt="BufferQueue处理流程"></p><hr><h3 id="BufferQueue状态"><a href="#BufferQueue状态" class="headerlink" title="BufferQueue状态"></a>BufferQueue状态</h3><ul><li>DEQUEUED 状态：</li></ul><p>Producer dequeue一个Buffer后，这个Buffer就变为DEQUEUED状态，release Fence发信号后，Producer就可以修改Buffer的内容，我们称为release Fence。此时Buffer被Producer占用。</p><p>DEQUEUED状态的Buffer可以迁移到 QUEUED 状态，通过queueBuffer或attachBuffer流程。也可以迁移到FREE装，通过cancelBuffer或detachBuffer流程。</p><ul><li>QUEUED 状态：</li></ul><p>Buffer绘制完后，queue到BufferQueue中，给Consumer进行消费。此时Buffer可能还没有真正绘制完成，必现要等对应的Fence发信号出来后，才真正完成。此时Buffer是BufferQueue持有，可以迁移到ACQUIRED状态，通过acquireBuffer流程。而且可以迁移到FREE状态，如果另外一个Buffer被异步的queue进来。</p><ul><li>ACQUIRED 状态：</li></ul><p>Buffer已经被Consumer获取，但是也必须要等对应的Fence发信号才能被Consumer读写，找个Fence是从Producer那边，queueBuffer的时候传过来的。我们将其称为acquire fence。此时，Buffer被Consumer持有。状态可以迁移到FREE状态，通过releaseBuffer或detachBuffer流程。除了从acquireBuffer流程可以迁移到ACQUIRED状态，attachBuffer流程也可以迁移到ACQUIRED状态。</p><ul><li>FREE 状态：</li></ul><p>FREE状态，说明Buffer被BufferQueue持有，可以被Producer dequeue，它将迁移到DEQUEUED状态，通过dequeueBuffer流程。</p><ul><li>SHARED状态：</li></ul><p>SHARED状态是一个特殊的状态，SHARED的Buffer并不参与前面所说的状态迁移。它说明Buffer被用与共享Buffer模式。除了FREE状态，它可以是其他的任何状态。它可以被多次dequeued, queued, 或者 acquired。这中共享Buffer的模式，主要用于VR等低延迟要求的场合。</p><hr><h3 id="BufferQueue创建以及创建一个监听"><a href="#BufferQueue创建以及创建一个监听" class="headerlink" title="BufferQueue创建以及创建一个监听"></a>BufferQueue创建以及创建一个监听</h3><p>在<code>BufferQueueLayer::onFirstRef</code>调用BufferQueue::createBufferQueue()创建了bufferQueue、生产者、消费者，在创建生产者和消费者的过程中，将他们绑定到同一个BufferQueue上。</p><p>之后会创建一个BufferLayerConsumer对象mConsumer，这个对象继承了ConsumerBase类，所以会回调基类的构造函数，注册一个监听对象到BufferQueue（空对象）。</p><p>真正的监听是在<code>mConsumer-&gt;setContentsChangedListener(this)</code>基类构造函数中还会调用consumerConnect将消费者关联到BufferQueue中。此时监听对象就赋给了BufferQueue的mConsumerListener成员（调用BufferQueueConsumer的connect函数）。</p><p>这个监听对象会在queueBuffer是触发，由生产者回调注册到BufferQueue的帧可用通知。</p><p><img src="BufferQueue_Create.png" alt="BufferQueue创建"></p><hr><h3 id="DequeuBuffer"><a href="#DequeuBuffer" class="headerlink" title="DequeuBuffer"></a>DequeuBuffer</h3><p>BufferQueue创建后，首先由生产者执行dequeueBuffer请求一块Buffer。</p><p>Dequeue和Queue的操作都是在硬件渲染(软件绘制暂不考虑)的过程中，在<code>ThreadedRenderer::draw</code>函数中，updateRootDisplayList创建好一个RootDisplayList后，开始渲染一帧，在这时调用父类的syncAndDrawFrame函数，这个函数层层调到CanvasContext::draw函数，然后依次调用三个函数：</p><ol><li>mRenderPipeline-&gt;getFrame            执行dequeueBuffer请求一块buffer</li><li>draw                                 填充buffer</li><li>mRenderPipeline-&gt;swapBuffers         执行queueBuffer送到BufferQueue</li></ol><p>在此处dequeuBuffer和queueBuffer两个操作调到gui/Surface.cpp的两个对应函数，这个流程基本一样。</p><p>大致都从<code>SkiaOpenPipeline.cpp -&gt; EglManager.cpp -&gt; eglApi.cpp -&gt; ANativeWindow.cpp</code>，之后到Bp客户端libgui库的Surface.cpp，执行具体操作。</p><p>Surface::dequeueBuffer中调用IGraphicBufferProducer::dequeueBuffer。然后<code>remote()-&gt;transact(DEQUEUE_BUFFER,data,&amp;reply)</code>调用到Bn端BufferQueueProducer::dequeueBuffer函数。</p><ol><li>首先查找mSlots[found]的序列号found，mSlots是存放Buffer的地方，他的数量是64。即至多存放64个buffer。</li><li>found是从waitForFreeSlotThenRelock中获取：</li></ol><ul><li>从非Free的buffer中统计dequeue和acquire的数量；</li><li>判断dequeueBufferCount数量不能大于最大允许dequeueBuffer的数量；</li><li>slot的获取主要来自两个集合，mFreeSlots和mFreeBuffers；两者包含的所有状态都是free，区别在于前者没有attached，后者以及attached；如果调用来自dequeueBuffer优先选择前者，如果调用来自attachBuffer，优先选择后者；</li><li>如果没找到符合要求的buffer或者queue的buffer还有太多没有完成，就要等待这个buffer被acquired或者released，或者修改最大的buffer数量。</li></ul><ol start="3"><li>找到可用的slot，还要判断是否重新分配空间：如果Buffer（本质上是GraphicBuffer）是空，并且需要重新分配空间，则对这个mSlots[found]初始化；</li><li>new GraphicBuffer为mSlots分配一个GraphicBuffer，赋值给BufferQueueCore中的变量mSlots[]的mGraphicBuffer；</li></ol><p><code>mSlots[*outSlot].mGraphicBuffer = graphicBuffer;</code></p><p><code>Surface::dequeueBuffer</code>从服务端申请到Buffer后，通过<code>requestBuffer</code>将客户端的buffer和服务端的buffer指向同一块物理内存。</p><p>具体是IGraphicBufferPruducer代理中通过REQUEST_BUFFER状态，在onTransact中将申请的GraphicBuffer，即<code>mSlots[slot].mGraphicBuffer</code>。将其写入reply，等待客户端读取。</p><hr><h3 id="QueueBuffer"><a href="#QueueBuffer" class="headerlink" title="QueueBuffer"></a>QueueBuffer</h3><p>queueBuffer是在渲染一帧后通过<code>mRenderPipeline-&gt;swapBuffers</code>调用到Surface::queueBuffer。将填充完数据的buffer放入BufferQueue，并且通过监听者通知消费者对象开始消费。</p><p>在Bn端BufferQueueProducer::queueBuffer L977中调用：<code>frameAvailableListener-&gt;onFrameAvailable(item);</code></p><p>通知消费者，在BufferQueueLayer::onFrameAvailable中调用：<code>mFlinger-&gt;signalLayerUpdate();</code></p><p>触发SurfaceFlinger的消息循环机制，开始处理SurfaceFlinger合成事件。</p><hr><h3 id="序列图-1"><a href="#序列图-1" class="headerlink" title="序列图"></a>序列图</h3><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-2-%E6%B8%B2%E6%9F%93%E6%97%B6BufferQueue-dequeue-queue.png" alt="渲染时BufferQueue的dequeue和queue操作"></p><h3 id="acquire-amp-release"><a href="#acquire-amp-release" class="headerlink" title="acquire &amp; release"></a>acquire &amp; release</h3><p>消费者SurfaceFlinger通过acquire从BufferQueue取出一块buffer消费。消费（合成）之后释放。</p><h3 id="序列图-2"><a href="#序列图-2" class="headerlink" title="序列图"></a>序列图</h3><p><img src="Android%E6%98%BE%E7%A4%BA%E6%A1%86%E6%9E%B6-3-BufferQueue-acquire-release.png" alt="合成时BufferQueue的acquire和release"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇对Android图形显示框架做一个概述，内容主要包含：SurfaceSession创建和销毁（添加/删除窗口），Surface创建和销毁，BufferQueue创建，以及BufferQueue的dequeueBuffer和queueBuffer、acquire和release大致流程梳理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android NE分析（二）</title>
    <link href="https://alonealive.github.io/Blog/2020/07/28/2020/200727_android_NE_Two/"/>
    <id>https://alonealive.github.io/Blog/2020/07/28/2020/200727_android_NE_Two/</id>
    <published>2020-07-28T13:52:00.000Z</published>
    <updated>2020-07-29T11:59:50.283Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解gcc将<code>*.c/cpp</code>编译成<code>*.o</code>，再将其链接为可执行程序或/lib库的过程，有助于我们将native从编译/加载/执行到崩溃一条路贯通起来。Android的Makefile只需要将source file填入<code>LOCAL_SRC_FILES</code>，然后<code>include $(BUILD_SHARED_LIBRARY)</code>或<code>$(BUILD_EXECUTABLE)</code>就可以将<code>*.c/cpp/s</code>编译为动态库或可执行程序。</p></blockquote><a id="more"></a><h2 id="native编译"><a href="#native编译" class="headerlink" title="native编译"></a>native编译</h2><h3 id="编译为obj"><a href="#编译为obj" class="headerlink" title="编译为obj"></a>编译为obj</h3><blockquote><p>在build/core/definitions.mk有定义transform-c-or-s-to-o-no-deps和transform-cpp-to-o，分别将每个<em>.c/s和</em>.cpp编译成*.o，里面传了很多参数给gcc</p></blockquote><ol><li><code>-fpic -fPIE</code></li></ol><ul><li>PIC是Position-Independent Code的缩写，经常被用在共享库中，这样就能将相同的库代码为每个程序映射到一个位置，不用担心覆盖掉其他程序或共享库。</li><li>PIE是Position-Independent-Executable的缩写，只能应用在可执行程序中。PIE和PIC很像，但做了一些调整（不用PLT，使用PC相关的重定位）。-fPIE给编译用，-pie给链接(ld)用。</li></ul><p>例如，一个程序没有使用PIC被链接到0地址，那么系统将其加载到0地址。</p><ol start="2"><li><code>-fstack-protector</code></li></ol><blockquote><p>顾名思义就是保护堆栈，每一个函数在运行时都有自己的栈帧，如果代码没有写好，很可能将自己甚至是其他的栈帧踩坏，那如何防护呢？简单的方法就是在栈帧头部也就是在局部变量开始之前多存储一个<strong>stack_chk_guard值，用于在函数返回前取出来和_stack_chk_guard做对比，失败则调用</strong>stack_chk_fail函数，这个就是该参数完成的行为。</p></blockquote><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p><code>build/core/combo/TARGET_linux-arm.mk</code>里有定义<code>transform-o-to-static-executable-inner</code>，将*.o链接成静态可执行程序，静态可执行程序是一个完整的程序，不需要额外的共享库即可执行，比如/init,/sbin/adbd等。</p><p>链接器用的是arm-linux-androideabi-g++</p><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p><code>build/core/combo/TARGET_linux-arm.mk</code>里有定义<code>transform-o-to-executable-inner</code>和<code>transform-o-to-shared-lib-inner</code>，分别将*.o链接为动态可执行程序和共享库。动态可执行程序需要linker才能进一步运行的。</p><p>链接器也是用arm-linux-androideabi-g++</p><h2 id="tombstone定位错误方法"><a href="#tombstone定位错误方法" class="headerlink" title="tombstone定位错误方法"></a>tombstone定位错误方法</h2><h3 id="signum"><a href="#signum" class="headerlink" title="signum"></a>signum</h3><p>一般debuggerd关注的是SIGILL，SIGBUS，SIGABRT，SIGFPE，SIGSEGV，SIGPIPE等。而这里，估计九成都是SIGSEGV (即signal 11)，段错误，和非法内存访问等价。</p><h3 id="sigcode"><a href="#sigcode" class="headerlink" title="*sigcode"></a>*sigcode</h3><ul><li>SEGV_MAPERR：访问一个没有映射到任何内容的地址，这种情况通常就是野指针，或者越界访问，访问空指针也是属于这类</li><li>SEGV_ACCERR：试图访问您无权访问的地址。说明访问出错地址，被map到地址空间来了，但是没访问权限。基本上是指针越界或野指针，比如写只读map的内存地址</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x7ecbf6a000   &#x2F;&#x2F;SEGV_ACCERR表示试图访问您无权访问的地址</span><br><span class="line">    x0  0000007e44001c30  x1  0000000000000000  x2  0000000000000000  x3  0000007e44001c30</span><br><span class="line">    x4  0000007ecbf6a008  x5  0000007e44001c98  x6  0000000000000000  x7  0000000000000000</span><br><span class="line">    x8  0000000000000000  x9  0000000000000000  x10 0000000000000000  x11 0000000000000000</span><br><span class="line">    x12 0000000000000000  x13 0000000000000000  x14 0000000000000001  x15 0000007ecbe3f540</span><br><span class="line">    x16 0000007eca917290  x17 0000007ec94ea480  x18 0000007e42e9c000  x19 0000007ecbdf5400</span><br><span class="line">    x20 0000000000000001  x21 0000007e44001c30  x22 0000000000000001  x23 0000007e44002020</span><br><span class="line">    x24 0000007ecb6bf045  x25 0000007ecb6bf260  x26 0000007ecb6bf278  x27 0000007ecb6bf041</span><br><span class="line">    x28 0000007ecb6bf044  x29 0000007e44001bf0</span><br><span class="line">    sp  0000007e44001bd0  lr  0000007eca910618  pc  0000007ec94ea460</span><br></pre></td></tr></table></figure><p>tombstone日志当中也提供了出错时寄存器地址里面的临近内存信息，信息量同样很丰富。查看<code>0000007e44001c30</code>附近的内存情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">memory near x0:</span><br><span class="line">    0000007e44001c10 0000000000030d40 00000000ffffffff  @...............</span><br><span class="line">    0000007e44001c20 0000007e44001cf0 0000007ecb6b83f0  ...D~.....k.~...</span><br><span class="line">    0000007e44001c30 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c40 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c50 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c60 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c70 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c80 0000000000000000 0000000000000000  ................</span><br><span class="line">    0000007e44001c90 0000000000000000 1c86a694ed72c72c  ........,.r.....</span><br><span class="line">    0000007e44001ca0 0000000000000001 00000000000fd000  ................</span><br><span class="line">    0000007e44001cb0 0000007ecb6b8170 0000007e44001d50  p.k.~...P..D~...</span><br><span class="line">    0000007e44001cc0 0000007e44001d50 0000007e44001dd8  P..D~......D~...</span><br><span class="line">    0000007e44001cd0 00000207000005ea 0000007e44001d50  ........P..D~...</span><br><span class="line">    0000007e44001ce0 0000007ec954e5f0 0000007e44001d50  ..T.~...P..D~...</span><br><span class="line">    0000007e44001cf0 0000007e44001d10 0000007ec954e618  ...D~.....T.~...</span><br><span class="line">    0000007e44001d00 0000007e44001d50 0000000000000000  P..D~...........</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Android Native/Tombstone Crash Log 详细分析：<a href="https://blog.csdn.net/u011006622/article/details/51496693" target="_blank" rel="noopener">https://blog.csdn.net/u011006622/article/details/51496693</a></li><li>Android Native程序crash的一些定位方法简介：<a href="https://msd.misuland.com/pd/300217191876268032" target="_blank" rel="noopener">https://msd.misuland.com/pd/300217191876268032</a></li><li>ARM64-memcpy.S 汇编源码分析：<a href="https://blog.csdn.net/ffmxnjm/article/details/68065090" target="_blank" rel="noopener">https://blog.csdn.net/ffmxnjm/article/details/68065090</a></li><li>android bionic memcpy 汇编源码解析：<a href="https://blog.csdn.net/qq_28637193/article/details/103681746" target="_blank" rel="noopener">https://blog.csdn.net/qq_28637193/article/details/103681746</a></li><li>PIC和PIE：<a href="https://www.cnblogs.com/sword03/p/9385660.html" target="_blank" rel="noopener">https://www.cnblogs.com/sword03/p/9385660.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;了解gcc将&lt;code&gt;*.c/cpp&lt;/code&gt;编译成&lt;code&gt;*.o&lt;/code&gt;，再将其链接为可执行程序或/lib库的过程，有助于我们将native从编译/加载/执行到崩溃一条路贯通起来。Android的Makefile只需要将source file填入&lt;code&gt;LOCAL_SRC_FILES&lt;/code&gt;，然后&lt;code&gt;include $(BUILD_SHARED_LIBRARY)&lt;/code&gt;或&lt;code&gt;$(BUILD_EXECUTABLE)&lt;/code&gt;就可以将&lt;code&gt;*.c/cpp/s&lt;/code&gt;编译为动态库或可执行程序。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android debug" scheme="https://alonealive.github.io/Blog/tags/android-debug/"/>
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android NE分析（一）</title>
    <link href="https://alonealive.github.io/Blog/2020/07/24/2020/200724_android_NE/"/>
    <id>https://alonealive.github.io/Blog/2020/07/24/2020/200724_android_NE/</id>
    <published>2020-07-24T12:52:00.000Z</published>
    <updated>2020-07-24T11:06:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>任何软件都可能存在BUG，调试和修复BUG伴随着整个开发流程，因此异常分析非常重要。如果是native层发生异常，我们一般称之为叫NE（native exception）</p></blockquote><a id="more"></a><p>异常可能发生任何一层，如果是：</p><ul><li>kernel层发生异常，叫KE（kernel exception）</li><li>native层发生异常，叫NE（native exception）</li><li>java成异常，叫JE（java exception）</li></ul><h2 id="NE简介"><a href="#NE简介" class="headerlink" title="NE简介"></a>NE简介</h2><blockquote><p>Native层是由各种lib/binary组成，这一层发生异常，我们称之为NE（native exception）<br>一般我们用offline调试，通过coredump借助gdb或trace32来调试。首先要先熟悉下linux信号和ptrace机制，coredump是通过信号触发生成的。<code>coredump是进程空间保存到文件系统的镜像，因此能看到异常时刻的所有变量值，就可以知道问题出在哪里。</code><br>Android是基于linux的，发生异常时，Android扩展了调试机制，这个机制是debuggerd机制。在没有coredump下，debuggerd以log或者tombstone的方式输出异常信息。</p></blockquote><p>本地应用程序是指可以直接运行在操作系统上，并且处理器直接执行机器码的程序。</p><p>在Android上，OS是linux，因此各种bin程序就是所谓的<code>natvie application</code>，比如/system/bin目录下的所有文件。</p><p>这些应用程序都是由GCC(c/c++)编译生成。</p><p>在Android软件架构里，这些应用程序组成了native layer:</p><p><img src="nativeLayer.png" alt="Native Layer"></p><p>native layer里的应用程序崩溃统称为Native Exception，即NE，比如空指针，非法指针，程序跑飞，内存踩坏等。</p><h3 id="发生NE流程"><a href="#发生NE流程" class="headerlink" title="发生NE流程"></a>发生NE流程</h3><p>原始的linux，对于用户进程崩溃之后，处理方式有2种：</p><ol><li>直接终止进程；</li><li>输出coredump再终止进程</li></ol><p>而在Android，为了方便调试，在收到崩溃信号后，会先输出tombstone，然后在根据设置是否抓取coredump，最后再终止进程。</p><p><strong>如果发生NE，内核会抛出信号，可以通过kernel log搜索<code>sig 11/7</code>等几个可以导致进程崩溃的关键字判断。</strong></p><p>此处的信号注册是发生在动态链接程序加载的时候，链接器（linker）负责将应用程序所需的库加载到进程空间内，然后跑应用程序大妈。linker在执行期间会注册信号。</p><p>流程：__linker_init() -&gt; __linker_init_post_relocation() -&gt; debuggerd_init()</p><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>目前会产生native exception（NE）的几个信号需要特别掌握产生的原因，这样才能进一步分析问题所在。</p><p>内核发送信号过来后会执行<code>debuggerd_init()</code>里注册的函数debugger_signal_handler()，该函数会打印基本信息到main log：</p><p><code>logSignalSummary()</code>函数会输出基本异常信息，类似<code>libc: Fatal signal 11(SIGSEGV) at 0x000 ...</code>日志打印。</p><p>然后连接debuggerd的socket，将pid等信息发送给debuggerd，请它帮忙后续的处理。之后将对应的信号恢复为默认，等待debuggerd处理完后抓取coredump。</p><hr><h2 id="debuggerd服务"><a href="#debuggerd服务" class="headerlink" title="debuggerd服务"></a>debuggerd服务</h2><p>关于上面的debuggerd服务，是由init.rc启动起来，具体代码在<code>system/core/debuggerd/</code>。</p><p>debuggerd起来后会创建1个socket，然后监听，等待别人通过socket请求服务，服务可以是生成tombstone或调用栈。</p><h3 id="使用debuggerd命令查看指定tid的调用栈和tombstone"><a href="#使用debuggerd命令查看指定tid的调用栈和tombstone" class="headerlink" title="使用debuggerd命令查看指定tid的调用栈和tombstone"></a>使用debuggerd命令查看指定tid的调用栈和tombstone</h3><ul><li><code>adb shell debuggerd -b $tid</code>：抓取指定tid的调用栈</li><li><code>adb shell debuggerd $tid</code>：抓取指定tid的tombstone</li></ul><h3 id="ptrace-attach-detach"><a href="#ptrace-attach-detach" class="headerlink" title="ptrace attach/detach"></a>ptrace attach/detach</h3><p>通过socket拿到tid等资料后，使用ptrace attach上目标tid，之后就可以通过ptrace访问目标进程空间，然后打印一些NE相关的寄存器/调用栈等信息。</p><ol><li>ptrace attach：ptrace attach会发送<code>sig 19</code>给对应的进程。在这里，我们将进程内所有线程都attach上，防止有线程提前退出。</li><li>ptrace cont：attach之后还不能直接访问目标进程，因为目标进程还处于信号处理函数里面，我们需要让它恢复到异常现场，因此需要用ptrace cont让其继续执行。</li><li>waitpid：程序接着往下跑必然会再次发生异常（如果是SIGABRT,SIGFPE,SIGPIPE,SIGSTKFLT，则会在信号处理函数重发一次信号），kernel会再次发出信号，只不过由于进程被ptrace了，信号会送给debuggerd。<strong>到这里，目标进程已经收到2次同样的信号了</strong></li><li><code>tombstone</code>:debuggerd收到信号后，就可以生成tombstone了</li><li>ptrace detach: 完成工作后，需要detach ptrace，然后发送<code>sig 18</code>让其继续奔跑。如果是访问空指针等错误，程序会再次发生异常，由于在信号处理函数里已经将对应信号恢复默认，因此可能会产生coredump。</li></ol><hr><h3 id="产生db文件"><a href="#产生db文件" class="headerlink" title="产生db文件"></a>产生db文件</h3><blockquote><p>debuggerd完成之后会通知aee，aee就开始了打包db的工作，具体生成在<code>/data/aee_exp</code>目录</p></blockquote><p>1个完整的NE的db，里面除了coredump还有其他文件，包含log文件(main/event/radio)，详细的NE信息文件(_exp_main/_exp_detail)等，这些文件绝大部分是通过aee_dumpstate保存起来的。</p><h4 id="PROCESS-MAPS文件描述进程空间"><a href="#PROCESS-MAPS文件描述进程空间" class="headerlink" title="PROCESS_MAPS文件描述进程空间"></a>PROCESS_MAPS文件描述进程空间</h4><p>db中有些文件对分析NE是至关重要的，比如PROCESS_MAPS，这文件就是<code>/proc/$pid/maps</code>，里面是对进程空间的描述。</p><p>例如以下部分截取的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1-进程里地址范围            2-虚拟内存的权限（r&#x3D;读&#x2F;w&#x3D;写&#x2F;x&#x3D;可执行&#x2F;s&#x3D;共享&#x2F;p&#x3D;私有）</span><br><span class="line">&#x2F;&#x2F;3-空间所映射的文件的偏移量    4-空间所映射的文件的主次设备号</span><br><span class="line">&#x2F;&#x2F;5-空间所映射的文件的节点号（0表示没有节点映射到内存）   6-空间所映射的文件的路径</span><br><span class="line">7ec808a000-7ec808b000 --xp 00001000 fd:01 3989                           &#x2F;system&#x2F;lib64&#x2F;libhardware.so</span><br><span class="line">7ec808b000-7ec808c000 rw-p 00002000 fd:01 3989                           &#x2F;system&#x2F;lib64&#x2F;libhardware.so</span><br><span class="line">7ec808c000-7ec808d000 r--p 00003000 fd:01 3989                           &#x2F;system&#x2F;lib64&#x2F;libhardware.so</span><br></pre></td></tr></table></figure><hr><h2 id="Tombstone"><a href="#Tombstone" class="headerlink" title="Tombstone"></a>Tombstone</h2><blockquote><p>Android Native程序本质上就是一个Linux程序，因此当它在执行时发生严重错误，也会导致程序crash，然后产生一个记录crash的现场信息的文件，而这个文件在Android系统中就是tombstone文件。</p></blockquote><p>从上面的分析看，发生NE的时候会创建tombstone文件，最多存在10个，如果已存在10个，会覆盖最旧的文件。</p><p><strong>组成部分：</strong></p><ol><li>版本信息：主要是fingerprint，可以看出异常版本是eng还是user</li><li>寄存器信息：主要查看是哪个进程崩溃，信号是什么。寄存器信息需要配合下面的调用栈信息及数据信息结合GNU的工具（<code>objdump -S反汇编</code>）分析。</li><li>调用栈信息：是最直接可以看出异常的信息（可以使用addr2line定位地址的代码函数对应位置）</li><li>其他线程信息：如果异常线程和其他线程有逻辑关系的话，可以查看对应线程的信息</li><li>main log信息：全面的log建议还是查看main log</li></ol><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p>最直接查看栈的位置就是log和Tombstone文件中。</p><p>C/C++语言的过程调用都需要栈，正在执行的函数有属于自己的栈帧，函数内部的局部变量就放在栈帧里，当然还会存放函数的返回地址，这样函数执行结束之后才知道返回到哪里。</p><p>不同的栈帧关联在一起就会形成一个调用链，最顶端表示当前正在执行的函数，第2行表示调用它的函数，以此类推（先进后出）。</p><p>例如以下栈：</p><blockquote><p><code>库里的偏移</code>：库默认都加载在0地址的，由OS随机加载在mmap区域，因此实际上库函数的地址都是<code>基址+偏移量</code>，其中的基址就是库加载的地址，这个地址可以从<code>/proc/$pid/maps</code>看到每个库的基址。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">backtrace:</span><br><span class="line">      #00 pc 00000000000e2f88  &#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;bionic&#x2F;libc.so (pthread_mutex_lock) (BuildId: ceedf0f98da575de138b0c631aceca44)</span><br><span class="line">    &#x2F;&#x2F;栈帧  +  地址       +       函数                                                 + 该函数的偏移量（+32） </span><br><span class="line">      #01 pc 00000000000c39a0  &#x2F;system&#x2F;lib64&#x2F;libgui.so (android::SurfaceControl::getHandle() const+32) (BuildId: d26a01ac90bf9cf5c7585e3fbbdbb327)</span><br><span class="line">      #02 pc 0000000000120a28  &#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so (android::nativeGetHandle(_JNIEnv*, _jclass*, long)+40) (BuildId: 5bd8af36fc54644383069436f63eec83)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="addr2line命令"><a href="#addr2line命令" class="headerlink" title="addr2line命令"></a>addr2line命令</h2><p>针对发生Native Crash的堆栈，将地址转换为地址所在的文件及行数(显示所在函数)</p><p>该命令可以用来解析so动态链接库（Symbol目录），分析单个pc地址对应的函数，然后参照代码寻找问题发生处。</p><p>含有调试信息的库或程序必须和手机里的库或程序是同一次编译生成的，否则得到的PC值和库里的调试信息不匹配。</p><blockquote><p>如何确定库或程序含有调试信息呢？或者说如何确定库能不能用来调试呢？是不是symbol目录下的库呢？</p></blockquote><blockquote><p>用file命令即可查看：<code>file xxx</code></p></blockquote><ul><li>如果没有含debug信息的话，会显示：<code>xxx: ELF 32-bit LSB shared object, ARM, version 1 (SYSV), dynamically linked, stripped</code></li><li>含有调试信息的话，则显示：<code>xxx: ELF 32-bit LSB shared object, ARM, version 1 (SYSV), dynamically linked, not stripped</code></li></ul><p>例如：（需要在Symbol目录下）</p><p><code>addr2line -Cfe .so address</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;out&#x2F;target&#x2F;product&#x2F;product&#x2F;symbols&#x2F;system&#x2F;lib64$ addr2line -f -e libgui.so 00000000000c39a0</span><br><span class="line">_ZNK7android12SortedVectorINS_12DisplayStateEE16do_move_backwardEPvPKvm</span><br></pre></td></tr></table></figure><p>解释：-e 后加上.so的文件名；-f 可同时输出函数名称</p><ul><li><code>-e --exe=&lt;executable&gt;</code>: 设置要查询地址的文件(默认: a.out)一般是<em>.so/</em>.a和可执行程序。此文件必须带有debug信息，在android codebase里是放在out/target/product/$project/symbols目录下</li><li><code>-f –functions</code>: 显示地址所在的函数名</li><li><code>-C --demangle[=style]</code>: 反重整函数名为可读方式</li></ul><h2 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h2><p><code>objdump –S **.so &gt; **.asm</code></p><p>该命令是用来把相应的so变成汇编语言的asm文件，然后根据地址信息就可以找到更加详细的相关函数信息。</p><p>即查看对象文件(<em>.so/</em>.a或应用程序)的内容信息</p><p>或者</p><p><code>symbols/out/target/product/merlin/symbols$ objdump -tT system/lib64/libgui.so</code></p><table><thead><tr><th align="center">后缀</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">-S 或 –source</td><td align="center">尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数</td></tr><tr><td align="center">-t 或 –syms</td><td align="center">显示文件的符号表入口。类似于nm -s提供的信息</td></tr><tr><td align="center">-T 或 –dynamic-syms</td><td align="center">显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于`nm -D</td></tr></tbody></table><h2 id="nm命令"><a href="#nm命令" class="headerlink" title="nm命令"></a>nm命令</h2><p>作用是：列出该文件的符号(函数，变量，文件等)，包含名字、地址、大小</p><hr><h2 id="ndk-stack"><a href="#ndk-stack" class="headerlink" title="ndk-stack"></a>ndk-stack</h2><blockquote><p>用来把log信息全部翻译成更加详细的带源码行数信息的log，相当于是在整个crash堆栈信息都执行addr2line命令。</p></blockquote><p>ndk-stack -sym  […/obj/local/{ABI类型}/]   -dump crash.log</p><hr><h2 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h2><p>查看elf文件(<em>.so/</em>.a或应用程序)的内容信息，可以使用<code>readelf -a [.so/.bin]</code>解析库地址。</p><hr><h2 id="c-filt"><a href="#c-filt" class="headerlink" title="c++filt"></a>c++filt</h2><p>反重整C++符号为可读方式。</p><p>根据解析结果查询函数，C++在linux系统编译后会变成类似<code>_ZNK...</code>的修饰名。使用<code>c++filt</code>获取函数的原始名称。</p><p><code>c++filt [_ZNK...函数修饰名]</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>关于不同版本aee db文件的抓取：<a href="https://blog.csdn.net/topsecrethhh/article/details/81453414" target="_blank" rel="noopener">https://blog.csdn.net/topsecrethhh/article/details/81453414</a></li><li>coredump配置、产生、分析以及分析示例：<a href="https://www.cnblogs.com/arnoldlu/p/11160510.html" target="_blank" rel="noopener">https://www.cnblogs.com/arnoldlu/p/11160510.html</a></li><li>Android Debuggerd 简要介绍和源码分析：<a href="https://www.cnblogs.com/lance-ehf/p/4249605.html" target="_blank" rel="noopener">https://www.cnblogs.com/lance-ehf/p/4249605.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;任何软件都可能存在BUG，调试和修复BUG伴随着整个开发流程，因此异常分析非常重要。如果是native层发生异常，我们一般称之为叫NE（native exception）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android debug" scheme="https://alonealive.github.io/Blog/tags/android-debug/"/>
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>C++ 对象和类（案例代码）</title>
    <link href="https://alonealive.github.io/Blog/2020/07/15/2020/200715_cpp_ObjAndClass/"/>
    <id>https://alonealive.github.io/Blog/2020/07/15/2020/200715_cpp_ObjAndClass/</id>
    <published>2020-07-15T15:52:00.000Z</published>
    <updated>2020-07-20T14:00:11.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++类的声明、实现和使用，以及构造函数和析构函数。包含案例代码，可编译运行。</p></blockquote><a id="more"></a><h2 id="类的声明、实现、使用"><a href="#类的声明、实现、使用" class="headerlink" title="类的声明、实现、使用"></a>类的声明、实现、使用</h2><h3 id="类的成员访问控制：公有-私有"><a href="#类的成员访问控制：公有-私有" class="headerlink" title="类的成员访问控制：公有/私有"></a>类的成员访问控制：公有/私有</h3><p>无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明他。</p><p>而隐藏数据是OOP（面向对象）主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分（否则就无法从程序中调用这些函数）</p><p>也可以把成员函数放在私有部分中，不能直接从程序中调用这种函数，但是公有方法却可以使用他们。通常，程序员使用私有成员函数处理不属于公有接口的实现细节。</p><p>类声明中的关键字private是类对象的默认访问控制，可以不用写出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> mass; <span class="comment">//private by default</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note：结构的默认访问类型是public，而类为private，可以不用再写出来。</p><h3 id="类成员函数实现"><a href="#类成员函数实现" class="headerlink" title="类成员函数实现"></a>类成员函数实现</h3><p>类声明后，需要具体实现原型表示的成员函数。成员函数有函数头和函数体，也可以有返回类型和参数，而其和常规函数的不同之处：</p><ul><li>定义成员函数时，使用作用域解析运算符<code>::</code>来标识函数所属的类。例如<code>void A::update(double price)...</code>，这意味着<code>update()</code>函数是A类的成员。同时意味着可以将另一个类的成员函数也命名成<code>update()</code>，例如<code>void B::update()...</code>。因此作用域解析运算符确定了方法定义对应的类。</li><li>类方法可以访问类的private私有成员，即定义的私有变量这些。</li></ul><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ol><li>头文件：</li></ol><figure class="highlight cpp"><figcaption><span>stock00.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stock00.h -- Stock class interfate</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCK00_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCK00_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:   <span class="comment">//can remove</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line"><span class="keyword">long</span> shares;</span><br><span class="line"><span class="keyword">double</span> share_val;</span><br><span class="line"><span class="keyword">double</span> total_val;</span><br><span class="line"><span class="comment">//定义于类声明中的函数将自动成为内联函数</span></span><br><span class="line"><span class="comment">//等价于在头文件的类外面使用inline void Stock::set_tot() &#123;...&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//对某公司股票的首次购买</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span></span>;</span><br><span class="line"><span class="comment">//管理增加/减少持有的股票，确保买入或者卖出的股票不为负数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> price)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>函数实现文件：</li></ol><figure class="highlight cpp"><figcaption><span>stock00.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stock00.cpp -- implementing the Stokc class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stock00.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp; co, <span class="keyword">long</span> n, <span class="keyword">double</span> pr)</span> </span>&#123;</span><br><span class="line">company = co;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of shares can't be negative, "</span></span><br><span class="line">  &lt;&lt; company &lt;&lt; <span class="string">" shares set to 0.\n"</span>;</span><br><span class="line">shares = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">shares = n;</span><br><span class="line"></span><br><span class="line">share_val = pr;</span><br><span class="line">set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::buy</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of shares purchased can't be negative, "</span></span><br><span class="line">  &lt;&lt; <span class="string">"Transaction is aborted.\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shares += num;</span><br><span class="line">share_val = price;</span><br><span class="line">set_tot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::sell</span><span class="params">(<span class="keyword">long</span> num, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of shares purchased can't be negative, "</span></span><br><span class="line">                          &lt;&lt; <span class="string">"Transaction is aborted.\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; shares) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't sell more than you have, "</span></span><br><span class="line">                          &lt;&lt; <span class="string">"Transaction is aborted.\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shares -= num;</span><br><span class="line">share_val = price;</span><br><span class="line">set_tot();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::update</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">share_val = price;</span><br><span class="line">set_tot();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Stock::show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Company: "</span> &lt;&lt; company</span><br><span class="line">  &lt;&lt; <span class="string">" Share: "</span> &lt;&lt; shares &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">                  &lt;&lt; <span class="string">" Share Price: $"</span> &lt;&lt; share_val</span><br><span class="line">  &lt;&lt; <span class="string">" Total Worth: $"</span> &lt;&lt; total_val &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类使用</li></ol><figure class="highlight cpp"><figcaption><span>usestock00.cpp </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//usestock00.cpp -- the client program</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stock00.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Stock f;</span><br><span class="line">f.acquire(<span class="string">"NanoSmart"</span>, <span class="number">20</span>, <span class="number">12.50</span>);</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line">f.buy(<span class="number">15</span>, <span class="number">18.125</span>);</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line">f.sell(<span class="number">400</span>, <span class="number">20.00</span>);</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line">f.buy(<span class="number">300000</span>, <span class="number">40.125</span>);</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line">f.sell(<span class="number">30000</span>, <span class="number">0.125</span>);</span><br><span class="line">f.show();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多个文件编译命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ -c stock00.cpp</span><br><span class="line">ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ -c usestock00.cpp</span><br><span class="line">ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ stock00.o usestock00.o -o usestock00</span><br></pre></td></tr></table></figure><ol start="5"><li>执行结果：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ .&#x2F;usestock00 </span><br><span class="line">Company: NanoSmart Share: 20</span><br><span class="line"> Share Price: $12.5 Total Worth: $250</span><br><span class="line">Company: NanoSmart Share: 35</span><br><span class="line"> Share Price: $18.125 Total Worth: $634.375</span><br><span class="line">You can&#39;t sell more than you have, Transaction is aborted.</span><br><span class="line">Company: NanoSmart Share: 35</span><br><span class="line"> Share Price: $18.125 Total Worth: $634.375</span><br><span class="line">Company: NanoSmart Share: 300035</span><br><span class="line"> Share Price: $40.125 Total Worth: $1.20389e+07</span><br><span class="line">Company: NanoSmart Share: 270035</span><br><span class="line"> Share Price: $0.125 Total Worth: $33754.4</span><br></pre></td></tr></table></figure><hr><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><h3 id="声明构造函数"><a href="#声明构造函数" class="headerlink" title="声明构造函数"></a>声明构造函数</h3><p>构造函数专门用于构造新对象、将值赋给他们的数据成员。</p><p>例如:<code>Stock::Stock(const string &amp; co, long n, double pr) {...}</code></p><p>此处构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员相同，否则会造成混乱。</p><p>常见的做法是在数据成员名中使用<code>m_</code>前缀或者使用后缀<code>_</code>。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> m_company;</span><br><span class="line"><span class="keyword">long</span> m_shares;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> company_;</span><br><span class="line"><span class="keyword">long</span> shares_;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h3><p>两种使用构造函数初始化对象的方式：</p><ol><li>显式调用构造函数：<code>Stock food = Stock(&quot;World&quot;, 250, 1.25);</code></li><li>隐式调用构造函数：<code>Stock garment(&quot;Good&quot;, 50, 2.5);</code>，等价于显式的方法：<code>Stock garment = Stock(&quot;Good&quot;, 50, 2.5);</code></li></ol><p>创建类对象的时候，C++都会使用类的构造函数：<code>Stock *pstock = new Stock(&quot;Best&quot;, 18, 1.9);</code></p><p>此处创建了一个Stock对象，并调用构造函数初始化为参数提供的值，将对象的地址赋给pstock指针。此时对象没有名称，但是可以使用指针来管理该对象。</p><p>使用对象调用方法：<code>stock1.show();</code></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。</p><p>如果Stock的构造函数没有使用new，则析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么都不做的隐式析构函数即可。</p><p>析构函数可以没有返回值和声明类型。</p><p>和构造函数不同，析构函数没有参数。</p><p>例如Stock析构函数的原型：<code>~Stock();</code></p><p>或者：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock::~Sotck &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Bye"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;C++类的声明、实现和使用，以及构造函数和析构函数。包含案例代码，可编译运行。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Android HWUI绘制流程</title>
    <link href="https://alonealive.github.io/Blog/2020/07/07/2020/200707_android_HWUI_Draw/"/>
    <id>https://alonealive.github.io/Blog/2020/07/07/2020/200707_android_HWUI_Draw/</id>
    <published>2020-07-07T13:12:00.000Z</published>
    <updated>2020-07-30T12:25:29.326Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。  </p></blockquote><a id="more"></a><blockquote><p>HWUI绘制的大致流程是先初始化绘制环境（创建rendernode、渲染线程RenderThread、Context上下文、RenderProxy代理对象），之后是创建DisplayList显示列表，然后开始视图绘制，视图绘制结束后开始同步帧数据。</p></blockquote><blockquote><p><code>硬件加速</code>：<strong>作用</strong>：是将2D的绘图操纵转换为对应的3D绘图操纵。需要显示的时候，再用OpenGLES通过GPU渲染。<strong>过程</strong>：界面创建时，第一次全部渲染，后续界面如果只有部分区域的widget更新，只需要重新渲染更新的widget。渲染好的绘图保存在一个显示列表<code>DisplayList</code>中，需要真正显示到界面的时候，直接显示DisplayList中的绘图。<strong>好处</strong>：一方面利用GPU去渲染，比Skia要快；另一方面，采用DisplayList，再次渲染只更新部分区域，最大程度利用上一帧的数据，提高效率。</p></blockquote><blockquote><p>使用Android Q AOSP源码梳理流程。</p></blockquote><h2 id="GPU渲染（硬件加速）介绍"><a href="#GPU渲染（硬件加速）介绍" class="headerlink" title="GPU渲染（硬件加速）介绍"></a>GPU渲染（硬件加速）介绍</h2><p>在Android应用程序中是通过Canvas API来绘制UI元素的。在硬件加速渲染环境中,这些Canvas API调用最终会转化为OpenGL API调用(转化过程对应用程序来说是透明的)。由于OpenGL API调用要求发生在Open GL环境中,因此在每当有新的Activity窗口启动时,系统都会为其初始化好OpenGL环境。</p><p>这里的渲染,主要是Android硬件加速,即GPU渲染。android上就是通过libhwui调用OpenGL api来渲染, Android P上libhwui 会调用skia,再调用GLES相关的API进行渲染。</p><p>GPU作为一个硬件 , 用户空间是不可以直接使用的, 它是由GPU厂商按照Open GL规范实现的驱动间接进行使用的。也就是说 , 如果一个设备支持GPU硬件加速渲染, 那么当Android应用程序调用OpenGL接口来绘制UI时 ,Android应用程序的UI就是通过硬件加速技术进行渲染的。</p><p><strong>名词介绍：</strong></p><ul><li>GPU:一个类似于CPU的专门用来处理Graphics的处理器, 作用用来帮助加快栅格化操作, 当然, 也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。</li><li>OpenGL ES:是手持嵌入式设备的3DAPI, 跨平台的、功能完善的2D和3D图形应用程序接口API, 有一套固定渲染管线流程</li><li>DisplayList:在Android把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</li><li>栅格化:是将图片等矢量资源, 转化为一格格像素点的像素图, 显示到屏幕上。</li><li>垂直同步VSYNC:让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前,要等待屏幕绘制完成前一帧。</li><li>RefreshRate:屏幕一秒内刷新屏幕的次数, 由硬件决定, 例如60Hz</li><li>Frame Rate:GPU一秒绘制操作的帧数, 单位是fps</li></ul><h2 id="Android-5-0-之后的渲染框架"><a href="#Android-5-0-之后的渲染框架" class="headerlink" title="Android 5.0 之后的渲染框架"></a>Android 5.0 之后的渲染框架</h2><p>在Android应用程序窗口中, 每一个View都抽象为一个Render Node, 而且如果一个View设置有Background, 这个background 也被抽象为一个Render Node 。</p><p>这是由于在OpenGLRenderer库中, 并没有View的概念, 所有的一切可绘制的元素都抽象为一个Render Node。</p><p>每一个Render Node都关联有一个<code>DisplayList Renderer</code>, Display List是一个绘制命令缓冲区。当View的成员函数onDraw被调用时, 我们调用通过参数传递进来的Canvas的<code>drawXXX</code>成员函数绘制图形时, 我们实际上只是将对应的绘制命令以及参数保存在一个Display List中。接下来再通过DisplayList Renderer执行这个Display List的命令, 这个过程称为Display List Replay。</p><p>Android应用程序窗口的View是通过树形结构来组织的。这些View不管是通过硬件加速渲染还是软件渲染, 或者是一个特殊的TextureView,在它们的成员函数onDraw被调用期间, 它们都是将自己的UI绘制在ParentView的DisplayList中。</p><p>其中, 最顶层的Parent View是一个Root View, 它关联的RootNode称为<code>Root Render Node</code>。也就是说, 最终Root Render Node的DisplayList将会包含一个窗口的所有绘制命令。</p><p>在绘制窗口的下一帧时, RootRender Node的Display List都会通过一个OpenGL Renderer真正地通过Open GL命令绘制在一个<code>Graphic Buffer</code>中。</p><p>最后这个 Graphic Buffer 被交给 SurfaceFlinger 服务进行合成和显示。</p><h2 id="Android原生硬件绘制案例"><a href="#Android原生硬件绘制案例" class="headerlink" title="Android原生硬件绘制案例"></a>Android原生硬件绘制案例</h2><blockquote><p>这个案例是用的SurfaceView.java的流程。这个流程和实际上从ViewRootImpl.java中通过performDraw的流程类似。可以互相借鉴参考。</p></blockquote><p>Android原生的硬件绘制案例，在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>：</p><figure class="highlight java"><figcaption><span>HardwareCanvasSurfaceViewActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SurfaceHolder mSurface;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mWidth, mHeight;</span><br><span class="line">        <span class="comment">//应用拿到一个Surface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RenderingThread</span><span class="params">(SurfaceHolder surface)</span> </span>&#123;</span><br><span class="line">            mSurface = surface;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            mWidth = width;</span><br><span class="line">            mHeight = height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> x = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> y = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedX = <span class="number">5.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedY = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            paint.setColor(<span class="number">0xff00ff00</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (mRunning &amp;&amp; !Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//先调用Surface的lockHardwareCanvas函数</span></span><br><span class="line">                <span class="keyword">final</span> Canvas canvas = mSurface.lockHardwareCanvas();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制</span></span><br><span class="line">                    canvas.drawColor(<span class="number">0x00000000</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">                    canvas.drawRect(x, y, x + <span class="number">20.0f</span>, y + <span class="number">20.0f</span>, paint);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制完成后</span></span><br><span class="line">                    mSurface.unlockCanvasAndPost(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x + <span class="number">20.0f</span> + speedX &gt;= mWidth || x + speedX &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedX = -speedX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">20.0f</span> + speedY &gt;= mHeight || y + speedY &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedY = -speedY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                x += speedX;</span><br><span class="line">                y += speedY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每个15s循环一次</span></span><br><span class="line">                    Thread.sleep(<span class="number">15</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Interrupted</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stopRendering</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            interrupt();</span><br><span class="line">            mRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Java层相关流程（frameworks-base的View模块和graphics模块）"><a href="#Java层相关流程（frameworks-base的View模块和graphics模块）" class="headerlink" title="Java层相关流程（frameworks/base的View模块和graphics模块）"></a>Java层相关流程（frameworks/base的View模块和graphics模块）</h3><ol><li>首先调用关键函数<code>lockHardwareCanvas</code>，在<code>frameworks/base/core/java/android/view/SurfaceView.java</code>：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/SurfaceView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Surface <span class="title">getSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> internalLockCanvas(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Canvas <span class="title">internalLockCanvas</span><span class="params">(Rect dirty, <span class="keyword">boolean</span> hardware)</span> </span>&#123;</span><br><span class="line">        mSurfaceLock.lock();</span><br><span class="line">        Canvas c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mDrawingStopped &amp;&amp; mSurfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hardware) &#123;</span><br><span class="line">                    <span class="comment">//hardware传递的是true，执行lockHardwareCanvas</span></span><br><span class="line">                    c = mSurface.lockHardwareCanvas();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = mSurface.lockCanvas(dirty);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"Exception locking surface"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastLockTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mLastLockTime = now;</span><br><span class="line">        mSurfaceLock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后就调用Surface.java的lockHardwareCanvas函数，此处封装了一个<code>HwuiContext</code>对象，构造函数如下：</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"lockHardwareCanvas"</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          checkNotReleasedLocked();</span><br><span class="line">          <span class="keyword">if</span> (mHwuiContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//Step 1 创建HwuiContext，调用构造函数</span></span><br><span class="line">              mHwuiContext = <span class="keyword">new</span> HwuiContext(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//Step 2 调用他的lockCanvas函数</span></span><br><span class="line">          <span class="keyword">return</span> mHwuiContext.lockCanvas(</span><br><span class="line">                  nativeGetWidth(mNativeObject),</span><br><span class="line">                  nativeGetHeight(mNativeObject));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从上面调用到</span></span><br><span class="line">  <span class="function">Canvas <span class="title">lockCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Surface was already locked!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用RenderNode的beginRecording函数</span></span><br><span class="line">          mCanvas = mRenderNode.beginRecording(width, height);</span><br><span class="line">          <span class="keyword">return</span> mCanvas;</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建RenderNode"><a href="#创建RenderNode" class="headerlink" title="创建RenderNode"></a>创建RenderNode</h3><blockquote><p>RenderNode用以绘图操纵的批处理，当绘制的时候，可以store和apply。java层的代码如下：其实RenderNode就对应前面我们所说的ViewGroup，有一个RootView，同样也有一个RootNode。</p></blockquote><ol><li>在上面Surface.java调用HwuiContext构造函数的时候，会创建RenderNode对象：</li></ol><figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RenderNode和HwuiRender</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RenderNode mRenderNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mHwuiRenderer;</span><br><span class="line">    <span class="keyword">private</span> RecordingCanvas mCanvas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mIsWideColorGamut;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    HwuiContext(<span class="keyword">boolean</span> isWideColorGamut) &#123;</span><br><span class="line">        <span class="comment">//创建一个RenderNode</span></span><br><span class="line">        mRenderNode = RenderNode.create(<span class="string">"HwuiCanvas"</span>, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>创建RenderNode对象：</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RenderNode <span class="title">create</span><span class="params">(String name, @Nullable AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RenderNode(name, animationHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RenderNode</span><span class="params">(String name, AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    mNativeRenderNode = nCreate(name);</span><br><span class="line">    NoImagePreloadHolder.sRegistry.registerNativeAllocation(<span class="keyword">this</span>, mNativeRenderNode);</span><br><span class="line">    mAnimationHost = animationHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>JNI层：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Regular JNI</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line">    &#123; <span class="string">"nCreate"</span>,               <span class="string">"(Ljava/lang/String;)J"</span>, (<span class="keyword">void</span>*) android_view_RenderNode_create &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetNativeFinalizer"</span>,   <span class="string">"()J"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_getNativeFinalizer &#125;,</span><br><span class="line">    &#123; <span class="string">"nOutput"</span>,               <span class="string">"(J)V"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_output &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong android_view_RenderNode_create(JNIEnv* env, jobject, jstring name) &#123;</span><br><span class="line">    <span class="comment">//创建一个native层的rendernode对象</span></span><br><span class="line">    RenderNode* renderNode = <span class="keyword">new</span> RenderNode();</span><br><span class="line">    renderNode-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* textArray = env-&gt;GetStringUTFChars(name, <span class="literal">NULL</span>);</span><br><span class="line">        renderNode-&gt;setName(textArray);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(name, textArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(renderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层，创建好RenderNode是提供给DisplayListCanvas。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RenderNode::RenderNode()</span><br><span class="line">        : mUniqueId(generateId())</span><br><span class="line">        , mDirtyPropertyFields(<span class="number">0</span>)</span><br><span class="line">        , mNeedsDisplayListSync(<span class="literal">false</span>)</span><br><span class="line">        , mDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mStagingDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mAnimatorManager(*<span class="keyword">this</span>)</span><br><span class="line">        , mParentCount(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="beginRecording初始化DisplayList"><a href="#beginRecording初始化DisplayList" class="headerlink" title="beginRecording初始化DisplayList"></a>beginRecording初始化DisplayList</h3><p><img src="beginRecording.jpg" alt="初始化DisplayList"></p><ol><li>在Surface.java中通过lockCanvas调用RenderNode对象的<code>beginRecording</code>函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">RecordingCanvas <span class="title">beginRecording</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mCurrentRecordingCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                 <span class="string">"Recording currently in progress - missing #endRecording() call?"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">     <span class="keyword">return</span> mCurrentRecordingCanvas;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>接着调用RecordingCanvas的obtain函数：</p><p><strong>类的继承关系：</strong> RecordingCanvas类继承DisplayListCanvas，而DisplayListCanvas继承BaseRecordingCanvas，<br>BaseRecordingCanvas继承Canvas（继承BaseCanvas）。</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RecordingCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordingCanvas</span> <span class="keyword">extends</span> <span class="title">DisplayListCanvas</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RecordingCanvas</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));</span><br><span class="line">        mDensity = <span class="number">0</span>; <span class="comment">// disable bitmap density scaling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RecordingCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"node cannot be null"</span>);</span><br><span class="line">        RecordingCanvas canvas = sPool.acquire();</span><br><span class="line">        <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas = <span class="keyword">new</span> RecordingCanvas(node, width, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个native的DisplayListCanvas对象（即显示列表的Canvas）</span></span><br><span class="line">            <span class="comment">//JNI通过mNativeCanvasWrapper（BaseCanvas.java创建）找对应的Native的Canvas</span></span><br><span class="line">            nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                    width, height);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.mNode = node;</span><br><span class="line">        canvas.mWidth = width;</span><br><span class="line">        canvas.mHeight = height;</span><br><span class="line">        <span class="keyword">return</span> canvas;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查看测试案例代码中的<code>canvas.drawColor</code>和<code>canvas.drawRect</code>函数，是调用了其父类<code>BaseCanvas</code>的对应方法。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/Canvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorLong <span class="keyword">long</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawColor(color, BlendMode.SRC_OVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull RectF rect, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawRect(rect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类<code>BaseCanvas.java</code>：</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层Canvas创建（JNI和HWUI模块）</li></ol><p>1.在上面RecordingCanvas.java的构造函数中调用了<code>nCreateDisplayListCanvas</code>函数，对饮的JNI实现：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kClassPathName = <span class="string">"android/graphics/RecordingCanvas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @FastNative ------------------</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">"nCallDrawGLFunction"</span>, <span class="string">"(JJLjava/lang/Runnable;)V"</span>,</span><br><span class="line">            (<span class="keyword">void</span>*) android_view_DisplayListCanvas_callDrawGLFunction &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @CriticalNative --------------</span></span><br><span class="line">    &#123; <span class="string">"nCreateDisplayListCanvas"</span>, <span class="string">"(JII)J"</span>,     (<span class="keyword">void</span>*) android_view_DisplayListCanvas_createDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nResetDisplayListCanvas"</span>,  <span class="string">"(JJII)V"</span>,    (<span class="keyword">void</span>*) android_view_DisplayListCanvas_resetDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureWidth"</span>,  <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureHeight"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nInsertReorderBarrier"</span>,    <span class="string">"(JZ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_insertReorderBarrier &#125;,</span><br><span class="line">    &#123; <span class="string">"nFinishRecording"</span>,         <span class="string">"(J)J"</span>,       (<span class="keyword">void</span>*) android_view_DisplayListCanvas_finishRecording &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRenderNode"</span>,          <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRenderNode &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawTextureLayer"</span>,        <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawTextureLayer &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawCircle"</span>,              <span class="string">"(JJJJJ)V"</span>,   (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawCircleProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRoundRect"</span>,           <span class="string">"(JJJJJJJJ)V"</span>,(<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRoundRectProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawWebViewFunctor"</span>,      <span class="string">"(JI)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawWebViewFunctor &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现，此处的renderNodePtr变量是RenderNode在native层的对象（地址）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到frameworks/base/libs/hwui/hwui/Canvas.cpp，<strong>在Andorid Q中，此处只调用了<code>SkiaRecordingCanvas</code>函数。使用skia进行绘制。</strong></p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/hwui/Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Canvas* <span class="title">Canvas::create_recording_canvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后初始化DisplayList：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SkiaRecordingCanvas</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    initDisplayList(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaRecordingCanvas::initDisplayList</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    mCurrentBarrier = <span class="literal">nullptr</span>;</span><br><span class="line">    SkASSERT(mDisplayList.get() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (renderNode) &#123;</span><br><span class="line">        mDisplayList = renderNode-&gt;detachAvailableList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mDisplayList) &#123;</span><br><span class="line">        mDisplayList.reset(<span class="keyword">new</span> SkiaDisplayList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayList-&gt;attachRecorder(&amp;mRecorder, SkIRect::MakeWH(width, height));</span><br><span class="line">    SkiaCanvas::reset(&amp;mRecorder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Draw绘制操纵"><a href="#Draw绘制操纵" class="headerlink" title="Draw绘制操纵"></a>Draw绘制操纵</h3><blockquote><p>正常流程的绘制是在frameworks/base/core/java/android/view/ThreadedRenderer.java的<code>updateRootDisplayList</code>函数中。<br>调用到drawRnderNode函数绘制。</p></blockquote><ol><li>Java层：上面案例中的<code>drawColor</code>和<code>drawRect</code>实际调用的是在frameworks/base/graphics/java/android/graphics/BaseCanvas.java中：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用JNI层在：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_graphics_Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gDrawMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JII)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColor&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JJJI)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColorLong&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPaint"</span>,<span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPaint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoint"</span>, <span class="string">"(JFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoints"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoints&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLine"</span>, <span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLine&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLines"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLines&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawRect"</span>,<span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawRect&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> drawColor(JNIEnv* env, jobject, jlong canvasHandle, jint color, jint modeHandle) &#123;</span><br><span class="line">    SkBlendMode mode = <span class="keyword">static_cast</span>&lt;SkBlendMode&gt;(modeHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top,</span></span></span><br><span class="line"><span class="function"><span class="params">                     jfloat right, jfloat bottom, jlong paintHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Paint* paint = <span class="keyword">reinterpret_cast</span>&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层：因为<code>class SkiaCanvas : public Canvas</code>，所以调用到SkiaCanvas类中的具体实现：</li></ol><p>调用</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/SkiaCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawColor</span><span class="params">(<span class="keyword">int</span> color, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    mCanvas-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(paint.nothingToDraw())) <span class="keyword">return</span>;</span><br><span class="line">    mCanvas-&gt;drawRect(&#123;left, top, right, bottom&#125;, *filterPaint(paint));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用到<code>external/skia</code>图形库模块：</li></ol><blockquote><p>Skia是Google一个底层的图形、图像、动画、SVG、文本等多方面的图形库，是Android中图形系统的引擎。Skia作为第三方软件放在目录：<code>external/skia/</code>。</p></blockquote><p>主要包含三个库：</p><ul><li>libcorecg.so: 包含<code>/skia/src/core</code>的部分内容，比如其中的<code>Region、Rect</code>是在SurfaceFlinger里面用来计算可视区域的；</li><li>libsgl.so: 包含<code>/skia/src/core|effects|images|ports|utils</code>的部分和全部内容，这个实现了skia大部分的图形效果，以及图形格式的编解码；</li><li>libskiagl.so: 包含<code>/skia/src/gl</code>里面的内容，主要用来调用opengl实现部分效果。</li></ul><figure class="highlight cpp"><figcaption><span>external/skia/src/core/SkCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawColor</span><span class="params">(SkColor c, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setColor(c);</span><br><span class="line">    paint.setBlendMode(mode);</span><br><span class="line">    <span class="keyword">this</span>-&gt;drawPaint(paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawRect</span><span class="params">(<span class="keyword">const</span> SkRect&amp; r, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    TRACE_EVENT0(<span class="string">"skia"</span>, TRACE_FUNC);</span><br><span class="line">    <span class="comment">// To avoid redundant logic in our culling code and various backends, we always sort rects</span></span><br><span class="line">    <span class="comment">// before passing them along.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;onDrawRect(r.makeSorted(), paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HwuiContext和HwuiRenderer"><a href="#HwuiContext和HwuiRenderer" class="headerlink" title="HwuiContext和HwuiRenderer"></a>HwuiContext和HwuiRenderer</h3><h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>从上面的Surface.java中看到，nHwuiCreate创建HwuiRenderer。</p><figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个native的HwuiRender对象</span></span><br><span class="line">mHwuiRenderer = nHwuiCreate(mRenderNode.mNativeRenderNode, mNativeObject,</span><br><span class="line">        isWideColorGamut);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><h4 id="JNI层"><a href="#JNI层" class="headerlink" title="JNI层"></a>JNI层</h4><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gSurfaceMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// HWUI context</span></span><br><span class="line">    &#123;<span class="string">"nHwuiCreate"</span>, <span class="string">"(JJZ)J"</span>, (<span class="keyword">void</span>*) hwui::create &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiSetSurface"</span>, <span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) hwui::setSurface &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDraw"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::draw &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDestroy"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::destroy &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========================================具体实现</span></span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android::uirenderer::renderthread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">create</span><span class="params">(JNIEnv* env, jclass clazz, jlong rootNodePtr, jlong surfacePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean isWideColorGamut)</span> </span>&#123;</span><br><span class="line">    RenderNode* rootNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(rootNodePtr);</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface*&gt;(surfacePtr))</span></span>;</span><br><span class="line">    ContextFactory factory;</span><br><span class="line">    <span class="comment">//创建一个RenderProxy对象，并作为返回对象</span></span><br><span class="line">    RenderProxy* proxy = <span class="keyword">new</span> RenderProxy(<span class="literal">false</span>, rootNode, &amp;factory);</span><br><span class="line">    proxy-&gt;loadSystemProperties();</span><br><span class="line">    <span class="keyword">if</span> (isWideColorGamut) &#123;</span><br><span class="line">        proxy-&gt;setWideGamut(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proxy-&gt;setSwapBehavior(SwapBehavior::kSwap_discardBuffer);</span><br><span class="line">    proxy-&gt;setSurface(surface);</span><br><span class="line">    <span class="comment">// Shadows can't be used via this interface, so just set the light source</span></span><br><span class="line">    <span class="comment">// to all 0s.</span></span><br><span class="line">    proxy-&gt;setLightAlpha(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    proxy-&gt;setLightGeometry((Vector3)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (jlong) proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>以下流程部分是和通常的HWUI环境初始化流程相同的。</strong></p></blockquote><h4 id="native层：调用RenderProxy-cpp构造函数"><a href="#native层：调用RenderProxy-cpp构造函数" class="headerlink" title="*native层：调用RenderProxy.cpp构造函数"></a>*native层：调用RenderProxy.cpp构造函数</h4><p>该构造函数的几个重要成员变量：</p><ul><li>RenderProxy是一个代理者，严格的单线程。所有的方法都必须在自己的线程中调用。<code>MainThread通过这个代理对象想Task Queue发送drawFrame命令</code>；</li><li>RenderThread（即构造函数中的mRenderThread）：渲染线程，是一个单例，也就是说，一个进程中只有一个，所有的绘制操纵都必须在这个线程中完成。应用端很多操纵，都以RenderTask的形式post到RenderThread线程中完成。（在Android 5.0之后独立出来的应用程序的OpenGL线程）</li><li>CanvasContext（即构造函数中的mContext）：上下文，由于OpenGL是单线程的，所以，我们给到GPU的绘图命令都封装在各自的上下文中。这个和上层的HwuiRenderer是对应的。（将窗口绑定到Open GL渲染上下文中，从而使后面的渲染操作都是针对被绑定窗口的）</li><li>DrawFrameTask（即构造函数中的mDrawFrameTask）：一个用来执行渲染任务的task，MainThread通过他向RenderThread线程发送渲染下一帧的命令。（比较特殊的一个RenderTask，可重复使用的绘制Task。）</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"><span class="keyword">namespace</span> renderthread &#123;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(<span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(<span class="literal">nullptr</span>) &#123;  <span class="comment">//Step1 创建RenderThread渲染线程</span></span><br><span class="line">    mContext = mRenderThread.<span class="built_in">queue</span>().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory); <span class="comment">//Step2 创建CanvasContext渲染上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h3 id="创建RenderThread渲染线程"><a href="#创建RenderThread渲染线程" class="headerlink" title="创建RenderThread渲染线程"></a>创建RenderThread渲染线程</h3><ol><li>从上面构造函数中的<code>RenderThread::getInstance()</code>调用下去。创建一个RenderThread线程。</li></ol><p>而该类的父类是ThreadBase.h，父类的父类是Thread.h</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderThread&amp; <span class="title">RenderThread::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is a pointer because otherwise __cxa_finalize</span></span><br><span class="line">    <span class="comment">// will try to delete it like a Good Citizen but that causes us to crash</span></span><br><span class="line">    <span class="comment">// because we don't want to delete the RenderThread normally.</span></span><br><span class="line">    <span class="keyword">static</span> RenderThread* sInstance = <span class="keyword">new</span> RenderThread();</span><br><span class="line">    gHasRenderThreadInstance = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> *sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderThread::RenderThread()</span><br><span class="line">        : ThreadBase()</span><br><span class="line">        , mVsyncSource(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>)</span><br><span class="line">        , mFunctorManager(WebViewFunctorManager::instance())</span><br><span class="line">        , mVkManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    <span class="comment">//实现父类的函数，调用run</span></span><br><span class="line">    start(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>父类创建looper循环和start函数实现，然后开始线程循环：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/thread/ThreadBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadBase()</span><br><span class="line">        : Thread(<span class="literal">false</span>)</span><br><span class="line">        , mLooper(<span class="keyword">new</span> Looper(<span class="literal">false</span>))</span><br><span class="line">        , mQueue([<span class="keyword">this</span>]() &#123; mLooper-&gt;wake(); &#125;, mLock) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"ThreadBase"</span>)</span> </span>&#123; Thread::run(name); &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>开始线程循环，调用ThreadLoop开始工作。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        waitForWork();</span><br><span class="line">        processQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下流程会处理vsync信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::initThreadLocals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setupFrameInterval();</span><br><span class="line">    initializeDisplayEventReceiver();</span><br><span class="line">    mEglManager = <span class="keyword">new</span> EglManager();</span><br><span class="line">    mRenderState = <span class="keyword">new</span> RenderState(*<span class="keyword">this</span>);</span><br><span class="line">    mVkManager = <span class="keyword">new</span> VulkanManager();</span><br><span class="line">    mCacheManager = <span class="keyword">new</span> CacheManager(DeviceInfo::get()-&gt;displayInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::initializeDisplayEventReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Properties::isolatedProcess) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Register the FD</span></span><br><span class="line">        mLooper-&gt;addFd(receiver-&gt;getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">                       RenderThread::displayEventReceiverCallback, <span class="keyword">this</span>);</span><br><span class="line">        mVsyncSource = <span class="keyword">new</span> DisplayEventReceiverWrapper(<span class="built_in">std</span>::move(receiver), [<span class="keyword">this</span>] &#123;</span><br><span class="line">            DeviceInfo::get()-&gt;onDisplayConfigChanged();</span><br><span class="line">            setupFrameInterval();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVsyncSource = <span class="keyword">new</span> DummyVsyncSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderThread::displayEventReceiverCallback</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;RenderThread*&gt;(data)-&gt;drainDisplayEventQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::drainDisplayEventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncEvent = mVsyncSource-&gt;latestVsyncEvent();</span><br><span class="line">    <span class="keyword">if</span> (vsyncEvent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mVsyncRequested = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTimeLord.vsyncReceived(vsyncEvent) &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            ATRACE_NAME(<span class="string">"queue mFrameCallbackTask"</span>);</span><br><span class="line">            mFrameCallbackTaskPending = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">nsecs_t</span> runAt = (vsyncEvent + mDispatchFrameDelay);</span><br><span class="line">            <span class="built_in">queue</span>().postAt(runAt, [<span class="keyword">this</span>]() &#123; dispatchFrameCallbacks(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CanvasContext渲染上下文"><a href="#CanvasContext渲染上下文" class="headerlink" title="CanvasContext渲染上下文"></a>CanvasContext渲染上下文</h3><p>该函数中会选择渲染绘制方式（渲染管线）。在Android Q中取消了OpenGL渲染。</p><ul><li>Android P之前：<code>enum class RenderPipelineType { OpenGL = 0, SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li><li>Android Q：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CanvasContext* <span class="title">CanvasContext::create</span><span class="params">(RenderThread&amp; thread, <span class="keyword">bool</span> translucent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RenderNode* rootRenderNode, IContextFactory* contextFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取渲染方式getRenderPipelineType</span></span><br><span class="line">    <span class="keyword">auto</span> renderType = Properties::getRenderPipelineType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (renderType) &#123;</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaGL:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaVulkan:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"canvas context type %d not supported"</span>, (<span class="keyword">int32_t</span>)renderType);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::getRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sRenderPipelineType = peekRenderPipelineType();</span><br><span class="line">    <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::peekRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If sRenderPipelineType has been locked, just return the locked type immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (sRenderPipelineType != RenderPipelineType::NotInitialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> useVulkan = use_vulkan().value_or(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">//PROPERTY_RENDERER "debug.hwui.renderer"</span></span><br><span class="line">    <span class="comment">//enum class RenderPipelineType &#123; SkiaGL, SkiaVulkan, NotInitialized = 128 &#125;;</span></span><br><span class="line">    property_get(PROPERTY_RENDERER, prop, useVulkan ? <span class="string">"skiavk"</span> : <span class="string">"skiagl"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(prop, <span class="string">"skiavk"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RenderPipelineType::SkiaVulkan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RenderPipelineType::SkiaGL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mRenderPipeline有几种类型，创建CanvasContext时（<code>create函数</code>），会根据pipeline的类型，创建对应的Pipeline。（即调用<code>getRenderPipelineType函数</code>）</p></blockquote><ul><li>渲染类型：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li></ul><hr><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">CanvasContext::CanvasContext(RenderThread&amp; thread, <span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                             IContextFactory* contextFactory,</span><br><span class="line">                             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;IRenderPipeline&gt; renderPipeline)</span><br><span class="line">        : mRenderThread(thread)</span><br><span class="line">        , mGenerationID(<span class="number">0</span>)</span><br><span class="line">        , mOpaque(!translucent)</span><br><span class="line">        , mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</span><br><span class="line">        , mJankTracker(&amp;thread.globalProfileData(), DeviceInfo::get()-&gt;displayInfo())</span><br><span class="line">        , mProfiler(mJankTracker.frames(), thread.timeLord().frameIntervalNanos())</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mRenderPipeline(<span class="built_in">std</span>::move(renderPipeline)) &#123;</span><br><span class="line">    rootRenderNode-&gt;makeRoot();</span><br><span class="line">    mRenderNodes.emplace_back(rootRenderNode);  <span class="comment">//是前面创建的RenderNode</span></span><br><span class="line">    mProfiler.setDensity(DeviceInfo::get()-&gt;displayInfo().density);</span><br><span class="line">    setRenderAheadDepth(Properties::defaultRenderAhead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面调用nHwuiCreate的JNI层，会创建ContextFactory，然后在此处的构造函数中会使用到。主要用来创建AnimationContext，即<code>mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</code></p><p>AnimationContext主要用来处理动画Animation。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AnimationContext* <span class="title">createAnimationContext</span><span class="params">(renderthread::TimeLord&amp; clock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnimationContext(clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>CanvasContext实现了IFrameCallback接口，所以，CanvasContext能接收编舞者Choreographer的callback，处理实时动画。<code>class CanvasContext : public IFrameCallback {...}</code></li></ul><h4 id="RenderThread渲染线程"><a href="#RenderThread渲染线程" class="headerlink" title="RenderThread渲染线程"></a>RenderThread渲染线程</h4><blockquote><p><strong>RenderThread渲染运行模型</strong>:空闲的时候, RenderThread睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnceh中。当其他线程需要调度RenderThread, 会向他的任务队列添加一个任务, 然后唤醒RenderThread进行处理。RenderThread通过<code>processQueue</code>方法处理任务。</p></blockquote><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承ThreadBase，而ThreadBase是继承基类Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderThread</span> :</span> <span class="keyword">private</span> ThreadBase &#123;</span><br><span class="line">    <span class="comment">//组织拷贝构造函数和重载</span></span><br><span class="line">    PREVENT_COPY_AND_ASSIGN(RenderThread);</span><br></pre></td></tr></table></figure><ol><li>调用构造函数中，同时启动了渲染线程RenderThread：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::RenderThread()</span><br><span class="line">        : ThreadBase()</span><br><span class="line">        , mVsyncSource(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>)</span><br><span class="line">        , mFunctorManager(WebViewFunctorManager::instance())</span><br><span class="line">        , mVkManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    start(<span class="string">"RenderThread"</span>); <span class="comment">//线程启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看父类的构造函数：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/thread/ThreadBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadBase()</span><br><span class="line">        : Thread(<span class="literal">false</span>)</span><br><span class="line">        , mLooper(<span class="keyword">new</span> Looper(<span class="literal">false</span>))</span><br><span class="line">        , mQueue([<span class="keyword">this</span>]() &#123;</span><br><span class="line">             mLooper-&gt;wake();  <span class="comment">//此处调用是唤醒mLooper，线程开始工作</span></span><br><span class="line">        &#125;, mLock) &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在渲染线程启动后，会调用RenderThread.cpp的threadLoop函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line">    Looper::setForThread(mLooper);</span><br><span class="line">    <span class="keyword">if</span> (gOnStartHook) &#123;</span><br><span class="line">        gOnStartHook(<span class="string">"RenderThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化Thread的本地变量</span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//没有任务就等在此处</span></span><br><span class="line">        waitForWork();</span><br><span class="line">        processQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Clean this up. This is working around an issue where a combination</span></span><br><span class="line">            <span class="comment">// of bad timing and slow drawing can result in dropping a stale vsync</span></span><br><span class="line">            <span class="comment">// on the floor (correct!) but fails to schedule to listen for the</span></span><br><span class="line">            <span class="comment">// next vsync (oops), so none of the callbacks are run.</span></span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="DrawFrameTask构造函数"><a href="#DrawFrameTask构造函数" class="headerlink" title="DrawFrameTask构造函数"></a>DrawFrameTask构造函数</h4><p>在<code>RenderProxy</code>调用构造函数时，会创建DrawFrameTask，同时调用其<code>setContext</code>函数：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DrawFrameTask::DrawFrameTask()</span><br><span class="line">        : mRenderThread(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContext(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mSyncResult(SyncResult::OK) &#123;&#125;</span><br><span class="line"></span><br><span class="line">DrawFrameTask::~DrawFrameTask() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::setContext</span><span class="params">(RenderThread* thread, CanvasContext* context,</span></span></span><br><span class="line"><span class="function"><span class="params">                               RenderNode* targetNode)</span> </span>&#123;</span><br><span class="line">    mRenderThread = thread;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mTargetNode = targetNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="syncAndDrawFrame绘制帧"><a href="#syncAndDrawFrame绘制帧" class="headerlink" title="syncAndDrawFrame绘制帧"></a>syncAndDrawFrame绘制帧</h3><ol><li>从上面的分析看，DisplayList和RenderThread都创建好了，正常绘制的时候会调用到<code>syncAndDrawFrame</code>：</li></ol><p>从ViewRootImpl的performDraw函数调用到draw，在调用到 ThreadedRenderer.java的draw函数。开始绘制：</p><figure class="highlight java"><figcaption><span>ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">      choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">      <span class="comment">//绘制每个视图的内容（在文章下面会梳理）</span></span><br><span class="line">      updateRootDisplayList(view, callbacks);</span><br><span class="line">      <span class="comment">//绘制一帧的内容</span></span><br><span class="line">      <span class="keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!mContext, <span class="string">"Cannot drawFrame with no CanvasContext!"</span>);</span><br><span class="line"></span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().post([<span class="keyword">this</span>]() &#123; run(); &#125;); <span class="comment">//执行此处的run函数</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此时，drawFrame，也就通过RenderThread，post一个WorkItem到RenderThread的队列里面，在RenderThread线程中执行的。</li></ol><p>然后RenderThread处理Queue时，执行的会是DrawFrameTask的run函数。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//info，即描述Viewtree的，也就是RenderNode tree</span></span><br><span class="line">        <span class="comment">//此处的mode是MODE_FULL，即只有primary的node是FULL，其他都是实时 **</span></span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        <span class="comment">//同步Frame帧状态</span></span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        <span class="comment">//判断是否可以绘制这一帧</span></span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFrameCompleteCallback) &#123;</span><br><span class="line">            mContext-&gt;addFrameCompleteListener(<span class="built_in">std</span>::move(mFrameCompleteCallback));</span><br><span class="line">            mFrameCompleteCallback = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int64_t</span>)&gt; callback = <span class="built_in">std</span>::move(mFrameCallback);</span><br><span class="line">    mFrameCallback = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        <span class="comment">//**绘制</span></span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步Frame的State</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DrawFrameTask::syncFrameState</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="comment">//通知GPU处理当前的Context上下文</span></span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    <span class="comment">//hwui为了提高速度，对各种object都做了cache，此处unpin，就是让cache去做unpin，其他都不要了</span></span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    <span class="comment">//设置绘制的区域大小</span></span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    <span class="comment">//**Android View是树型结构的，这就是在绘制之前，去准备这些Tree节点的绘图操作</span></span><br><span class="line">    <span class="comment">//准备绘制一帧的数据</span></span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h4><ol><li>调用函数<strong>prepareTree</strong>：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::prepareTree</span><span class="params">(TreeInfo&amp; info, <span class="keyword">int64_t</span>* uiFrameInfo, <span class="keyword">int64_t</span> syncQueued,</span></span></span><br><span class="line"><span class="function"><span class="params">                                RenderNode* target)</span> </span>&#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRenderPipeline-&gt;onPrepareTree();</span><br><span class="line">    <span class="comment">//Context可能会有多个Node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        <span class="comment">//即只有Primary的node是 FULL，其他都是实时</span></span><br><span class="line">        info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);</span><br><span class="line">        <span class="comment">//此处遍历，对每个RenderNode都进行prepare</span></span><br><span class="line">        node-&gt;prepareTree(info);</span><br><span class="line">        GL_CHECKPOINT(MODERATE);</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    freePrefetchedLayers();</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    mIsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果窗口已经没有Native Surface，这一帧就丢掉！！</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!hasSurface())) &#123;</span><br><span class="line">        mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame);</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">                                &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>遍历RenderNode的prepareTree方法：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTree</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!info.damageAccumulator, <span class="string">"DamageAccumulator missing"</span>);</span><br><span class="line">    <span class="function">MarkAndSweepRemoved <span class="title">observer</span><span class="params">(&amp;info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> before = info.disableForceDark;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">    prepareTreeImpl(observer, info, <span class="literal">false</span>);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(before != info.disableForceDark, <span class="string">"Mis-matched force dark"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>prepareTreeImpl是RenderNode真正进行Prepare的地方。</li></ol><p>damageAccumulator是从CanvasContext中传过来的，是CanvasContext的成员，damage的叠加器。主要是用来标记，屏幕的那些区域被破坏了，需要重新绘制，所有的RenderNode累加起来，就是总的。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTreeImpl</span><span class="params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="keyword">bool</span> functorsNeedLayer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDamageGenerationId == info.damageGenerationId) &#123;</span><br><span class="line">        info.damageAccumulator-&gt;dirty(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Step 1</span></span><br><span class="line">    info.damageAccumulator-&gt;pushTransform(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        <span class="comment">//property是对RenderNode的描述，也就是对View的描述，比如大小，位置等。</span></span><br><span class="line">        <span class="comment">//有两个状态，正在使用的syncProperties和待处理的mStagingProperties。</span></span><br><span class="line">        <span class="comment">//syncProperties时，将mStagingProperties赋值给syncProperties</span></span><br><span class="line">        pushStagingPropertiesChanges(info);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    pushLayerUpdate(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mProperties.getAllowForceDark()) &#123;</span><br><span class="line">        info.disableForceDark--;</span><br><span class="line">    &#125;</span><br><span class="line">    info.damageAccumulator-&gt;popTransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用pushTransform函数，damage累加器中，每一个元素由DirtyStack描述，分两种类型：TransformMatrix4和TransformRenderNode。采用一个双向链表mHead进行管理。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/DamageAccumulator.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHead-&gt;next) &#123;</span><br><span class="line">        DirtyStack* nextFrame = mAllocator.create_trivial&lt;DirtyStack&gt;();</span><br><span class="line">        nextFrame-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        nextFrame-&gt;prev = mHead;</span><br><span class="line">        mHead-&gt;next = nextFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    mHead = mHead-&gt;next;</span><br><span class="line">    mHead-&gt;pendingDirty.setEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushTransform</span><span class="params">(<span class="keyword">const</span> RenderNode* transform)</span> </span>&#123;</span><br><span class="line">    pushCommon();</span><br><span class="line">    mHead-&gt;type = TransformRenderNode;</span><br><span class="line">    mHead-&gt;renderNode = transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时prepare完成后，绘制一帧的数据就准备好了。</p><hr><h3 id="绘制帧数据"><a href="#绘制帧数据" class="headerlink" title="绘制帧数据"></a>绘制帧数据</h3><ol><li>从<code>syncAndDrawFrame绘制帧</code>上面的章节，此处会调用到HardwareRenderer.java父类函数；</li><li>然后JNI到Native层，调用到RenderProxy.cpp的该函数，</li><li>再到<code>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</code>的drawFrame函数，开始绘制一帧数据，</li><li>此时启动RenderThread线程的run函数，调用到关键函数<code>CanvasContext::draw()</code></li></ol><p>Android Q中，具体绘制是在各自的pipeline中进行的。（在<code>frameworks/base/libs/hwui/pipeline/</code>）</p><p>在Android P中，一般是执行的<code>frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp</code></p><p>在Android Q中，可以看出Google在慢慢用Vulkan替代OpenGL。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line">    <span class="comment">//跳过绘制条件：脏区域为空、空帧数据、不需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; Properties::skipEmptyFrames &amp;&amp; !surfaceRequiresRedraw()) &#123;</span><br><span class="line">        mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    mCurrentFrameInfo-&gt;markIssueDrawCommandsStart();</span><br><span class="line">    <span class="comment">//获取frame(一帧数据信息，主要是ufferAge、Surface等)</span></span><br><span class="line">    Frame frame = mRenderPipeline-&gt;getFrame();</span><br><span class="line">    setPresentTime();</span><br><span class="line"></span><br><span class="line">    SkRect windowDirty = computeDirtyRect(frame, &amp;dirty);</span><br><span class="line">    <span class="comment">//绘制</span></span><br><span class="line">    <span class="keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> frameCompleteNr = mFrameCompleteCallbacks.size() ? getFrameNumber() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    waitOnFences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> requireSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//绘制完成后调用</span></span><br><span class="line">    <span class="keyword">bool</span> didSwap =</span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制完成后unlockCanvasAndPost流程"><a href="#绘制完成后unlockCanvasAndPost流程" class="headerlink" title="绘制完成后unlockCanvasAndPost流程"></a>绘制完成后unlockCanvasAndPost流程</h3><p>回到绘制案例，此时，RenderThread，DrawFrameTask，CanvasContext等已经就绪，绘制操纵已经被添加到了DisplayList中。</p><ol><li>绘制完成，然后会在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>中调用到<code>方法unlockCanvasAndPost</code>。</li></ol><p>SurfaceHolder直接调的Surface的unlockCanvasAndPost。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHwuiContext != null) &#123;</span><br><span class="line">                <span class="comment">//硬件加速执行此处</span></span><br><span class="line">                mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//软件绘制</span></span><br><span class="line">                unlockSwCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">//HwuiContext的unlockAndPost函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unlockAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (canvas != mCanvas) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"canvas object must be the same instance that "</span></span><br><span class="line">                        + <span class="string">"was previously returned by lockCanvas"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRenderNode.endRecording();</span><br><span class="line">            mCanvas = null;</span><br><span class="line">            nHwuiDraw(mHwuiRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>上面代码看到，在lockHardwareCanvas的时候有相同流程，会调用<code>mRenderNode.beginRecording</code>。</li></ol><p>此处就对应的调用到<code>mRenderNode.endRecording();</code>，结束RenderNode，保存数据。</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mCurrentRecordingCanvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"No recording in progress, forgot to call #beginRecording()?"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       RecordingCanvas canvas = mCurrentRecordingCanvas;</span><br><span class="line">       mCurrentRecordingCanvas = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//Step1 先结束Canvas的录制</span></span><br><span class="line">       <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">       <span class="comment">//Step2 然后将录制的list给mNativeRenderNode</span></span><br><span class="line">       nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">       canvas.recycle();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>首先finishRecording函数通过JIN层<code>android_view_DisplayListCanvas.cpp</code>调用到Native层。</li></ol><p>返回录制好的mDisplayList。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uirenderer::DisplayList* <span class="title">SkiaRecordingCanvas::finishRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// close any existing chunks if necessary</span></span><br><span class="line">    insertReorderBarrier(<span class="literal">false</span>);</span><br><span class="line">    mRecorder.restoreToCount(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mDisplayList.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>第二步的nSetDisplayList通过JNI层<code>android_view_RenderNode.cpp</code>调用到Native层。</li></ol><p>将displayList给到RenderNode的mStagingDisplayList。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::setStagingDisplayList</span><span class="params">(DisplayList* displayList)</span> </span>&#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Activity-HWUI渲染环境初始化流程（RenderThreadc创建）"><a href="#Activity-HWUI渲染环境初始化流程（RenderThreadc创建）" class="headerlink" title="Activity HWUI渲染环境初始化流程（RenderThreadc创建）"></a>Activity HWUI渲染环境初始化流程（RenderThreadc创建）</h2><blockquote><p>主要是通过setView创建rendernode，渲染线程RenderThread，Context上下文，RenderProxy代理对象等。</p></blockquote><h3 id="附序列图"><a href="#附序列图" class="headerlink" title="附序列图"></a>附序列图</h3><p><img src="HWUI_Initialize_RenderThreadCreate.png" alt="Android HWUI环境初始化 - 创建RenderThread"></p><h3 id="Java层-1"><a href="#Java层-1" class="headerlink" title="Java层"></a>Java层</h3><ol><li>Activity.java开始设置view：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/app/Activity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWindow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(view);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>PhoneWindow继承Window抽象类调用setContentView函数：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新对象ViewGroup</span></span><br><span class="line">        setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用此处添加一个view到Parent View中</span></span><br><span class="line">            mContentParent.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>mContentParent.addView(view, params);</code>，mContentParent是ViewGroup类型对象。</p><p>ViewGroup实现接口ViewManager，而<code>interface WindowManager extends ViewManager</code>，WindowManagerImpl.java又是接口WindowManager的实现类。所以会同时调用WindowManagerImpl类的addView函数。</p><ol start="3"><li>WindowManagerImpl.java调用addView函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用windowManagerGlobal的addView函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用ViewRootImpl的setView函数</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>ViewRootImpl.java中调用流程：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We have one child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置根节点视图（顶层视图）</span></span><br><span class="line">            mView = view;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// While this is supposed to enable only, it can effectively disable</span></span><br><span class="line">                <span class="comment">// the acceleration too.</span></span><br><span class="line">                <span class="comment">//启动硬件加速！</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                    <span class="comment">// Shouldn't be resizing, as it's done only in window setup,</span></span><br><span class="line">                    <span class="comment">// but end just in case.</span></span><br><span class="line">                    endDragResizing();</span><br><span class="line">                    mUseMTRenderer = useMTRenderer;</span><br><span class="line">            ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在ThreadedRenderer的create函数中new了一个该对象，从而调用其构造函数。构造函数的<code>super()</code>调用基类HardwareRenderer的构造函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/HardwareRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance of a HardwareRenderer. The HardwareRenderer will default</span></span><br><span class="line"><span class="comment"> * to opaque with no light source configured.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//创建硬件渲染rendernode对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HardwareRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个窗口的Root Render Node，并用Java层的RenderNode封装起来，即adopt通过new对象返回一个java层的RenderNode对象</span></span><br><span class="line">    mRootNode = RenderNode.adopt(nCreateRootRenderNode());</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//调用到JNI层，创建一个RenderProxy（即MainThread的代理对象）</span></span><br><span class="line">    mNativeProxy = nCreateProxy(!mOpaque, mRootNode.mNativeRenderNode);</span><br><span class="line">    <span class="keyword">if</span> (mNativeProxy == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Unable to create hardware renderer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> DestroyContextRunnable(mNativeProxy));</span><br><span class="line">    ProcessInitializer.sInstance.init(mNativeProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h3><ol><li>从上面的nCreateRootRenderNode函数调用到JNI层的android_view_ThreadedRenderer.cpp文件中。</li></ol><p>创建一个窗口的Root Render Node。</p><p>之后创建RenderProxy对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = <span class="keyword">reinterpret_cast</span>&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>之后调用RenderProxy构造函数，就同上面Google原生绘制案例的流程分析相同<code>RenderProxy::RenderProxy(){...}</code>，负责从MainThread向RenderThread发送命令。</li></ol><p><strong>参考上面的<code>native层：调用RenderProxy.cpp构造函数</code>和<code>CanvasContext渲染上下文</code>章节</strong></p><h3 id="ThreadedRenderer架构图"><a href="#ThreadedRenderer架构图" class="headerlink" title="ThreadedRenderer架构图"></a>ThreadedRenderer架构图</h3><p><img src="ThreadedRenderer.jpg" alt="ThreadedRenderer和底层结构关系"></p><hr><h2 id="Activity-窗口绘制流程"><a href="#Activity-窗口绘制流程" class="headerlink" title="Activity 窗口绘制流程"></a>Activity 窗口绘制流程</h2><blockquote><p>由ViewRootImpl的成员函数<code>performTraversals</code>发起。</p></blockquote><ol><li>在绘制之前，首先需要创建一个Surface，即描述一个窗口（创建Surface的流程后续单独整理）</li><li>一旦获得对应的Surface， 就需要将其绑定到RenderThread中。</li><li>Activity窗口对应的Surface是通过ViewRootImpl类的成员函数<code>relayoutWindow</code>向WindowManagerService服务请求创建和返回的，并且保存在ViewRootImpl类的成员变量mSurface中。</li><li>如果Surface是新创建的，将调用ViewRootImpl类的成员变量mAttachInfo指向的AttachInfo函数。对象的成员变量mHardwareRenderer描述的一个HardwareRenderer对象的成员函数<code>initialize</code>将它绑定到RenderThread中。</li><li>最后, 如果需要绘制当前的Activity窗口, 那会调用 iewRootImpl类的另外一个成员函数<code>performDraw</code></li></ol><blockquote><p>此处在performTraversals函数中，先是用relayoutWindow创建mSurface，将Native层之前通过构造函数创建的Surface copy过来。<br>而后是三个主要流程：performMeasure测量、performLayout布局、performDraw绘制</p></blockquote><h3 id="绘制序列图"><a href="#绘制序列图" class="headerlink" title="绘制序列图"></a>绘制序列图</h3><p><img src="%E7%A1%AC%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" alt="Android HWUI窗口绘制"></p><h3 id="ViewRootImpl中的软-硬件绘制区分"><a href="#ViewRootImpl中的软-硬件绘制区分" class="headerlink" title="ViewRootImpl中的软/硬件绘制区分"></a>ViewRootImpl中的软/硬件绘制区分</h3><p>在ViewRootImpl.java的draw函数中：</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">        Surface surface = mSurface;</span><br><span class="line">        <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with hardware renderer.</span></span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//硬件加速</span></span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">//软件绘制</span></span><br><span class="line">                <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">                        Log.v(mTag, <span class="string">"drawSoftware return: this = "</span> + <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>drawSoftware中会调用到Surface.java的<code>lockCanvas</code>和<code>unlockCanvasAndPost</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">/// M: add for white list @&#123;</span></span><br><span class="line">            <span class="comment">//如果在白名单，则返回，仍使用硬件绘制</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceExt.isInWhiteList()) &#123;</span><br><span class="line">                <span class="keyword">return</span> lockHardwareCanvas();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// @&#125;</span></span><br><span class="line">            ...</span><br><span class="line">            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">            <span class="keyword">return</span> mCanvas;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            nativeRelease(mLockedObject);</span><br><span class="line">            mLockedObject = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化DisplayList"><a href="#初始化DisplayList" class="headerlink" title="初始化DisplayList"></a>初始化DisplayList</h3><ol><li>updateRootDisplayList方法的作用是先初始化DIsplayList（即调用<code>beginRecording</code>，流程同上面案例中的分析），然后绘制整个树型视图结构，从顶层视图开始，每个视图节点逐一绘制，最终目的是触发每个视图的<code>Canvas#draw***</code>方法。</li><li><code>syncAndDrawFrame</code>查看上面章节<code>绘制准备，同步帧</code></li></ol><p>updateRootDisplayList方法分成两步：</p><ol><li>先顶层视图结构遍历绘制，更新DisplayList数据，</li><li>第二步是ThreadedRenderer的根RenderNode绘制，同样，通过根RenderNode创建DisplayListCanvas，通过它的drawRenderNode方法，负责绘制顶层视图DecorView的RenderNode节点。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">        choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        updateRootDisplayList(view, callbacks);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//同步帧数据，最终目的OpenGL指令写入gpu</span></span><br><span class="line">        <span class="keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Step1 初始化DisplayList，从顶层视图开始，更新所有视图的DisplayList</span></span><br><span class="line">        updateViewTreeDisplayList(view);</span><br><span class="line">        <span class="comment">//Step2 根节点绘制顶层视图RenderNode</span></span><br><span class="line">        <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;</span><br><span class="line">            <span class="comment">//参考上面目录`beginRecording创建DisplayList`小节</span></span><br><span class="line">            RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">                canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">                callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">                canvas.enableZ();</span><br><span class="line">                <span class="comment">//此处还会调用一次根View的updateDisplayListIfDirty方法，不会再进行一次View树绘制</span></span><br><span class="line">                <span class="comment">//这时的view还是DecorView，它的DisplayListCanvas已经end结束记录</span></span><br><span class="line">                <span class="comment">//并且，View的RenderNode节点mValid已有效，且mRecreateDisplayList标志已被恢复。</span></span><br><span class="line">                canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">                canvas.disableZ();</span><br><span class="line"></span><br><span class="line">                callbacks.onPostDraw(canvas);</span><br><span class="line">                canvas.restoreToCount(saveCount);</span><br><span class="line">                mRootNodeNeedsUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mRootNode.endRecording();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="绘制view视图"><a href="#绘制view视图" class="headerlink" title="绘制view视图"></a>绘制view视图</h3><p><img src="ThreadedRender_Draw.jpg" alt="绘制视图"></p><blockquote><p>参考上面目录<code>beginRecording初始化DisplayList</code>小节</p></blockquote><ul><li>updateViewTreeDisplayList方法，从顶层视图DecorView开始，遍历树形视图结构的每一个节点，利用视图内的RenderNode创建Canvas，绘制。</li><li>利用ThreadedRenderer的根RootRenderNode创建Canvas，绘制顶层RenderNode节点</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">     view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">     <span class="comment">//判断视图的PFLAG_INVALIDATED标志</span></span><br><span class="line">     <span class="comment">//有这个标志，在调用每个View的updateDisplayListIfDirty()时，才会创建Canvas</span></span><br><span class="line">     <span class="comment">//当一个视图需要绘制时，上层肯定会设置该标志</span></span><br><span class="line">     <span class="comment">//最后会将重建标志还原</span></span><br><span class="line">     view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">             == View.PFLAG_INVALIDATED;</span><br><span class="line">     view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">     <span class="comment">//此处会用到mRecreateDisplayList进行判断是否创建DisplayListCanvas</span></span><br><span class="line">     view.updateDisplayListIfDirty();</span><br><span class="line">     view.mRecreateDisplayList = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>每个视图的流程是一样的，都有三个步骤，第一次绘制时，每个视图都要建立Canvas。</p><ol><li>通过视图RenderNode节点start方法，创建DisplayListCanvas画布对象（调用<code>beginRecording</code>，流程同上面案例中的分析）</li><li>通过View的draw(canvas)方法，实现具体记录绘制操作，(绘制自身与派发)，draw方法包括很多步骤，包括递归到子视图的updateDisplayListIfDirty方法。</li><li>最后，RenderNode结束记录<code>endRecording</code>方法。</li></ol><h4 id="draw实现视图绘制六个步骤"><a href="#draw实现视图绘制六个步骤" class="headerlink" title="draw实现视图绘制六个步骤"></a>draw实现视图绘制六个步骤</h4><p>第二步的draw实现视图绘制。参数就是上面创建的DisplayListConvas画布，视图有一些公用绘制，例如背景，滚定条，修饰等。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体视图绘制六个步骤：</strong></p><ol><li>绘制背景:<code>drawBackground(canvas)</code></li></ol><ul><li>这里会先得到一个mBGDrawable对象</li><li>然后根据layout过程确定的视图位置来设置背景的绘制区域</li><li>之后再调用Drawable的draw()方法来完成背景的绘制工作</li></ul><ol start="2"><li>必要时保存canvas的layers，绘制边缘fade</li><li>onDraw方法：绘制视图内容，调用Canvas API，<strong>此处是空方法，子类会实现。例如TextView、ImageView等类的源码，它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用，可以将其当成一块画布</strong></li></ol><ul><li>下面有个APP代码案例</li></ul><ol start="4"><li>dispatchDraw派发绘制子视图，空方法，容器类视图会重写。如果有跳过标志，将不会来到draw方法，直接去dispatchDraw。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处调用View.java的三个参数的draw函数中，也会调用<code>updateDisplayListIfDirty()</code>函数。并且如果是硬件绘制会重新判断<code>mRecreateDisplayList</code>。</p><p>这样就实现了View视图的递归绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (hardwareAcceleratedCanvas) &#123;</span><br><span class="line">            <span class="comment">// Clear INVALIDATED flag to allow invalidation to occur during rendering, but</span></span><br><span class="line">            <span class="comment">// retain the flag's value temporarily in the mRecreateDisplayList flag</span></span><br><span class="line">            mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="number">0</span>;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>如有绘制fading edges，恢复canvas’ layers。</li><li>绘制修饰，如滚动条。</li></ol><hr><h4 id="APP绘制案例代码"><a href="#APP绘制案例代码" class="headerlink" title="APP绘制案例代码"></a>APP绘制案例代码</h4><ol><li>假如APP代码中创建一个非常简单的视图，并且用Canvas随便绘制了一点东西，代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        mPaint.setColor(Color.YELLOW);</span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), mPaint);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        mPaint.setTextSize(<span class="number">20</span>);</span><br><span class="line">        String text = <span class="string">"Hello View"</span>;</span><br><span class="line">        canvas.drawText(text, <span class="number">0</span>, getHeight() / <span class="number">2</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制。</p><p>绘制逻辑比较简单，在<code>onDraw()</code>方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。</p><ol start="2"><li>然后在XML布局假如这个视图，将MyView的宽度设置成200dp，高度设置成100dp。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.diyview.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="关闭硬件加速"><a href="#关闭硬件加速" class="headerlink" title="关闭硬件加速"></a>关闭硬件加速</h2><p>android提供了以下四个级别的硬件加速控制：</p><ul><li>Application：<code>&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</code></li><li>Activity：例如启用全局的硬件加速，但却禁止了一个Activity的硬件加速：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:hardwareAccelerated</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Window：针对给定的Window来启用硬件加速：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setFlags(</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</span><br></pre></td></tr></table></figure><ul><li>View级别：针对一个独立的View对象使用下列代码来禁止硬件加速：<code>myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</code></li></ul><p><strong>android关闭硬件加速的方法：</strong></p><ol><li>APK中，在AndroidManifest.xml中设置<code>android:hardwareAccelerated=&quot;false&quot;</code>，这是关闭整个app的硬件加速，慎用！</li><li>View有个方法支持单独的View关闭硬件加速，可以设置<code>mView.setLaterType(View.LAYER_TYPE_SOFTWARE);</code>，或者关闭某一个控件的硬件加速功能使用<code>findViewById(R.id.btn).setLayerType(View.LAYER_TYPE_SOFTWARE,null);</code></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在Java层，硬件渲染由ThreadedRenderer负责，每个窗体根视图ViewRootImpl下都有一个ThreadedRenderer，保存在AttachInfo，<code>它的draw方法是硬件渲染绘制的入口</code>。</li><li>从ViewRootImpl开始，一般视图会创建ThreadedRenderer，启用硬件渲染，关键点在遍历每一个视图，根据视图RenderNode创建画布，<code>有效绘制记录存储在RenderNode关联的底层DisplayListData</code></li><li>绘制架构包含<code>RenderNode节点，DisplayListCanvas画布，底层DisplayListData对象，CanvasState状态存储对象</code>，做完这些初始化工作，就可以在Java层画布上执行绘制操作方法。<code>树形视图结构每一节点都有一个DisplayListCanvas，利用Canvas#drawXxx方法分别记录一些绘制操作，drawXxx画点、圆、矩形等操作，将这些操作存储在一个DisplayList集合中，这是App的UI线程负责的任务</code></li><li><code>onDraw方法自己在APP中重写</code>，View和ViewGroup有什么自己需要的绘制在这里完成。</li><li>View的dispatchDraw是空方法，不做任何操作。ViewGroup重写dispatchDraw方法，实现绘制派发到子视图。容器视图一般没有自己要绘制的东西，可能在updateDisplayListIfDirty方法就已经选择dispatchDraw了；</li><li>顶层视图绘制入口是draw(一个参数)方法，在draw(一个参数)中，包含六个步骤，第四步会派发每个子视图，子视图绘制入口是draw(三个参数)，在draw(三个参数)中，会根据硬件渲染，进入每个子视图updateDisplayListIfDirty方法，实现递归绘制；</li><li>当走到RenderNode的<code>endRecording</code>方法时，表示视图本身以及子视图已经全部绘制完毕，也就是说当DecorView的RenderNode#end方准备执行时，所有draw已经完成</li><li>View构造方法创建每一个视图的RenderNode。每一个RenderNode都会创建DisplayListCanvas，使用时是一一对应关系；</li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li>Android Q AOSP： <a href="http://aosp.opersys.com/xref/android-10.0.0_r39/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r39/</a></li><li>Android P 图像显示系统（三）Android HWUI 绘制流程： <a href="https://www.jianshu.com/p/abfaea892611" target="_blank" rel="noopener">https://www.jianshu.com/p/abfaea892611</a></li><li>硬件渲染一绘制阶段上层基本流程：<a href="https://www.jianshu.com/p/85d38ef937e9" target="_blank" rel="noopener">https://www.jianshu.com/p/85d38ef937e9</a></li><li>Android视图绘制流程之onDraw()：<a href="https://www.jianshu.com/p/f0f44cd58711" target="_blank" rel="noopener">https://www.jianshu.com/p/f0f44cd58711</a></li><li>Android硬件加速（译文）：<a href="https://www.jianshu.com/p/601a21b00475" target="_blank" rel="noopener">https://www.jianshu.com/p/601a21b00475</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android ANR traces.txt文件分析</title>
    <link href="https://alonealive.github.io/Blog/2020/06/11/2020/200611_android_tracetxt/"/>
    <id>https://alonealive.github.io/Blog/2020/06/11/2020/200611_android_tracetxt/</id>
    <published>2020-06-11T15:52:00.000Z</published>
    <updated>2020-07-22T12:03:21.223Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>trace.txt</code>生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。</p></blockquote><a id="more"></a><p>ANR:Application Not Responding，即应用无响应</p><h2 id="ANR类型"><a href="#ANR类型" class="headerlink" title="ANR类型"></a>ANR类型</h2><p>一般有三种类型:</p><ol><li>KeyDispatchTimeout(5 seconds) –主要类型：按键或触摸事件在特定时间内无响应</li><li>BroadcastTimeout(10 seconds)  –BroadcastReceiver：在特定时间内无法处理完成</li><li>ServiceTimeout(20 seconds) –小概率类型：Service在特定的时间内无法处理完成</li></ol><p>另外还有<code>ProviderTimeout</code>和<code>WatchDog看门狗</code>等导致的ANR。</p><p>还有当系统内存或CPU资源不足时容易出现ANR， 一般这种情况会有<code>lowmemorykill</code>的log打印。</p><p>应用ANR产生的时候，在<code>ActivityManagerService</code>中会调用<code>appNotResponding</code>方法, 然后在<code>/data/anr/traces.txt</code>文件中写入ANR相关信息。</p><h2 id="trace-txt获取"><a href="#trace-txt获取" class="headerlink" title="trace.txt获取"></a>trace.txt获取</h2><ol><li><code>adb shell</code>进入手机的<code>/data/anr</code>文件目录下面查看生成的<code>trace.txt</code>文件(如果<code>ls</code>查看文件列表没有权限,可以先<code>adb root</code>一下)</li><li><code>adb pull /data/anr/</code> 将该文件导出,然后分析</li></ol><p>log打印了ANR的基本信息(<code>adb shell top</code>查看进程, <code>adb logcat -v process |grep PID</code>查看日志), 可以分析<code>CPU使用率</code>得知ANR的简单情况;</p><p>如果CPU使用率很高,接近100%,可能是在进行大规模的计算更可能是陷入死循环;</p><p>如果CUP使用率很低,说明主线程被阻塞了,并且当IOwait很高,可能是主线程在等待I/O操作的完成。</p><p>对于ANR只是分析Log， 很难知道问题所在,我们还需要通过<code>Trace文件分析stack调用情况</code>,在log中显示的pid在traces文件中与之对应, 然后通过查看堆栈调用信息分析ANR的代码。</p><p>注:trace 文件的分析参考 <a href="https://blog.csdn.net/qq_25804863/article/details/49111005" target="_blank" rel="noopener">https://blog.csdn.net/qq_25804863/article/details/49111005</a></p><hr><h2 id="Trace分析"><a href="#Trace分析" class="headerlink" title="Trace分析"></a>Trace分析</h2><p>Traces中显示的线程状态都是C代码定义的，可以通过查看线程状态对应的信息分析ANR问题。</p><p>如:</p><ul><li><code>TimedWaiting</code>对应的线程状态是TIMED_WAITING；</li><li><code>kTimedWaiting, // TIMED_WAITING TS_WAIT in Object.wait() with a timeout</code>执行了无超时参数的wait函数；</li><li><code>kSleeping, // TIMED_WAITING TS_SLEEPING in Thread.sleep()</code>执行了带有超时参数的 sleep 函数；</li><li>ZOMBIE                    线程死亡,终止运行</li><li>RUNNING/RUNNABLE          线程可运行或正在运行</li><li>TIMED_WAIT                执行了带有超时参数的 wait、sleep 或 join 函数</li><li>MONITOR                   线程阻塞,等待获取对象锁</li><li>WAIT                      执行了无超时参数的 wait 函数</li><li>INITIALIZING              新建,正在初始化,为其分配资源</li><li>STARTING                  新建,正在启动</li><li>NATIVE                    正在执行 JNI 本地函数</li><li>VMWAIT                    正在等待 VM 资源</li><li>SUSPENDED                 线程暂停,通常是由于 GC 或 debug 被暂停</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;trace.txt&lt;/code&gt;生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发者选项的“指针位置”坐标值</title>
    <link href="https://alonealive.github.io/Blog/2020/06/10/2020/200610_android_pointerDraw/"/>
    <id>https://alonealive.github.io/Blog/2020/06/10/2020/200610_android_pointerDraw/</id>
    <published>2020-06-10T15:52:00.000Z</published>
    <updated>2020-06-13T13:34:23.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？</p></blockquote><a id="more"></a><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>在frameworks/base/core/java/com/android/internal/widget/PointerLocationView.java的<code>onDraw</code>方法中，在触屏的时候会实时打印底层读取的X/Y值。</p><p>如下代码（Android Q AOSP源码）,<code>ps.mCoords.x</code>和<code>ps.mCoords.y</code>是底层传递读取的坐标值，float类型。</p><p>最后会显示成类似<code>X:500.5  Y:200.6</code></p><figure class="highlight java"><figcaption><span>PointerLocationView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> w = getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> itemW = w/<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> base = -mTextMetrics.ascent+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bottom = mHeaderBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NP = mPointers.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Labels</span></span><br><span class="line">    <span class="keyword">if</span> (mActivePointerId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> PointerState ps = mPointers.get(mActivePointerId);</span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, itemW-<span class="number">1</span>, bottom,mTextBackgroundPaint);</span><br><span class="line">        canvas.drawText(mText.clear()</span><br><span class="line">                .append(<span class="string">"P: "</span>).append(mCurNumPointers)</span><br><span class="line">                .append(<span class="string">" / "</span>).append(mMaxNumPointers)</span><br><span class="line">                .toString(), <span class="number">1</span>, base, mTextPaint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = ps.mTraceCount;</span><br><span class="line">        <span class="keyword">if</span> ((mCurDown &amp;&amp; ps.mCurDown) || N == <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawRect(itemW, <span class="number">0</span>, (itemW * <span class="number">2</span>) - <span class="number">1</span>, bottom, mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"X: "</span>).append(ps.mCoords.x, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW, base, mTextPaint);</span><br><span class="line">            canvas.drawRect(itemW * <span class="number">2</span>, <span class="number">0</span>, (itemW * <span class="number">3</span>) - <span class="number">1</span>, bottom, mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"Y: "</span>).append(ps.mCoords.y, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW * <span class="number">2</span>, base, mTextPaint);</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>如果此时设备的分辨率是<code>1080x2340</code>，“指针位置”坐标值边缘滑动需要显示到<code>1079x2339</code>。而现在出现了问题：在竖屏的时候只能显示到<code>1078x2338</code>，横屏（两种横屏情况）只能显示到<code>1079x2338</code>和<code>1078xz2339</code>？此处如何进行修改？</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先要对此处读取的<code>ps.mCoords.x</code>和<code>ps.mCoords.y</code>值打印，发现在滑动到边缘的时候，应该显示1079，打印的值大约是<code>1078.0001</code>；应该显示2339的时候，打印的值大约是<code>2038.0001</code>。</p><p>所以在此处需要判断，在大于1078或2339的时候，使用<code>进一法</code>，将其作加一操作。</p><p>同时还要考虑到横屏和竖屏两种状态。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>因为PointerLocationView.java继承view.java，可以使用<code>getResources().getConfiguration();</code>来获取设备参数，从而获取到当前横竖屏的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是true，则对坐标加一操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mRealX = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mRealY = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//获取当前设备横竖屏状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mOrientation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">            <span class="comment">//获取横屏、竖屏状态并判断</span></span><br><span class="line">            Configuration mConfiguration = getResources().getConfiguration();</span><br><span class="line">            mOrientation = mConfiguration.orientation;</span><br><span class="line">            <span class="keyword">if</span> (mOrientation == mConfiguration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">              mRealX = ps.mCoords.x &gt; <span class="number">972.0f</span> &amp;&amp; ps.mCoords.x &lt; <span class="number">1079.0f</span>;</span><br><span class="line">              mRealY = ps.mCoords.y &gt; <span class="number">2106.0f</span> &amp;&amp; ps.mCoords.y &lt; <span class="number">2339.0f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrientation == mConfiguration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">              mRealX = ps.mCoords.x &gt; <span class="number">2106.0f</span> &amp;&amp; ps.mCoords.x &lt; <span class="number">2339.0f</span>;</span><br><span class="line">              mRealY = ps.mCoords.y &gt; <span class="number">972.0f</span> &amp;&amp; ps.mCoords.y &lt; <span class="number">1079.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绘制的时候判断是否加一</span></span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"X: "</span>).append(mRealX ? ps.mCoords.x + <span class="number">1.0f</span> : ps.mCoords.x, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW, base, mTextPaint);</span><br><span class="line">            canvas.drawRect(itemW * <span class="number">2</span>, mHeaderPaddingTop, (itemW * <span class="number">3</span>) - <span class="number">1</span>, bottom,</span><br><span class="line">                    mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"Y: "</span>).append(mRealY ? ps.mCoords.y + <span class="number">1.0f</span> : ps.mCoords.y, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW * <span class="number">2</span>, base, mTextPaint);</span><br><span class="line">            mRealX = <span class="keyword">false</span>;</span><br><span class="line">            mRealY = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android 屏幕旋转流程</title>
    <link href="https://alonealive.github.io/Blog/2020/06/01/2020/200601_android_rotation/"/>
    <id>https://alonealive.github.io/Blog/2020/06/01/2020/200601_android_rotation/</id>
    <published>2020-06-01T15:52:00.000Z</published>
    <updated>2020-06-13T13:34:42.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。</p></blockquote><a id="more"></a><blockquote><p>参考：<a href="https://blog.csdn.net/jinzhuojun/article/details/50085491" target="_blank" rel="noopener">https://blog.csdn.net/jinzhuojun/article/details/50085491</a><br>参考：<a href="https://blog.csdn.net/kc58236582/article/details/53741445" target="_blank" rel="noopener">https://blog.csdn.net/kc58236582/article/details/53741445</a></p></blockquote><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><h3 id="打开debug-log开关"><a href="#打开debug-log开关" class="headerlink" title="打开debug log开关"></a>打开debug log开关</h3><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerDebugConfig.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String TAG_WM = <span class="string">"WindowManager"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_ORIENTATION = <span class="keyword">false</span>;  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_APP_ORIENTATION = <span class="keyword">false</span>;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>adb logcat -v threadtime|grep -Ei &quot;rotation|ActivityTaskManager|WindowOrientationListener&quot;</code></p><h2 id="Settings设置开启-关闭自动旋转屏幕"><a href="#Settings设置开启-关闭自动旋转屏幕" class="headerlink" title="Settings设置开启/关闭自动旋转屏幕"></a>Settings设置开启/关闭自动旋转屏幕</h2><p>是否要自动转屏是在Setting中设置的。为了监听Setting中的改动，系统启动时，<code>PhoneWindowManager</code>的init()函数中创建了SettingsObserver对象。</p><p>它的observe()方法会监听<code>Settings.System.USER_ROTATION</code>的值（Android Q中此处没有这个property了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, IWindowManager windowManager,</span></span></span><br><span class="line"><span class="function"><span class="params">          WindowManagerFuncs windowManagerFuncs)</span> </span>&#123;</span><br><span class="line">              ...</span><br><span class="line">              mSettingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler);</span><br><span class="line">              mSettingsObserver.observe();</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>当用户在Setting中设置自动转屏后，会触发以下流程：</p><ol><li><code>public boolean onPreferenceTreeClick(Preference preference)</code>：packages/apps/Settings/src/com/android/settings/accessibility/AccessibilitySettings.java</li><li><code>handleLockScreenRotationPreferenceClick()</code>：被调用</li><li><code>setRotationLockForAccessibility(Context context, final boolean enabled)</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLockForAccessibility</span><span class="params">(Context context, <span class="keyword">final</span> boolean enabled)</span> </span>&#123;</span><br><span class="line">    Settings.System.putIntForUser(context.getContentResolver(),</span><br><span class="line">            Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line"></span><br><span class="line">    setRotationLock(enabled, NATURAL_ROTATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>setRotationLockForAccessibility</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLockForAccessibility</span><span class="params">(Context context, <span class="keyword">final</span> boolean enabled)</span> </span>&#123;</span><br><span class="line">    Settings.System.putIntForUser(context.getContentResolver(),</span><br><span class="line">            Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line"></span><br><span class="line">    setRotationLock(enabled, NATURAL_ROTATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>setRotationLock(final boolean enabled, final int rotation)</code>调用<code>wm.freezeRotation</code>或者<code>wm.thawRotation</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLock</span><span class="params">(<span class="keyword">final</span> boolean enabled, <span class="keyword">final</span> <span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">    AsyncTask.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IWindowManager wm = WindowManagerGlobal.getWindowManagerService();</span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    wm.freezeRotation(rotation);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wm.thawRotation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException exc) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Unable to save auto-rotate setting"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>thawRotation()</code>，此处在Android Q中有变化。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thawRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,</span><br><span class="line">                <span class="string">"thawRotation()"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Requires SET_ORIENTATION permission"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"thawRotation: mRotation="</span></span><br><span class="line">                + getDefaultDisplayRotation());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE,</span><br><span class="line">                    <span class="number">777</span>); <span class="comment">// rot not used   free</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateRotationUnchecked(<span class="keyword">false</span>, <span class="keyword">false</span>);  <span class="comment">//查看下面第十步分析</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而<code>freezeRotation函数</code>，只是调用PhoneWindowManager的setUserRotationMode的参数不一样，这里是Locked，而thawRotation传下去的参数是free。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeRotation</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// TODO(multi-display): Track which display is rotated.</span></span><br><span class="line">     <span class="keyword">if</span> (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,</span><br><span class="line">             <span class="string">"freezeRotation()"</span>)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Requires SET_ORIENTATION permission"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (rotation &lt; -<span class="number">1</span> || rotation &gt; Surface.ROTATION_270) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Rotation argument must be -1 or a valid "</span></span><br><span class="line">                 + <span class="string">"rotation constant."</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> defaultDisplayRotation = getDefaultDisplayRotation();</span><br><span class="line">     <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"freezeRotation: mRotation="</span></span><br><span class="line">             + defaultDisplayRotation);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_LOCKED,</span><br><span class="line">                 rotation == -<span class="number">1</span> ? defaultDisplayRotation : rotation);    <span class="comment">//lock</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         Binder.restoreCallingIdentity(origId);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     updateRotationUnchecked(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>setUserRotationMode(int mode, int rot)</code>：此处是设置property（即Settings数据库），然后会触发到上面初始化的<code>mSettingsObserver</code>对象的<code>onChange</code>函数。</li></ol><p>触发监听<code>SettingsObserver.onChange()</code>， 其中主要调用了updateSettings()和updateRotation()两个函数。</p><p>简单地说，主要的工作是根据需要监听传感器数据，据此判断是否要转屏。如果需要就是<strong>对configuration的各种更新</strong>。过程中会冻结屏幕，同时截屏并以此作为转屏动画。另外还需要将新configuration传给AMS，广播该事件给需要的模块，同时App也会被调度来响应变更。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// User rotation: to be used when all else fails in assigning an orientation to the device</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRotationMode</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> rot)</span> </span>&#123;</span><br><span class="line">        ContentResolver res = mContext.getContentResolver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mUserRotationMode and mUserRotation will be assigned by the content observer</span></span><br><span class="line">        <span class="keyword">if</span> (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) &#123;</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.USER_ROTATION,</span><br><span class="line">                    rot,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION,</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">       @<span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(boolean selfChange)</span> </span>&#123;</span><br><span class="line">            updateSettings();    <span class="comment">//以下8,9步骤</span></span><br><span class="line">            updateRotation(<span class="literal">false</span>);  <span class="comment">//以下10-步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        boolean updateRotation = <span class="literal">false</span>;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> userRotationMode = Settings.System.getIntForUser(resolver,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION, <span class="number">0</span>, UserHandle.USER_CURRENT) != <span class="number">0</span> ?</span><br><span class="line">                            WindowManagerPolicy.USER_ROTATION_FREE :</span><br><span class="line">                                    WindowManagerPolicy.USER_ROTATION_LOCKED;</span><br><span class="line">            <span class="keyword">if</span> (mUserRotationMode != userRotationMode) &#123;</span><br><span class="line">                mUserRotationMode = userRotationMode;</span><br><span class="line">                updateRotation = <span class="literal">true</span>;</span><br><span class="line">                updateOrientationListenerLp();  <span class="comment">//传感器相关操作</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>第一个函数<code>updateSettings()</code>如它的名字主要更新设置信息。</p><p>如果UserRotation（朝向信息，如Surface.ROTATION_0）和UserRotationMode（USER_ROTATION_FREE vs. USER_ROTATION_LOCKED）有更新，就设置标记updateRotation为true，表示接下去需要更新rotation相关信息。</p><p>此外，如果UserRotationMode的配置有变，由于需要传感器信息的配合，还需调用updateOrientationListenerLp()来设置或取消监听传感器。</p><p>这里假设设置为自动旋转，那么PhoneWindowManager会通过MyOrientationListener来监听传感器信息。MyOrientationListener是WindowOrientationListener的继承类。它的enable()函数中调用SensorManager提供的registerListener()接口来设置Sensor信息的listener。</p><ol start="8"><li><code>updateOrientationListenerLp()</code>：作用是enable和disable传感器</li></ol><p>其中的<code>mOrientationListener.enable</code>和<code>mOrientationListener.disable</code>是注册传感器回调和去除传感器回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrientationListenerLp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mOrientationListener.canDetectOrientation()) &#123;</span><br><span class="line">            <span class="comment">// If sensor is turned off or nonexistent for some reason</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"mScreenOnEarly="</span> + mScreenOnEarly</span><br><span class="line">                + <span class="string">", mAwake="</span> + mAwake + <span class="string">", mCurrentAppOrientation="</span> + mCurrentAppOrientation</span><br><span class="line">                + <span class="string">", mOrientationSensorEnabled="</span> + mOrientationSensorEnabled</span><br><span class="line">                + <span class="string">", mKeyguardDrawComplete="</span> + mKeyguardDrawComplete</span><br><span class="line">                + <span class="string">", mWindowManagerDrawComplete="</span> + mWindowManagerDrawComplete);</span><br><span class="line"></span><br><span class="line">        boolean disable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mScreenOnEarly &amp;&amp; mAwake &amp;&amp; ((mKeyguardDrawComplete &amp;&amp; mWindowManagerDrawComplete))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needSensorRunningLp()) &#123;</span><br><span class="line">                disable = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//enable listener if not already enabled 启动传感器监听！！</span></span><br><span class="line">                <span class="keyword">if</span> (!mOrientationSensorEnabled) &#123;</span><br><span class="line">                    mOrientationListener.enable(<span class="literal">true</span> <span class="comment">/* clearCurrentRotation */</span>);</span><br><span class="line">                    <span class="keyword">if</span>(localLOGV) Slog.v(TAG, <span class="string">"Enabling listeners"</span>);</span><br><span class="line">                    mOrientationSensorEnabled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check if sensors need to be disabled</span></span><br><span class="line">        <span class="keyword">if</span> (disable &amp;&amp; mOrientationSensorEnabled) &#123;</span><br><span class="line">            mOrientationListener.disable();   <span class="comment">//关闭传感器</span></span><br><span class="line">            <span class="keyword">if</span>(localLOGV) Slog.v(TAG, <span class="string">"Disabling listeners"</span>);</span><br><span class="line">            mOrientationSensorEnabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>mOrientationListener是MyOrientationListener对象，而MyOrientationListener类继承父类WindowOrientationListener，从而会调用父类的<code>enable</code>函数。</li></ol><p>该函数中会调用registerListener向SensorManager注册一个监听。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">(boolean clearCurrentRotation)</span> </span>&#123;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mSensor == null) &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">"Cannot detect sensors. Not enabled"</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mEnabled) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (LOG) &#123;</span><br><span class="line">               Slog.d(TAG, <span class="string">"WindowOrientationListener enabled clearCurrentRotation="</span></span><br><span class="line">                       + clearCurrentRotation);</span><br><span class="line">           &#125;</span><br><span class="line">           mOrientationJudge.resetLocked(clearCurrentRotation);</span><br><span class="line">           <span class="keyword">if</span> (mSensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123;</span><br><span class="line">               mSensorManager.registerListener(</span><br><span class="line">                       mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler);   <span class="comment">//mOrientationJudge的回调</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, mHandler);</span><br><span class="line">           &#125;</span><br><span class="line">           mEnabled = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>registerListener()的具体实现在frameworks/base/core/java/android/hardware/SensorManager.java中。</p><p>然后调用SystemSensorManager.java的registerListenerImpl()，其中会创建<code>SensorEventQueue</code>对象（基类为BaseEventQueue），它是传感器事件的队列，记录需要监听哪些传感器信息。</p><p><code>SensorEventQueue queue = mSensorListeners.get(listener);</code></p><p>同时它也负责与SensorService的连接和通信，可以说是SensorEventListener与SensorService间的桥梁。</p><p>SensorEventListener和SensorEventQueue之间是1:1的关系，它们的映射关系保存在成员mSensorListeners中。如果这里注册的SensorEventListener还没有相应的SensorEventQueue，则新建一个，然后通过addSensor()方法将要关注的传感器进行注册。这个过程中addSensor()调用了enableSensor()，它最终是通过SensorService的enableDisable()方法来完成注册工作的。</p><p>这样，SensorService就开始监听该Sensor，当底层有传感器数据来时，SensorService主线程中会调用相应SensorEventConnection的sendEvents()将之发给对应的Client。</p><p>前面初始化SensorEventQueue时会创建Receiver，它是一个Looper的回调对象，在Client端收到从SensorService来的数据后被回调。</p><p>当有数据收到时Receiver的handleEvent()被调用，继而通过JNI调用到SystemSensorManager::dispatchSensorEvent()。</p><p><strong>接着就调到了<code>WindowOrientationListener的onSensorChanged()函数</code>。该函数计算是否需要转屏。如果需要转屏，将计算结果传给onProposedRotationChanged()。</strong></p><p>比如以下函数的日志打印，在旋转手机，传感器会触发屏幕旋转打印这部分log：</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">// Tell the listener.</span></span><br><span class="line">     <span class="keyword">if</span> (proposedRotation != oldProposedRotation &amp;&amp; proposedRotation &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (LOG) &#123;</span><br><span class="line">             Slog.v(TAG, <span class="string">"Proposed rotation changed!  proposedRotation="</span> + proposedRotation</span><br><span class="line">                     + <span class="string">", oldProposedRotation="</span> + oldProposedRotation);</span><br><span class="line">         &#125;</span><br><span class="line">         onProposedRotationChanged(proposedRotation);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><ol start="10"><li>另一处<code>updateRotation(false)</code>函数会调用到WMS.java，然后调用到<code>updateRotationUnchecked</code>函数。</li></ol><p>最终在该函数中调用<code>rotationChanged = displayContent.updateRotationUnchecked();</code></p><h2 id="屏幕旋转"><a href="#屏幕旋转" class="headerlink" title="屏幕旋转"></a>屏幕旋转</h2><p>假设现在用户转了屏幕，期望转屏事件发生。如上面第九步的代码，<code>onProposedRotationChanged()</code>被调用。</p><p>最后就调用其run函数，run函数先会提升性能（cpu频率），然后调用了updateRotation，这个函数一样就到WMS的updateRotationUnchecked函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOrientationListener</span> <span class="keyword">extends</span> <span class="title">WindowOrientationListener</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mRotation;</span><br><span class="line">            UpdateRunnable(<span class="keyword">int</span> rotation) &#123;</span><br><span class="line">                mRotation = rotation;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// send interaction hint to improve redraw performance</span></span><br><span class="line">                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (isRotationChoicePossible(mCurrentAppOrientation)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> isValid = isValidRotationChoice(mCurrentAppOrientation,</span><br><span class="line">                            mRotation);</span><br><span class="line">                    sendProposedRotationChangeToStatusBarInternal(mRotation, isValid);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    updateRotation(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProposedRotationChanged</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"onProposedRotationChanged, rotation="</span> + rotation);</span><br><span class="line">            Runnable r = mRunnableCache.get(rotation, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>)&#123;</span><br><span class="line">                r = <span class="keyword">new</span> UpdateRunnable(rotation);</span><br><span class="line">                mRunnableCache.put(rotation, r);</span><br><span class="line">            &#125;</span><br><span class="line">            mHandler.post(r);  <span class="comment">//发送了一个消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>updateRotation()中主要是执行两个函数：updateRotationUnchecked()（<code>displayContent.updateRotationUnchecked()</code>）和sendNewConfiguration()。前者执行转屏动作，包含转屏动画<br>等。后者使AMS获取当前新的configuration，并且广播该事件给所有相应的listener。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRotation</span><span class="params">(<span class="keyword">boolean</span> alwaysSendConfiguration, <span class="keyword">boolean</span> forceRelayout)</span> </span>&#123;</span><br><span class="line">        updateRotationUnchecked(alwaysSendConfiguration, forceRelayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//上面settings中设置自动旋转屏幕也会调用到（thawRotation和freezeRotation函数）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRotationUnchecked</span><span class="params">(<span class="keyword">boolean</span> alwaysSendConfiguration, <span class="keyword">boolean</span> forceRelayout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"updateRotationUnchecked:"</span></span><br><span class="line">                + <span class="string">" alwaysSendConfiguration="</span> + alwaysSendConfiguration</span><br><span class="line">                + <span class="string">" forceRelayout="</span> + forceRelayout);</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO(multi-display): Update rotation for different displays separately.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> rotationChanged;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId;</span><br><span class="line">            <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                <span class="keyword">final</span> DisplayContent displayContent = getDefaultDisplayContentLocked();</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">"updateRotation: display"</span>);</span><br><span class="line">                <span class="comment">//Step 1</span></span><br><span class="line">                rotationChanged = displayContent.updateRotationUnchecked();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotationChanged || alwaysSendConfiguration) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">"updateRotation: sendNewConfiguration"</span>);</span><br><span class="line">                <span class="comment">//Step 2</span></span><br><span class="line">                sendNewConfiguration(displayId);</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>: 其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的<code>updateOrientationFromAppTokensLocked()</code>方法）。</p><h3 id="updateRotationUnchecked函数"><a href="#updateRotationUnchecked函数" class="headerlink" title="updateRotationUnchecked函数"></a>updateRotationUnchecked函数</h3><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateRotationUnchecked</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldRotation = mRotation;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastOrientation = mLastOrientation;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> oldAltOrientation = mAltOrientation;</span><br><span class="line">        <span class="comment">//先调用PhoneWindowManager的rotationForOrientationLw函数来获取rotation，然后与之前的mRotation对比是否有变化</span></span><br><span class="line">        <span class="comment">//没有变化直接返回false。有变化将mRotation重新赋值</span></span><br><span class="line">        <span class="comment">//函数rotationForOrientationLw作用：获取sensor的rotation，然后计算返回我们需要的rotation</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rotation = mService.mPolicy.rotationForOrientationLw(lastOrientation, oldRotation,</span><br><span class="line">                isDefaultDisplay);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"Computed rotation="</span> + rotation + <span class="string">" for display id="</span></span><br><span class="line">                + mDisplayId + <span class="string">" based on lastOrientation="</span> + lastOrientation</span><br><span class="line">                + <span class="string">" and oldRotation="</span> + oldRotation);</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (oldRotation == rotation &amp;&amp; oldAltOrientation == altOrientation) &#123;  <span class="comment">//没有变化</span></span><br><span class="line">            <span class="comment">// No change.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mRotation = rotation;   <span class="comment">//有变化则赋值</span></span><br><span class="line">        mAltOrientation = altOrientation; </span><br><span class="line">        ...</span><br><span class="line">        updateDisplayAndOrientation(getConfiguration().uiMode);</span><br><span class="line">        ...</span><br><span class="line">        mService.mDisplayManagerInternal.performTraversal(getPendingTransaction());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateDisplayAndOrientation函数"><a href="#updateDisplayAndOrientation函数" class="headerlink" title="updateDisplayAndOrientation函数"></a>updateDisplayAndOrientation函数</h4><p>还会调用到updateDisplayAndOrientation函数，会把<code>各种数据更新下放到DisplayInfo中</code>，最后调用了DisplayManagerService的<code>setDisplayInfoOverrideFromWindowManager</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DisplayInfo <span class="title">updateDisplayAndOrientation</span><span class="params">(<span class="keyword">int</span> uiMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use the effective "visual" dimensions based on current rotation</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> rotated = (mRotation == ROTATION_90 || mRotation == ROTATION_270);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realdw = rotated ? mBaseDisplayHeight : mBaseDisplayWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realdh = rotated ? mBaseDisplayWidth : mBaseDisplayHeight;</span><br><span class="line">    <span class="keyword">int</span> dw = realdw;</span><br><span class="line">    <span class="keyword">int</span> dh = realdh;</span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> appWidth = mService.mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation, uiMode,</span><br><span class="line">            mDisplayId, displayCutout);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appHeight = mService.mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation, uiMode,</span><br><span class="line">            mDisplayId, displayCutout);</span><br><span class="line">    mDisplayInfo.rotation = mRotation;</span><br><span class="line">    mDisplayInfo.logicalWidth = dw;</span><br><span class="line">    mDisplayInfo.logicalHeight = dh;</span><br><span class="line">    mDisplayInfo.logicalDensityDpi = mBaseDisplayDensity;</span><br><span class="line">    mDisplayInfo.appWidth = appWidth;</span><br><span class="line">    mDisplayInfo.appHeight = appHeight;</span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        mDisplayInfo.getLogicalMetrics(mRealDisplayMetrics,</span><br><span class="line">                CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mDisplayInfo.displayCutout = displayCutout.isEmpty() ? <span class="keyword">null</span> : displayCutout;</span><br><span class="line">    mDisplayInfo.getAppMetrics(mDisplayMetrics);</span><br><span class="line">    <span class="keyword">if</span> (mDisplayScalingDisabled) &#123;</span><br><span class="line">        mDisplayInfo.flags |= Display.FLAG_SCALING_DISABLED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDisplayInfo.flags &amp;= ~Display.FLAG_SCALING_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mService.mDisplayManagerInternal.setDisplayInfoOverrideFromWindowManager(mDisplayId,</span><br><span class="line">        overrideDisplayInfo);</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setDisplayInfoOverrideFromWindowManager会调用setDisplayInfoOverrideFromWindowManagerInternal，然后调用<code>display.setDisplayInfoOverrideFromWindowManagerLocked(info)</code>函数，最后到LogicalDisplay的setDisplayInfoOverrideFromWindowManagerLocked函数中，把DisplayInfo数据放到了mOverrideDisplayInfo中。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setDisplayInfoOverrideFromWindowManagerLocked</span><span class="params">(DisplayInfo info)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mOverrideDisplayInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mOverrideDisplayInfo = <span class="keyword">new</span> DisplayInfo(info);</span><br><span class="line">             mInfo = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!mOverrideDisplayInfo.equals(info)) &#123;</span><br><span class="line">             mOverrideDisplayInfo.copyFrom(info); <span class="comment">//拷贝到mOverrideDisplayInfo中</span></span><br><span class="line">             mInfo = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOverrideDisplayInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mOverrideDisplayInfo = <span class="keyword">null</span>;</span><br><span class="line">         mInfo = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="performTraversal处理显示Layer的大小宽高尺寸"><a href="#performTraversal处理显示Layer的大小宽高尺寸" class="headerlink" title="performTraversal处理显示Layer的大小宽高尺寸"></a>performTraversal处理显示Layer的大小宽高尺寸</h4><p>调用到DisplayManagerService.java中，然后调用performTraversalInternal函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performTraversalInternal</span><span class="params">(SurfaceControl.Transaction t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!mPendingTraversal) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          mPendingTraversal = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//遍历所有的Device</span></span><br><span class="line">          performTraversalLocked(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// List is self-synchronized copy-on-write.</span></span><br><span class="line">      <span class="keyword">for</span> (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123;</span><br><span class="line">          listener.onDisplayTransaction();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversalLocked</span><span class="params">(SurfaceControl.Transaction t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Clear all viewports before configuring displays so that we can keep</span></span><br><span class="line">      <span class="comment">// track of which ones we have configured.</span></span><br><span class="line">      clearViewportsLocked();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有的Device</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> count = mDisplayDevices.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          DisplayDevice device = mDisplayDevices.get(i);</span><br><span class="line">          <span class="comment">//step 1：找到那个LogicalDisplay 然后调用其configureDisplayInTransactionLocked函数（看上面的将参数赋值到mOverrideDisplayInfo中）</span></span><br><span class="line">          configureDisplayLocked(t, device);</span><br><span class="line">          <span class="comment">//step 2:调用了各个Device的performTraversalInTransactionLocked，而普通的Device的为空</span></span><br><span class="line">          device.performTraversalLocked(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the input system about these new viewports.</span></span><br><span class="line">      <span class="keyword">if</span> (mInputManagerInternal != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mHandler.sendEmptyMessage(MSG_UPDATE_VIEWPORT);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t, DisplayDevice device)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//设置长宽，旋转角度等</span></span><br><span class="line">      display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>configureDisplayLocked函数的这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layer。</strong></p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t,</span></span></span><br><span class="line"><span class="function"><span class="params">           DisplayDevice device,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> isBlanked)</span> </span>&#123;</span><br><span class="line">               ...</span><br><span class="line">       <span class="comment">//step 1. 获取mInfo的数据，而mOverrideDisplayInfo如有数据就要copy到mInfo中去</span></span><br><span class="line">       <span class="keyword">final</span> DisplayInfo displayInfo = getDisplayInfoLocked(); </span><br><span class="line">       <span class="keyword">final</span> DisplayDeviceInfo displayDeviceInfo = device.getDisplayDeviceInfoLocked();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Set the viewport.</span></span><br><span class="line">       <span class="comment">// This is the area of the logical display that we intend to show on the</span></span><br><span class="line">       <span class="comment">// display device.  For now, it is always the full size of the logical display.</span></span><br><span class="line">       mTempLayerStackRect.set(<span class="number">0</span>, <span class="number">0</span>, displayInfo.logicalWidth, displayInfo.logicalHeight);</span><br><span class="line">       ...</span><br><span class="line">       mTempDisplayRect.left += mDisplayOffsetX;</span><br><span class="line">       mTempDisplayRect.right += mDisplayOffsetX;</span><br><span class="line">       mTempDisplayRect.top += mDisplayOffsetY;</span><br><span class="line">       mTempDisplayRect.bottom += mDisplayOffsetY;</span><br><span class="line">       <span class="comment">//step 2</span></span><br><span class="line">       device.setProjectionLocked(t, orientation, mTempLayerStackRect, mTempDisplayRect);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayInfo <span class="title">getDisplayInfoLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInfo = <span class="keyword">new</span> DisplayInfo();</span><br><span class="line">           mInfo.copyFrom(mBaseDisplayInfo);</span><br><span class="line">           <span class="keyword">if</span> (mOverrideDisplayInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mInfo.appWidth = mOverrideDisplayInfo.appWidth;</span><br><span class="line">               mInfo.appHeight = mOverrideDisplayInfo.appHeight;</span><br><span class="line">               mInfo.smallestNominalAppWidth = mOverrideDisplayInfo.smallestNominalAppWidth;</span><br><span class="line">               mInfo.smallestNominalAppHeight = mOverrideDisplayInfo.smallestNominalAppHeight;</span><br><span class="line">               mInfo.largestNominalAppWidth = mOverrideDisplayInfo.largestNominalAppWidth;</span><br><span class="line">               mInfo.largestNominalAppHeight = mOverrideDisplayInfo.largestNominalAppHeight;</span><br><span class="line">               mInfo.logicalWidth = mOverrideDisplayInfo.logicalWidth;</span><br><span class="line">               mInfo.logicalHeight = mOverrideDisplayInfo.logicalHeight;</span><br><span class="line">               mInfo.overscanLeft = mOverrideDisplayInfo.overscanLeft;</span><br><span class="line">               mInfo.overscanTop = mOverrideDisplayInfo.overscanTop;</span><br><span class="line">               mInfo.overscanRight = mOverrideDisplayInfo.overscanRight;</span><br><span class="line">               mInfo.overscanBottom = mOverrideDisplayInfo.overscanBottom;</span><br><span class="line">               mInfo.rotation = mOverrideDisplayInfo.rotation;</span><br><span class="line">               mInfo.displayCutout = mOverrideDisplayInfo.displayCutout;</span><br><span class="line">               mInfo.logicalDensityDpi = mOverrideDisplayInfo.logicalDensityDpi;</span><br><span class="line">               mInfo.physicalXDpi = mOverrideDisplayInfo.physicalXDpi;</span><br><span class="line">               mInfo.physicalYDpi = mOverrideDisplayInfo.physicalYDpi;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>setProjectionLocked会调用SurfaceControl的SurfaceControl函数。然后在SurfaceControl中调用nativeSetDisplayProjection函数，通过JNI调用到Native层。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/DisplayDevice.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setProjectionLocked</span><span class="params">(SurfaceControl.Transaction t, <span class="keyword">int</span> orientation,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect layerStackRect, Rect displayRect)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">            t.setDisplayProjection(mDisplayToken,</span><br><span class="line">                    orientation, layerStackRect, displayRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时Java层的<code>updateRotationUnchecked</code>函数分析完。</p><hr><h2 id="sendNewConfiguration函数"><a href="#sendNewConfiguration函数" class="headerlink" title="sendNewConfiguration函数"></a>sendNewConfiguration函数</h2><p>从上面的updateRotation()函数中看到，除了调用updateRotationUnchecked()（即<code>displayContent.updateRotationUnchecked()</code>），还会调用sendNewConfiguration()。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendNewConfiguration</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> configUpdated = mActivityManager.updateDisplayOverrideConfiguration(</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* values */</span>, displayId);</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateDisplayOverrideConfiguration</span><span class="params">(Configuration values, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        enforceCallingPermission(CHANGE_CONFIGURATION, <span class="string">"updateDisplayOverrideConfiguration()"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (values == <span class="keyword">null</span> &amp;&amp; mWindowManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// sentinel: fetch the current configuration from the window manager</span></span><br><span class="line">                <span class="comment">//Step 1 获取一些配置信息</span></span><br><span class="line">                values = mWindowManager.computeNewConfiguration(displayId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Settings.System.clearConfiguration(values);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Step 2</span></span><br><span class="line">                updateDisplayOverrideConfigurationLocked(values, <span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* deferResume */</span>, displayId, mTmpUpdateConfigurationResult);</span><br><span class="line">                <span class="keyword">return</span> mTmpUpdateConfigurationResult.changes != <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateDisplayOverrideConfigurationLocked</span><span class="params">(Configuration values,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord starting, <span class="keyword">boolean</span> deferResume, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            UpdateConfigurationResult result)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (displayId == DEFAULT_DISPLAY) &#123;</span><br><span class="line">                    <span class="comment">//Step 1:调用</span></span><br><span class="line">                    changes = updateGlobalConfigurationLocked(values, <span class="keyword">false</span> <span class="comment">/* initLocale */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* persistent */</span>, UserHandle.USER_NULL <span class="comment">/* userId */</span>, deferResume);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    changes = performDisplayOverrideConfigUpdate(values, deferResume, displayId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Step 2</span></span><br><span class="line">            kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowManager.continueSurfaceLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.changes = changes;</span><br><span class="line">            result.activityRelaunched = !kept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateGlobalConfigurationLocked</span><span class="params">(@NonNull Configuration values, <span class="keyword">boolean</span> initLocale,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> persistent, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> deferResume)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把Configuration数据保存在mTempConfig</span></span><br><span class="line">        mTempConfig.setTo(getGlobalConfiguration());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> changes = mTempConfig.updateFrom(values);</span><br><span class="line">        <span class="keyword">if</span> (changes == <span class="number">0</span>) &#123;</span><br><span class="line">            performDisplayOverrideConfigUpdate(values, deferResume, DEFAULT_DISPLAY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//会发送ACTION_CONFIGURATION_CHANGED广播，然后获取当前最上面活动的Activity，调用ActivityStack的ensureActivityConfigurationLocked函数和ActivityStackSupervisor的ensureActivitiesVisibleLocked函数。</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CONFIGURATION_CHANGED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND</span><br><span class="line">                | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);</span><br><span class="line">        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, SYSTEM_UID,</span><br><span class="line">                UserHandle.USER_ALL);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">performDisplayOverrideConfigUpdate</span><span class="params">(Configuration values, <span class="keyword">boolean</span> deferResume,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        mTempConfig.setTo(mStackSupervisor.getDisplayOverrideConfiguration(displayId));</span><br><span class="line">        <span class="comment">//把Configuration数据保存在mTempConfig</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> changes = mTempConfig.updateFrom(values);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ensureConfigAndVisibilityAfterUpdate</span><span class="params">(ActivityRecord starting, <span class="keyword">int</span> changes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> kept = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack mainStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        <span class="comment">// mainStack is null during startup.</span></span><br><span class="line">        <span class="keyword">if</span> (mainStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (changes != <span class="number">0</span> &amp;&amp; starting == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If the configuration changed, and the caller is not already</span></span><br><span class="line">                <span class="comment">// in the process of starting an activity, then find the top</span></span><br><span class="line">                <span class="comment">// activity to check if its configuration needs to change.</span></span><br><span class="line">                starting = mainStack.topRunningActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先后调用两个函数</span></span><br><span class="line">            <span class="keyword">if</span> (starting != <span class="keyword">null</span>) &#123;</span><br><span class="line">                kept = starting.ensureActivityConfiguration(changes,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* preserveWindow */</span>);</span><br><span class="line">                <span class="comment">// And we need to make sure at this point that all other activities</span></span><br><span class="line">                <span class="comment">// are made visible with the correct configuration.</span></span><br><span class="line">                mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes,</span><br><span class="line">                        !PRESERVE_WINDOWS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="应用强制设置屏幕方向"><a href="#应用强制设置屏幕方向" class="headerlink" title="应用强制设置屏幕方向"></a>应用强制设置屏幕方向</h2><p>之前提过，其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的<code>updateOrientationFromAppTokensLocked()</code>方法）。</p><p>首先调用AMS的<code>setRequestedOrientation</code>函数，然后调用到ActivityRecord的setRequestedOrientation函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/am/ActivityRecord.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRequestedOrientation</span><span class="params">(<span class="keyword">int</span> requestedOrientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> Configuration displayConfig =</span><br><span class="line">                mStackSupervisor.getDisplayOverrideConfiguration(displayId);</span><br><span class="line">        <span class="comment">//Step 1</span></span><br><span class="line">        <span class="keyword">final</span> Configuration config = mWindowContainerController.setOrientation(requestedOrientation,</span><br><span class="line">                displayId, displayConfig, mayFreezeScreenLocked(app));</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            frozenBeforeDestroy = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//Step 2：当返回false，就是现在的状态要改变（比如重启Activity）</span></span><br><span class="line">            <span class="comment">//然后就调用ActivityStackSupervisor的resumeTopActivitiesLocked函数来启动最上面的Activity。</span></span><br><span class="line">            <span class="keyword">if</span> (!service.updateDisplayOverrideConfigurationLocked(config, <span class="keyword">this</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* deferResume */</span>, displayId)) &#123;</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        service.mTaskChangeNotificationController.notifyActivityRequestedOrientationChanged(</span><br><span class="line">                task.taskId, requestedOrientation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中调用到<code>frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java</code>的<code>mWindowContainerController.setOrientation</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> requestedOrientation, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration displayConfig, <span class="keyword">boolean</span> freezeScreenIfNeeded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM,</span><br><span class="line">                        <span class="string">"Attempted to set orientation of non-existing app token: "</span> + mToken);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mContainer.setOrientation(requestedOrientation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> IBinder binder = freezeScreenIfNeeded ? mToken.asBinder() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//调用WMS的该函数旋转屏幕！！</span></span><br><span class="line">            <span class="keyword">return</span> mService.updateOrientationFromAppTokens(displayConfig, binder, displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该函数调用到WMS的<code>updateOrientationFromAppTokensLocked</code>函数。这个函数先调用另一个updateOrientationFromAppTokensLocked函数，根据这个函数的返回值，返回true代表要旋转，就调用computeNewConfigurationLocked计算Configuration返回。</p><figure class="highlight java"><figcaption><span>WMS.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Configuration <span class="title">updateOrientationFromAppTokensLocked</span><span class="params">(Configuration currentConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder freezeThisOneIfNeeded, <span class="keyword">int</span> displayId, <span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Configuration config = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updateOrientationFromAppTokensLocked(displayId, forceUpdate)) &#123;</span><br><span class="line">            <span class="comment">// If we changed the orientation but mOrientationChangeComplete is already true,</span></span><br><span class="line">            <span class="comment">// we used seamless rotation, and we don't need to freeze the screen.</span></span><br><span class="line">            <span class="keyword">if</span> (freezeThisOneIfNeeded != <span class="keyword">null</span> &amp;&amp; !mRoot.mOrientationChangeComplete) &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowToken atoken = mRoot.getAppWindowToken(freezeThisOneIfNeeded);</span><br><span class="line">                <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    atoken.startFreezingScreen();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            config = computeNewConfigurationLocked(displayId);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOrientationFromAppTokensLocked</span><span class="params">(<span class="keyword">int</span> displayId, <span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayContent dc = mRoot.getDisplayContent(displayId);</span><br><span class="line">            <span class="comment">//获取上次强制设置的方向</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> req = dc.getOrientation();</span><br><span class="line">            <span class="comment">//如果和上次设置的方向不同</span></span><br><span class="line">            <span class="keyword">if</span> (req != dc.getLastOrientation() || forceUpdate) &#123;</span><br><span class="line">                dc.setLastOrientation(req);</span><br><span class="line">                <span class="comment">//send a message to Policy indicating orientation change to take</span></span><br><span class="line">                <span class="comment">//action like disabling/enabling sensors etc.,</span></span><br><span class="line">                <span class="comment">// TODO(multi-display): Implement policy for secondary displays.</span></span><br><span class="line">                <span class="keyword">if</span> (dc.isDefaultDisplay) &#123;</span><br><span class="line">                    mPolicy.setCurrentOrientationLw(req);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dc.updateRotationUnchecked(forceUpdate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="应用Activity强制设置方向"><a href="#应用Activity强制设置方向" class="headerlink" title="应用Activity强制设置方向"></a>应用Activity强制设置方向</h2><ol><li>Activity：</li></ol><p>如果要强制设置一个Activity的横竖屏可以通过Manifest去设置，跟Activity相关的信息都会保存在ActivityInfo当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:screenOrientation&#x3D;[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; |</span><br><span class="line">                                     &quot;landscape&quot; | &quot;portrait&quot; |</span><br><span class="line">                                     &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; |</span><br><span class="line">                                     &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; |</span><br><span class="line">                                     &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot;]</span><br></pre></td></tr></table></figure><ol start="2"><li>Window</li></ol><p>如果是要强制设置一个Window的横竖屏可以通过<code>LayoutParams.screenOrientation</code>来设置。在通过<code>WindowManager.addView的时候把对应的LayoutParams</code>传递给WMS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowManager.LayoutParams.screenOrientation</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android InputDispatcher获取点击事件</title>
    <link href="https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/"/>
    <id>https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/</id>
    <published>2020-05-20T15:52:00.000Z</published>
    <updated>2020-05-20T16:37:34.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。<br>参考上一篇《Android 触控事件分析》：<a href="http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/</a></p></blockquote><!--mode--><h2 id="Input-down-up事件查看"><a href="#Input-down-up事件查看" class="headerlink" title="Input down/up事件查看"></a>Input down/up事件查看</h2><p>在开发者选项打开“显示点按操作反馈”和“指针位置”，通过<code>adb shell getevent -lrt</code>命令，然后点击屏幕可以查看到控制台的打印。</p><p>查看帮助：<code>adb shell getevent -h</code></p><p>打印结果包含Input的down/up事件，以及点击点的坐标（十六进制）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   0000003b            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_X    0000017e            &#x2F;&#x2F;横坐标X&#x3D;382  十六进制转成十进制&#x3D;》 1*16*16+7*16+14*1&#x3D;382</span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_Y    0000032d            &#x2F;&#x2F;纵坐标Y&#x3D;813  十六进制转成十进制&#x3D;》 3*16*16+2*16+13*1&#x3D;813  </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   0000000a            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      000003e8            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            DOWN                </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   ffffffff            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            UP                  </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000             rate 0</span><br></pre></td></tr></table></figure><h2 id="systrace分析"><a href="#systrace分析" class="headerlink" title="systrace分析"></a>systrace分析</h2><p>抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。<br>(参考：<a href="http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/</a>)</p><h2 id="input-debug开关打开抓取日志分析"><a href="#input-debug开关打开抓取日志分析" class="headerlink" title="input debug开关打开抓取日志分析"></a>input debug开关打开抓取日志分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop sys.input.TouchFilterEnable true</span><br><span class="line">adb shell setprop sys.input.TouchFilterLogEnable true</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_FOCUS</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_INPUT</span><br><span class="line">adb shell setprop sys.inputlog.enabled true</span><br><span class="line">adb shell dumpsys input</span><br></pre></td></tr></table></figure><p>然后抓取log可以看到类似<code>InputDispatcher: notifyMotion</code>、<code>dispatchMotion</code>这些日志打印。</p><h2 id="日志打印分析代码流程"><a href="#日志打印分析代码流程" class="headerlink" title="日志打印分析代码流程"></a>日志打印分析代码流程</h2><h3 id="inputReader通过QueuedInputListener"><a href="#inputReader通过QueuedInputListener" class="headerlink" title="inputReader通过QueuedInputListener"></a>inputReader通过QueuedInputListener</h3><p>负责读取触摸事件交给 InputDispatcher 进行事件派发。</p><ol><li>首先在构造函数中new一个QueueListener对象：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputReader.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mNextSequenceNum(<span class="number">1</span>), mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// M: for nwk @&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *func;</span><br><span class="line">    <span class="comment">/// @&#125;</span></span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>InputReader::loopOnce()</code>循环等待消息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    ...</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>flush刷新将遍历QueuedInputListener中<code>mArgsQueue</code>的数组元素，触发每一个元素NotifyArgs的<code>notify</code>方法，交给内部InputDispatcher，清空数组。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>结构体NotifyMotionArgs/NotifySwitchArgs/NotifyDeviceResetArgs继承自NotifyArgs，所以执行NotifyArgs的<code>notify</code>函数。调用派发者InputDispatcher的通知notifyMotion，将自己交给派发者。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyMotionArgs::notify</span><span class="params">(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    listener-&gt;notifyMotion(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputDispatcher获取数据"><a href="#InputDispatcher获取数据" class="headerlink" title="InputDispatcher获取数据"></a>InputDispatcher获取数据</h3><ol><li>触发InputDispatcher.cpp的<code>notifyMotion</code>函数，读取线程InputReaderThread在处理事务，notifyMotion方法之后会唤醒分发线程，接下来的任务就由分发线程处理。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS   <span class="comment">//打开了input debug log后会打印以下log</span></span></span><br><span class="line">    ALOGD(<span class="string">"notifyMotion - eventTime=%"</span> PRId64 <span class="string">", deviceId=%d, source=0x%x, displayId=%"</span> PRId32</span><br><span class="line">            <span class="string">", policyFlags=0x%x, "</span></span><br><span class="line">            <span class="string">"action=0x%x, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x,"</span></span><br><span class="line">            <span class="string">"edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%"</span> PRId64,</span><br><span class="line">            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, args-&gt;policyFlags,</span><br><span class="line">            args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">            args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; args-&gt;pointerCount; i++) &#123;</span><br><span class="line">        ALOGD(<span class="string">"  Pointer %d: id=%d, toolType=%d, "</span></span><br><span class="line">                <span class="string">"x=%f, y=%f, pressure=%f, size=%f, "</span></span><br><span class="line">                <span class="string">"touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, "</span></span><br><span class="line">                <span class="string">"orientation=%f"</span>,</span><br><span class="line">                i, args-&gt;pointerProperties[i].id,</span><br><span class="line">                args-&gt;pointerProperties[i].toolType,</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">        <span class="comment">// Just enqueue a new motion event. //将NotifyMotionArgs的数据封装为MotionEntry</span></span><br><span class="line">        MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;sequenceNum, args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags,</span><br><span class="line">                args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">                args-&gt;metaState, args-&gt;buttonState, args-&gt;classification,</span><br><span class="line">                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//插入InputDispatcher的mInboundQueue队列中</span></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;   <span class="comment">//需要唤醒分发线程</span></span><br><span class="line">        mLooper-&gt;wake();  <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong>注意：mLooper属于InputDispatcher，InputManager创建InputDispatcher时，在其构造方法同时创建mLooper，创建的线程是服务线程，并非读取或分发线程<br>这里只是借用了Looper提供的epoll唤醒与休眠机制，在分发线程中InputDispatcherThread中使用mLooper休眠，读取线程负责唤醒。</p><ol start="2"><li>数据封装成MotionEntry，然后作为enqueueInboundEventLocked函数的入参，插入到mInboundQueue队列尾部。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::enqueueInboundEventLocked</span><span class="params">(EventEntry* entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br></pre></td></tr></table></figure><h3 id="InputDispatcherThread分发线程被唤醒"><a href="#InputDispatcherThread分发线程被唤醒" class="headerlink" title="InputDispatcherThread分发线程被唤醒"></a>InputDispatcherThread分发线程被唤醒</h3><blockquote><p>参考：<a href="http://wizzie.top/2020/05/10/2020/200510_android_inputANR/" target="_blank" rel="noopener">http://wizzie.top/2020/05/10/2020/200510_android_inputANR/</a></p></blockquote><ol><li>在InputDispatcherThread线程threadLoop循环中，触发InputDispatcher的dispatchOnce方法。然后调用dispatchOnce方法。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下次唤醒事件，设置无限大</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="built_in">std</span>::scoped_lock _l(mLock);</span><br><span class="line">        mDispatcherIsAlive.notify_all();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mCommandQueue为空时，触发dispatchOnceInnerLocked</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;         <span class="comment">//mCommandQueue为空时是false</span></span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="comment">//计算下一次唤醒时间，比当前时间大</span></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Looper在epoll_wait处进入休眠，休眠timeoutMillis时间仍无事件，threadLoop会一直循环，继续dispatchOnce。<br>当被唤醒时，执行switch循环进入dispatchOnceInnerLocked取出队列中的事件。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPendingEvent的type做区分处理，此处对motion事件分析</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="comment">//如果没有及时响应窗口切换操作</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//事件过期</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻碍其他窗口获取事件</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处执行事件</span></span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong>Looper借助epoll机制实现线程休眠，它本身内部有套接字mWakeEventFd，在rebuildEpollLocked建立时，注册到epoll_ctl监听。因此wake方法就是向mWakeEventFd套接字发送一段字符，促使epoll_wait处的线程能监听到，从而InputDispatcherThread线程被唤醒。</p><h3 id="InputDispatcher事件处理"><a href="#InputDispatcher事件处理" class="headerlink" title="InputDispatcher事件处理"></a>InputDispatcher事件处理</h3><ol><li>InputDispatcher#dispatchMotionLocked处理MotionEntry。此处函数开头会有类似<code>InputDispatcher: dispatchMotion - eventTime= ...</code>的日志打印。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入参：dropReason代表了事件丢弃的原因，它的默认值为DROP_REASON_NOT_DROPPED，代表事件不被丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();   <span class="comment">//systrace抓取</span></span><br><span class="line">    <span class="comment">//*************1**************//</span></span><br><span class="line">    <span class="comment">// Preprocessing. 即标记当前已经进入分发的过程</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundMotionDetails(<span class="string">"dispatchMotion - "</span>, entry);    <span class="comment">//log打印</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*************2**************//</span></span><br><span class="line">   <span class="comment">// Clean up if dropping the event. 如果事件是需要丢弃的，则返回true，不会去为该事件寻找合适的窗口</span></span><br><span class="line">    <span class="keyword">if</span> (*dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">        setInjectionResult(entry, *dropReason == DROP_REASON_POLICY</span><br><span class="line">                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//此时就是事件被丢弃了，分发任务就没有完成！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************3*************//</span></span><br><span class="line">    <span class="keyword">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标窗口信息列表会存储在inputTargets中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt; inputTargets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="comment">//事件处理的结果交由injectionResult</span></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">//1. 处理点击形式的事件，比如触摸屏幕</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. 处理非触摸形式的事件，比如轨迹球</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************4*************//</span></span><br><span class="line">    <span class="comment">//1. 如果injectionResult的值为INPUT_EVENT_INJECTION_PENDING，这说明找到了窗口并且窗口无响应输入事件被挂起，这时就会返回false</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResult(entry, injectionResult);</span><br><span class="line">    <span class="comment">//2. 如果injectionResult的值不为INPUT_EVENT_INJECTION_SUCCEEDED，这说明没有找到合适的窗口，输入事件没有分发成功，这时就会返回true</span></span><br><span class="line">    <span class="comment">//输入事件被挂起，说明找到了窗口并且窗口无响应</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_PERMISSION_DENIED) &#123;</span><br><span class="line">            <span class="function">CancelationOptions::Mode <span class="title">mode</span><span class="params">(isPointerEvent ?</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_POINTER_EVENTS :</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_NON_POINTER_EVENTS)</span></span>;</span><br><span class="line">            <span class="function">CancelationOptions <span class="title">options</span><span class="params">(mode, <span class="string">"input event injection failed"</span>)</span></span>;</span><br><span class="line">            synthesizeCancelationEventsForMonitorsLocked(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**************5*************//</span></span><br><span class="line">    <span class="comment">//分发目标添加到inputTargets列表中    // Add monitor channels from event's or focused display.</span></span><br><span class="line">    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> stateIndex = mTouchStatesByDisplay.indexOfKey(entry-&gt;displayId);</span><br><span class="line">        <span class="keyword">if</span> (stateIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> TouchState&amp; state = mTouchStatesByDisplay.valueAt(stateIndex);</span><br><span class="line">            <span class="keyword">if</span> (!state.portalWindows.empty()) &#123;</span><br><span class="line">                <span class="comment">// The event has gone through these portal windows, so we add monitoring targets of</span></span><br><span class="line">                <span class="comment">// the corresponding displays as well.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; state.portalWindows.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> InputWindowInfo* windowInfo = state.portalWindows[i]-&gt;getInfo();</span><br><span class="line">                    addGlobalMonitoringTargetsLocked(inputTargets, windowInfo-&gt;portalToDisplayId,</span><br><span class="line">                            -windowInfo-&gt;frameLeft, -windowInfo-&gt;frameTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the motion.</span></span><br><span class="line">    <span class="keyword">if</span> (conflictingPointerActions) &#123;</span><br><span class="line">        <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"conflicting pointer actions"</span>)</span></span>;</span><br><span class="line">        synthesizeCancelationEventsForAllConnectionsLocked(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将事件分发给inputTargets列表中的目标</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="InputTarget结构体"><a href="#InputTarget结构体" class="headerlink" title="InputTarget结构体"></a>InputTarget结构体</h4><p>InputTarget结构体可以说是inputDispatcher与目标窗口的转换器。<br>其分为两大部分：</p><ol><li>一个是枚举中存储的inputDispatcher与目标窗口交互的标记，</li><li>另一部分是inputDispatcher与目标窗口交互参数，比如：</li></ol><ul><li><code>inputChannel</code>，它实际上是一个SocketPair，SocketPair用于进程间双向通信，这非常适合inputDispatcher与目标窗口之间的通信，因为inputDispatcher不仅要将事件分发到目标窗口，同时inputDispatcher也需要得到目标窗口对事件的响应。</li><li><code>xOffset和yOffset</code>，屏幕坐标系相对于目标窗口坐标系的偏移量，MotionEntry(MotionEvent)中的存储的坐标是屏幕坐标系，因此就需要注释2和注释3处的参数，来将屏幕坐标系转换为目标窗口的坐标系。</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputTarget</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">//此标记表示事件正在交付给前台应用程序</span></span><br><span class="line">    FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//此标记指示MotionEvent位于目标区域内</span></span><br><span class="line">    FLAG_WINDOW_IS_OBSCURED = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inputDispatcher与目标窗口的通信管道</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//事件派发的标记</span></span><br><span class="line">    <span class="keyword">int32_t</span> flags;</span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的偏移量</span></span><br><span class="line">    <span class="keyword">float</span> xOffset, yOffset;<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的缩放系数</span></span><br><span class="line">    <span class="keyword">float</span> scaleFactor;<span class="comment">//3</span></span><br><span class="line">    BitSet32 pointerIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="处理点击事件findTouchedWindowTargetsLocked"><a href="#处理点击事件findTouchedWindowTargetsLocked" class="headerlink" title="处理点击事件findTouchedWindowTargetsLocked"></a>处理点击事件findTouchedWindowTargetsLocked</h3><blockquote><p>参考：<a href="https://www.codercto.com/a/52484.html" target="_blank" rel="noopener">https://www.codercto.com/a/52484.html</a><br>在函数dispatchMotionLocked中，会分别对Motion事件中的点击形式事件和非触摸形式事件做了处理。其中点击事件调用函数<code>findTouchedWindowTargetsLocked</code>。</p></blockquote><p>函数末尾会打印类似日志<code>InputDispatcher: findTouchedWindow finished: injectionResult=0, injectionPermission=1, timeSpentWaitingForApplication=0.0ms</code>，injectionResult=0是succeed，injectionPermission=1是允许。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::findTouchedWindowTargetsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> MotionEntry* entry, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span>* outConflictingPointerActions)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL(); <span class="comment">//systrace</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123;</span><br><span class="line">        <span class="comment">/* Case 1: New splittable pointer going down, or need target for hover or scroll. */</span></span><br><span class="line">        <span class="comment">//从MotionEntry中获取坐标点</span></span><br><span class="line">        <span class="keyword">int32_t</span> pointerIndex = getMotionEventActionPointerIndex(action);</span><br><span class="line">        <span class="keyword">int32_t</span> x = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_X));</span><br><span class="line">        <span class="keyword">int32_t</span> y = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_Y));</span><br><span class="line">        <span class="keyword">bool</span> isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将符合条件的窗口放入TempTouchState中，以便后续处理</span></span><br><span class="line">        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);</span><br><span class="line">        &#125;</span><br><span class="line">        mTempTouchState.addGestureMonitors(newGestureMonitors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Case 2: Pointer move, up, cancel or non-splittable pointer down. */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处说明窗口已经查找成功</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    <span class="comment">//为每个mTempTouchState中的窗口生成InputTargets</span></span><br><span class="line">    addWindowTargetLocked(focusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">        Unresponsive:</span><br><span class="line">    <span class="comment">// Reset temporary touch state to ensure we release unnecessary references to input channels.</span></span><br><span class="line">    <span class="comment">//重置TempTouchState</span></span><br><span class="line">    mTempTouchState.reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    <span class="comment">//日志打印输出</span></span><br><span class="line">    ALOGD(<span class="string">"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, injectionPermission, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatchEventLocked向目标窗口发送事件"><a href="#dispatchEventLocked向目标窗口发送事件" class="headerlink" title="dispatchEventLocked向目标窗口发送事件"></a>dispatchEventLocked向目标窗口发送事件</h3><ol><li>上面函数dispatchMotionLocked的末尾，会执行<code>dispatchEventLocked</code>函数，将事件分发给inputTargets列表中的分发目标（目标窗口）。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        EventEntry* eventEntry, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"dispatchEventToCurrentInputTargets"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line">    <span class="comment">//遍历inputTargets列表，获取每一个inputTarget</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> InputTarget&amp; inputTarget : inputTargets) &#123;</span><br><span class="line">        <span class="comment">//1. 根据inputTarget内部的inputChannel来获取Connection的索引</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2. 根据索引，获取保存在mConnectionsByFd容器中的Connection（可以理解为InputDispatcher和目标窗口的连接，其内部包含了连接的状态、InputChannel、InputWindowHandle和事件队列等）</span></span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">//3. 根据inputTarget，开始事件发送循环</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_FOCUS</span><br><span class="line">            ALOGD(<span class="string">"Dropping event delivery to target with channel '%s' because it "</span></span><br><span class="line">                    <span class="string">"is no longer registered with the input dispatcher."</span>,</span><br><span class="line">                    inputTarget.inputChannel-&gt;getName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>开始事件发送，最终会通过inputTarget中的inputChannel和窗口进行<code>进程间通信</code>，最终将Motion事件发送给目标窗口。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(</span><br><span class="line">                <span class="string">"prepareDispatchCycleLocked(inputChannel=%s, sequenceNum=%"</span> PRIu32 <span class="string">")"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str(), eventEntry-&gt;sequenceNum);</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "</span></span><br><span class="line">            <span class="string">"xOffset=%f, yOffset=%f, globalScaleFactor=%f, "</span></span><br><span class="line">            <span class="string">"windowScaleFactor=(%f, %f), pointerIds=0x%x"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags,</span><br><span class="line">            inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;globalScaleFactor,</span><br><span class="line">            inputTarget-&gt;windowXScale, inputTarget-&gt;windowYScale,</span><br><span class="line">            inputTarget-&gt;pointerIds.value);</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><ol start="3"><li>然后调用startDispatchCycleLocked（在函数dispatchMotionLocked末尾处），最终调用两种事件的<code>connection-&gt;inputPublisher...</code>函数，至此，InputDisapatcher结束。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(<span class="string">"startDispatchCycleLocked(inputChannel=%s)"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str());</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source, keyEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">    <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState, motionEntry-&gt;classification,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。&lt;br&gt;参考上一篇《Android 触控事件分析》：&lt;a href=
      
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
      <category term="input" scheme="https://alonealive.github.io/Blog/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>Android Input事件ANR流程</title>
    <link href="https://alonealive.github.io/Blog/2020/05/10/2020/200510_android_inputANR/"/>
    <id>https://alonealive.github.io/Blog/2020/05/10/2020/200510_android_inputANR/</id>
    <published>2020-05-10T15:32:00.000Z</published>
    <updated>2020-05-20T16:37:09.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听<code>/dev/input</code>产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。<br>常说的Input ANR超时，都是指的是Input事件分发超时。</p></blockquote><a id="more"></a><blockquote><p>参考：<a href="https://blog.csdn.net/abm1993/article/details/80461752" target="_blank" rel="noopener">https://blog.csdn.net/abm1993/article/details/80461752</a><br>参考：<a href="https://blog.csdn.net/abm1993/article/details/80497039" target="_blank" rel="noopener">https://blog.csdn.net/abm1993/article/details/80497039</a><br>参考：<a href="https://www.jianshu.com/p/f05d6b05ba17" target="_blank" rel="noopener">https://www.jianshu.com/p/f05d6b05ba17</a></p></blockquote><h2 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h2><p>从下面的log可以看到超过了5s导致发生Input ANR事件。</p><ul><li>main log：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">04-22 10:49:36.222646  1270  1376 I InputDispatcher: Application is not responding: AppWindowToken&#123;e4f7c16 token&#x3D;Token&#123;8a1cd31 ActivityRecord&#123;21295d8 u0 com.android.PACKAGE&#x2F;.PACKAGE_Activity t10&#125;&#125;&#125;.  It has been 5008.2ms since event, 5005.5ms since wait started.  Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span><br><span class="line">04-22 10:49:36.342164  1270  1407 E TAG     : 82 Tanet</span><br><span class="line">......</span><br><span class="line">04-22 10:49:41.347174  1270  1376 I InputDispatcher: Dropped event because it is stale.</span><br></pre></td></tr></table></figure><ul><li>system log：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">04-22 10:49:31.216699  1270  1376 D PowerManagerService: getScreenOffTimeoutLocked:  isTestFlag &#x3D; false</span><br><span class="line">04-22 10:49:31.216986  1270  1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182 com.android.server.input.InputManagerService.interceptKeyBeforeDispatching:1839 &lt;bottom of call stack&gt; </span><br><span class="line">04-22 10:49:36.224611  1270  1376 I WindowManager: Input event dispatching timed out .  Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span><br><span class="line">04-22 10:49:36.341180  1270  1407 W InputManager: Input event injection from pid 6143 timed out.</span><br><span class="line">04-22 10:49:36.342467  1270  1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="循环读取分发Input事件"><a href="#循环读取分发Input事件" class="headerlink" title="循环读取分发Input事件"></a>循环读取分发Input事件</h3><p>在frameworks/native/services/inputflinger/InputDispatcher.cpp中，流程从<code>InputDispatcherThread::threadLoop()</code>线程循环开始，方法体只调用循环一个函数<code>mDispatcher-&gt;dispatchOnce()</code>。</p><p>如果没有等待的命令，则会循环运行主要函数<code>dispatchOnceInnerLocked</code>不断的读取并分发Input事件：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now(); <span class="comment">//记录事件的当前时间点</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;   <span class="comment">//点击事件</span></span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchKeyEvent(typedEntry)) &#123;</span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">true</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">                dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);  <span class="comment">//执行该函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数最后调用了dropInputEvent事件<code>dropInboundEventLocked(mPendingEvent, dropReason);</code></p><h3 id="若case-EventEntry-TYPE-KEY"><a href="#若case-EventEntry-TYPE-KEY" class="headerlink" title="若case EventEntry::TYPE_KEY"></a>若case EventEntry::TYPE_KEY</h3><p>如果是Key事件，则会执行<code>InputDispatcher::dispatchKeyLocked</code>函数。然后在该函数中调用<code>findFocusedWindowTargetsLocked</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchKeyLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span></span></span><br><span class="line"><span class="function"><span class="params">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResult(entry, injectionResult);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add monitor channels from event's or focused display.</span></span><br><span class="line">    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>findFocusedWindowTargetsLocked</code>中开始就会进行判断，当<code>focusedWindowHandle == nullptr</code>但是<code>focusedApplicationHandle != nullptr</code>的时候调用<code>handleTargetsNotReadyLocked</code>报出ANR的错误日志。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::findFocusedWindowTargetsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> EventEntry* entry, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// If there is no currently focused window and no focused application</span></span><br><span class="line">    <span class="comment">// then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (focusedWindowHandle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (focusedApplicationHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//monkey test的时候经常遇到类似log的ANR。典型的无窗口，有应用的ANR问题，这里我们就需要了解Android应用的启动流程了，一般此类问题都是Android应用首次启动时会发生此类问题，此时我们应用本身需要检查一下我们的Android应用重写的Application onCreate方法，Android应用的启动界面是否在onCreate onStart方法中是否存在耗时操作。当然不排除系统原因造成的启动慢，直接导致ANR问题发生的情况</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    focusedApplicationHandle, <span class="literal">nullptr</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);  </span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>InputDispatcher::handleTargetsNotReadyLocked</code>执行代码：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::handleTargetsNotReadyLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> EventEntry* entry,   <span class="comment">//点击触摸事件</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span>* nextWakeupTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason)</span> </span>&#123;   </span><br><span class="line">....</span><br><span class="line"><span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line"><span class="comment">//这里一般是有应用（application已经创建），无窗口，或者有应用，有窗口ANR的情形，一般同一个窗口至进入一次该方法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">nsecs_t</span> timeout;  <span class="comment">//int64类型秒数</span></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationHandle != <span class="literal">nullptr</span>) &#123;   <span class="comment">//执行这个，有应用无窗口</span></span><br><span class="line">                timeout = applicationHandle-&gt;getDispatchingTimeout(</span><br><span class="line">                        DEFAULT_INPUT_DISPATCHING_TIMEOUT); <span class="comment">//5s超时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT; <span class="comment">//5s</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;<span class="comment">//超时等待原因</span></span><br><span class="line">mInputTargetWaitStartTime = currentTime;<span class="comment">//函数入参当前时间，此处就是当前input事件的第一次分发时间</span></span><br><span class="line">mInputTargetWaitTimeoutTime = currentTime + timeout; <span class="comment">//设置超时</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//无窗口</span></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;<span class="comment">//记录当前等待的应用</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//TODO 记录当前等待的应用，针对无窗口，有应用</span></span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitApplicationHandle == <span class="literal">NULL</span> &amp;&amp; applicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = applicationHandle;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">//当前时间已经大于超时时间，说明应用有时间分发超时了，需要触发ANR</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;   <span class="comment">//应该是超时5s</span></span><br><span class="line">        onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                entry-&gt;eventTime , mInputTargetWaitStartTime, reason);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force poll loop to wake up immediately on next iteration once we get the</span></span><br><span class="line">        <span class="comment">// ANR response back from the policy.</span></span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ANR的函数调用onANRLocked"><a href="#ANR的函数调用onANRLocked" class="headerlink" title="ANR的函数调用onANRLocked"></a>ANR的函数调用onANRLocked</h3><p>最后发生ANR调用<code>InputDispatcher::onANRLocked</code></p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::onANRLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> currentTime, <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> eventTime, <span class="keyword">nsecs_t</span> waitStartTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dispatchLatency = (currentTime - eventTime) * <span class="number">0.000001f</span>;</span><br><span class="line">    <span class="keyword">float</span> waitDuration = (currentTime - waitStartTime) * <span class="number">0.000001f</span>;</span><br><span class="line">    ALOGI(<span class="string">"Application is not responding: %s.  "</span></span><br><span class="line">            <span class="string">"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s"</span>,</span><br><span class="line">            getApplicationWindowLabel(applicationHandle, windowHandle).c_str(),</span><br><span class="line">            dispatchLatency, waitDuration, reason);</span><br></pre></td></tr></table></figure><hr><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><ol><li>抓取systrace分析：可以分析Input事件的部分</li><li>系统的Trace log：系统生成的Trace文件保存在<code>data/anr</code>,可以用过命令<code>adb pull data/anr/</code>取出。</li><li>抓取日志分析</li></ol><h2 id="可能导致ANR的原因"><a href="#可能导致ANR的原因" class="headerlink" title="可能导致ANR的原因"></a>可能导致ANR的原因</h2><ol><li>怀疑是不是在Activty oncreate和onstart耗时太多，导致窗口还未创建好，input事件超时5s<br>应用窗口是在onResume中才去向WindowManager添加注册的。因此在注册添加窗口之前，application或者启动的Activity的生命周期onCreate，onStart的任意方法，做了耗时操作，或者他们加载一起的执行时间过长，都是能够导致<code>无窗口，有应用类型的Input ANR问题</code>发生的。所以实际开发应用的时候，就要尽可能的把耗时的操作，异步处理。具体异步实现思路可以使用<code>new thread + handler，Asynctask，HandlerThread</code>等等，这里推荐使用HandlerThread，因为google封装的接口，使用起来简单。</li><li>可能是UI主线程做了耗时的操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听&lt;code&gt;/dev/input&lt;/code&gt;产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。&lt;br&gt;常说的Input ANR超时，都是指的是Input事件分发超时。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
      <category term="input" scheme="https://alonealive.github.io/Blog/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>C++字符串比较函数strcmp和strstr的用法</title>
    <link href="https://alonealive.github.io/Blog/2020/04/14/2020/200413_cpp_strstrTostrcmp/"/>
    <id>https://alonealive.github.io/Blog/2020/04/14/2020/200413_cpp_strstrTostrcmp/</id>
    <published>2020-04-14T15:32:00.000Z</published>
    <updated>2020-04-13T14:12:25.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天碰到一个细节bug，使用<code>strcmp</code>来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用<code>strstr</code>函数。</p></blockquote><a id="more"></a><h2 id="strcmp函数比较字符串大小"><a href="#strcmp函数比较字符串大小" class="headerlink" title="strcmp函数比较字符串大小"></a>strcmp函数比较字符串大小</h2><p>设这两个字符串为str1、str2，</p><ul><li>若str1 == str2，则返回零；</li><li>若str1 &lt; str2，则返回负数；</li><li>若str1 &gt; str2，则返回正数。</li></ul><p>测试类：</p><figure class="highlight c++"><figcaption><span>testFunc_strcmp.cpp </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROPERTY_VALUE_MAX 92</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> char1[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> char2[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> isCon[<span class="number">20</span>] = <span class="string">"y"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (con) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Compare two char by func strcmp(char1, char2):"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char1: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char1, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char2: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char2, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Result: strcmp("</span> &lt;&lt; char1 &lt;&lt; <span class="string">", "</span> &lt;&lt; char2 &lt;&lt; <span class="string">"): "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strcmp</span>(char1, char2) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue? y/n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(isCon, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(isCon, <span class="string">"n"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           con = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: wen</span><br><span class="line">Result: strcmp(sun, wen): </span><br><span class="line">-4</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wen</span><br><span class="line">Enter char2: gan</span><br><span class="line">Result: strcmp(wen, gan): </span><br><span class="line">16</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wizzie</span><br><span class="line">Enter char2: wizzie</span><br><span class="line">Result: strcmp(wizzie, wizzie): </span><br><span class="line">0</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wizzie_test</span><br><span class="line">Enter char2: wizzie</span><br><span class="line">Result: strcmp(wizzie_test, wizzie): </span><br><span class="line">95</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">n</span><br></pre></td></tr></table></figure><h2 id="strstr函数比较字符串是否相同或者存在包含关系"><a href="#strstr函数比较字符串是否相同或者存在包含关系" class="headerlink" title="strstr函数比较字符串是否相同或者存在包含关系"></a>strstr函数比较字符串是否相同或者存在包含关系</h2><p>如果两个字符串可能存在相同，并且可能会有包含关系，则需要使用<code>strstr</code>函数来比较字符串。如果不包含（或相同），则返回NULL。</p><p>测试类：</p><figure class="highlight c++"><figcaption><span>testFunc_strstr.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROPERTY_VALUE_MAX 92</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> char1[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> char2[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> isCon[<span class="number">20</span>] = <span class="string">"y"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*** Determine whethe char2 is in char1. ***"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (con) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input two char by func strstr(char1, char2):"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char1: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char1, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char2: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char2, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Result: strstr("</span> &lt;&lt; char1 &lt;&lt; <span class="string">", "</span> &lt;&lt; char2 &lt;&lt; <span class="string">"): "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(char1, char2) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Success: char2 is in char1!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: char2 is not in char1!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue? y/n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(isCon, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(isCon, <span class="string">"n"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           con = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Determine whethe char2 is in char1. ***</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: sun</span><br><span class="line">Result: strstr(sun, sun): </span><br><span class="line">Success: char2 is in char1!</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sunwengang</span><br><span class="line">Enter char2: wen</span><br><span class="line">Result: strstr(sunwengang, wen): </span><br><span class="line">Success: char2 is in char1!</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: sunwengang</span><br><span class="line">Result: strstr(sun, sunwengang): </span><br><span class="line">Error: char2 is not in char1!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天碰到一个细节bug，使用&lt;code&gt;strcmp&lt;/code&gt;来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用&lt;code&gt;strstr&lt;/code&gt;函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Android HWC2硬件合成</title>
    <link href="https://alonealive.github.io/Blog/2020/04/01/2020/200401_android_HWC2_Display/"/>
    <id>https://alonealive.github.io/Blog/2020/04/01/2020/200401_android_HWC2_Display/</id>
    <published>2020-04-01T15:32:00.000Z</published>
    <updated>2020-04-01T12:55:07.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载夕月风大佬博客： <a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">https://www.jianshu.com/p/824a9ddf68b9</a><br>参考Android P AOSP源码添加修改部分内容<br>参考源码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r14/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r14/</a></p></blockquote><a id="more"></a><h2 id="显示屏Display"><a href="#显示屏Display" class="headerlink" title="显示屏Display"></a>显示屏Display</h2><blockquote><p>显示屏Display是合成的另一个重要单元，系统可以有多个显示设备，并且在正常系统操作期间可以添加/删除显示设备。该添加/删除操作可以对应HWC设备的热插拔请求，或者应客户端的请求进行，这允许创建虚拟显示设备，其内容会渲染到离屏缓冲区（而不是物理显示设备）。</p></blockquote><blockquote><p>可以通过Dump SF查看display的layer信息，同时也可以根据layerstack异同判断多个display是否用的同一个layer。</p></blockquote><p>HWC中，SurfaceFlinger中创建的Layer，在合成开始时，将被指定到每个Display上，此后合成过程中，每个Display合成指定给自己的Layer。</p><p>SurfaceFlinger前端，每个显示屏用<code>DisplayDevice</code>类描述，在后端显示数据用<code>DisplayData</code>描述。而在HWC2的Client端，定义了Display类进行描述。对于HWC2服务端则用<code>hwc2_display_t</code>描述，他只是一个序号，Vendor具体实现时，才具体的去管理Display的信息。</p><p>HWC2提供相应函数来确定给定显示屏的属性，在不同配置（例如4K/1080分辨率）和颜色模式（例如Native颜色或者真彩sRGB）之间切换，以及打开/关闭显示设备或者将其切换到低功率模式（如果支持）。</p><h2 id="HWC设备composerDevice"><a href="#HWC设备composerDevice" class="headerlink" title="HWC设备composerDevice"></a>HWC设备composerDevice</h2><p><strong>Note:</strong><br>注意显示屏Display和合成设备的区别，HWC合成设备只有一个，定义在头文件：</p><figure class="highlight cpp"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc2_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*getCapabilities)(struct hwc2_device* device, <span class="keyword">uint32_t</span>* outCount,</span><br><span class="line">            <span class="keyword">int32_t</span>* <span class="comment">/*hwc2_capability_t*/</span> outCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">hwc2_function_pointer_t</span> (*getFunction)(struct hwc2_device* device,</span><br><span class="line">            <span class="keyword">int32_t</span> <span class="comment">/*hwc2_function_descriptor_t*/</span> descriptor);</span><br><span class="line">&#125; <span class="keyword">hwc2_device_t</span>;</span><br></pre></td></tr></table></figure><h3 id="HWC合成服务"><a href="#HWC合成服务" class="headerlink" title="HWC合成服务"></a>HWC合成服务</h3><p><code>hardware/interfaces/graphics/composer/2.1/default</code>这个HWC的的默认服务。SurfaceFlinger初始化时，可以通过属性<code>debug.sf.hwc_service_name</code>来制定，默认为default。在编译时，manifest.xml中配置的也是default。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getHwcServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX] = &#123;&#125;;</span><br><span class="line">    property_get(<span class="string">"debug.sf.hwc_service_name"</span>, value, <span class="string">"default"</span>);</span><br><span class="line">    ALOGI(<span class="string">"Using HWComposer service: '%s'"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWC服务分两部分：</p><ol><li>可以执行程序<code>android.hardware.graphics.composer@2.1-service</code>（在目录/vendor/bin/hw/）</li></ol><p>其main函数如下，通过defaultPassthroughServiceImplementation函数注册IComposer服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hardware/interfaces/graphics/composer/2.1/default/service.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the conventional HAL might start binder services</span></span><br><span class="line">    android::ProcessState::initWithDriver(<span class="string">"/dev/vndbinder"</span>);</span><br><span class="line">    android::ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line">    android::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// same as SF main thread</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, SCHED_FIFO | SCHED_RESET_ON_FORK,</span><br><span class="line">                &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Couldn't set SCHED_FIFO: %d"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;IComposer&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应.rc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service vendor.hwcomposer-2-1 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.graphics.composer@2.1-service</span><br><span class="line">    class hal animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    capabilities SYS_NICE</span><br><span class="line">    onrestart restart surfaceflinger</span><br></pre></td></tr></table></figure><ol start="2"><li>实现库<code>android.hardware.graphics.composer@2.1-impl.so</code></li></ol><p>hwc的执行程序中，注册的IComposer，将调到对应的FETCH函数，FETCH函数实现及是so库中。FETCH如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IComposer* <span class="title">HIDL_FETCH_IComposer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGI(<span class="string">"falling back to FB HAL"</span>);</span><br><span class="line">        err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGE(<span class="string">"failed to get hwcomposer or fb module"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HwcHal(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FETCH函数中，才正在去加载Vendor的实现，通过统一的接口<code>hw_get_module</code>根据IDHWC_HARDWARE_MODULE_ID去加载。加载完成后，创建HAL描述类似HwcHal。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HwcHal::HwcHal(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>)</span><br><span class="line">    : mDevice(<span class="literal">nullptr</span>), mDispatch(), mMustValidateDisplay(<span class="literal">true</span>), mAdapter() &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> majorVersion;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;id &amp;&amp; <span class="built_in">strcmp</span>(<span class="keyword">module</span>-&gt;id, GRALLOC_HARDWARE_MODULE_ID) == <span class="number">0</span>) &#123;</span><br><span class="line">        majorVersion = initWithFb(<span class="keyword">module</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        majorVersion = initWithHwc(<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initCapabilities();</span><br><span class="line">    <span class="keyword">if</span> (majorVersion &gt;= <span class="number">2</span> &amp;&amp; hasCapability(HWC2_CAPABILITY_PRESENT_FENCE_IS_NOT_RELIABLE)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Present fence must be reliable from HWC2 on."</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initDispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是FrameBuffer驱动，通过initWithFb初始化。如果是HWC驱动，通过initWithHwc初始化。我们需要的是HWC2的接口，如果不是HWC2的HAl实现，那么需要做适配。</p><hr><h2 id="Client和Server的通信"><a href="#Client和Server的通信" class="headerlink" title="Client和Server的通信"></a>Client和Server的通信</h2><p>SurfaceFlinger和HWC服务之间，很多函数，并没有直接的调用，而是通过Buffer的读写来实现调用和参数的传递的。所以，Client端和Server端通信，基本通过以下相关的途径：</p><ul><li>通过IComposerClient.hal接口</li><li>通过IComposer.hal接口</li><li>通过command Buffer</li></ul><p>Server端回调Client端，通过IComposerCallback.hal接口。</p><p>hal接口的方式，其本质就是Binder。又加了一个command Buffer的方式，其实这是为了解决Binder通信慢的问题。</p><h3 id="HWC2中Fence的更改"><a href="#HWC2中Fence的更改" class="headerlink" title="HWC2中Fence的更改"></a>HWC2中Fence的更改</h3><p>HWC 2.0 中同步栅栏的含义相对于以前版本的HAL已有很大的改变。</p><p>在 HWC v1.x 中，释放Fence和退出Fence是推测性的。在帧 N 中检索到的Buffer的释放Fence或显示设备的退出Fence不会先于在帧 N + 1 中检索到的Fence变为触发状态。换句话说，该Fence的含义是“不再需要您为帧 N 提供的Buffer内容”。这是推测性的，因为在理论上，SurfaceFlinger 在帧 N 之后的一段不确定的时间内可能无法再次运行，这将使得这些栅栏在该时间段内不会变为触发状态。</p><p>在 HWC 2.0 中，释放Fence和退出Fence是非推测性的。在帧 N 中检索到的释放Fence或退出Fence，将在相关Buffer的内容替换帧 N - 1 中缓冲区的内容后立即变为触发状态，或者换句话说，该Fence的含义是“您为帧 N 提供的缓冲区内容现在已经替代以前的内容”。这是非推测性的，因为在硬件呈现此帧的内容之后，该栅栏应该在 presentDisplay 被调用后立即变为触发状态。</p><p><strong>Notes:</strong> 关于Fence同步机制需要单独拎出来梳理学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载夕月风大佬博客： &lt;a href=&quot;https://www.jianshu.com/p/824a9ddf68b9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/824a9ddf68b9&lt;/a&gt;&lt;br&gt;参考Android P AOSP源码添加修改部分内容&lt;br&gt;参考源码： &lt;a href=&quot;http://aosp.opersys.com/xref/android-10.0.0_r14/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://aosp.opersys.com/xref/android-10.0.0_r14/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>智能健身车</title>
    <link href="https://alonealive.github.io/Blog/2020/04/01/2020/200401_diary_exerciseBike/"/>
    <id>https://alonealive.github.io/Blog/2020/04/01/2020/200401_diary_exerciseBike/</id>
    <published>2020-04-01T13:32:00.000Z</published>
    <updated>2020-07-16T13:57:25.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。<a id="more"></a></p></blockquote><blockquote><p>但是提到顽鹿竞技、zwift，就有很多骑手会用骑行台、自己的自行车等设备在家模拟骑行，智能健身车目前的方向就是将这些一体化，而且更偏向智能、简约、便捷。</p></blockquote><h2 id="智能健身车"><a href="#智能健身车" class="headerlink" title="智能健身车"></a>智能健身车</h2><p>智能健身车可以具备接入互联网（一般都是通过蓝牙）、能够进行独立数据采集处理运算能力的健身车。也就是说，健身车成了像手机、智能手表等等一样的智能硬件。<br>当下的智能健身车一般会具备以下智能体验，最起码包括：</p><ol><li>运动数据检测以及采集、运算、反馈的体验（比如说心率、踏频这些运动数据的获取）；</li><li>在线社交的体验，比如国内的顽鹿竞技，国外的zwift，健身车可以通过蓝牙连接到这些APP，通过数据的传输，模拟骑车，而且能够多人一起竞赛；</li><li>自动调节阻力，能够根据路况调节阻力。</li></ol><h2 id="两千内的智能健身车"><a href="#两千内的智能健身车" class="headerlink" title="两千内的智能健身车"></a>两千内的智能健身车</h2><p>这两天一直想入手一辆智能健身车，下班之余可以在家运动运动。通过一些模拟骑行APP更有趣，边骑车边玩游戏，和VR眼镜打游戏一样，让运动更加游戏性。在网上查了资料，比较倾向于2000以内的几种款型，以下这三种：骑纪智能健身车、小米NEXGIM智能健身车、顽鹿健身车。</p><table><thead><tr><th align="center">-</th><th align="center">骑纪智能健身车</th><th align="center">小米NEXGIM智能健身车</th><th align="center">顽鹿游戏功率健身车（京东众筹）</th></tr></thead><tbody><tr><td align="center">价钱</td><td align="center">1578</td><td align="center">1699</td><td align="center">999（众筹活动）</td></tr><tr><td align="center">尺寸</td><td align="center">长86<em>高110</em>宽44，折叠后长63<em>高54</em>宽44</td><td align="center">长88<em>宽50.5</em>高121</td><td align="center">长85<em>宽54</em>高127</td></tr><tr><td align="center">电源</td><td align="center">插电</td><td align="center">插电</td><td align="center">内置两节5号电池</td></tr><tr><td align="center">重量</td><td align="center">N/A</td><td align="center">28kg</td><td align="center">25.1kg</td></tr><tr><td align="center">阻力</td><td align="center">精密电机磁控,32档智能阻力控制，自动换挡，根据上下坡度自动调节</td><td align="center">自动调节电机阻力</td><td align="center">磁控阻力调节，非自动换挡，8级速度档位匹配</td></tr><tr><td align="center">蓝牙</td><td align="center">智能蓝牙5.0</td><td align="center">蓝牙</td><td align="center">普通蓝牙连接</td></tr><tr><td align="center">心率测量</td><td align="center">有</td><td align="center">无</td><td align="center">N/A</td></tr><tr><td align="center">踏频记录</td><td align="center">有</td><td align="center">测量踩踏功率</td><td align="center">有</td></tr><tr><td align="center">静音磁控</td><td align="center">有</td><td align="center">静音</td><td align="center">有</td></tr><tr><td align="center">实时功率</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">功率精度</td><td align="center">N/A</td><td align="center">50W以上&gt;=90%</td><td align="center">50W以上+-5%</td></tr><tr><td align="center">车身</td><td align="center">车把角度可以调整</td><td align="center">多功能控制旋钮，手动调节阻力大小、档位高低、，可查看时间、扭力、功率、踏频等</td><td align="center"></td></tr><tr><td align="center">飞轮</td><td align="center">全包金属</td><td align="center">全包活飞</td><td align="center">全包</td></tr><tr><td align="center">传动方式</td><td align="center">N/A</td><td align="center">皮带传动</td><td align="center">皮带传动</td></tr><tr><td align="center">游戏模式</td><td align="center">自己微信小程序、zwift,Kinomap,Ride Social,Trainer Road,FulGaz，顽鹿</td><td align="center">zwift,顽鹿，自己的APP-NEXGIM</td><td align="center">顽鹿、zwift</td></tr><tr><td align="center">其他</td><td align="center">卡路里、距离、速度，智能芯片手动升级，可折叠</td><td align="center">N/A</td><td align="center">坐凳可以前后调节</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。
    
    </summary>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/categories/diary/"/>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Android 两种实时获取FPS的方法</title>
    <link href="https://alonealive.github.io/Blog/2020/03/31/2020/200330_android_getFPS/"/>
    <id>https://alonealive.github.io/Blog/2020/03/31/2020/200330_android_getFPS/</id>
    <published>2020-03-31T15:32:00.000Z</published>
    <updated>2020-03-31T13:27:43.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过ADB命令实时获取FPS帧率有两种方式，一种是<code>dump gfxinfo</code>，一种是<code>dump SF --latency</code>。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。<br>如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。</p></blockquote><a id="more"></a><h2 id="dumpsys-gfxinfo"><a href="#dumpsys-gfxinfo" class="headerlink" title="dumpsys gfxinfo"></a>dumpsys gfxinfo</h2><blockquote><p>dumpsys是一款运行在设备上的Android工具，将 gfxinfo命令传递给dumpsys可在logcat中提供输出，其中包含各阶段发生的动画以及帧相关的性能信息。但是gfxinfo不统计SurfaceView。</p></blockquote><p>步骤：</p><ol><li>打开开发者选项中的HWUI呈现模式分析，选择“在adb shell dumpsys gfxinfo中”</li><li>在需要测试的界面获取包名，可以使用dump SF/activity获取</li><li>清空后台任务，操作UI滑动，然后执行获取<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt;</code></li></ol><p>framestats信息和frame耗时信息通常为2s收集一次（一次120帧，一帧16ms，耗时约2s）。如果要重置所有计数器重新收集帧率数据，执行<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; reset</code></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如测试我的设备一加六滑动桌面的帧率，执行上述的前两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity top|grep ACTIVITY</span><br><span class="line"> ACTIVITY net.oneplus.launcher&#x2F;.Launcher 5f5af6c pid&#x3D;4077</span><br></pre></td></tr></table></figure><p>然后滑动桌面执行<code>adb shell dumpsys gfxinfo net.oneplus.launcher</code>，获取到128帧的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell dumpsys gfxinfo net.oneplus.launcher</span><br><span class="line"></span><br><span class="line">Applications Graphics Acceleration Info:</span><br><span class="line">Uptime: 594308934 Realtime: 1044551416</span><br><span class="line"></span><br><span class="line">** Graphics info for pid 4077 [net.oneplus.launcher] **  &#x2F;&#x2F;表明当前dump的界面和进程ID</span><br><span class="line"></span><br><span class="line">Stats since: 573121582148193ns</span><br><span class="line">Total frames rendered: 17625  &#x2F;&#x2F;本次dump搜集了17625帧的信息</span><br><span class="line">Janky frames: 1735 (9.84%)  &#x2F;&#x2F;有1735帧超过了16.6ms.卡帧率是9.84%</span><br><span class="line">50th percentile: 6ms </span><br><span class="line">90th percentile: 16ms</span><br><span class="line">95th percentile: 20ms</span><br><span class="line">99th percentile: 38ms</span><br><span class="line">Number Missed Vsync: 72  &#x2F;&#x2F;垂直同步失败的帧</span><br><span class="line">Number High input latency: 8269  &#x2F;&#x2F;处理input时间超时的帧</span><br><span class="line">Number Slow UI thread: 482  &#x2F;&#x2F;因为UI线程的工作超时导致的帧数</span><br><span class="line">Number Slow bitmap uploads: 101  &#x2F;&#x2F;因为bitmap加载耗时的帧数</span><br><span class="line">Number Slow issue draw commands: 31  &#x2F;&#x2F;因为绘制导致超时的帧数</span><br><span class="line">Number Frame deadline missed: 544</span><br><span class="line">HISTOGRAM: 5ms&#x3D;7576 6ms&#x3D;2645 7ms&#x3D;1902  ... &#x2F;&#x2F;直方图数据，表面耗时为0~5ms的帧数是7576，同理类推</span><br><span class="line">......</span><br><span class="line">Profile data in ms:</span><br><span class="line"></span><br><span class="line">net.oneplus.launcher&#x2F;net.oneplus.launcher.Launcher&#x2F;android.view.ViewRootImpl@3b33fe6 (visibility&#x3D;0)</span><br><span class="line">DrawPrepareProcessExecute</span><br><span class="line">6.940.402.691.70   &#x2F;&#x2F;四个加起来小于16.6ms属于正常的一帧，超过则是jank（丢帧）</span><br><span class="line">2.860.355.192.36</span><br><span class="line">2.550.321.100.98</span><br><span class="line">2.770.341.391.49</span><br><span class="line">2.160.311.381.34</span><br><span class="line">2.320.301.090.66</span><br><span class="line">2.050.251.040.83</span><br><span class="line">2.130.251.041.16</span><br><span class="line">1.990.301.111.51</span><br><span class="line">3.090.443.012.22</span><br><span class="line">2.340.722.401.68</span><br><span class="line">2.280.362.491.84</span><br><span class="line">2.580.482.901.64</span><br><span class="line">2.310.402.131.78</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>Draw：构建java显示列表DisplayList的时间，也就是执行每一个View的onDraw方法,创建或者更新每一个View的DisplayList对象的时间。</li><li>Prepare：准备函数的执行耗时</li><li>Process：小号在Android的2D渲染器执行显示列表的时间，view越多，要执行的绘制命令就越多，耗时越长</li><li>Execture：消耗在排列每个发送过来的帧的顺序的时间.或者说是CPU告诉GPU渲染一帧的时间,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复。所以这个时间，一般都很短。</li></ul><p>Draw + Prepare+Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保存每秒60帧。</p><h3 id="参数framestats"><a href="#参数framestats" class="headerlink" title="参数framestats"></a>参数framestats</h3><p>如果需要获取详细的帧信息，可以使用Android 6引入的新参数framestats，执行<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats</code></p><p>结果会打印额外的信息，以CSV格式输出。每一行代表应用程序生成的一帧。每一行的列数都相同，每列对应描述帧在不同的时间段的耗时情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">0,594399833469194,594399833469194,9223372036854775807,0,594399833992420,594399834015180,594399834093462,594399835255753,594399835397316,594399835719034,594399835808878,594399836632628,594399837228514,96000,146000,</span><br><span class="line">0,594429840570165,594429840570165,9223372036854775807,0,594429841649231,594429841736940,594429841741471,594429842202356,594429845314544,594429847401106,594429847993190,594429853626210,594429854321679,264000,326000,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>flags：FLAGS列为’0’的行可以通过从FRAME_COMPLETED列中减去INTENDED_VSYNC列计算其总帧时间。如果非零，则该行应该被忽略，因为该帧的预期布局和绘制时间超过16ms，为异常帧。</li><li>*IntendedVsync：帧的的预期起点。如果此值与VSYNC不同，是由于UI线程中的工作使其无法及时响应垂直同步信号所造成的；</li><li>Vsync：花费在vsync监听器和帧绘制的时间（Choreographer frame回调，动画，<code>View.getDrawingTime（）</code>等）；</li><li>OldestInputEvent：输入队列中最旧输入事件的时间戳，如果没有输入事件，则输入Long.MAX_VALUE。此值主要用于平台工作，对应用程序开发人员的用处有限。</li><li>NewestInputEvent：输入队列中最新输入事件的时间戳，如果帧没有输入事件，则为0。此值主要用于平台工作，对应用程序开发人员的用处有限。然而，通过查看（FRAME_COMPLETED - NEWEST_INPUT_EVENT），可以大致了解应用程序添加的延迟时间。</li><li>HandleInputStart：将输入事件分派给应用程序的时间戳（deliverInputEvent函数）。通过查看这段时间和ANIMATION_START之间的时间，可以测量应用程序处理输入事件的时间。<code>如果这个数字很高（&gt; 2ms），这表明程序花费了非常长的时间来处理输入事件</code>。例如View.onTouchEvent（），也就是说此工作需要优化，或者分发到不同的线程。请注意，某些情况下这是可以接受的，例如发起新活动或类似活动的点击事件，并且此数字很大。</li><li>AnimationStart：运行Choreographer注册动画的时间戳。通过查看这段时间和PERFORM_TRANVERSALS_START之间的时间，可以确定评估运行的所有动画器（ObjectAnimator，ViewPropertyAnimator和常用转换器）需要多长时间。<code>如果此数字很高（&gt; 2ms），请检查您的应用是否编写了自定义动画以确保它们适用于动画。</code></li><li>PerformTraversalsStart：计算<code>PERFORM_TRAVERSALS_STAR-DRAW_START</code>，则可以获取到布局和测量阶段完成的时间。（注意，在滚动或动画期间，希望这应该接近于零）</li><li>DrawStart：performTraversals的绘制阶段开始的时间。这是录制任何无效视图的显示列表的起点。这和SYNC_START之间的时间是在树中所有无效视图上调用View.draw（）所花费的时间。</li><li>SyncQueued：同步请求发送到RenderThread的时间。如果此时间和SYNC_START之间的时间很长（&gt; 0.1ms左右），则意味着RenderThread忙于处理不同的帧。在内部，这被用来区分帧做了太多的工作，超过了16ms的预算，由于前一帧超过了16ms的预算，帧被停止了。</li><li>SYNC_START：绘图的同步阶段开始的时间。如果此时间与<code>ISSUE_DRAW_COMMANDS_START</code>之间的时间很长（&gt; 0.4ms左右），则通常表示有许多新的位图必须上传到GPU。</li><li>IssueDrawCommandsStart：硬件渲染器开始向GPU发出绘图命令的时间。这段时间和<code>FRAME_COMPLETED</code>之间的时间间隔显示了应用程序正在生产多少GPU。像这样出现太多透支或低效率渲染效果的问题。</li><li>SwapBuffers：eglSwapBuffers被调用的时间。</li><li>*FrameCompleted：帧的完整时间。花在这个帧上的总时间可以通过<code>FRAME_COMPLETED - INTENDED_VSYNC</code>来计算。</li></ul><p>这些数据可以直接通过修改开发者选项的HWUI呈现模式分析为<code>在屏幕显示为条形图</code>，如图：</p><p><img src="hwui_framestats.png" alt="帧率条形图"></p><hr><h2 id="dumpsys-SurfaceFlinger-–latency"><a href="#dumpsys-SurfaceFlinger-–latency" class="headerlink" title="dumpsys SurfaceFlinger –latency"></a>dumpsys SurfaceFlinger –latency</h2><blockquote><p><code>adb shell dumpsys SurfaceFlinger --latency LayerName</code>命令主要用于获取游戏/视频应用的fps数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">16666666</span><br><span class="line">597043335926672597043380168807597043346611672</span><br><span class="line">597043352801411597043396837974597043363218234</span><br><span class="line">597043368960943597043413558338597043379891672</span><br><span class="line">597043385568078597043430198078597043396569641</span><br><span class="line">597043405252505597043446885266597043413698495</span><br><span class="line">597043421909328597043463546203597043430320943</span><br><span class="line">597043718620370597043747090734597043725964432</span><br><span class="line">597043729160422597043763770213597043730802818</span><br><span class="line">597043745858911597043780445786597043747847765</span><br><span class="line">597043758497193597043797131620597043764349745</span><br><span class="line">597043775327557597043813810786597043781148963</span><br><span class="line">597043791070734597043830486880597043796912974</span><br><span class="line">597043808038338597043847152140597043813671047</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>第一行数据，表示刷新的时间间隔refresh_period，我的机器打印出来的间隔期是。即Dump SF里面的VSYNC period。<br>剩下的127行（127帧）数据分为三部分，每一列表是一种类型。</p><ul><li>第一列：表示应用绘制图像的时间点</li><li>第二列：SF将帧提交给H/W(硬件)绘制之前的垂直同步时间。</li><li>第三列：在SF将帧提交给H/W的时间点，算是H/W接受完SF发来数据的时间点，绘制完成的时间点。s</li></ul><p><strong>计算方式：</strong>一般打印出来的数据是129行（部分机型打印两次257行，但是第一部分是无效数据，取后半部分），取len-2的第一列数据为end_time，取len-128的第一列数据为start_time。</p><p><code>fps = 127/((end_time - start_time) / 1000000.0)</code></p><p>除以1000000是因为命令打印出来的是纳秒单位，要转为毫秒进行计算，127就是因为命令一次打印出来127帧的数据而已。</p><ul><li>参考：<a href="https://blog.csdn.net/itfootball/article/details/43084527/" target="_blank" rel="noopener">https://blog.csdn.net/itfootball/article/details/43084527/</a></li><li>参考：<a href="https://www.jianshu.com/p/6c0cfc25b038" target="_blank" rel="noopener">https://www.jianshu.com/p/6c0cfc25b038</a></li><li>参考：<a href="https://blog.csdn.net/luoshengyang/article/details/7846923" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/7846923</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过ADB命令实时获取FPS帧率有两种方式，一种是&lt;code&gt;dump gfxinfo&lt;/code&gt;，一种是&lt;code&gt;dump SF --latency&lt;/code&gt;。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。&lt;br&gt;如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>想把我唱给你听</title>
    <link href="https://alonealive.github.io/Blog/2020/03/26/2020/200326_diary_our/"/>
    <id>https://alonealive.github.io/Blog/2020/03/26/2020/200326_diary_our/</id>
    <published>2020-03-26T12:32:00.000Z</published>
    <updated>2020-03-26T14:33:42.138Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7169b08079e7fa2b8dab9e78959a48d7535e82adca521f2cb422eb645699111f">37fb60dd34e7ed552175bb50ade7970d21da2c4342209e481bf7686949ef4d46b7df9287ee0998d84ea4aed811dcfcc9ed551aeb3226fc1c426207bf595d8c75526882441e35874992132ac6daa6af343b8e71ac5aebea49cd8a472efd24c592bbb931eb82be6882de5483c02987a34ae6fae2198ae9a934ea2832acd2405e927e3d713da80d5f04cb1d58022cbf16b84e7f3f6a6f9011834af8995f5ef4e5f32264251ba7eaa1defb27ed4749a2d4bf8561f4c6feed09ea843a37e137095f0a7fdf096359d225781d2cad0bc92af5886daad8a1bbe0e160477a6582424e90fc28edb4e4e24890864f9064da6d257d0717cdcf4330832175f4e6a3bd1d10d1c67cff6aa2c0a7b5ce53d274184b62d84240b894d60bb67c9e8dbe5244323cb8fc56d671ef8d9c1fa1edaee6963fa1999892775cf4ea8e8969de37c62300895897ed1f21bbab97e4ba0aa1c4ad318095d08b6123d5636101aa6428fb6567813b48ba8734c222d8514172eb76ccf4fecda11f84705719eb2a29ab76a6a576c183b6234ebc1404dd325d38bfc7a0e884fe867cb38278f8c5e1f975682e447375d649270aca7c12bd4db48ab266b25fdee8c8c1b0d3da7c863ec1b396e12601501f726ccf5cbb3b61fac74b97d50bf6decf9560b694e4b90a38ba43088680391a5c9494655d8f5eb245fbe978bb641d855007fc961f6b30acf479d01bc3f5a22c6b1b2cab4fe3cf334a02df9d777014533e536a9286290849a960658edbf72115f13c2154b57b99d88075f495d8752bbd1128c152f0e3370b3820374d510f66a494337e9eb11d1799044cf8ef6704ef2a74dbf4dc769b412adff5af89f94aef5025c859dc317fd9611e61c19f4daa273707327c5c1bc532d99866c20518c2ba075b8d19cff9fd896e1782364da145990811445cad47227bd7e5733173aee525b42b3ea66dd6ca35d3a4ab31dcf8f823ead26e9f862d9efb54317df9a1ef811b33278998cff66f17172b349440ed7f1b97f76ce3604edf14b375521890ec12abf5b16dd7d0c2925ca9f2edb58a35350e40493c90f3d168267b4760927cae8054f1f6f7935dc335df4600efb3fcb2f6ed7ad1798a9a1621369efe694762dc58225793d66aaaba3edc3213cba57a01008328b91c342714f65126a70a0239675c851fea2b7fc530d86a56be782e1bbe5d635e38181d74a89a26bfb36ac550b4722662f614f83e070899ac85f41b2bb64370a9d35cf532742169a503d018f85120214733fec7c017b81f3130aeb3b189bbd223fc49ca14607cf7b5842c3a5a2944e687d5143be7d46b53def4cfbca477936d55976f234c5d2432b6d6d4f12722b1eeff678af4524e3ddfa25726261721341026a2ad70301e90d7eaada5fd494184066ce01368d7f7e36e8899035b07390485d89bb62a8fc8abf4356cd78c8c53cf5eb35cb7d55972c285c092c0ab04bd0d9dfa78d1c527e8ea5e6f8758fc224fe156bc59731d8eb883d643217ba2a78f5c84730fc9be36cbb443218353f8093555188c6001dd3a0b0247b2b2c371ad86a362364887f39cd2952a2cb2cc3787c9f9cae0b0044bf4e37e28df5a8277c1adc15cdea696769d0c813b1520145d544fb5b71ad0d5c1120bfc6cae641a23dcd462aa8e8e5a7b53401e191ea9eb54edc0c9b8cd65877775530a6c4b2bcd8eecf38b7f6674a787db318e065bbe23dcf89b625923b948bf56465a3e4cec71bfcc7d4d61019e267489cb973d68b62e6d41983ffaf2a5c33fac2c0a7a9fd1abea0b06ad4f0db3b71897ca3a5e91eebebc58b3a9390be4e6856509d2b5b6202da6b5867f773ce1b80569b70825e37349321bdf63ba96e6ee4a7e51c1781a73e795408b69a7550b63167d82abd0c392777542e1a09f671776c7c16f9139f8e89dee74627a35c52cfb01f829fee6fdf87fe9ceb7f3ebd8031fdff79812fee6e1ef6a8ebe9ceb42e74fda5b68bca331ccd1d4a155bb932d62c568ddbc1646cd06653aaa03d87a018a5b782a20ace6a57dddb8c919ffc160e4be11bbfd5d6142faaf0038cc3e109cd788bc6dcfad3424abe9d404fd3790e9cce2541d5006dbb098a98848bca1a5928c271aefb382ee7f9561c9be10329affc067f5aec03c85409d458e36ec507a63d822f88b294ca3b42ceb0550b9a7882494215d1ea192598327a1855bde6098741cbd0419584b675bae1d5e03e04d78680f74792fb37854de8628930889aa4561e5c148c625c2775b4a28bd99df94747e3b3e1282355a083d85fb3fb71fff6ff2610c416324b541cae3cedccb2bd811c4e25fd8bc2be09bc6aba77448e697b8223170bb70f3411ff411b2da8ca67674cc1b3cf9d0ef6ef47299ffc030e6abaa08a44a28bbf5e9e59f1b8537aa77fb12f5cf728991cad2c0e1dd04ee16ed82521e6a75b6cd8b122e6dfe554151cee41806584f06b49d5ff51a04117745bd9d66bfe1a71c8230192b5b6c3d4c20c1e78340fa2e23732c7711d74b85d773e91a5ad2a37886ddf37274071a60fae36cda20304a026b5f63d3ea960cf18751fed58a36b8cb2d8c8f393c7e35acd61ae72bb488fe37277b18fc0aa116dd52644d0cc291a02650f2ffda4b1f243a708102801a29d8a0c55858ebb255c3f655b6da56b74432143774edc2840589ac73a0e978b124620f9d0ac550048b0e0c1ad91679631231bac07ea04b7a00d94222d9b1fded1a91389da40473f88d92fabb8bf5f187993d29941fb378bdfd0fdcbab10125681845fb2e80805d58fa172ad50fa16b6165b5dbca38f30ec09f904b8dad0df955b1d76c7fe9fcc91540ec8496780d98638ad790af09919a0f88d1376ae975e05d0737dac0a0003d368e669cd12cd51d9f745bfb75bcbfc05870446064c781203bbceefbf70e23e673b063f973da80cc4cef7b38b9482d426b98cdf96fcb83f988c4ed8356ea245ca74bdff5a7f8ead98365e0716835cfee243f3647eb1c21fa8f3a726619a9cba8ca7e4e3462e7951cd5356e0dad399fea4014dfe1a2ffb358fb1d807924defc12cfc4e850a3edb38777a47018d61b624ceef2b6141d01afdc708d524f2952a5f57dc982297d86239c071daa962a6acbf137a93586d9867629ee1ccd6b93b30bde88fea2b275da06a7d8030adcb7eb9abf545a208ffbcf73ee5c466bd380b8e430110c7ec108f4caeb011a05aa0c61c73370699ca8a87da4ce9a8889ba941bef586596a115e53e11a125b8cfe4cde4105eec37a37ed392ab220aec1fda6a9a701911c8de345d6cc1f4289fb8facd33451c404184ef244a1c7513ec0a209bd0cae0ef22021e48cb1a8511f37f31884aa27595e779190a397c7afbbb4faa4862460509d4aabc22fcf03b0779fb19828cd383ca70cfaa44a693202457ae8d447abf4dc4bd3caccf8e6f81bf39a712ee0418927c416e9ef402d1a95a0262cf3191cc921d78a86c9a291f7ffe3d5e774767c6144dca2cd92df4a70f4bb4073bee29ea23b39598d770824f8f24975ddec1f362168554b222e6faac5dd983b8cbc591e3a63cf7cd87d29964da694a6cd775fba31a6e4daca20f594a500189b4f3fa4e21835649383278e983fe2e98349577ef859508447994762834b20da78839b975984ce3d34e44c71846dad17acb74c19634a1b91ebe3bb3e67097c3e660f7d62fc0a4f2e10d65a2c25c8d80e1aeef4f1fb372d93171721d7bbc9ab06e4b14db254ad9a0453f3d96ea9eaab1e3f247a886a47078176ab4611ffd8fcd4b6a36fa063746aaa368fc3950036e446abcc645c49d65388b4ef179146b81688711aa9e9548822fb4415bc3e1916df167a8e2f7189666a7c22920dcf36c31a5f9ed21272fe4b7f3dccb70b2369ff6b8df825074017b6eb6702d19254023cdbd1762f632df9e93d66d53c803039857dae28c9e217bef8a1b66307e26781d4d66823773fe95734b1e0448da1fc14ce217eb2a82d8704d95125956662704c00d319ba555a3cc555dce7d775d28db47e50043d4c1dbee294f908d2aa0f74d78d99f938d94c398fa7d8cc5af239c1a95f6e65bec080c3edede4036bb3cab3254138db44b051b59f4004ac3769fff170572f377143e7457a39324bf9038953d909762f59f500cb1d51bbdeb6616399d945c494c2bc1b7ca55afbeabd91badfbe5103aee1f4a34d09bf36928acd9f5d6c9a757e23b9e73d859cba7d2b37254a8ecbe17819ae3dbc2e22ee4dc2b47fece08af3ba0a8568aee9ce8e42973734c96db91aaf2ce5c6c1cd30b63bee512751e5b2954c8c2ea72cdd5c73b327dbd175607e4d065173679dde05d699e803cc2d3308b9810c8bc723fa82b453af8c1f20be4a85e43917a11004345dbdd984dbf6d44ab754efff8b5481fc664f98e067cf830b8029f28b0a96d510148dd55a219f2e0bda0e3d823d08de465db820331f28afedb62164017d7f055c76e5668f9ce218cc1b3a06ef581975417dc308960dbaab816f7d4d3364df25e9ee0e60bc453dc0b18ae05bb6153e022cac88ad1f051f06d84a13f76fa2e1db9cf5fa561f78b41b1365297b4d74a7832d93d71f8d2c8bc204bba9921527f1a2afbedfbd2e48dfccdadfef8b4e338ef3a67af78f9b148af758c873974a2754a231ca15f3e5d147844b7b6952b795dd8f4c8fec997a90e8fe9ab92b5fc896a1e46ef11d17b2e4fe08b2d9f8e7088da6fe0b19a81187630055ec44a60b2ecbe0d19e62ac9410ff3cfc46130b382890325abcedd33415bc4253d4674e07408a1bbb64ff7804fe03ca32fec282713212c0d27aae64bdf94d3efdbe1a710c3fceb22667b3c545966c4dfcf2c2cf9f4378dccb755f85a119c161317f67da2c7c81533550bf445d22e0cc659169db074503bf475b0c8b36ade953f396a04494991e38defcc1f204addca4792dcea8d944fef4c8fb5f0b02082d86b76c31f56b553f6f5ee4599a87e516a5d42d11c8e270e9f4fcab5bd5b4552bc3a49ec9e820420154fb1e99c6d442d4288a0f7825c82bd1214dbfc21c786b12238a2b27ee583d1ecbc2a6d1e06683005c9031c7c306d88949d4b199c91d26a704330ecb2d71d3222f74e2e9f14e73176ebc8e1334991eeb285d5875edafad40a853c47c35a4cf8b8cf7341369c70b9e6adfa3ed058276ff1ba031b15e7ec9862ad78a5bbefefc26cd9e486941df76b44d19dad7abdab51670f19a12cfb7c36dfd8622e9915c264c92c70e3e60312511104f8cfcbe89e48d82b57c631e3731e1701a837e0c05477bfc4d32d67402a766f86ecdb71beef49153cbf9a536951ec917a942360126f9513c8f5ab2a4a8557e7a81ce72d0a68f375916a8c476edd957490e0e88799a3933b8430c78a253552b33d9129afbb4be6acf410f7e3b6f5dfc85e53a252ffb8bae8312df57bc0bcfc22acce67f419f2ee0d833b9f2edbc6f379c6cf489cb208233e641858efc4bc9493934a3e734e3f2c5c55c60bbfabc73acc866b72906d5375b085a6ee06eb0610d59c4372f1508b56ca21ac9a9a729ddc517e110647094a5a0bba5de368e3821e7140d3a994583cf36374cfd6856f317c7cee05eee84b2c46c06ecc2b94b7e59c2d78b59775e36b58abe66e549a499667105c47d61c153483a41b7ce871d15a41f3c6dca365e6e522669ca555ee09cb635c9b875b60f3e1462b2746f630ff31f672961a668553296ff7eadb1a84bfa9b89eaf51ec3b7be06281514451e55f6bd43592b019e4816d31a8dca90f04c670b5bf0408f03ea26ff8289bbf6edd1442bd4844277c0cff7d9c1322541196e1ed67210f940bf8a1a83bec422d171b180dac6ce784a8c9e8d0435537cea3cf23f0c2e41c4339f1023be020d4294b0b984b105160940a468e5173981adeec3f1c974176386fe8941fbb44c6163aac22aa511a05afd266ee02b58b638d8d0c10c9d39ab19c5d2534cbdb0b182eaf789eba0486fdfe314282c2134da46e06e663471cdf10bce329db2e5ba658cc78a08c4d2d3b6f9baf4062ebc373e1a60874a2432914f191c8613e548ebc2f6e46f1e4b5f1e595aecdc0fa67a6bfc6b73c26ca7bc14384970c6b7dcd1742c8af2a1197bacbb6bf96a660598cb83659b8fcb61533c21ca82162b2238ef8a93c72982698560f2e855e9667be22c13d8f9f4bb262a691120c0becf62e15ac92c388fc72d53bfa0500504f68b7268dcbb70d456c1f010bc99395debddc1fb92d877fd0b0161d13a2813f982471ff543ef1a0db3787dc4b004b7797cdb7cb186642435dd22b7a9fed5afffbe85c1265b5298c376209be3e1e217b90ab310f1e0b9a520fdb4c257a7d8fd033107005028596ba038556452a918ed2b0f96cdde16e619ba22b9613bec36c1f6ad420a4d7708782b3dc2ca9b34861835c4180031a8bd023e99216c10acc2f7e003dd506a17c5daaa3571921f0f7c7343d1940a54eec9e8d5ffc6f1c54831f4bcdb3f3a8fd074e0951b1a134443d951ac5295adb96886971351f539698dc3a82d8a0b421f566f7b7818651fff767fd3e3159ba79d19e177f644a9e0f1e164bf87da7750340f178c4d33f0a4675fefbcd86d82e9a22e5e62475585ed75923ac09e736c07decf591cc1b9a60c2d521d2c1768a5f6cd7d81be2075e2e10c88dd2f413ab7d06c83423258b55c74185d676a24390c87a8f17e422d9902bb491728d56d0d2b01719e13c3fad6417eba4b5aa9a2bbace73b1afb50a1f8109a2804119923e47b108dbe15c5d49a54220787d4d6a12997d884ecab82be35e5951706ec88f7d104b46cbe7b105873a65840793ebe3af950b5c22392e2108647dfce18fc3c23465c9ffdf053428a17bb2d81280e84e0bb8b48d6ecca461b4039edf1c73c135b121c76faa170d1397706ae72234746e0184e6469017fdf9e0cf660ddfe1d986c89fb8bc791f1a0ac648385c6126395653dd6893ee6b3ba5ac9835d97dfb5b5e72ac6c399ba1acd410239cb70f2665fed4a3b581bec0167f083080a6890feb0b52303be1e6880e0947635fe3ec7d3ca76fc26069dd3cb06e50e0503fbb8c67d605569b7a50f44178532fbb560c110a4fb4aeb436772eb5d68fe210ea60c1c085b8de3b42897a057c2a615bc6008a0ec5e3f8ad9e8a615b6c4f2b43cd291328bfd0aee1895069c7c73ca5e59ed6bd2887c9436d22b000ad67409793d667bb293f14bd18bec7562950e3cf8bb36cb36aea4782fb37726fe0f628e68e0584bd0508ab865c8afec7119f265448697af423ce0dc9df9905db8a6d85ab7d8114246734a64dbb5f26e8d395286e1d050f30d8ba497f318da5c5e55f804205650d55b2f8651af4c25154d34ce2dea9af52516e49545708c10f1f9036696dffea0afcfde8776db3a289abbfcf4a1fae44a933f2b042e9ffd19f9d98946bd417113a2a4b4bcdb2483192f2977a62660904591f50e1041a1bfe4360bf1ff6c85ac6574f29fa25bc2edceed02cd3582cbd6fed1a6fe473a38f81982db6962029d7451030d104186142476ce569a0aba8cb69be0dee46598f56bb08e3197710bece1502251ac22c086a6fa406b2d48fcaf210b0426988ba4b6b21250cf4a75611f29285366b76230ab646e9017c05f83aebff7d7dfecaa56e50cf8b0c2495fcef87f919a3a99f9e882681f2f9e29b22468964f4f7f83c00eebcf52136975b5bc2501471175aa69b1df234908dd9fbba5e16406a03aefaf938859371d53be334a2da5a19b3e7006949c77b511c376c6243276c44a510d29eee5484e294cd91037dc1f4094bf23db75e2c114e4a7033f533f594e38d0c29bdeb2eb8093a6442c4bcc7811616e2fb0e1dc6c3c91ade2db3d808e0a50de4c2af6352b0d120c5f3e7e4270898f9b12b525510fd7e9768605e07513eea792b2c0826dcb385c875b8fb337835cb838632197903b575c0d8aed8757b8aa222d5f0ef93d1cfd4cfac678b7e94a6e7e82b44f85881e8528486e6f6d2f3d1e508387a44380e05aca955978486da3b594926f0f3c3496480af386243b2fbeb21fd5b077f05aee198ff927151150d0154ef909bf39e8f2f911e64678266843154a9a23c7fc8c78810e1a5714027868b58d68b8a7d02deebc221e46071898fafc3273b0c020d3bf8a7b3fb89c58f79f5deb32f47ff13ca8c02e875c70036ca6eaaf8efb50d2678ac7899609248457ae5a403532ca34462b406ab9f5a60c1cc32ca6340e820be08ffb80df7571276cbb27fee3910daaf555cd92b2e92b38f0f6c031ac0ef62b0bd22eef45de18c90ed27c1cdab0a38fb36b8266430d42d1ece77341a28db1b8a61b75b7c9f2083ab7782abc9eadb7bee8bbac5a31c4f883d851b07423c66d5daa0984343184e59fd64fd89d4692f912a61794d0e3de423f097bcbc89debbb1af10099e94d0bf97c51ee20041fe2e4561ec5c86963c77ef8c44cb0037d2b7e56fed371a31252b89e9b113a5d64d04e713aff295987d66ce8c957e6b8379c4ad148368c5376fac15c43a6eb1d476903c83eac372766f0f73eb522b404db7ab042c889a7dfb1ee57f6e071477ca1ad3873b595be641f62d7d585b068aa3155c41f409fee0347407c34681c77535cdc68bbdd8d0c4a315269f814b755419840142068266f8a749c6edaa801312c7a65a6019c331d24a77fb635c256b14d6461e1f70606d9598a7b3b6192d31f99b6332fd0cd0a6139b4bb490779ff87a7c97f767f8d429b62c3c81218820c46167790db23ad00da14ebdd38ed05bd3a6330fbd0b36c138909e410b2aa2b2f1eb79a0be48811f1525997bd03fea1260fa4c6abfc03bcf074cbd7ac7e96ea67e016d72bb28f9e30a268a10d939157cb1b9c67e52446d6fd27c433ea658387f80842266ee0b0c5bb6aff40d35d1aaab4313092e66f883f26c23cc3061c43d84d79075024016f2184eb434d778c892c7c9e65f0f346af9aa85471dfb8646dd6e190175750a261f81266f831f34a296836d8f11069d9665e332583cac6e67d7be7fae6db1a8f56800ea0351f639690218fe394df72c6c2ff6fb6c0955e384a6888a55622b634584428e3183ca14c5b3dbc4d27450eeb5c9f731fabe9ca9151e168ba36f9b10e002022e15ffd99e026c11f622ec26b10725a6cea2402688ae20b3aed2e52e3683b2b5ab7aaf4170e4587d9ef92bb2591acb128f0eff87bfb3518571d600e1aad3d0a2f133a19f6ec12651bbb61773753d17594ff86cdd5783b18ea23a5a6aa70a984e8491de9b207986fce6aac4c9792b3378e9119939e199859396bed31e52180e0010e2bce535fc4f526d29f0fd42181a0d18d5a33a4430df5471b40d41923a6ecbbd226de5045dd7019f266884726663f6683c8ad96930a221c04d8451889e85b5a15fb0be0305cf0beed68974937ba4dc9ab6583aa93aae00da4cfc5f38f914cca6c06d65cb8328505b98008e50d16b664579dac076e1e09576ae1fc820dca5fbd3c7419c0e8a7706b8672d767e7b5aa21d7e5218ec71d8a163be1aa271f11e4ad83ac8d112502baf2268e0d5aa4873c2e8468f5a604bafa8e03e9446b49ec5cdef721ee7d8a2730847729ce893ae5d57833434bdde77f9ee637048f3a08a3598d5930b8fa662bb2b10d92311c91805d23d90a104a8b0985621673d8478b5847bfdc8845aad7ccb2a1d7b0a603010a215755d8098ef3fc64c09878579617be817bbb513b6ef558809e8fec4ea4fa9767b308c179bcd4c19ce9f0ffc7fe89ab312adab3bbefbf0a948cab58b5dd6de935b617f9d69571629fa176e375584bf3e2d342a25ab3994744974f65a2d8327ed5705908e4e75146db42dc8bdfaac5a680410026f4cef5025ed4e89aaf8156160c7578576bd458ce5c4bfca3ffc2c3c05b2093717ca6485026a213415b2fc31fec294d28524f90ea36be60d9e27aab59caa2034351399cfcb9f160ad2e3b50efa6a55802c90a1f9852b52794b7fde1dab128815274f73efaecf4d9b51021da5e40478320ea31f98e47711845925e0ed9fcbe659593ffb6dfdd08f2fa641e94f98a5c5a3f393c53775986596141760423c2568fcbdd3c71d540b5e93ac36b597d1ed764e72bd8a834d59161bb550745ef9e6405926b82dff8e3d2d4510b2d35dd23e7547356615a4cbe219a92408372cc72a516823c22608500f18baefe43644b3287187c5af9766197871ab9d304d92251f479bd8884698e8f5376a3af26ac94ffd118ae04ebfd0086f02f68b098e2254506f1902c0fe2236c71e4a2eabc3e5470da25d9df196fdfee731b76993124c32abebb3aa1eee599150569b3d56dc6e1f8228cd4e99706a59983119cfd4f0b455bff9284bbc52b112f8dfded6af0f71fd2e199ed682b17cb40af4d7c792bbe4ff6c3316ad56dda668eebbbca8d7bddf98adb4ebe72041e92b5c290982af39da7923cebe8a42680418a7804cf93fd87d913adef124698cf4618736496fd05734e8ef6ccde825d5ff037c0147d2cb6fffc183e807ef755b87009cdf97df53bbd9bc5b9183120727ae663fee43f6619e99001d31aec52fb14ee60e05490a0589ab6437da6b3ad2f0dad918f45fbdc1950df6f7452d3d4698242b92780517ed2e033e1b78ae6d765cc720dfdd31d23546918cdd3db1161a1fd958ab51bc47e58f1ac1e708bb095d7c21a608df4966301fae804336bc71aa327448fb791e73dc98d69dbb68e3cb7614cf7c33b780b328a6ce394f2f2c3afc2f1468b8eddc620376c2baddd6cf67adec1093c2939fbe984fe8a835b2bd5afd98b16ab6e54ac0506db5a10e4e2e50e038692e7c6ce94a71065f4c70d98897dae5688a4cab95a6de33f66115a0119f859c7cdbe2e72994dff0b14c75835ee8def0c8eb0b92ae2cae8236073ce4972d192fd2dfe639ba4a2a61e1836c435f2170530b427c65288d34977c9176493dd25e4bdbfdc032e130261337828106a18708b2486d05db8d0c08619bcee81715210a7c7ef02010a092047c4db8747636a8195f4e2a7cfbd50492a77737220c5174ac38f80eacc1e73fbeba6e3e4697dcf4d0db28f26e0c822bd7f762ad4cee718fd04243bad1120df1d89b591390165123d898bd93ca8b6190e87e63f4b410c14473ba16eacc63ecf927944c2f25eebd129f5c3139f94a54a87b409c85c8b5edc2a870b74f4cdce84efe9eeb4308b83382f05cffb8baea2a787b2f802d0825b7b2d10ad2c0f871950d4b4b39bd1c12a0990024d775732ba096533f0272a448f912bc2707675313ea2765933dc6061f215213097233889a7f19b6a2ee19ee6835ffa6f95a8c950b0a5389490b1c77d29aea5ef8b53ab7cab0bdb7d27ae8a365f59fa71b310f7f72beaff26794282c535aeeea37790079cae1b109a14dac981227ef8cdad09b1fd9437f1b2ad895e3ecf905055431b7aa92ecb58906e8a776c7e89c8d2f79c43dd716e93d71ab2ab73a8ecb029ab8d1e71a4a3b28c1513c76963c75dd8a83130b05d2f6da1822f0b4733ad6e890e60d8aa7125f8ffca25a97f0244174fcebae2e991609a32244781398e5cf3ae186006209adf65303211a2c5a2354eca08c34af782f7d14dd4146c7199d37e48dfef97f0bf2421b26763887e3b0671b742aad004a9ff6f8fa3b696be9e236f7623df8c00d3a3368045d94f1f64783b6ac879d24d795f45275e2cf0086fa7a079ecf5c5542778db287121cf10828e17d0d5ea8320fd2c5488b56297b00edb4be69353377b3c09699ad80c9381ae3add3af9721bd87279d71b1425f2a16e642e973c0332655089e66319c7f1c88c142de06e4b06637ef5a879c9f013f82225b5d7f9bb7073f3994ce7d64274057c115b8f1029c663d39333d2b6da9e5396f4c2c9b4b199bd989335aedc35946fe18b4d9106125bc61864639f8ce01c631f09ca16be7e7b6c9edc682cf7e408c626305a3437eae5ec322299910409bb4597a18b0048785a1ca31e580bcc71cb336502cc9726b4ad7247001289d1ac4d6338097faa87c2068a229ae602b08725fd31b0b2c7a469d0e8ab08779a5c1b4b5f904c42192405abb426ad5b8b9994f12e956dc702412d8a9fae2ed4782f46e1db04e154fbdaafac1c627c65c2f5e8bf918c4026656de033cbd797f4ebb38b779f92c2009f478b6fab153299b303bd3e784955e991cd9e9a7d5b311794e64ebc50b121334c463afceddf85ce884673d03fbe78c60f40efed08c0f6807f031d5ccfc1fbea2b659daccce7b5192a80f17e7ebf21c3855e4dee3d8fc61e1e0caa9b783a3f4402dc326a75eaaa8108c52993f9bd1cf25b669c88fbee5b819770ce99f559a758aa426b300e97df59f0c896ac283234192d02fc1bcb59a9e57e8e1b756d264240ab2493a5052e82ca76238353b470f41086607ace8341f2c1bf4583c0b3e8f0269babe2968ffdb82b6d632bf9f052984b82c9121deab7330232fbf7fa127ca805894a3a7049ccfd0634be5437d1c15c8d101e57a032f319b34de475b57dda07a8b6901e5aada74bc790980d9b2b08a649926eaa3adc3b76d8314a15a7ed3a7bbfc8d1d31d5b39d0637b5193e372d0472469213b03f27d2eead4d2e0e06d521007dfede98f1f162e6c80ef8d3d6b31e1e2df70916c29a0485697a923cbdbccb478b1baf93d47bf06e13ea2a209c52505cc7bc48d8f2179bf8b93844462593ecbdc06cd43bebd313e32d6b6b74ed6fee6ef4f9062b6dab34272c9e1c99f9da24e7bb1a6c898c00fa55a94f2f5891f4f5d47e6245a060e6b15b8d1836e92560a8990c4f08ef88b54da97a12eeab71d34dbfa356c01895f1f5a4b2e151de649fb842ccd0713fc77af077d489671af267a754be2fab37de4aee886e0e23dc9bf4f00a8e2a2f81cf68b6652dada91d44ef02602fa3b6bbf4624028ecdbc6fcccdca9f1071d3f95d9dc2bb3a9cf4680be1bfbcdba759b3b7f06ed6df756029252aad00e483e013f11b081dc305f86cffb08199cdb91affd4f892232daee2e4d1235c2f3381681c6d3261809b1d3406cc081f186e9ff534e2168e745748fa34cc57b7ec1c713773089300a3fabd2504e67d87a8b68699b8da709fc2365931edaf36fb6eccdd815d84881f03f2139646a0de4e039536486bf309d5490c3f25b8be750cdec5846012b4ea460e0d44cdc35dfebaa4740015462f054732e5500f926301be2ef18a43e23e2770614d0e1324de8313969e51b500b1031815d076612ece4bc0c37996ae18ed23b63e63fb124c4bf2f64140405275952eb5c2c5e9666e91e8d6e7862bb8c55cf5510371ef1753bd52e8b38b577231c94d1f73da0c3320860b4fc3f95da12f173d272ad00cd1806b9ea53fefa714f12cc56369b3279585897e28736e9ad194e584880dbde7f18708a00645faef40e5c15adc8f572ef3aaea5734131e6016625bd7f7d092c3b90f6e36df661577643de15a7975190259636bc2a40d56de868be870f746918b2f2cb0ffc75f16bff63bf5808aaa101bd808c956ec7bb1135176734a1cd451e62db614c4ff6c5f621732a76ec79c17e399c1735db09d0e2b20b5348f8e0188b36b97e215bc96bb490048fa5c9c5e77493dca56b69a293b3749c0b7b189b990961f626dab9362f03fd4d0a24726043a83272c431a48ecc6fc3558890fab362debb7827fe59ce1fdd74c95511db52cb73d6d6f3b151fbba355870e325eb0de1eb8b9e48dc82893ca194b235a77a89084c09594bb8172467e1ccfd03cdec927a9be407cd05c95f63a116741d84d074b967c91bcabd30a806689c021042c63787a6bc08d09afb8d508c5f8ce1a98ec5e403290d7d0e5124cf31ae9d03ae9bd58adf3e4c6d8a524bac35036e9df5861c7133b1463b07f6db494ee57e34cd2a8585901f70e2e5b8a8300996df3214856f2b9893a8d47abc5cd873af74636294e6fabc7abcb7f47e5718f7883aaad8ca98e6e74044e4b9a73a92400d7b597563c6c73d52e3fc751d30e7bde213e5f89abfd54f09b3ce2ed4cb1d411dfa3a6fcda9924c855b52f88a2f9a9bd5564bf09926e7c6aa83efc9a1a50c71a15da4fbcfa47a2d17cbe779bf9af5d1c233e81a594b22c0cd33738af64e754766804a546006b5e22f64de1c1cfd406e90fb0c864bb3b59ff7a9477d09b3edebab0075899475b58fda544760ddcd56b2f8888ad38d65234990205fa36d1cf08f59d16d889a36c3788da8c3ab454b8dbb8875634c9c599428be93a641a8e09daa5c4e7944bb290ed58f4d521bba22e2c5b5824080f846be7de9b7e29940895d3372d941f43eec455b4969fc0ed34016649051d8ba31d1835afb979ae4bc343153cf6218a9c2352452549e6575c18d07e336108ef1673aae5ccbd15f5ada254423a397ce86ebbe6756a7067efa8e7d21c35f22c042cbfe2e8670e462753f56cd8392efab9520b3cb87dc97af758444503f24811bd9a610006dee0beb97de22a500acf2c5fc4c19747786080d5c9d8c15a094c3dcba701026ae5cdafb9f6cdd8ca2dc840a50191ec68e5efcd4754a9ae597dcb068a7c3e3a25b50488f0e4fb7c255d08918729a4902b89dc4f7d7bdd2981a619a8e1697cb4453ad3f6921f2f638d1991530f42bba6b1e22ec3735dd14e5dbc5683f3b2daafe0fda7436159e8c6f1876848b8d246c86fc8022d46131bd8e961115ae4278bbdc964722490a2dcd7bc273cfe11a62cd47e3c2660f7a397147e86500bcee14fe88c6d5d4939685b47e5a357bd07f455db03c6631fb6579decb1ab02ba6d5c87e718a217921531f7a18be62e9becf6deb591754adf51c28769123c455cb86a2cd05ea8ee3ff7cf1a2bef01712cef67719fd31252abed18dfc051dc0a6ff8f0f53e123706c81d11684a434ee52ea15b1f60bef8813fc8847227673505b343a8304d8698c2279c0c24d0c4dc85dcd3f564de14c0624007210e132ff5a338586afcbed59fa55479731a33c2dfc9ed0a36dbb51c1ef69faad881c5820575d92a49be77fee8085bb780225d758ff848ecc39d4673afb67279af0f50dd2d0d48de1570fd305c8eb146f71ecf4d8d7de92fa036fa1b52993772a1f5eab455be9f12d0b271940f0a611b5520c24ebee7827d690ab61607a1a5e1c5368de4ac00b4a1769b6bb461d1f9f5e81d25e237b1d9ecdb92435ac26eeaf9901205672789ffcab806cf4455828a31bc90ef339abce8fa70761a1f05b53ad50ee9adf2e05ce14ec0b7daeecbb30d477196e4e638b48921436b166c96adb0f1a2e9ed941f124ebbf562acc0634f3bfaefc92c07b66d6cd0cca47f92e659b194dda64f24a39ca21c3e7b556cdef64c1cae08e217e8465f7cd2883d4fee0f12a0272cc348e66407f19b4952133900ef7ac211effb5e9dd7a1e17cf1611f356a5c2b8ed685130cada939fa7fc81a41a5182fadac619d511dce022fcf8fac8d693ab18834c036d5ae46afb2a1303bcbb093a2ae222c0502419fc828ab6c0f6068230c0edfed50e013002b6bed7313b2d3cb3ff4736dc24e6db51e8137f86d1e867c970c3287a2f53d8f17f1c92f46e32b7d371781f4aa47a18d744b9f2814110a84336900a4c0fab5573e1657d7d2edfe57faa4143786bc431189aefa413a52614128e693b8aa58447e932dc75b1e3cdfd0266e84af4c0bb126ee0b12e94ddfb2e190e9fa3123c17ff8e38b7d0b630c54fe8d59e49809e58a21f070721778581740a08f73fb7139ceae7b19bd225cc3835407ef6588e77d43c66e1f47dd7183c35e8dae94fa854da74320d62c2f7a31172bb784dc81d865784f570639dad887c8e1c98ae6e729abd645a4b07732b1f1ce855252b1d996c1b326bb9a44d9e21a52f6849eb8a357c4b730289d3b5f75321c8e0c0c85d003dc4dad59e1cb1aa6cc7eb1620af7e58affb2021ad228c1792d0332de6096b3965fe959bd8e5156b43e67efabd742d2bfba1014da8f3784a2f1c43d1baad423a8ac025c7d5de6a97bbcd2b08d7ea3920028b6832e6d9aa64a83b42f6ce802b301dfa929e5bbebb1133ec324b2ffd3f7b49bdb477786c5890928633aa196b95c3982470d06c5295f38091c0d54058c7d4a85512f36d45a966060bd5fa4f336a5586f3b9b22015260b95793bbdc80e67ca5b2ee7878f055afa0e84a86dafd931e21936e10ae1258c56007b5f2fbf1abd7a4dba306262eb80778dac037df8df79c900417eba28df49be60ae2a3c1a433ee5d52c6467e75f3c9e3aa835c36a1da98e5ea49e4806d26163e65707a56d85547f5f36c22cf4db62817ef6031af7ed66b2fb23b8ad157f48ac4fc5256c50cb95cf736519706b7125388a7ca2ea1cab5eed9cb261a34214d2d02a79dd30ef7ceed27dd9e367b7620c9b3506f725b6b52033214a0a44f852d36fc242ec09b968b4743834903ba9ddc777b3594b6ec13f968b1712cca54a1929ebb2b57cbc94d0595a5e922b2de309fc88cfdabbecdf369a2c9aa17b823690963e6a77c9f34242d9d23eb7724b2955cf451348f1678a09d4c390c421d52caf4f68acc4c5ca18f981d9c880a26c17f87d54ea0d800459a13f94b61be69a4f6450def0ef457d8a89de1beda4d17d28a750364fdd25adefab8597e8975b25a2753b2c13b1c7f19633d9ee0188d6795747a17951d28aa05eeae63d1d56871e14998feda90f04f2ec1dded9b406f49cd86c060855e7d329bbcb6db85026e5095a936db08cb4a42994ad7a5fa40760c2c865eda3f2a0515a1e56d990eafb07fef33063a7f25a86a572e01ae4e8c7380c73c0ce41de95e669c7b9a5d12a589b2e26162b4ab7e8e92ada6cc5f5db5700c3a619f98613ef5d534ff5a6b1bbcc75be554f51b179f143eab90df85f8565c2eec47f0fa681896d3e356c4166ab81a219c11bbc5cb145859e727e59fa35a9bcfbb1718bceb3a7554c99fdcbddd5f2e333b7851f3f94e2cf24ed78f0f7753c33dfe18b071087d3c43d8ec6aa0cf489a16c43966df707f629e6f61e4e1de096b7cbe2876c5f3266c57702679a426144c38b2f202d50e98cd9f2d730b2bea90fce73a23189f583b96fbe20c79c1f403272c58a4df18d5ddac5040c6f156772c3b09ae6970212ac54ea9bc4ad9785cbd3c0d8626ce6a0b012a75a8f83311c26ac87d645e6375138e44eb7058fcd62a38444bb6abd39b73e017db89d92e8eb335ad1d84e1f5edca46865a43775009624046c840e79af80f9fa854b79755d719a3735cebf0d16737ace4297531b6f2bb5780d48c4c866f396358bb1bfd614dd97d090da13a29cbc820a0178a1b6266ff626509beef64fc59725bd834ba8efeb022fd28bde2d037de87172b00232094bc173020f0e025a8e9d867391fd2327a97d051d26cce53ef53c519b60222d4c265ca18c86087aca2657af209b0ef79a8aded5c562170a3f09e0d5b28d68e66a47fb31c7946a518491c07d882a513dc7de4c0ec45b45cee4d1913bb2ab71c37f528216c24e0f1a23032c984eba5db613aea45a2dabe874ba2a2ee3ca16ac87afaae6be682e0cb44081406e02cf54c92c60d5024024b0d4f820247b4432c38174d51f800a454897bb82d30f7ddd5115fcf13b5b16e052979ce090163e86adf0090434effc8494316b40060c5504108f316d6ab26e9964c3efa3b4a404d3971300b56737acf5895b78b182868ff2c15801938b6679f5c3d79323d750da70c4416ae0f0b02d685b7b2242742b119bad4c936adadea9cffc071eb4d29eb282d2a665d559f974d22e089208ead18030e543e6bb20ca99f5d977d1e4f1f09bcf111d811228dee457274fa010925e76756435f700d12afbdfa3fe094b8431202850a7a2df35e76baccd184a85721db06260e5e6692fa90d479489f074c241d229981916765dd769cf13d70d9d30d4bea1fe5d28dda14f7c4199a1945570475273f30cba681628a037749c378b89510b901047ed09928eae1d37ea991e6ff527b7e51612943dd927eec2ce69e46f8550d3c9dc41181eb440c4e23c6714e4244fd2cc129364275ac2c7b913121413ddd8597e72af374ea20008e00eb7aa366518df096d06081ae3f42a78910c8c2f880c58205fb6a553c1efcdb8282dc89b37236afbe584c3d567aa0a2321022ffd75769d7be1d3</script></div><script src="/Blog/lib/blog-encrypt.js"></script><link href="/Blog/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      请输入密码，查看文章
    
    </summary>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/categories/diary/"/>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Android SELinux权限笔记</title>
    <link href="https://alonealive.github.io/Blog/2020/03/25/2020/200325_android_sepolicy_study/"/>
    <id>https://alonealive.github.io/Blog/2020/03/25/2020/200325_android_sepolicy_study/</id>
    <published>2020-03-25T14:32:00.000Z</published>
    <updated>2020-03-25T14:39:15.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在新增一个HIDL Service后，需要对其进行权限配置，不然通过<code>adb shell ps -A|grep NAService</code>会发现该service无法启动，也会通过抓取log发现一堆的<code>avc: denied</code>权限问题。关于SELinux可以推荐文档：<a href="https://www.pianshen.com/article/6549296922/，" target="_blank" rel="noopener">https://www.pianshen.com/article/6549296922/，</a> 非常详细，本文只是作为记录部分常用的笔记。</p></blockquote><a id="more"></a><blockquote><p><code>Android sepolicy</code>，SEAndroid是一种基于安全策略的MAC安全机制。SEAndroid安全机制中的安全策略就是在安全上下文的基础上进行描述的，也就是说，它通过主体和客体的安全上下文，定义主体是否有权限访问客体。</p></blockquote><blockquote><p>例如添加一个service，在<code>.rc</code>文件定义了service，还需要在<code>sepolicy</code>的<code>file_context</code>中添加权限。</p></blockquote><h2 id="selinux相关命令"><a href="#selinux相关命令" class="headerlink" title="selinux相关命令"></a>selinux相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看进程的sContext</span><br><span class="line">ps -Z</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看文件权限</span><br><span class="line">ls -Z</span><br></pre></td></tr></table></figure><p>查看selinux开关状态：<code>adb shell getenforce</code></p><p>可能返回结果有三种：Enforcing、Permissive 和 Disabled。Disabled 代表 SELinux 被禁用，Permissive 代表仅记录安全警告但不阻止可疑行为，Enforcing 代表记录警告且阻止可疑行为。</p><p>一般调试通过以下命令关闭SELinux权限（需重启生效）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure><h3 id="抓取SELinux-Log"><a href="#抓取SELinux-Log" class="headerlink" title="抓取SELinux Log"></a>抓取SELinux Log</h3><ol><li>抓kernel log，<code>adb shell dmesg</code></li><li>抓kernel log，使用命令,可以直接提出avc的log：<code>adb shell &quot;cat /proc/kmsg | grep avc&quot; &gt; avc_log.txt</code></li><li><code>adb logcat –b events</code>,搜索关键字：<code>avc: denied</code></li></ol><hr><h2 id="File-contexts"><a href="#File-contexts" class="headerlink" title="File_contexts"></a>File_contexts</h2><blockquote><p>用于声明文件的安全上下文，plat前缀的文件用于声明system、rootfs、data等与设备无关的文件。Nonplat 用于声明vendor、data/vendor等文件。</p></blockquote><h3 id="domain-te"><a href="#domain-te" class="headerlink" title="domain.te"></a>domain.te</h3><blockquote><p>该策略文件会限制一些特征文件的权限，一般不建议修改。</p></blockquote><h3 id="selinux没有对某个文件的权限（有neverAllow）处理方法"><a href="#selinux没有对某个文件的权限（有neverAllow）处理方法" class="headerlink" title="selinux没有对某个文件的权限（有neverAllow）处理方法"></a>selinux没有对某个文件的权限（有neverAllow）处理方法</h3><blockquote><p>参考：<a href="https://blog.csdn.net/ly890700/article/details/54645212" target="_blank" rel="noopener">https://blog.csdn.net/ly890700/article/details/54645212</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-01 08:03:22.410000   217   217 W applypatch: type&#x3D;1400 audit(0.0:16): avc: denied &#123; read &#125; for name&#x3D;&quot;mmcblk0p15&quot; dev&#x3D;&quot;tmpfs&quot; ino&#x3D;3364 scontext&#x3D;u:r:install_recovery:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0</span><br></pre></td></tr></table></figure><p>意思是说明<code>install_revovery</code>没有block_device的权限</p><p>只要在install_recovery.te中加入下面权限就可以了。</p><ul><li><code>allow install_recovery recover_block_device:blk_file { open read write };</code></li></ul><hr><h2 id="Service-contexts"><a href="#Service-contexts" class="headerlink" title="Service_contexts"></a>Service_contexts</h2><blockquote><p>用于声明java service 的安全上下文， O上将该文件拆分为<code>plat</code>和<code>nonplat</code>前缀的两个文件，但nonplat前缀的文件并没有具体的内容（vendor和system java service不允许binder操作）。</p></blockquote><h2 id="Property-contexts"><a href="#Property-contexts" class="headerlink" title="Property_contexts"></a>Property_contexts</h2><blockquote><p>用于声明属性的安全上下文，plat 前缀的文件用于声明system属性，nonplat前缀的文件用于声明vendor 属性。ril.开头的属性的安全上下文为<code>u:object_r:radio_prop:s0</code>，这意味着只有有权限访问Type为radio_prop的资源的进程才可以访问这些属性。</p></blockquote><h2 id="Hwservice-contexts"><a href="#Hwservice-contexts" class="headerlink" title="Hwservice_contexts"></a>Hwservice_contexts</h2><p>新增文件，用于声明HIDL service 安全上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android.hardware.vibrator::IVibrator                u:object_r:hal_vibrator_hwservice:s0</span><br><span class="line">android.hardware.vr::IVr                            u:object_r:hal_vr_hwservice:s0</span><br><span class="line">android.hardware.weaver::IWeaver                    u:object_r:hal_weaver_hwservice:s0</span><br><span class="line">android.hardware.wifi::IWifi                        u:object_r:hal_wifi_hwservice:s0</span><br><span class="line">android.hardware.wifi.hostapd::IHostapd             u:object_r:hal_wifi_hostapd_hwservice:s0</span><br><span class="line">android.hardware.wifi.offload::IOffload             u:object_r:hal_wifi_offload_hwservice:s0</span><br><span class="line">android.hidl.allocator::IAllocator                  u:object_r:hidl_allocator_hwservice:s0</span><br><span class="line">android.hidl.base::IBase                            u:object_r:hidl_base_hwservice:s0</span><br><span class="line">android.hidl.manager::IServiceManager               u:object_r:hidl_manager_hwservice:s0</span><br><span class="line">android.hidl.memory::IMapper                        u:object_r:hidl_memory_hwservice:s0</span><br><span class="line">android.hidl.token::ITokenManager                   u:object_r:hidl_token_hwservice:s0</span><br><span class="line">android.system.net.netd::INetd                      u:object_r:system_net_netd_hwservice:s0</span><br></pre></td></tr></table></figure><h2 id="te语法"><a href="#te语法" class="headerlink" title="te语法"></a>te语法</h2><ul><li><code>allow signal</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow domain domain : process signal; # 每个进程都能向它自己和其它进程发送signal  </span><br><span class="line">allow domain self : process signal;   # 每个进程都能向它自己发送signal</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文档：</p></blockquote><ul><li><a href="https://blog.csdn.net/ch853199769/article/details/82501078" target="_blank" rel="noopener">https://blog.csdn.net/ch853199769/article/details/82501078</a></li><li><a href="https://blog.csdn.net/innost/article/details/19299937" target="_blank" rel="noopener">https://blog.csdn.net/innost/article/details/19299937</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在新增一个HIDL Service后，需要对其进行权限配置，不然通过&lt;code&gt;adb shell ps -A|grep NAService&lt;/code&gt;会发现该service无法启动，也会通过抓取log发现一堆的&lt;code&gt;avc: denied&lt;/code&gt;权限问题。关于SELinux可以推荐文档：&lt;a href=&quot;https://www.pianshen.com/article/6549296922/，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pianshen.com/article/6549296922/，&lt;/a&gt; 非常详细，本文只是作为记录部分常用的笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android RC文件分析</title>
    <link href="https://alonealive.github.io/Blog/2020/03/20/2020/200320_android_rcFile_study/"/>
    <id>https://alonealive.github.io/Blog/2020/03/20/2020/200320_android_rcFile_study/</id>
    <published>2020-03-20T15:32:00.000Z</published>
    <updated>2020-08-05T11:50:21.492Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android中最熟知的RC文件就是<code>init.rc</code>了，而在Hal接口服务定义中也会创建<code>.rc</code>文件。<code>init.rc</code>的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。<code>.rc</code>文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用<code>.rc</code>资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。</p></blockquote><a id="more"></a><h2 id="android-rc文件分析"><a href="#android-rc文件分析" class="headerlink" title="android rc文件分析"></a>android rc文件分析</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li><p>结构：service关键字声明了你要定义一个service，而test就是这个service的名字，至于后面的目录则是这个service对应的可执行文件在系统中的位置（<code>adb shell</code>，即编译后的系统目录）。</p></li><li><p>init是分段(section)解析init.rc的，在<code>keywords.h</code>中可以查看关键字的定义。结合init.rc的内容，可以看出，init是以on 和 service来分段标记的。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   <span class="keyword">...</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service test /system/bin/vold \</span><br><span class="line">        --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \</span><br><span class="line">        --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0</span><br><span class="line">    class core</span><br><span class="line">    socket vold stream <span class="number">0660</span> root mount</span><br><span class="line">    socket cryptd stream <span class="number">0660</span> root mount</span><br><span class="line">    ioprio be <span class="number">2</span></span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><p><strong>关键字解释：</strong></p><table><thead><tr><th align="center">语法</th><th align="center">关键字</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>SECTION</code></td><td align="center">on</td><td align="center">触发条件</td></tr><tr><td align="center">同上..</td><td align="center">service</td><td align="center">解析service</td></tr><tr><td align="center"><code>COMMAND</code></td><td align="center">chdir</td><td align="center">更改当前工作目录</td></tr><tr><td align="center">同上..</td><td align="center">chroot</td><td align="center">更改参考的根目录位置</td></tr><tr><td align="center">..</td><td align="center">class_start <serviceclass></td><td align="center">开启class start all services(启动某个设置了class名称的服务)</td></tr><tr><td align="center">..</td><td align="center">class_stop <servicelass></td><td align="center">停止某个设置了class名称的服务</td></tr><tr><td align="center">..</td><td align="center">domainname <name></td><td align="center">域名</td></tr><tr><td align="center">..</td><td align="center">exec [ <seclabel> [ <user> [ <group> ] * ] ]  – <command> [ <argument> ] *</td><td align="center">调用程序并转移进程(Fork一个进程然后执行命令)</td></tr><tr><td align="center">..</td><td align="center">export</td><td align="center">提交变量</td></tr><tr><td align="center">..</td><td align="center">hostname</td><td align="center">主机名</td></tr><tr><td align="center">..</td><td align="center">ifup</td><td align="center">激活网卡</td></tr><tr><td align="center">..</td><td align="center">insmod</td><td align="center">挂载模块(安装一个module)</td></tr><tr><td align="center">..</td><td align="center">import <filename></td><td align="center">引入init文件，比如etc下的一些rc文件，和java中的import差不多</td></tr><tr><td align="center">..</td><td align="center">mkdir <path> [mode] [owner] [group]</td><td align="center">建立目录</td></tr><tr><td align="center">..</td><td align="center">mount</td><td align="center">挂载文件系统</td></tr><tr><td align="center">..</td><td align="center">setkey</td><td align="center">从源码看，应该是设置一个命令的关键字缩写，比如可以将domainname映射为dn</td></tr><tr><td align="center">..</td><td align="center">setprop</td><td align="center">设置一个属性</td></tr><tr><td align="center">..</td><td align="center">setrlimit</td><td align="center">设置当前程序可以打开的最大文件数到系统规定程序可以打开的最大文件数</td></tr><tr><td align="center">..</td><td align="center">start</td><td align="center">启动服务</td></tr><tr><td align="center">..</td><td align="center">stop</td><td align="center">停止服务</td></tr><tr><td align="center">..</td><td align="center">symlink</td><td align="center">建立软链接</td></tr><tr><td align="center">..</td><td align="center">sysclktz</td><td align="center">设置基准时间</td></tr><tr><td align="center">..</td><td align="center">loglevel</td><td align="center">Log输出级别，低于这个级别的就输出</td></tr><tr><td align="center">..</td><td align="center">restart <service></td><td align="center">重启服务,类似stop 但是不会disable service</td></tr><tr><td align="center">..</td><td align="center">bootchart_init</td><td align="center">开启bootcharting</td></tr><tr><td align="center">..</td><td align="center">chmod <octal-mode> <path></td><td align="center">改变文件执行权限</td></tr><tr><td align="center">..</td><td align="center">chown <owner> <group> <path></td><td align="center">改变文件的owner group</td></tr><tr><td align="center">..</td><td align="center">enable <servicename></td><td align="center">将一个disabled的service变成enabled。且start</td></tr><tr><td align="center">..</td><td align="center">load_all_props</td><td align="center">加载system vendor的属性</td></tr><tr><td align="center">..</td><td align="center">load_persist_props</td><td align="center">加载data下面的persist属性</td></tr><tr><td align="center">..</td><td align="center">mount_all <fstab></td><td align="center">挂载fstab中的设备</td></tr><tr><td align="center">..</td><td align="center"><code>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt; ]* [&lt;option&gt;]</code></td><td align="center">挂载设备</td></tr><tr><td align="center">..</td><td align="center">powerctl</td><td align="center">对sys.powerctl属性的respond</td></tr><tr><td align="center">..</td><td align="center"><code>restorecon &lt;path&gt; [ &lt;path&gt; ] *</code></td><td align="center">恢复文件到sercurity context在file_contexts配置的</td></tr><tr><td align="center">..</td><td align="center"><code>restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]*</code></td><td align="center">递归的恢复目录中的文件到sercurity context</td></tr><tr><td align="center">..</td><td align="center"><code>trigger &lt;event&gt;</code></td><td align="center">触发触发器</td></tr><tr><td align="center">..</td><td align="center"><code>wait &lt;path&gt; [ &lt;timeout&gt; ]</code></td><td align="center">poll for 给定的文件 或者 timeout时间到。如果时间没有设定，默认为5秒</td></tr><tr><td align="center">..</td><td align="center"><code>write &lt;path&gt; &lt;content&gt;</code></td><td align="center">打开文件，write string到给定文件。没有文件会被创建。有的话，会truncated</td></tr><tr><td align="center"><code>OPTION</code>(用来初始化Service的)</td><td align="center">capability</td><td align="center">能力，也就是系统对进程的一种权限控制。</td></tr><tr><td align="center">同上..</td><td align="center">class</td><td align="center">设置class name</td></tr><tr><td align="center">..</td><td align="center">console</td><td align="center">启用控制台</td></tr><tr><td align="center">..</td><td align="center">critical</td><td align="center">是否关键，也就是4分钟之内重启超过4次的话，重启之后就进入recovery模式</td></tr><tr><td align="center">..</td><td align="center">disabled</td><td align="center">当它的class启动时，Service不会自动开启。必须显示的started by name(用其名字)</td></tr><tr><td align="center">..</td><td align="center">group <groupname> [ <groupname> ]*</td><td align="center">组归属（改变username当执行这个Service之前）</td></tr><tr><td align="center">..</td><td align="center">oneshot</td><td align="center">只启动一次，意外退出后不必重启</td></tr><tr><td align="center">..</td><td align="center">onrestart</td><td align="center">执行一个命令，当Service重启时</td></tr><tr><td align="center">..</td><td align="center">setenv</td><td align="center">增加环境变量</td></tr><tr><td align="center">..</td><td align="center">socket</td><td align="center">申请socket资源</td></tr><tr><td align="center">..</td><td align="center">user<username></td><td align="center">用户归属（改变username当执行这个Service之前）</td></tr><tr><td align="center">..</td><td align="center">ioprio</td><td align="center">io调度优先级</td></tr><tr><td align="center">..</td><td align="center">writepid &lt;file…&gt;</td><td align="center">当fork一个子进程时，写子进程的pid到一个给定的文件。是给cgroup/cpuset使用</td></tr><tr><td align="center">..</td><td align="center">Triggers</td><td align="center">Triggers被用来匹配事件，然后加入执行队列。</td></tr><tr><td align="center">..</td><td align="center">boot</td><td align="center">当init开启时，这是第一个执行的trigger</td></tr></tbody></table><h3 id="class-lt-name-gt"><a href="#class-lt-name-gt" class="headerlink" title="class &lt;name&gt;"></a><code>class &lt;name&gt;</code></h3><blockquote><p><code>class &lt;name&gt;</code>意思是为该服务定义一个类名，所有在这个类名下的服务都将一起启动和停止、<br>如果没有定义class选项，则默认<code>class deafult</code>。</p></blockquote><p>定义为核心service，当<code>class core</code>服务启动时，这个vold启动。<br>如果是定义<code>class hal</code>，是不会自动启动的。可以定义为<code>class main</code>能够自动启动。</p><p>通过<code>adb shell ps -A|grep 关键字</code>查看进程服务。</p><h3 id="on-lt-name-gt"><a href="#on-lt-name-gt" class="headerlink" title="on &lt;name&gt;"></a><code>on &lt;name&gt;</code></h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br></pre></td></tr></table></figure><p>on属于行为。</p><ul><li><code>on early-init</code>: init之前、加载完所有rc文件后即执行，init.rc在early-init执行的是<code>start ueventd</code>，根据keywords.h的定义，start是个命令(COMMAND)。</li><li><code>on init</code>: 加载propety各项属性文件之前执行，在init变为propety service之前都属于init阶段。</li><li><code>on early-boot</code>: 启动属性服务后即执行。</li><li><code>on boot</code>: boot的时候执行。</li><li><code>on property:xxxxx=x</code>: 当某个属性设置为预期值时执行。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android中最熟知的RC文件就是&lt;code&gt;init.rc&lt;/code&gt;了，而在Hal接口服务定义中也会创建&lt;code&gt;.rc&lt;/code&gt;文件。&lt;code&gt;init.rc&lt;/code&gt;的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。&lt;code&gt;.rc&lt;/code&gt;文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用&lt;code&gt;.rc&lt;/code&gt;资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
</feed>
