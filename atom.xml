<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunwengang blog</title>
  
  <subtitle>wizzie</subtitle>
  <link href="/Blog/atom.xml" rel="self"/>
  
  <link href="https://alonealive.github.io/Blog/"/>
  <updated>2020-07-07T13:18:53.282Z</updated>
  <id>https://alonealive.github.io/Blog/</id>
  
  <author>
    <name>sunwengang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android HWUI绘制流程</title>
    <link href="https://alonealive.github.io/Blog/2020/07/07/2020/200707_android_HWUI_Draw/"/>
    <id>https://alonealive.github.io/Blog/2020/07/07/2020/200707_android_HWUI_Draw/</id>
    <published>2020-07-07T13:12:00.000Z</published>
    <updated>2020-07-07T13:18:53.282Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。<br>HWUI绘制的大致流程是先初始化绘制环境（创建rendernode、渲染线程RenderThread、Context上下文、RenderProxy代理对象），之后是创建DisplayList显示列表，然后开始视图绘制，视图绘制结束后开始同步帧数据。</p></blockquote><a id="more"></a><blockquote><p><code>硬件加速</code>：<strong>作用</strong>：是将2D的绘图操纵转换为对应的3D绘图操纵。需要显示的时候，再用OpenGLES通过GPU渲染。<strong>过程</strong>：界面创建时，第一次全部渲染，后续界面如果只有部分区域的widget更新，只需要重新渲染更新的widget。渲染好的绘图保存在一个显示列表<code>DisplayList</code>中，需要真正显示到界面的时候，直接显示DisplayList中的绘图。<strong>好处</strong>：一方面利用GPU去渲染，比Skia要快；另一方面，采用DisplayList，再次渲染只更新部分区域，最大程度利用上一帧的数据，提高效率。</p></blockquote><blockquote><p>使用Android Q AOSP源码梳理流程。</p></blockquote><h2 id="GPU渲染（硬件加速）介绍"><a href="#GPU渲染（硬件加速）介绍" class="headerlink" title="GPU渲染（硬件加速）介绍"></a>GPU渲染（硬件加速）介绍</h2><p>在Android应用程序中是通过Canvas API来绘制UI元素的。在硬件加速渲染环境中,这些Canvas API调用最终会转化为OpenGL API调用(转化过程对应用程序来说是透明的)。由于OpenGL API调用要求发生在Open GL环境中,因此在每当有新的Activity窗口启动时,系统都会为其初始化好OpenGL环境。</p><p>这里的渲染,主要是Android硬件加速,即GPU渲染。android上就是通过libhwui调用OpenGL api来渲染, Android P上libhwui 会调用skia,再调用GLES相关的API进行渲染。</p><p>GPU作为一个硬件 , 用户空间是不可以直接使用的, 它是由GPU厂商按照Open GL规范实现的驱动间接进行使用的。也就是说 , 如果一个设备支持GPU硬件加速渲染, 那么当Android应用程序调用OpenGL接口来绘制UI时 ,Android应用程序的UI就是通过硬件加速技术进行渲染的。</p><p><strong>名词介绍：</strong></p><ul><li>GPU:一个类似于CPU的专门用来处理Graphics的处理器, 作用用来帮助加快栅格化操作, 当然, 也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。</li><li>OpenGL ES:是手持嵌入式设备的3DAPI, 跨平台的、功能完善的2D和3D图形应用程序接口API, 有一套固定渲染管线流程</li><li>DisplayList:在Android把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。</li><li>栅格化:是将图片等矢量资源, 转化为一格格像素点的像素图, 显示到屏幕上。</li><li>垂直同步VSYNC:让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前,要等待屏幕绘制完成前一帧。</li><li>RefreshRate:屏幕一秒内刷新屏幕的次数, 由硬件决定, 例如60Hz</li><li>Frame Rate:GPU一秒绘制操作的帧数, 单位是fps</li></ul><h2 id="Android-5-0-之后的渲染框架"><a href="#Android-5-0-之后的渲染框架" class="headerlink" title="Android 5.0 之后的渲染框架"></a>Android 5.0 之后的渲染框架</h2><p>在Android应用程序窗口中, 每一个View都抽象为一个Render Node, 而且如果一个View设置有Background, 这个background 也被抽象为一个Render Node 。</p><p>这是由于在OpenGLRenderer库中, 并没有View的概念, 所有的一切可绘制的元素都抽象为一个Render Node。</p><p>每一个Render Node都关联有一个<code>DisplayList Renderer</code>, Display List是一个绘制命令缓冲区。当View的成员函数onDraw被调用时, 我们调用通过参数传递进来的Canvas的<code>drawXXX</code>成员函数绘制图形时, 我们实际上只是将对应的绘制命令以及参数保存在一个Display List中。接下来再通过DisplayList Renderer执行这个Display List的命令, 这个过程称为Display List Replay。</p><p>Android应用程序窗口的View是通过树形结构来组织的。这些View不管是通过硬件加速渲染还是软件渲染, 或者是一个特殊的TextureView,在它们的成员函数onDraw被调用期间, 它们都是将自己的UI绘制在ParentView的DisplayList中。</p><p>其中, 最顶层的Parent View是一个Root View, 它关联的RootNode称为<code>Root Render Node</code>。也就是说, 最终Root Render Node的DisplayList将会包含一个窗口的所有绘制命令。</p><p>在绘制窗口的下一帧时, RootRender Node的Display List都会通过一个OpenGL Renderer真正地通过Open GL命令绘制在一个<code>Graphic Buffer</code>中。</p><p>最后这个 Graphic Buffer 被交给 SurfaceFlinger 服务进行合成和显示。</p><h2 id="Android原生硬件绘制案例"><a href="#Android原生硬件绘制案例" class="headerlink" title="Android原生硬件绘制案例"></a>Android原生硬件绘制案例</h2><blockquote><p>这个案例是用的SurfaceView.java的流程。这个流程和实际上从ViewRootImpl.java中通过performDraw的流程类似。可以互相借鉴参考。</p></blockquote><p>Android原生的硬件绘制案例，在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>：</p><figure class="highlight java"><figcaption><span>HardwareCanvasSurfaceViewActivity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RenderingThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SurfaceHolder mSurface;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mRunning = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> mWidth, mHeight;</span><br><span class="line">        <span class="comment">//应用拿到一个Surface</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RenderingThread</span><span class="params">(SurfaceHolder surface)</span> </span>&#123;</span><br><span class="line">            mSurface = surface;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            mWidth = width;</span><br><span class="line">            mHeight = height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> x = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> y = <span class="number">0.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedX = <span class="number">5.0f</span>;</span><br><span class="line">            <span class="keyword">float</span> speedY = <span class="number">3.0f</span>;</span><br><span class="line"></span><br><span class="line">            Paint paint = <span class="keyword">new</span> Paint();</span><br><span class="line">            paint.setColor(<span class="number">0xff00ff00</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (mRunning &amp;&amp; !Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">//先调用Surface的lockHardwareCanvas函数</span></span><br><span class="line">                <span class="keyword">final</span> Canvas canvas = mSurface.lockHardwareCanvas();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制</span></span><br><span class="line">                    canvas.drawColor(<span class="number">0x00000000</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">                    canvas.drawRect(x, y, x + <span class="number">20.0f</span>, y + <span class="number">20.0f</span>, paint);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//绘制完成后</span></span><br><span class="line">                    mSurface.unlockCanvasAndPost(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x + <span class="number">20.0f</span> + speedX &gt;= mWidth || x + speedX &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedX = -speedX;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (y + <span class="number">20.0f</span> + speedY &gt;= mHeight || y + speedY &lt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    speedY = -speedY;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                x += speedX;</span><br><span class="line">                y += speedY;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//每个15s循环一次</span></span><br><span class="line">                    Thread.sleep(<span class="number">15</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// Interrupted</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">stopRendering</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            interrupt();</span><br><span class="line">            mRunning = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Java层相关流程（frameworks-base的View模块和graphics模块）"><a href="#Java层相关流程（frameworks-base的View模块和graphics模块）" class="headerlink" title="Java层相关流程（frameworks/base的View模块和graphics模块）"></a>Java层相关流程（frameworks/base的View模块和graphics模块）</h3><ol><li>首先调用关键函数<code>lockHardwareCanvas</code>，在<code>frameworks/base/core/java/android/view/SurfaceView.java</code>：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/SurfaceView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Surface <span class="title">getSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSurface;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> internalLockCanvas(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Canvas <span class="title">internalLockCanvas</span><span class="params">(Rect dirty, <span class="keyword">boolean</span> hardware)</span> </span>&#123;</span><br><span class="line">        mSurfaceLock.lock();</span><br><span class="line">        Canvas c = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mDrawingStopped &amp;&amp; mSurfaceControl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hardware) &#123;</span><br><span class="line">                    <span class="comment">//hardware传递的是true，执行lockHardwareCanvas</span></span><br><span class="line">                    c = mSurface.lockHardwareCanvas();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = mSurface.lockCanvas(dirty);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(LOG_TAG, <span class="string">"Exception locking surface"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mLastLockTime = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mLastLockTime = now;</span><br><span class="line">        mSurfaceLock.unlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后就调用Surface.java的lockHardwareCanvas函数，此处封装了一个<code>HwuiContext</code>对象，构造函数如下：</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Canvas <span class="title">lockHardwareCanvas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"lockHardwareCanvas"</span>);</span><br><span class="line">      <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          checkNotReleasedLocked();</span><br><span class="line">          <span class="keyword">if</span> (mHwuiContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//Step 1 创建HwuiContext，调用构造函数</span></span><br><span class="line">              mHwuiContext = <span class="keyword">new</span> HwuiContext(<span class="keyword">false</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//Step 2 调用他的lockCanvas函数</span></span><br><span class="line">          <span class="keyword">return</span> mHwuiContext.lockCanvas(</span><br><span class="line">                  nativeGetWidth(mNativeObject),</span><br><span class="line">                  nativeGetHeight(mNativeObject));</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从上面调用到</span></span><br><span class="line">  <span class="function">Canvas <span class="title">lockCanvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (mCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Surface was already locked!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//调用RenderNode的beginRecording函数</span></span><br><span class="line">          mCanvas = mRenderNode.beginRecording(width, height);</span><br><span class="line">          <span class="keyword">return</span> mCanvas;</span><br><span class="line">      &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建RenderNode"><a href="#创建RenderNode" class="headerlink" title="创建RenderNode"></a>创建RenderNode</h3><blockquote><p>RenderNode用以绘图操纵的批处理，当绘制的时候，可以store和apply。java层的代码如下：其实RenderNode就对应前面我们所说的ViewGroup，有一个RootView，同样也有一个RootNode。</p></blockquote><ol><li>在上面Surface.java调用HwuiContext构造函数的时候，会创建RenderNode对象：</li></ol><figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建RenderNode和HwuiRender</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RenderNode mRenderNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mHwuiRenderer;</span><br><span class="line">    <span class="keyword">private</span> RecordingCanvas mCanvas;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mIsWideColorGamut;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    HwuiContext(<span class="keyword">boolean</span> isWideColorGamut) &#123;</span><br><span class="line">        <span class="comment">//创建一个RenderNode</span></span><br><span class="line">        mRenderNode = RenderNode.create(<span class="string">"HwuiCanvas"</span>, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><p>创建RenderNode对象：</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RenderNode <span class="title">create</span><span class="params">(String name, @Nullable AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RenderNode(name, animationHost);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RenderNode</span><span class="params">(String name, AnimationHost animationHost)</span> </span>&#123;</span><br><span class="line">    mNativeRenderNode = nCreate(name);</span><br><span class="line">    NoImagePreloadHolder.sRegistry.registerNativeAllocation(<span class="keyword">this</span>, mNativeRenderNode);</span><br><span class="line">    mAnimationHost = animationHost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>JNI层：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Regular JNI</span></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------------</span></span><br><span class="line">    &#123; <span class="string">"nCreate"</span>,               <span class="string">"(Ljava/lang/String;)J"</span>, (<span class="keyword">void</span>*) android_view_RenderNode_create &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetNativeFinalizer"</span>,   <span class="string">"()J"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_getNativeFinalizer &#125;,</span><br><span class="line">    &#123; <span class="string">"nOutput"</span>,               <span class="string">"(J)V"</span>,    (<span class="keyword">void</span>*) android_view_RenderNode_output &#125;,</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> jlong android_view_RenderNode_create(JNIEnv* env, jobject, jstring name) &#123;</span><br><span class="line">    <span class="comment">//创建一个native层的rendernode对象</span></span><br><span class="line">    RenderNode* renderNode = <span class="keyword">new</span> RenderNode();</span><br><span class="line">    renderNode-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (name != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* textArray = env-&gt;GetStringUTFChars(name, <span class="literal">NULL</span>);</span><br><span class="line">        renderNode-&gt;setName(textArray);</span><br><span class="line">        env-&gt;ReleaseStringUTFChars(name, textArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(renderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层，创建好RenderNode是提供给DisplayListCanvas。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RenderNode::RenderNode()</span><br><span class="line">        : mUniqueId(generateId())</span><br><span class="line">        , mDirtyPropertyFields(<span class="number">0</span>)</span><br><span class="line">        , mNeedsDisplayListSync(<span class="literal">false</span>)</span><br><span class="line">        , mDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mStagingDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mAnimatorManager(*<span class="keyword">this</span>)</span><br><span class="line">        , mParentCount(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="beginRecording初始化DisplayList"><a href="#beginRecording初始化DisplayList" class="headerlink" title="beginRecording初始化DisplayList"></a>beginRecording初始化DisplayList</h3><p><img src="beginRecording.jpg" alt="初始化DisplayList"></p><ol><li>在Surface.java中通过lockCanvas调用RenderNode对象的<code>beginRecording</code>函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">RecordingCanvas <span class="title">beginRecording</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (mCurrentRecordingCanvas != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                 <span class="string">"Recording currently in progress - missing #endRecording() call?"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     mCurrentRecordingCanvas = RecordingCanvas.obtain(<span class="keyword">this</span>, width, height);</span><br><span class="line">     <span class="keyword">return</span> mCurrentRecordingCanvas;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>接着调用RecordingCanvas的obtain函数：</p><p><strong>类的继承关系：</strong> RecordingCanvas类继承DisplayListCanvas，而DisplayListCanvas继承BaseRecordingCanvas，<br>BaseRecordingCanvas继承Canvas（继承BaseCanvas）。</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RecordingCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordingCanvas</span> <span class="keyword">extends</span> <span class="title">DisplayListCanvas</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">RecordingCanvas</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height));</span><br><span class="line">        mDensity = <span class="number">0</span>; <span class="comment">// disable bitmap density scaling</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RecordingCanvas <span class="title">obtain</span><span class="params">(@NonNull RenderNode node, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"node cannot be null"</span>);</span><br><span class="line">        RecordingCanvas canvas = sPool.acquire();</span><br><span class="line">        <span class="keyword">if</span> (canvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">            canvas = <span class="keyword">new</span> RecordingCanvas(node, width, height);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个native的DisplayListCanvas对象（即显示列表的Canvas）</span></span><br><span class="line">            <span class="comment">//JNI通过mNativeCanvasWrapper（BaseCanvas.java创建）找对应的Native的Canvas</span></span><br><span class="line">            nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode,</span><br><span class="line">                    width, height);</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.mNode = node;</span><br><span class="line">        canvas.mWidth = width;</span><br><span class="line">        canvas.mHeight = height;</span><br><span class="line">        <span class="keyword">return</span> canvas;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>查看测试案例代码中的<code>canvas.drawColor</code>和<code>canvas.drawRect</code>函数，是调用了其父类<code>BaseCanvas</code>的对应方法。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/Canvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorLong <span class="keyword">long</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawColor(color, BlendMode.SRC_OVER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull RectF rect, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.drawRect(rect, paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类<code>BaseCanvas.java</code>：</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层Canvas创建（JNI和HWUI模块）</li></ol><p>1.在上面RecordingCanvas.java的构造函数中调用了<code>nCreateDisplayListCanvas</code>函数，对饮的JNI实现：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_DisplayListCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> kClassPathName = <span class="string">"android/graphics/RecordingCanvas"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @FastNative ------------------</span></span><br><span class="line"></span><br><span class="line">    &#123; <span class="string">"nCallDrawGLFunction"</span>, <span class="string">"(JJLjava/lang/Runnable;)V"</span>,</span><br><span class="line">            (<span class="keyword">void</span>*) android_view_DisplayListCanvas_callDrawGLFunction &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------ @CriticalNative --------------</span></span><br><span class="line">    &#123; <span class="string">"nCreateDisplayListCanvas"</span>, <span class="string">"(JII)J"</span>,     (<span class="keyword">void</span>*) android_view_DisplayListCanvas_createDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nResetDisplayListCanvas"</span>,  <span class="string">"(JJII)V"</span>,    (<span class="keyword">void</span>*) android_view_DisplayListCanvas_resetDisplayListCanvas &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureWidth"</span>,  <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nGetMaximumTextureHeight"</span>, <span class="string">"()I"</span>,        (<span class="keyword">void</span>*) android_view_DisplayListCanvas_getMaxTextureSize &#125;,</span><br><span class="line">    &#123; <span class="string">"nInsertReorderBarrier"</span>,    <span class="string">"(JZ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_insertReorderBarrier &#125;,</span><br><span class="line">    &#123; <span class="string">"nFinishRecording"</span>,         <span class="string">"(J)J"</span>,       (<span class="keyword">void</span>*) android_view_DisplayListCanvas_finishRecording &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRenderNode"</span>,          <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRenderNode &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawTextureLayer"</span>,        <span class="string">"(JJ)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawTextureLayer &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawCircle"</span>,              <span class="string">"(JJJJJ)V"</span>,   (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawCircleProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawRoundRect"</span>,           <span class="string">"(JJJJJJJJ)V"</span>,(<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawRoundRectProps &#125;,</span><br><span class="line">    &#123; <span class="string">"nDrawWebViewFunctor"</span>,      <span class="string">"(JI)V"</span>,      (<span class="keyword">void</span>*) android_view_DisplayListCanvas_drawWebViewFunctor &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体实现，此处的renderNodePtr变量是RenderNode在native层的对象（地址）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_DisplayListCanvas_createDisplayListCanvas</span><span class="params">(jlong renderNodePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint width, jint height)</span> </span>&#123;</span><br><span class="line">    RenderNode* renderNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(renderNodePtr);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到frameworks/base/libs/hwui/hwui/Canvas.cpp，<strong>在Andorid Q中，此处只调用了<code>SkiaRecordingCanvas</code>函数。使用skia进行绘制。</strong></p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/hwui/Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Canvas* <span class="title">Canvas::create_recording_canvas</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, uirenderer::RenderNode* renderNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后初始化DisplayList：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">SkiaRecordingCanvas</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    initDisplayList(renderNode, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaRecordingCanvas::initDisplayList</span><span class="params">(uirenderer::RenderNode* renderNode, <span class="keyword">int</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    mCurrentBarrier = <span class="literal">nullptr</span>;</span><br><span class="line">    SkASSERT(mDisplayList.get() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (renderNode) &#123;</span><br><span class="line">        mDisplayList = renderNode-&gt;detachAvailableList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mDisplayList) &#123;</span><br><span class="line">        mDisplayList.reset(<span class="keyword">new</span> SkiaDisplayList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayList-&gt;attachRecorder(&amp;mRecorder, SkIRect::MakeWH(width, height));</span><br><span class="line">    SkiaCanvas::reset(&amp;mRecorder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Draw绘制操纵"><a href="#Draw绘制操纵" class="headerlink" title="Draw绘制操纵"></a>Draw绘制操纵</h3><blockquote><p>正常流程的绘制是在frameworks/base/core/java/android/view/ThreadedRenderer.java的<code>updateRootDisplayList</code>函数中。<br>调用到drawRnderNode函数绘制。</p></blockquote><ol><li>Java层：上面案例中的<code>drawColor</code>和<code>drawRect</code>实际调用的是在frameworks/base/graphics/java/android/graphics/BaseCanvas.java中：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/BaseCanvas.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawColor</span><span class="params">(@ColorInt <span class="keyword">int</span> color, @NonNull PorterDuff.Mode mode)</span> </span>&#123;</span><br><span class="line">      nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(@NonNull Rect r, @NonNull Paint paint)</span> </span>&#123;</span><br><span class="line">      throwIfHasHwBitmapInSwMode(paint);</span><br><span class="line">      drawRect(r.left, r.top, r.right, r.bottom, paint);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用JNI层在：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_graphics_Canvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gDrawMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JII)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColor&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawColor"</span>,<span class="string">"(JJJI)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawColorLong&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPaint"</span>,<span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPaint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoint"</span>, <span class="string">"(JFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoint&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawPoints"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawPoints&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLine"</span>, <span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLine&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawLines"</span>, <span class="string">"(J[FIIJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawLines&#125;,</span><br><span class="line">    &#123;<span class="string">"nDrawRect"</span>,<span class="string">"(JFFFFJ)V"</span>, (<span class="keyword">void</span>*) CanvasJNI::drawRect&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> drawColor(JNIEnv* env, jobject, jlong canvasHandle, jint color, jint modeHandle) &#123;</span><br><span class="line">    SkBlendMode mode = <span class="keyword">static_cast</span>&lt;SkBlendMode&gt;(modeHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawRect</span><span class="params">(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top,</span></span></span><br><span class="line"><span class="function"><span class="params">                     jfloat right, jfloat bottom, jlong paintHandle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Paint* paint = <span class="keyword">reinterpret_cast</span>&lt;Paint*&gt;(paintHandle);</span><br><span class="line">    get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Native层：因为<code>class SkiaCanvas : public Canvas</code>，所以调用到SkiaCanvas类中的具体实现：</li></ol><p>调用</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/SkiaCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawColor</span><span class="params">(<span class="keyword">int</span> color, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    mCanvas-&gt;drawColor(color, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkiaCanvas::drawRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(paint.nothingToDraw())) <span class="keyword">return</span>;</span><br><span class="line">    mCanvas-&gt;drawRect(&#123;left, top, right, bottom&#125;, *filterPaint(paint));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用到<code>external/skia</code>图形库模块：</li></ol><blockquote><p>Skia是Google一个底层的图形、图像、动画、SVG、文本等多方面的图形库，是Android中图形系统的引擎。Skia作为第三方软件放在目录：<code>external/skia/</code>。</p></blockquote><p>主要包含三个库：</p><ul><li>libcorecg.so: 包含<code>/skia/src/core</code>的部分内容，比如其中的<code>Region、Rect</code>是在SurfaceFlinger里面用来计算可视区域的；</li><li>libsgl.so: 包含<code>/skia/src/core|effects|images|ports|utils</code>的部分和全部内容，这个实现了skia大部分的图形效果，以及图形格式的编解码；</li><li>libskiagl.so: 包含<code>/skia/src/gl</code>里面的内容，主要用来调用opengl实现部分效果。</li></ul><figure class="highlight cpp"><figcaption><span>external/skia/src/core/SkCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawColor</span><span class="params">(SkColor c, SkBlendMode mode)</span> </span>&#123;</span><br><span class="line">    SkPaint paint;</span><br><span class="line">    paint.setColor(c);</span><br><span class="line">    paint.setBlendMode(mode);</span><br><span class="line">    <span class="keyword">this</span>-&gt;drawPaint(paint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SkCanvas::drawRect</span><span class="params">(<span class="keyword">const</span> SkRect&amp; r, <span class="keyword">const</span> SkPaint&amp; paint)</span> </span>&#123;</span><br><span class="line">    TRACE_EVENT0(<span class="string">"skia"</span>, TRACE_FUNC);</span><br><span class="line">    <span class="comment">// To avoid redundant logic in our culling code and various backends, we always sort rects</span></span><br><span class="line">    <span class="comment">// before passing them along.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;onDrawRect(r.makeSorted(), paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HwuiContext和HwuiRenderer"><a href="#HwuiContext和HwuiRenderer" class="headerlink" title="HwuiContext和HwuiRenderer"></a>HwuiContext和HwuiRenderer</h3><h4 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h4><p>从上面的Surface.java中看到，nHwuiCreate创建HwuiRenderer。</p><figure class="highlight java"><figcaption><span>Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个native的HwuiRender对象</span></span><br><span class="line">mHwuiRenderer = nHwuiCreate(mRenderNode.mNativeRenderNode, mNativeObject,</span><br><span class="line">        isWideColorGamut);</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure><h4 id="JNI层"><a href="#JNI层" class="headerlink" title="JNI层"></a>JNI层</h4><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gSurfaceMethods[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// HWUI context</span></span><br><span class="line">    &#123;<span class="string">"nHwuiCreate"</span>, <span class="string">"(JJZ)J"</span>, (<span class="keyword">void</span>*) hwui::create &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiSetSurface"</span>, <span class="string">"(JJ)V"</span>, (<span class="keyword">void</span>*) hwui::setSurface &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDraw"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::draw &#125;,</span><br><span class="line">    &#123;<span class="string">"nHwuiDestroy"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*) hwui::destroy &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//=========================================具体实现</span></span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android::uirenderer::renderthread;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">create</span><span class="params">(JNIEnv* env, jclass clazz, jlong rootNodePtr, jlong surfacePtr,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean isWideColorGamut)</span> </span>&#123;</span><br><span class="line">    RenderNode* rootNode = <span class="keyword">reinterpret_cast</span>&lt;RenderNode*&gt;(rootNodePtr);</span><br><span class="line">    <span class="function">sp&lt;Surface&gt; <span class="title">surface</span><span class="params">(<span class="keyword">reinterpret_cast</span>&lt;Surface*&gt;(surfacePtr))</span></span>;</span><br><span class="line">    ContextFactory factory;</span><br><span class="line">    <span class="comment">//创建一个RenderProxy对象，并作为返回对象</span></span><br><span class="line">    RenderProxy* proxy = <span class="keyword">new</span> RenderProxy(<span class="literal">false</span>, rootNode, &amp;factory);</span><br><span class="line">    proxy-&gt;loadSystemProperties();</span><br><span class="line">    <span class="keyword">if</span> (isWideColorGamut) &#123;</span><br><span class="line">        proxy-&gt;setWideGamut(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    proxy-&gt;setSwapBehavior(SwapBehavior::kSwap_discardBuffer);</span><br><span class="line">    proxy-&gt;setSurface(surface);</span><br><span class="line">    <span class="comment">// Shadows can't be used via this interface, so just set the light source</span></span><br><span class="line">    <span class="comment">// to all 0s.</span></span><br><span class="line">    proxy-&gt;setLightAlpha(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    proxy-&gt;setLightGeometry((Vector3)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> (jlong) proxy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><strong>以下流程部分是和通常的HWUI环境初始化流程相同的。</strong></p></blockquote><h4 id="native层：调用RenderProxy-cpp构造函数"><a href="#native层：调用RenderProxy-cpp构造函数" class="headerlink" title="*native层：调用RenderProxy.cpp构造函数"></a>*native层：调用RenderProxy.cpp构造函数</h4><p>该构造函数的几个重要成员变量：</p><ul><li>RenderProxy是一个代理者，严格的单线程。所有的方法都必须在自己的线程中调用。<code>MainThread通过这个代理对象想Task Queue发送drawFrame命令</code>；</li><li>RenderThread（即构造函数中的mRenderThread）：渲染线程，是一个单例，也就是说，一个进程中只有一个，所有的绘制操纵都必须在这个线程中完成。应用端很多操纵，都以RenderTask的形式post到RenderThread线程中完成。（在Android 5.0之后独立出来的应用程序的OpenGL线程）</li><li>CanvasContext（即构造函数中的mContext）：上下文，由于OpenGL是单线程的，所以，我们给到GPU的绘图命令都封装在各自的上下文中。这个和上层的HwuiRenderer是对应的。（将窗口绑定到Open GL渲染上下文中，从而使后面的渲染操作都是针对被绑定窗口的）</li><li>DrawFrameTask（即构造函数中的mDrawFrameTask）：一个用来执行渲染任务的task，MainThread通过他向RenderThread线程发送渲染下一帧的命令。（比较特殊的一个RenderTask，可重复使用的绘制Task。）</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="keyword">namespace</span> uirenderer &#123;</span><br><span class="line"><span class="keyword">namespace</span> renderthread &#123;</span><br><span class="line"></span><br><span class="line">RenderProxy::RenderProxy(<span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                         IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance()), mContext(<span class="literal">nullptr</span>) &#123;  <span class="comment">//Step1 创建RenderThread渲染线程</span></span><br><span class="line">    mContext = mRenderThread.<span class="built_in">queue</span>().runSync([&amp;]() -&gt; CanvasContext* &#123;</span><br><span class="line">        <span class="keyword">return</span> CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory); <span class="comment">//Step2 创建CanvasContext渲染上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h3 id="创建RenderThread渲染线程"><a href="#创建RenderThread渲染线程" class="headerlink" title="创建RenderThread渲染线程"></a>创建RenderThread渲染线程</h3><ol><li>从上面构造函数中的<code>RenderThread::getInstance()</code>调用下去。创建一个RenderThread线程。</li></ol><p>而该类的父类是ThreadBase.h，父类的父类是Thread.h</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RenderThread&amp; <span class="title">RenderThread::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This is a pointer because otherwise __cxa_finalize</span></span><br><span class="line">    <span class="comment">// will try to delete it like a Good Citizen but that causes us to crash</span></span><br><span class="line">    <span class="comment">// because we don't want to delete the RenderThread normally.</span></span><br><span class="line">    <span class="keyword">static</span> RenderThread* sInstance = <span class="keyword">new</span> RenderThread();</span><br><span class="line">    gHasRenderThreadInstance = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> *sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RenderThread::RenderThread()</span><br><span class="line">        : ThreadBase()</span><br><span class="line">        , mVsyncSource(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>)</span><br><span class="line">        , mFunctorManager(WebViewFunctorManager::instance())</span><br><span class="line">        , mVkManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    <span class="comment">//实现父类的函数，调用run</span></span><br><span class="line">    start(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>父类创建looper循环和start函数实现，然后开始线程循环：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/thread/ThreadBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadBase()</span><br><span class="line">        : Thread(<span class="literal">false</span>)</span><br><span class="line">        , mLooper(<span class="keyword">new</span> Looper(<span class="literal">false</span>))</span><br><span class="line">        , mQueue([<span class="keyword">this</span>]() &#123; mLooper-&gt;wake(); &#125;, mLock) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"ThreadBase"</span>)</span> </span>&#123; Thread::run(name); &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>开始线程循环，调用ThreadLoop开始工作。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        waitForWork();</span><br><span class="line">        processQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下流程会处理vsync信号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::initThreadLocals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setupFrameInterval();</span><br><span class="line">    initializeDisplayEventReceiver();</span><br><span class="line">    mEglManager = <span class="keyword">new</span> EglManager();</span><br><span class="line">    mRenderState = <span class="keyword">new</span> RenderState(*<span class="keyword">this</span>);</span><br><span class="line">    mVkManager = <span class="keyword">new</span> VulkanManager();</span><br><span class="line">    mCacheManager = <span class="keyword">new</span> CacheManager(DeviceInfo::get()-&gt;displayInfo());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::initializeDisplayEventReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Properties::isolatedProcess) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Register the FD</span></span><br><span class="line">        mLooper-&gt;addFd(receiver-&gt;getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">                       RenderThread::displayEventReceiverCallback, <span class="keyword">this</span>);</span><br><span class="line">        mVsyncSource = <span class="keyword">new</span> DisplayEventReceiverWrapper(<span class="built_in">std</span>::move(receiver), [<span class="keyword">this</span>] &#123;</span><br><span class="line">            DeviceInfo::get()-&gt;onDisplayConfigChanged();</span><br><span class="line">            setupFrameInterval();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVsyncSource = <span class="keyword">new</span> DummyVsyncSource(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderThread::displayEventReceiverCallback</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">reinterpret_cast</span>&lt;RenderThread*&gt;(data)-&gt;drainDisplayEventQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderThread::drainDisplayEventQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncEvent = mVsyncSource-&gt;latestVsyncEvent();</span><br><span class="line">    <span class="keyword">if</span> (vsyncEvent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mVsyncRequested = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTimeLord.vsyncReceived(vsyncEvent) &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            ATRACE_NAME(<span class="string">"queue mFrameCallbackTask"</span>);</span><br><span class="line">            mFrameCallbackTaskPending = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">nsecs_t</span> runAt = (vsyncEvent + mDispatchFrameDelay);</span><br><span class="line">            <span class="built_in">queue</span>().postAt(runAt, [<span class="keyword">this</span>]() &#123; dispatchFrameCallbacks(); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="CanvasContext渲染上下文"><a href="#CanvasContext渲染上下文" class="headerlink" title="CanvasContext渲染上下文"></a>CanvasContext渲染上下文</h3><p>该函数中会选择渲染绘制方式（渲染管线）。在Android Q中取消了OpenGL渲染。</p><ul><li>Android P之前：<code>enum class RenderPipelineType { OpenGL = 0, SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li><li>Android Q：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CanvasContext* <span class="title">CanvasContext::create</span><span class="params">(RenderThread&amp; thread, <span class="keyword">bool</span> translucent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RenderNode* rootRenderNode, IContextFactory* contextFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取渲染方式getRenderPipelineType</span></span><br><span class="line">    <span class="keyword">auto</span> renderType = Properties::getRenderPipelineType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (renderType) &#123;</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaGL:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">case</span> RenderPipelineType::SkiaVulkan:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(thread, translucent, rootRenderNode, contextFactory,</span><br><span class="line">                                     <span class="built_in">std</span>::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread));</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"canvas context type %d not supported"</span>, (<span class="keyword">int32_t</span>)renderType);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::getRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sRenderPipelineType = peekRenderPipelineType();</span><br><span class="line">    <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RenderPipelineType <span class="title">Properties::peekRenderPipelineType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If sRenderPipelineType has been locked, just return the locked type immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (sRenderPipelineType != RenderPipelineType::NotInitialized) &#123;</span><br><span class="line">        <span class="keyword">return</span> sRenderPipelineType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> useVulkan = use_vulkan().value_or(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">//PROPERTY_RENDERER "debug.hwui.renderer"</span></span><br><span class="line">    <span class="comment">//enum class RenderPipelineType &#123; SkiaGL, SkiaVulkan, NotInitialized = 128 &#125;;</span></span><br><span class="line">    property_get(PROPERTY_RENDERER, prop, useVulkan ? <span class="string">"skiavk"</span> : <span class="string">"skiagl"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(prop, <span class="string">"skiavk"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> RenderPipelineType::SkiaVulkan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> RenderPipelineType::SkiaGL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>mRenderPipeline有几种类型，创建CanvasContext时（<code>create函数</code>），会根据pipeline的类型，创建对应的Pipeline。（即调用<code>getRenderPipelineType函数</code>）</p></blockquote><ul><li>渲染类型：<code>enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 };</code></li></ul><hr><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">CanvasContext::CanvasContext(RenderThread&amp; thread, <span class="keyword">bool</span> translucent, RenderNode* rootRenderNode,</span><br><span class="line">                             IContextFactory* contextFactory,</span><br><span class="line">                             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;IRenderPipeline&gt; renderPipeline)</span><br><span class="line">        : mRenderThread(thread)</span><br><span class="line">        , mGenerationID(<span class="number">0</span>)</span><br><span class="line">        , mOpaque(!translucent)</span><br><span class="line">        , mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</span><br><span class="line">        , mJankTracker(&amp;thread.globalProfileData(), DeviceInfo::get()-&gt;displayInfo())</span><br><span class="line">        , mProfiler(mJankTracker.frames(), thread.timeLord().frameIntervalNanos())</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mRenderPipeline(<span class="built_in">std</span>::move(renderPipeline)) &#123;</span><br><span class="line">    rootRenderNode-&gt;makeRoot();</span><br><span class="line">    mRenderNodes.emplace_back(rootRenderNode);  <span class="comment">//是前面创建的RenderNode</span></span><br><span class="line">    mProfiler.setDensity(DeviceInfo::get()-&gt;displayInfo().density);</span><br><span class="line">    setRenderAheadDepth(Properties::defaultRenderAhead);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面调用nHwuiCreate的JNI层，会创建ContextFactory，然后在此处的构造函数中会使用到。主要用来创建AnimationContext，即<code>mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord()))</code></p><p>AnimationContext主要用来处理动画Animation。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/jni/android_view_Surface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextFactory</span> :</span> <span class="keyword">public</span> IContextFactory &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AnimationContext* <span class="title">createAnimationContext</span><span class="params">(renderthread::TimeLord&amp; clock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AnimationContext(clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>CanvasContext实现了IFrameCallback接口，所以，CanvasContext能接收编舞者Choreographer的callback，处理实时动画。<code>class CanvasContext : public IFrameCallback {...}</code></li></ul><h4 id="RenderThread渲染线程"><a href="#RenderThread渲染线程" class="headerlink" title="RenderThread渲染线程"></a>RenderThread渲染线程</h4><blockquote><p><strong>RenderThread渲染运行模型</strong>:空闲的时候, RenderThread睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnceh中。当其他线程需要调度RenderThread, 会向他的任务队列添加一个任务, 然后唤醒RenderThread进行处理。RenderThread通过<code>processQueue</code>方法处理任务。</p></blockquote><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承ThreadBase，而ThreadBase是继承基类Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderThread</span> :</span> <span class="keyword">private</span> ThreadBase &#123;</span><br><span class="line">    <span class="comment">//组织拷贝构造函数和重载</span></span><br><span class="line">    PREVENT_COPY_AND_ASSIGN(RenderThread);</span><br></pre></td></tr></table></figure><ol><li>调用构造函数中，同时启动了渲染线程RenderThread：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderThread.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RenderThread::RenderThread()</span><br><span class="line">        : ThreadBase()</span><br><span class="line">        , mVsyncSource(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>)</span><br><span class="line">        , mFunctorManager(WebViewFunctorManager::instance())</span><br><span class="line">        , mVkManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    start(<span class="string">"RenderThread"</span>); <span class="comment">//线程启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看父类的构造函数：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/thread/ThreadBase.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadBase()</span><br><span class="line">        : Thread(<span class="literal">false</span>)</span><br><span class="line">        , mLooper(<span class="keyword">new</span> Looper(<span class="literal">false</span>))</span><br><span class="line">        , mQueue([<span class="keyword">this</span>]() &#123;</span><br><span class="line">             mLooper-&gt;wake();  <span class="comment">//此处调用是唤醒mLooper，线程开始工作</span></span><br><span class="line">        &#125;, mLock) &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在渲染线程启动后，会调用RenderThread.cpp的threadLoop函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RenderThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_DISPLAY);</span><br><span class="line">    Looper::setForThread(mLooper);</span><br><span class="line">    <span class="keyword">if</span> (gOnStartHook) &#123;</span><br><span class="line">        gOnStartHook(<span class="string">"RenderThread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化Thread的本地变量</span></span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//没有任务就等在此处</span></span><br><span class="line">        waitForWork();</span><br><span class="line">        processQueue();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(),</span><br><span class="line">                                   mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Clean this up. This is working around an issue where a combination</span></span><br><span class="line">            <span class="comment">// of bad timing and slow drawing can result in dropping a stale vsync</span></span><br><span class="line">            <span class="comment">// on the floor (correct!) but fails to schedule to listen for the</span></span><br><span class="line">            <span class="comment">// next vsync (oops), so none of the callbacks are run.</span></span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="DrawFrameTask构造函数"><a href="#DrawFrameTask构造函数" class="headerlink" title="DrawFrameTask构造函数"></a>DrawFrameTask构造函数</h4><p>在<code>RenderProxy</code>调用构造函数时，会创建DrawFrameTask，同时调用其<code>setContext</code>函数：</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DrawFrameTask::DrawFrameTask()</span><br><span class="line">        : mRenderThread(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContext(<span class="literal">nullptr</span>)</span><br><span class="line">        , mContentDrawBounds(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        , mSyncResult(SyncResult::OK) &#123;&#125;</span><br><span class="line"></span><br><span class="line">DrawFrameTask::~DrawFrameTask() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::setContext</span><span class="params">(RenderThread* thread, CanvasContext* context,</span></span></span><br><span class="line"><span class="function"><span class="params">                               RenderNode* targetNode)</span> </span>&#123;</span><br><span class="line">    mRenderThread = thread;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mTargetNode = targetNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="syncAndDrawFrame绘制帧"><a href="#syncAndDrawFrame绘制帧" class="headerlink" title="syncAndDrawFrame绘制帧"></a>syncAndDrawFrame绘制帧</h3><ol><li>从上面的分析看，DisplayList和RenderThread都创建好了，正常绘制的时候会调用到<code>syncAndDrawFrame</code>：</li></ol><p>从ViewRootImpl的performDraw函数调用到draw，在调用到 ThreadedRenderer.java的draw函数。开始绘制：</p><figure class="highlight java"><figcaption><span>ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">      choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">      <span class="comment">//绘制每个视图的内容（在文章下面会梳理）</span></span><br><span class="line">      updateRootDisplayList(view, callbacks);</span><br><span class="line">      <span class="comment">//绘制一帧的内容</span></span><br><span class="line">      <span class="keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/RenderProxy.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RenderProxy::syncAndDrawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDrawFrameTask.drawFrame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DrawFrameTask::drawFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!mContext, <span class="string">"Cannot drawFrame with no CanvasContext!"</span>);</span><br><span class="line"></span><br><span class="line">    mSyncResult = SyncResult::OK;</span><br><span class="line">    mSyncQueued = systemTime(CLOCK_MONOTONIC);</span><br><span class="line">    postAndWait();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mSyncResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::postAndWait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mRenderThread-&gt;<span class="built_in">queue</span>().post([<span class="keyword">this</span>]() &#123; run(); &#125;); <span class="comment">//执行此处的run函数</span></span><br><span class="line">    mSignal.wait(mLock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>此时，drawFrame，也就通过RenderThread，post一个WorkItem到RenderThread的队列里面，在RenderThread线程中执行的。</li></ol><p>然后RenderThread处理Queue时，执行的会是DrawFrameTask的run函数。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawFrameTask::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//info，即描述Viewtree的，也就是RenderNode tree</span></span><br><span class="line">        <span class="comment">//此处的mode是MODE_FULL，即只有primary的node是FULL，其他都是实时 **</span></span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        <span class="comment">//同步Frame帧状态</span></span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        <span class="comment">//判断是否可以绘制这一帧</span></span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFrameCompleteCallback) &#123;</span><br><span class="line">            mContext-&gt;addFrameCompleteListener(<span class="built_in">std</span>::move(mFrameCompleteCallback));</span><br><span class="line">            mFrameCompleteCallback = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int64_t</span>)&gt; callback = <span class="built_in">std</span>::move(mFrameCallback);</span><br><span class="line">    mFrameCallback = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        <span class="comment">//**绘制</span></span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步Frame的State</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DrawFrameTask::syncFrameState</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int64_t</span> vsync = mFrameInfo[<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(FrameInfoIndex::Vsync)];</span><br><span class="line">    mRenderThread-&gt;timeLord().vsyncReceived(vsync);</span><br><span class="line">    <span class="comment">//通知GPU处理当前的Context上下文</span></span><br><span class="line">    <span class="keyword">bool</span> canDraw = mContext-&gt;makeCurrent();</span><br><span class="line">    <span class="comment">//hwui为了提高速度，对各种object都做了cache，此处unpin，就是让cache去做unpin，其他都不要了</span></span><br><span class="line">    mContext-&gt;unpinImages();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mLayers.size(); i++) &#123;</span><br><span class="line">        mLayers[i]-&gt;apply();</span><br><span class="line">    &#125;</span><br><span class="line">    mLayers.clear();</span><br><span class="line">    <span class="comment">//设置绘制的区域大小</span></span><br><span class="line">    mContext-&gt;setContentDrawBounds(mContentDrawBounds);</span><br><span class="line">    <span class="comment">//**Android View是树型结构的，这就是在绘制之前，去准备这些Tree节点的绘图操作</span></span><br><span class="line">    <span class="comment">//准备绘制一帧的数据</span></span><br><span class="line">    mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is after the prepareTree so that any pending operations</span></span><br><span class="line">    <span class="comment">// (RenderNode tree state, prefetched layers, etc...) will be flushed.</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mContext-&gt;hasSurface()) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::LostSurfaceRewardIfFound;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If we have a surface but can't draw we must be stopped</span></span><br><span class="line">            mSyncResult |= SyncResult::ContextIsStopped;</span><br><span class="line">        &#125;</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.out.hasAnimations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (info.out.requiresUiRedraw) &#123;</span><br><span class="line">            mSyncResult |= SyncResult::UIRedrawRequired;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!info.out.canDrawThisFrame) &#123;</span><br><span class="line">        mSyncResult |= SyncResult::FrameDropped;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If prepareTextures is false, we ran out of texture cache space</span></span><br><span class="line">    <span class="keyword">return</span> info.prepareTextures;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="prepareTree"><a href="#prepareTree" class="headerlink" title="prepareTree"></a>prepareTree</h4><ol><li>调用函数<strong>prepareTree</strong>：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::prepareTree</span><span class="params">(TreeInfo&amp; info, <span class="keyword">int64_t</span>* uiFrameInfo, <span class="keyword">int64_t</span> syncQueued,</span></span></span><br><span class="line"><span class="function"><span class="params">                                RenderNode* target)</span> </span>&#123;</span><br><span class="line">    mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">    mAnimationContext-&gt;startFrame(info.mode);</span><br><span class="line">    mRenderPipeline-&gt;onPrepareTree();</span><br><span class="line">    <span class="comment">//Context可能会有多个Node</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        <span class="comment">//即只有Primary的node是 FULL，其他都是实时</span></span><br><span class="line">        info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY);</span><br><span class="line">        <span class="comment">//此处遍历，对每个RenderNode都进行prepare</span></span><br><span class="line">        node-&gt;prepareTree(info);</span><br><span class="line">        GL_CHECKPOINT(MODERATE);</span><br><span class="line">    &#125;</span><br><span class="line">    mAnimationContext-&gt;runRemainingAnimations(info);</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    freePrefetchedLayers();</span><br><span class="line">    GL_CHECKPOINT(MODERATE);</span><br><span class="line"></span><br><span class="line">    mIsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果窗口已经没有Native Surface，这一帧就丢掉！！</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(!hasSurface())) &#123;</span><br><span class="line">        mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame);</span><br><span class="line">        info.out.canDrawThisFrame = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">                                &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>遍历RenderNode的prepareTree方法：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTree</span><span class="params">(TreeInfo&amp; info)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(!info.damageAccumulator, <span class="string">"DamageAccumulator missing"</span>);</span><br><span class="line">    <span class="function">MarkAndSweepRemoved <span class="title">observer</span><span class="params">(&amp;info)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> before = info.disableForceDark;</span><br><span class="line">    <span class="comment">//具体实现</span></span><br><span class="line">    prepareTreeImpl(observer, info, <span class="literal">false</span>);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(before != info.disableForceDark, <span class="string">"Mis-matched force dark"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>prepareTreeImpl是RenderNode真正进行Prepare的地方。</li></ol><p>damageAccumulator是从CanvasContext中传过来的，是CanvasContext的成员，damage的叠加器。主要是用来标记，屏幕的那些区域被破坏了，需要重新绘制，所有的RenderNode累加起来，就是总的。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::prepareTreeImpl</span><span class="params">(TreeObserver&amp; observer, TreeInfo&amp; info, <span class="keyword">bool</span> functorsNeedLayer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDamageGenerationId == info.damageGenerationId) &#123;</span><br><span class="line">        info.damageAccumulator-&gt;dirty(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Step 1</span></span><br><span class="line">    info.damageAccumulator-&gt;pushTransform(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.mode == TreeInfo::MODE_FULL) &#123;</span><br><span class="line">        <span class="comment">//property是对RenderNode的描述，也就是对View的描述，比如大小，位置等。</span></span><br><span class="line">        <span class="comment">//有两个状态，正在使用的syncProperties和待处理的mStagingProperties。</span></span><br><span class="line">        <span class="comment">//syncProperties时，将mStagingProperties赋值给syncProperties</span></span><br><span class="line">        pushStagingPropertiesChanges(info);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    pushLayerUpdate(info);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mProperties.getAllowForceDark()) &#123;</span><br><span class="line">        info.disableForceDark--;</span><br><span class="line">    &#125;</span><br><span class="line">    info.damageAccumulator-&gt;popTransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用pushTransform函数，damage累加器中，每一个元素由DirtyStack描述，分两种类型：TransformMatrix4和TransformRenderNode。采用一个双向链表mHead进行管理。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/DamageAccumulator.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHead-&gt;next) &#123;</span><br><span class="line">        DirtyStack* nextFrame = mAllocator.create_trivial&lt;DirtyStack&gt;();</span><br><span class="line">        nextFrame-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        nextFrame-&gt;prev = mHead;</span><br><span class="line">        mHead-&gt;next = nextFrame;</span><br><span class="line">    &#125;</span><br><span class="line">    mHead = mHead-&gt;next;</span><br><span class="line">    mHead-&gt;pendingDirty.setEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DamageAccumulator::pushTransform</span><span class="params">(<span class="keyword">const</span> RenderNode* transform)</span> </span>&#123;</span><br><span class="line">    pushCommon();</span><br><span class="line">    mHead-&gt;type = TransformRenderNode;</span><br><span class="line">    mHead-&gt;renderNode = transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时prepare完成后，绘制一帧的数据就准备好了。</p><hr><h3 id="绘制帧数据"><a href="#绘制帧数据" class="headerlink" title="绘制帧数据"></a>绘制帧数据</h3><ol><li>从<code>syncAndDrawFrame绘制帧</code>上面的章节，此处会调用到HardwareRenderer.java父类函数；</li><li>然后JNI到Native层，调用到RenderProxy.cpp的该函数，</li><li>再到<code>frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp</code>的drawFrame函数，开始绘制一帧数据，</li><li>此时启动RenderThread线程的run函数，调用到关键函数<code>CanvasContext::draw()</code></li></ol><p>Android Q中，具体绘制是在各自的pipeline中进行的。（在<code>frameworks/base/libs/hwui/pipeline/</code>）</p><p>在Android P中，一般是执行的<code>frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp</code></p><p>在Android Q中，可以看出Google在慢慢用Vulkan替代OpenGL。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/renderthread/CanvasContext.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CanvasContext::draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line">    <span class="comment">//跳过绘制条件：脏区域为空、空帧数据、不需要重绘</span></span><br><span class="line">    <span class="keyword">if</span> (dirty.isEmpty() &amp;&amp; Properties::skipEmptyFrames &amp;&amp; !surfaceRequiresRedraw()) &#123;</span><br><span class="line">        mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">    mCurrentFrameInfo-&gt;markIssueDrawCommandsStart();</span><br><span class="line">    <span class="comment">//获取frame(一帧数据信息，主要是狂傲、ufferAge、Surface等)</span></span><br><span class="line">    Frame frame = mRenderPipeline-&gt;getFrame();</span><br><span class="line">    setPresentTime();</span><br><span class="line"></span><br><span class="line">    SkRect windowDirty = computeDirtyRect(frame, &amp;dirty);</span><br><span class="line">    <span class="comment">//绘制</span></span><br><span class="line">    <span class="keyword">bool</span> drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue,</span><br><span class="line">                                      mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes,</span><br><span class="line">                                      &amp;(profiler()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> frameCompleteNr = mFrameCompleteCallbacks.size() ? getFrameNumber() : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    waitOnFences();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> requireSwap = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//绘制完成后调用</span></span><br><span class="line">    <span class="keyword">bool</span> didSwap =</span><br><span class="line">            mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制完成后unlockCanvasAndPost流程"><a href="#绘制完成后unlockCanvasAndPost流程" class="headerlink" title="绘制完成后unlockCanvasAndPost流程"></a>绘制完成后unlockCanvasAndPost流程</h3><p>回到绘制案例，此时，RenderThread，DrawFrameTask，CanvasContext等已经就绪，绘制操纵已经被添加到了DisplayList中。</p><ol><li>绘制完成，然后会在<code>frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java</code>中调用到<code>方法unlockCanvasAndPost</code>。</li></ol><p>SurfaceHolder直接调的Surface的unlockCanvasAndPost。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            checkNotReleasedLocked();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHwuiContext != null) &#123;</span><br><span class="line">                <span class="comment">//硬件加速执行此处</span></span><br><span class="line">                mHwuiContext.unlockAndPost(canvas);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//软件绘制</span></span><br><span class="line">                unlockSwCanvasAndPost(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HwuiContext</span> &#123;</span></span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">//HwuiContext的unlockAndPost函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unlockAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (canvas != mCanvas) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"canvas object must be the same instance that "</span></span><br><span class="line">                        + <span class="string">"was previously returned by lockCanvas"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRenderNode.endRecording();</span><br><span class="line">            mCanvas = null;</span><br><span class="line">            nHwuiDraw(mHwuiRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>上面代码看到，在lockHardwareCanvas的时候有相同流程，会调用<code>mRenderNode.beginRecording</code>。</li></ol><p>此处就对应的调用到<code>mRenderNode.endRecording();</code>，结束RenderNode，保存数据。</p><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/RenderNode.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mCurrentRecordingCanvas == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                   <span class="string">"No recording in progress, forgot to call #beginRecording()?"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       RecordingCanvas canvas = mCurrentRecordingCanvas;</span><br><span class="line">       mCurrentRecordingCanvas = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//Step1 先结束Canvas的录制</span></span><br><span class="line">       <span class="keyword">long</span> displayList = canvas.finishRecording();</span><br><span class="line">       <span class="comment">//Step2 然后将录制的list给mNativeRenderNode</span></span><br><span class="line">       nSetDisplayList(mNativeRenderNode, displayList);</span><br><span class="line">       canvas.recycle();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>首先finishRecording函数通过JIN层<code>android_view_DisplayListCanvas.cpp</code>调用到Native层。</li></ol><p>返回录制好的mDisplayList。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uirenderer::DisplayList* <span class="title">SkiaRecordingCanvas::finishRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// close any existing chunks if necessary</span></span><br><span class="line">    insertReorderBarrier(<span class="literal">false</span>);</span><br><span class="line">    mRecorder.restoreToCount(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> mDisplayList.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>第二步的nSetDisplayList通过JNI层<code>android_view_RenderNode.cpp</code>调用到Native层。</li></ol><p>将displayList给到RenderNode的mStagingDisplayList。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/libs/hwui/RenderNode.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderNode::setStagingDisplayList</span><span class="params">(DisplayList* displayList)</span> </span>&#123;</span><br><span class="line">    mValid = (displayList != <span class="literal">nullptr</span>);</span><br><span class="line">    mNeedsDisplayListSync = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">delete</span> mStagingDisplayList;</span><br><span class="line">    mStagingDisplayList = displayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Activity-HWUI渲染环境初始化流程（RenderThreadc创建）"><a href="#Activity-HWUI渲染环境初始化流程（RenderThreadc创建）" class="headerlink" title="Activity HWUI渲染环境初始化流程（RenderThreadc创建）"></a>Activity HWUI渲染环境初始化流程（RenderThreadc创建）</h2><blockquote><p>主要是通过setView创建rendernode，渲染线程RenderThread，Context上下文，RenderProxy代理对象等。</p></blockquote><h3 id="附序列图"><a href="#附序列图" class="headerlink" title="附序列图"></a>附序列图</h3><p><img src="HWUI_Initialize_RenderThreadCreate.png" alt="Android HWUI环境初始化 - 创建RenderThread"></p><h3 id="Java层-1"><a href="#Java层-1" class="headerlink" title="Java层"></a>Java层</h3><ol><li>Activity.java开始设置view：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/app/Activity.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Window <span class="title">getWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mWindow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        getWindow().setContentView(view);</span><br><span class="line">        initWindowDecorActionBar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>PhoneWindow继承Window抽象类调用setContentView函数：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneWindow</span> <span class="keyword">extends</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">MenuBuilder</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新对象ViewGroup</span></span><br><span class="line">        setContentView(view, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            view.setLayoutParams(params);</span><br><span class="line">            <span class="keyword">final</span> Scene newScene = <span class="keyword">new</span> Scene(mContentParent, view);</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//调用此处添加一个view到Parent View中</span></span><br><span class="line">            mContentParent.addView(view, params);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的<code>mContentParent.addView(view, params);</code>，mContentParent是ViewGroup类型对象。</p><p>ViewGroup实现接口ViewManager，而<code>interface WindowManager extends ViewManager</code>，WindowManagerImpl.java又是接口WindowManager的实现类。所以会同时调用WindowManagerImpl类的addView函数。</p><ol start="3"><li>WindowManagerImpl.java调用addView函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用windowManagerGlobal的addView函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用ViewRootImpl的setView函数</span></span><br><span class="line">            root.setView(view, wparams, panelParentView);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>ViewRootImpl.java中调用流程：</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * We have one child</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//设置根节点视图（顶层视图）</span></span><br><span class="line">            mView = view;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// While this is supposed to enable only, it can effectively disable</span></span><br><span class="line">                <span class="comment">// the acceleration too.</span></span><br><span class="line">                <span class="comment">//启动硬件加速！</span></span><br><span class="line">                enableHardwareAcceleration(attrs);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                    <span class="comment">// Shouldn't be resizing, as it's done only in window setup,</span></span><br><span class="line">                    <span class="comment">// but end just in case.</span></span><br><span class="line">                    endDragResizing();</span><br><span class="line">                    mUseMTRenderer = useMTRenderer;</span><br><span class="line">            ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent,</span><br><span class="line">                    attrs.getTitle().toString());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在ThreadedRenderer的create函数中new了一个该对象，从而调用其构造函数。构造函数的<code>super()</code>调用基类HardwareRenderer的构造函数。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/graphics/java/android/graphics/HardwareRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new instance of a HardwareRenderer. The HardwareRenderer will default</span></span><br><span class="line"><span class="comment"> * to opaque with no light source configured.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//创建硬件渲染rendernode对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HardwareRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个窗口的Root Render Node，并用Java层的RenderNode封装起来，即adopt通过new对象返回一个java层的RenderNode对象</span></span><br><span class="line">    mRootNode = RenderNode.adopt(nCreateRootRenderNode());</span><br><span class="line">    mRootNode.setClipToBounds(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//调用到JNI层，创建一个RenderProxy（即MainThread的代理对象）</span></span><br><span class="line">    mNativeProxy = nCreateProxy(!mOpaque, mRootNode.mNativeRenderNode);</span><br><span class="line">    <span class="keyword">if</span> (mNativeProxy == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Unable to create hardware renderer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> DestroyContextRunnable(mNativeProxy));</span><br><span class="line">    ProcessInitializer.sInstance.init(mNativeProxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h3><ol><li>从上面的nCreateRootRenderNode函数调用到JNI层的android_view_ThreadedRenderer.cpp文件中。</li></ol><p>创建一个窗口的Root Render Node。</p><p>之后创建RenderProxy对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = <span class="keyword">reinterpret_cast</span>&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="comment">//new对象</span></span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>之后调用RenderProxy构造函数，就同上面Google原生绘制案例的流程分析相同<code>RenderProxy::RenderProxy(){...}</code>，负责从MainThread向RenderThread发送命令。</li></ol><p><strong>参考上面的<code>native层：调用RenderProxy.cpp构造函数</code>和<code>CanvasContext渲染上下文</code>章节</strong></p><h3 id="ThreadedRenderer架构图"><a href="#ThreadedRenderer架构图" class="headerlink" title="ThreadedRenderer架构图"></a>ThreadedRenderer架构图</h3><p><img src="ThreadedRenderer.jpg" alt="ThreadedRenderer和底层结构关系"></p><hr><h2 id="Activity-窗口绘制流程"><a href="#Activity-窗口绘制流程" class="headerlink" title="Activity 窗口绘制流程"></a>Activity 窗口绘制流程</h2><blockquote><p>由ViewRootImpl的成员函数<code>performTraversals</code>发起。</p></blockquote><ol><li>在绘制之前，首先需要创建一个Surface，即描述一个窗口（创建Surface的流程后续单独整理）</li><li>一旦获得对应的Surface， 就需要将其绑定到RenderThread中。</li><li>Activity窗口对应的Surface是通过ViewRootImpl类的成员函数<code>relayoutWindow</code>向WindowManagerService服务请求创建和返回的，并且保存在ViewRootImpl类的成员变量mSurface中。</li><li>如果Surface是新创建的，将调用ViewRootImpl类的成员变量mAttachInfo指向的AttachInfo函数。对象的成员变量mHardwareRenderer描述的一个HardwareRenderer对象的成员函数<code>initialize</code>将它绑定到RenderThread中。</li><li>最后, 如果需要绘制当前的Activity窗口, 那会调用 iewRootImpl类的另外一个成员函数<code>performDraw</code></li></ol><blockquote><p>此处在performTraversals函数中，先是用relayoutWindow创建mSurface，将Native层之前通过构造函数创建的Surface copy过来。<br>而后是三个主要流程：performMeasure测量、performLayout布局、performDraw绘制</p></blockquote><h3 id="绘制序列图"><a href="#绘制序列图" class="headerlink" title="绘制序列图"></a>绘制序列图</h3><p><img src="%E7%A1%AC%E4%BB%B6%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F%E5%9B%BE.png" alt="Android HWUI窗口绘制"></p><h3 id="ViewRootImpl中的软-硬件绘制区分"><a href="#ViewRootImpl中的软-硬件绘制区分" class="headerlink" title="ViewRootImpl中的软/硬件绘制区分"></a>ViewRootImpl中的软/硬件绘制区分</h3><p>在ViewRootImpl.java的draw函数中：</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">        Surface surface = mSurface;</span><br><span class="line">        <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Draw with hardware renderer.</span></span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mThreadedRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//硬件加速</span></span><br><span class="line">        mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">                <span class="comment">//软件绘制</span></span><br><span class="line">                <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                        scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">                        Log.v(mTag, <span class="string">"drawSoftware return: this = "</span> + <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>drawSoftware中会调用到Surface.java的<code>lockCanvas</code>和<code>unlockCanvasAndPost</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/Surface.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">/// M: add for white list @&#123;</span></span><br><span class="line">            <span class="comment">//如果在白名单，则返回，仍使用硬件绘制</span></span><br><span class="line">            <span class="keyword">if</span> (mSurfaceExt.isInWhiteList()) &#123;</span><br><span class="line">                <span class="keyword">return</span> lockHardwareCanvas();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/// @&#125;</span></span><br><span class="line">            ...</span><br><span class="line">            mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">            <span class="keyword">return</span> mCanvas;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlockSwCanvasAndPost</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            nativeUnlockCanvasAndPost(mLockedObject, canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            nativeRelease(mLockedObject);</span><br><span class="line">            mLockedObject = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="初始化DisplayList"><a href="#初始化DisplayList" class="headerlink" title="初始化DisplayList"></a>初始化DisplayList</h3><ol><li>updateRootDisplayList方法的作用是先初始化DIsplayList（即调用<code>beginRecording</code>，流程同上面案例中的分析），然后绘制整个树型视图结构，从顶层视图开始，每个视图节点逐一绘制，最终目的是触发每个视图的<code>Canvas#draw***</code>方法。</li><li><code>syncAndDrawFrame</code>查看上面章节<code>绘制准备，同步帧</code></li></ol><p>updateRootDisplayList方法分成两步：</p><ol><li>先顶层视图结构遍历绘制，更新DisplayList数据，</li><li>第二步是ThreadedRenderer的根RenderNode绘制，同样，通过根RenderNode创建DisplayListCanvas，通过它的drawRenderNode方法，负责绘制顶层视图DecorView的RenderNode节点。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(View view, AttachInfo attachInfo, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer;</span><br><span class="line">        choreographer.mFrameInfo.markDrawStart();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        updateRootDisplayList(view, callbacks);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//同步帧数据，最终目的OpenGL指令写入gpu</span></span><br><span class="line">        <span class="keyword">int</span> syncResult = syncAndDrawFrame(choreographer.mFrameInfo);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, DrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Step1 初始化DisplayList，从顶层视图开始，更新所有视图的DisplayList</span></span><br><span class="line">        updateViewTreeDisplayList(view);</span><br><span class="line">        <span class="comment">//Step2 根节点绘制顶层视图RenderNode</span></span><br><span class="line">        <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123;</span><br><span class="line">            <span class="comment">//参考上面目录`beginRecording创建DisplayList`小节</span></span><br><span class="line">            RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">                canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">                callbacks.onPreDraw(canvas);</span><br><span class="line"></span><br><span class="line">                canvas.enableZ();</span><br><span class="line">                <span class="comment">//此处还会调用一次根View的updateDisplayListIfDirty方法，不会再进行一次View树绘制</span></span><br><span class="line">                <span class="comment">//这时的view还是DecorView，它的DisplayListCanvas已经end结束记录</span></span><br><span class="line">                <span class="comment">//并且，View的RenderNode节点mValid已有效，且mRecreateDisplayList标志已被恢复。</span></span><br><span class="line">                canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">                canvas.disableZ();</span><br><span class="line"></span><br><span class="line">                callbacks.onPostDraw(canvas);</span><br><span class="line">                canvas.restoreToCount(saveCount);</span><br><span class="line">                mRootNodeNeedsUpdate = <span class="literal">false</span>;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mRootNode.endRecording();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="绘制view视图"><a href="#绘制view视图" class="headerlink" title="绘制view视图"></a>绘制view视图</h3><p><img src="ThreadedRender_Draw.jpg" alt="绘制视图"></p><blockquote><p>参考上面目录<code>beginRecording初始化DisplayList</code>小节</p></blockquote><ul><li>updateViewTreeDisplayList方法，从顶层视图DecorView开始，遍历树形视图结构的每一个节点，利用视图内的RenderNode创建Canvas，绘制。</li><li>利用ThreadedRenderer的根RootRenderNode创建Canvas，绘制顶层RenderNode节点</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/android/view/ThreadedRenderer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">     view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">     <span class="comment">//判断视图的PFLAG_INVALIDATED标志</span></span><br><span class="line">     <span class="comment">//有这个标志，在调用每个View的updateDisplayListIfDirty()时，才会创建Canvas</span></span><br><span class="line">     <span class="comment">//当一个视图需要绘制时，上层肯定会设置该标志</span></span><br><span class="line">     <span class="comment">//最后会将重建标志还原</span></span><br><span class="line">     view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">             == View.PFLAG_INVALIDATED;</span><br><span class="line">     view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">     <span class="comment">//此处会用到mRecreateDisplayList进行判断是否创建DisplayListCanvas</span></span><br><span class="line">     view.updateDisplayListIfDirty();</span><br><span class="line">     view.mRecreateDisplayList = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>每个视图的流程是一样的，都有三个步骤，第一次绘制时，每个视图都要建立Canvas。</p><ol><li>通过视图RenderNode节点start方法，创建DisplayListCanvas画布对象（调用<code>beginRecording</code>，流程同上面案例中的分析）</li><li>通过View的draw(canvas)方法，实现具体记录绘制操作，(绘制自身与派发)，draw方法包括很多步骤，包括递归到子视图的updateDisplayListIfDirty方法。</li><li>最后，RenderNode结束记录<code>endRecording</code>方法。</li></ol><h4 id="draw实现视图绘制六个步骤"><a href="#draw实现视图绘制六个步骤" class="headerlink" title="draw实现视图绘制六个步骤"></a>draw实现视图绘制六个步骤</h4><p>第二步的draw实现视图绘制。参数就是上面创建的DisplayListConvas画布，视图有一些公用绘制，例如背景，滚定条，修饰等。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体视图绘制六个步骤：</strong></p><ol><li>绘制背景:<code>drawBackground(canvas)</code></li></ol><ul><li>这里会先得到一个mBGDrawable对象</li><li>然后根据layout过程确定的视图位置来设置背景的绘制区域</li><li>之后再调用Drawable的draw()方法来完成背景的绘制工作</li></ul><ol start="2"><li>必要时保存canvas的layers，绘制边缘fade</li><li>onDraw方法：绘制视图内容，调用Canvas API，<strong>此处是空方法，子类会实现。例如TextView、ImageView等类的源码，它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用，可以将其当成一块画布</strong></li></ol><ul><li>下面有个APP代码案例</li></ul><ol start="4"><li>dispatchDraw派发绘制子视图，空方法，容器类视图会重写。如果有跳过标志，将不会来到draw方法，直接去dispatchDraw。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewGroup.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处调用View.java的三个参数的draw函数中，也会调用<code>updateDisplayListIfDirty()</code>函数。并且如果是硬件绘制会重新判断<code>mRecreateDisplayList</code>。</p><p>这样就实现了View视图的递归绘制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (hardwareAcceleratedCanvas) &#123;</span><br><span class="line">            <span class="comment">// Clear INVALIDATED flag to allow invalidation to occur during rendering, but</span></span><br><span class="line">            <span class="comment">// retain the flag's value temporarily in the mRecreateDisplayList flag</span></span><br><span class="line">            mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != <span class="number">0</span>;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_INVALIDATED;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>如有绘制fading edges，恢复canvas’ layers。</li><li>绘制修饰，如滚动条。</li></ol><hr><h4 id="APP绘制案例代码"><a href="#APP绘制案例代码" class="headerlink" title="APP绘制案例代码"></a>APP绘制案例代码</h4><ol><li>假如APP代码中创建一个非常简单的视图，并且用Canvas随便绘制了一点东西，代码如下所示：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs);</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">        mPaint.setColor(Color.YELLOW);</span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, getWidth(), getHeight(), mPaint);</span><br><span class="line">        mPaint.setColor(Color.BLUE);</span><br><span class="line">        mPaint.setTextSize(<span class="number">20</span>);</span><br><span class="line">        String text = <span class="string">"Hello View"</span>;</span><br><span class="line">        canvas.drawText(text, <span class="number">0</span>, getHeight() / <span class="number">2</span>, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制。</p><p>绘制逻辑比较简单，在<code>onDraw()</code>方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。</p><ol start="2"><li>然后在XML布局假如这个视图，将MyView的宽度设置成200dp，高度设置成100dp。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.example.diyview.MyView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"100dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h2 id="关闭硬件加速"><a href="#关闭硬件加速" class="headerlink" title="关闭硬件加速"></a>关闭硬件加速</h2><p>android提供了以下四个级别的硬件加速控制：</p><ul><li>Application：<code>&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt;</code></li><li>Activity：例如启用全局的硬件加速，但却禁止了一个Activity的硬件加速：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span> <span class="attr">android:hardwareAccelerated</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:hardwareAccelerated</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Window：针对给定的Window来启用硬件加速：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getWindow().setFlags(</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED,</span><br><span class="line">    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED);</span><br></pre></td></tr></table></figure><ul><li>View级别：针对一个独立的View对象使用下列代码来禁止硬件加速：<code>myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</code></li></ul><p><strong>android关闭硬件加速的方法：</strong></p><ol><li>APK中，在AndroidManifest.xml中设置<code>android:hardwareAccelerated=&quot;false&quot;</code>，这是关闭整个app的硬件加速，慎用！</li><li>View有个方法支持单独的View关闭硬件加速，可以设置<code>mView.setLaterType(View.LAYER_TYPE_SOFTWARE);</code>，或者关闭某一个控件的硬件加速功能使用<code>findViewById(R.id.btn).setLayerType(View.LAYER_TYPE_SOFTWARE,null);</code></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>在Java层，硬件渲染由ThreadedRenderer负责，每个窗体根视图ViewRootImpl下都有一个ThreadedRenderer，保存在AttachInfo，<code>它的draw方法是硬件渲染绘制的入口</code>。</li><li>从ViewRootImpl开始，一般视图会创建ThreadedRenderer，启用硬件渲染，关键点在遍历每一个视图，根据视图RenderNode创建画布，<code>有效绘制记录存储在RenderNode关联的底层DisplayListData</code></li><li>绘制架构包含<code>RenderNode节点，DisplayListCanvas画布，底层DisplayListData对象，CanvasState状态存储对象</code>，做完这些初始化工作，就可以在Java层画布上执行绘制操作方法。<code>树形视图结构每一节点都有一个DisplayListCanvas，利用Canvas#drawXxx方法分别记录一些绘制操作，drawXxx画点、圆、矩形等操作，将这些操作存储在一个DisplayList集合中，这是App的UI线程负责的任务</code></li><li><code>onDraw方法自己在APP中重写</code>，View和ViewGroup有什么自己需要的绘制在这里完成。</li><li>View的dispatchDraw是空方法，不做任何操作。ViewGroup重写dispatchDraw方法，实现绘制派发到子视图。容器视图一般没有自己要绘制的东西，可能在updateDisplayListIfDirty方法就已经选择dispatchDraw了；</li><li>顶层视图绘制入口是draw(一个参数)方法，在draw(一个参数)中，包含六个步骤，第四步会派发每个子视图，子视图绘制入口是draw(三个参数)，在draw(三个参数)中，会根据硬件渲染，进入每个子视图updateDisplayListIfDirty方法，实现递归绘制；</li><li>当走到RenderNode的<code>endRecording</code>方法时，表示视图本身以及子视图已经全部绘制完毕，也就是说当DecorView的RenderNode#end方准备执行时，所有draw已经完成</li><li>View构造方法创建每一个视图的RenderNode。每一个RenderNode都会创建DisplayListCanvas，使用时是一一对应关系；</li></ol><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li>Android Q AOSP： <a href="http://aosp.opersys.com/xref/android-10.0.0_r39/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r39/</a></li><li>Android P 图像显示系统（三）Android HWUI 绘制流程： <a href="https://www.jianshu.com/p/abfaea892611" target="_blank" rel="noopener">https://www.jianshu.com/p/abfaea892611</a></li><li>硬件渲染一绘制阶段上层基本流程：<a href="https://www.jianshu.com/p/85d38ef937e9" target="_blank" rel="noopener">https://www.jianshu.com/p/85d38ef937e9</a></li><li>Android视图绘制流程之onDraw()：<a href="https://www.jianshu.com/p/f0f44cd58711" target="_blank" rel="noopener">https://www.jianshu.com/p/f0f44cd58711</a></li><li>Android硬件加速（译文）：<a href="https://www.jianshu.com/p/601a21b00475" target="_blank" rel="noopener">https://www.jianshu.com/p/601a21b00475</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。&lt;br&gt;HWUI绘制的大致流程是先初始化绘制环境（创建rendernode、渲染线程RenderThread、Context上下文、RenderProxy代理对象），之后是创建DisplayList显示列表，然后开始视图绘制，视图绘制结束后开始同步帧数据。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android ANR traces.txt文件分析</title>
    <link href="https://alonealive.github.io/Blog/2020/06/11/2020/200611_android_tracetxt/"/>
    <id>https://alonealive.github.io/Blog/2020/06/11/2020/200611_android_tracetxt/</id>
    <published>2020-06-11T15:52:00.000Z</published>
    <updated>2020-06-13T13:34:40.577Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>trace.txt</code>生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。</p></blockquote><a id="more"></a><p>ANR:Application Not Responding，即应用无响应</p><h2 id="ANR类型"><a href="#ANR类型" class="headerlink" title="ANR类型"></a>ANR类型</h2><p>一般有三种类型:</p><ol><li>KeyDispatchTimeout(5 seconds) –主要类型：按键或触摸事件在特定时间内无响应</li><li>BroadcastTimeout(10 seconds)  –BroadcastReceiver：在特定时间内无法处理完成</li><li>ServiceTimeout(20 seconds) –小概率类型：Service在特定的时间内无法处理完成</li></ol><p>另外还有<code>ProviderTimeout</code>和<code>WatchDog看门狗</code>等导致的ANR。</p><p>还有当系统内存或CPU资源不足时容易出现ANR， 一般这种情况会有<code>lowmemorykill</code>的log打印。</p><p>应用ANR产生的时候，在<code>ActivityManagerService</code>中会调用<code>appNotResponding</code>方法, 然后在<code>/data/anr/traces.txt</code>文件中写入ANR相关信息。</p><h2 id="trace-txt获取"><a href="#trace-txt获取" class="headerlink" title="trace.txt获取"></a>trace.txt获取</h2><ol><li><code>adb shell</code>进入手机的<code>/data/anr</code>文件目录下面查看生成的<code>trace.txt</code>文件(如果<code>ls</code>查看文件列表没有权限,可以先<code>adb root</code>一下)</li><li><code>adb pull /data/anr/</code> 将该文件导出,然后分析</li></ol><p>log打印了ANR的基本信息(<code>adb shell top</code>查看进程, <code>adb logcat -v process |grep PID</code>查看日志), 可以分析<code>CPU使用率</code>得知ANR的简单情况;</p><p>如果CPU使用率很高,接近100%,可能是在进行大规模的计算更可能是陷入死循环;</p><p>如果CUP使用率很低,说明主线程被阻塞了,并且当IOwait很高,可能是主线程在等待I/O操作的完成。</p><p>对于ANR只是分析Log， 很难知道问题所在,我们还需要通过<code>Trace文件分析stack调用情况</code>,在log中显示的pid在traces文件中与之对应, 然后通过查看堆栈调用信息分析ANR的代码。</p><p>注:trace 文件的分析参考 <a href="https://blog.csdn.net/qq_25804863/article/details/49111005" target="_blank" rel="noopener">https://blog.csdn.net/qq_25804863/article/details/49111005</a></p><hr><h2 id="Trace分析"><a href="#Trace分析" class="headerlink" title="Trace分析"></a>Trace分析</h2><p>Traces中显示的线程状态都是C代码定义的，可以通过查看线程状态对应的信息分析ANR问题。</p><p>如:</p><ul><li><code>TimedWaiting</code>对应的线程状态是TIMED_WAITING；</li><li><code>kTimedWaiting, // TIMED_WAITING TS_WAIT in Object.wait() with a timeout</code>执行了无超时参数的wait函数；</li><li><code>kSleeping, // TIMED_WAITING TS_SLEEPING in Thread.sleep()</code>执行了带有超时参数的 sleep 函数；</li><li>ZOMBIE                    线程死亡,终止运行</li><li>RUNNING/RUNNABLE          线程可运行或正在运行</li><li>TIMED_WAIT                执行了带有超时参数的 wait、sleep 或 join 函数</li><li>MONITOR                   线程阻塞,等待获取对象锁</li><li>WAIT                      执行了无超时参数的 wait 函数</li><li>INITIALIZING              新建,正在初始化,为其分配资源</li><li>STARTING                  新建,正在启动</li><li>NATIVE                    正在执行 JNI 本地函数</li><li>VMWAIT                    正在等待 VM 资源</li><li>SUSPENDED                 线程暂停,通常是由于 GC 或 debug 被暂停</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;trace.txt&lt;/code&gt;生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android 开发者选项的“指针位置”坐标值</title>
    <link href="https://alonealive.github.io/Blog/2020/06/10/2020/200610_android_pointerDraw/"/>
    <id>https://alonealive.github.io/Blog/2020/06/10/2020/200610_android_pointerDraw/</id>
    <published>2020-06-10T15:52:00.000Z</published>
    <updated>2020-06-13T13:34:23.321Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？</p></blockquote><a id="more"></a><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>在frameworks/base/core/java/com/android/internal/widget/PointerLocationView.java的<code>onDraw</code>方法中，在触屏的时候会实时打印底层读取的X/Y值。</p><p>如下代码（Android Q AOSP源码）,<code>ps.mCoords.x</code>和<code>ps.mCoords.y</code>是底层传递读取的坐标值，float类型。</p><p>最后会显示成类似<code>X:500.5  Y:200.6</code></p><figure class="highlight java"><figcaption><span>PointerLocationView.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> w = getWidth();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> itemW = w/<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> base = -mTextMetrics.ascent+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> bottom = mHeaderBottom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NP = mPointers.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Labels</span></span><br><span class="line">    <span class="keyword">if</span> (mActivePointerId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> PointerState ps = mPointers.get(mActivePointerId);</span><br><span class="line"></span><br><span class="line">        canvas.drawRect(<span class="number">0</span>, <span class="number">0</span>, itemW-<span class="number">1</span>, bottom,mTextBackgroundPaint);</span><br><span class="line">        canvas.drawText(mText.clear()</span><br><span class="line">                .append(<span class="string">"P: "</span>).append(mCurNumPointers)</span><br><span class="line">                .append(<span class="string">" / "</span>).append(mMaxNumPointers)</span><br><span class="line">                .toString(), <span class="number">1</span>, base, mTextPaint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = ps.mTraceCount;</span><br><span class="line">        <span class="keyword">if</span> ((mCurDown &amp;&amp; ps.mCurDown) || N == <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawRect(itemW, <span class="number">0</span>, (itemW * <span class="number">2</span>) - <span class="number">1</span>, bottom, mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"X: "</span>).append(ps.mCoords.x, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW, base, mTextPaint);</span><br><span class="line">            canvas.drawRect(itemW * <span class="number">2</span>, <span class="number">0</span>, (itemW * <span class="number">3</span>) - <span class="number">1</span>, bottom, mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"Y: "</span>).append(ps.mCoords.y, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW * <span class="number">2</span>, base, mTextPaint);</span><br><span class="line">        &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote><p>如果此时设备的分辨率是<code>1080x2340</code>，“指针位置”坐标值边缘滑动需要显示到<code>1079x2339</code>。而现在出现了问题：在竖屏的时候只能显示到<code>1078x2338</code>，横屏（两种横屏情况）只能显示到<code>1079x2338</code>和<code>1078xz2339</code>？此处如何进行修改？</p></blockquote><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先要对此处读取的<code>ps.mCoords.x</code>和<code>ps.mCoords.y</code>值打印，发现在滑动到边缘的时候，应该显示1079，打印的值大约是<code>1078.0001</code>；应该显示2339的时候，打印的值大约是<code>2038.0001</code>。</p><p>所以在此处需要判断，在大于1078或2339的时候，使用<code>进一法</code>，将其作加一操作。</p><p>同时还要考虑到横屏和竖屏两种状态。</p><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>因为PointerLocationView.java继承view.java，可以使用<code>getResources().getConfiguration();</code>来获取设备参数，从而获取到当前横竖屏的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果是true，则对坐标加一操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mRealX = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mRealY = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//获取当前设备横竖屏状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mOrientation;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">            <span class="comment">//获取横屏、竖屏状态并判断</span></span><br><span class="line">            Configuration mConfiguration = getResources().getConfiguration();</span><br><span class="line">            mOrientation = mConfiguration.orientation;</span><br><span class="line">            <span class="keyword">if</span> (mOrientation == mConfiguration.ORIENTATION_PORTRAIT) &#123;</span><br><span class="line">              mRealX = ps.mCoords.x &gt; <span class="number">972.0f</span> &amp;&amp; ps.mCoords.x &lt; <span class="number">1079.0f</span>;</span><br><span class="line">              mRealY = ps.mCoords.y &gt; <span class="number">2106.0f</span> &amp;&amp; ps.mCoords.y &lt; <span class="number">2339.0f</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrientation == mConfiguration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">              mRealX = ps.mCoords.x &gt; <span class="number">2106.0f</span> &amp;&amp; ps.mCoords.x &lt; <span class="number">2339.0f</span>;</span><br><span class="line">              mRealY = ps.mCoords.y &gt; <span class="number">972.0f</span> &amp;&amp; ps.mCoords.y &lt; <span class="number">1079.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绘制的时候判断是否加一</span></span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"X: "</span>).append(mRealX ? ps.mCoords.x + <span class="number">1.0f</span> : ps.mCoords.x, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW, base, mTextPaint);</span><br><span class="line">            canvas.drawRect(itemW * <span class="number">2</span>, mHeaderPaddingTop, (itemW * <span class="number">3</span>) - <span class="number">1</span>, bottom,</span><br><span class="line">                    mTextBackgroundPaint);</span><br><span class="line">            canvas.drawText(mText.clear()</span><br><span class="line">                    .append(<span class="string">"Y: "</span>).append(mRealY ? ps.mCoords.y + <span class="number">1.0f</span> : ps.mCoords.y, <span class="number">1</span>)</span><br><span class="line">                    .toString(), <span class="number">1</span> + itemW * <span class="number">2</span>, base, mTextPaint);</span><br><span class="line">            mRealX = <span class="keyword">false</span>;</span><br><span class="line">            mRealY = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android 屏幕旋转流程</title>
    <link href="https://alonealive.github.io/Blog/2020/06/01/2020/200601_android_rotation/"/>
    <id>https://alonealive.github.io/Blog/2020/06/01/2020/200601_android_rotation/</id>
    <published>2020-06-01T15:52:00.000Z</published>
    <updated>2020-06-13T13:34:42.781Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。</p></blockquote><a id="more"></a><blockquote><p>参考：<a href="https://blog.csdn.net/jinzhuojun/article/details/50085491" target="_blank" rel="noopener">https://blog.csdn.net/jinzhuojun/article/details/50085491</a><br>参考：<a href="https://blog.csdn.net/kc58236582/article/details/53741445" target="_blank" rel="noopener">https://blog.csdn.net/kc58236582/article/details/53741445</a></p></blockquote><h2 id="调试方法"><a href="#调试方法" class="headerlink" title="调试方法"></a>调试方法</h2><h3 id="打开debug-log开关"><a href="#打开debug-log开关" class="headerlink" title="打开debug log开关"></a>打开debug log开关</h3><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerDebugConfig.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String TAG_WM = <span class="string">"WindowManager"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_ORIENTATION = <span class="keyword">false</span>;  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG_APP_ORIENTATION = <span class="keyword">false</span>;  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>adb logcat -v threadtime|grep -Ei &quot;rotation|ActivityTaskManager|WindowOrientationListener&quot;</code></p><h2 id="Settings设置开启-关闭自动旋转屏幕"><a href="#Settings设置开启-关闭自动旋转屏幕" class="headerlink" title="Settings设置开启/关闭自动旋转屏幕"></a>Settings设置开启/关闭自动旋转屏幕</h2><p>是否要自动转屏是在Setting中设置的。为了监听Setting中的改动，系统启动时，<code>PhoneWindowManager</code>的init()函数中创建了SettingsObserver对象。</p><p>它的observe()方法会监听<code>Settings.System.USER_ROTATION</code>的值（Android Q中此处没有这个property了）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, IWindowManager windowManager,</span></span></span><br><span class="line"><span class="function"><span class="params">          WindowManagerFuncs windowManagerFuncs)</span> </span>&#123;</span><br><span class="line">              ...</span><br><span class="line">              mSettingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler);</span><br><span class="line">              mSettingsObserver.observe();</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><p>当用户在Setting中设置自动转屏后，会触发以下流程：</p><ol><li><code>public boolean onPreferenceTreeClick(Preference preference)</code>：packages/apps/Settings/src/com/android/settings/accessibility/AccessibilitySettings.java</li><li><code>handleLockScreenRotationPreferenceClick()</code>：被调用</li><li><code>setRotationLockForAccessibility(Context context, final boolean enabled)</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLockForAccessibility</span><span class="params">(Context context, <span class="keyword">final</span> boolean enabled)</span> </span>&#123;</span><br><span class="line">    Settings.System.putIntForUser(context.getContentResolver(),</span><br><span class="line">            Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line"></span><br><span class="line">    setRotationLock(enabled, NATURAL_ROTATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><code>setRotationLockForAccessibility</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLockForAccessibility</span><span class="params">(Context context, <span class="keyword">final</span> boolean enabled)</span> </span>&#123;</span><br><span class="line">    Settings.System.putIntForUser(context.getContentResolver(),</span><br><span class="line">            Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line"></span><br><span class="line">    setRotationLock(enabled, NATURAL_ROTATION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><code>setRotationLock(final boolean enabled, final int rotation)</code>调用<code>wm.freezeRotation</code>或者<code>wm.thawRotation</code></li></ol><figure class="highlight cpp"><figcaption><span>frameworks/base/core/java/com/android/internal/view/RotationPolicy.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setRotationLock</span><span class="params">(<span class="keyword">final</span> boolean enabled, <span class="keyword">final</span> <span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">    AsyncTask.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                IWindowManager wm = WindowManagerGlobal.getWindowManagerService();</span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    wm.freezeRotation(rotation);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    wm.thawRotation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException exc) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Unable to save auto-rotate setting"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><code>thawRotation()</code>，此处在Android Q中有变化。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">thawRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,</span><br><span class="line">                <span class="string">"thawRotation()"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Requires SET_ORIENTATION permission"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"thawRotation: mRotation="</span></span><br><span class="line">                + getDefaultDisplayRotation());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE,</span><br><span class="line">                    <span class="number">777</span>); <span class="comment">// rot not used   free</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        updateRotationUnchecked(<span class="keyword">false</span>, <span class="keyword">false</span>);  <span class="comment">//查看下面第十步分析</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而<code>freezeRotation函数</code>，只是调用PhoneWindowManager的setUserRotationMode的参数不一样，这里是Locked，而thawRotation传下去的参数是free。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freezeRotation</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// TODO(multi-display): Track which display is rotated.</span></span><br><span class="line">     <span class="keyword">if</span> (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION,</span><br><span class="line">             <span class="string">"freezeRotation()"</span>)) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Requires SET_ORIENTATION permission"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (rotation &lt; -<span class="number">1</span> || rotation &gt; Surface.ROTATION_270) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Rotation argument must be -1 or a valid "</span></span><br><span class="line">                 + <span class="string">"rotation constant."</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> defaultDisplayRotation = getDefaultDisplayRotation();</span><br><span class="line">     <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"freezeRotation: mRotation="</span></span><br><span class="line">             + defaultDisplayRotation);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_LOCKED,</span><br><span class="line">                 rotation == -<span class="number">1</span> ? defaultDisplayRotation : rotation);    <span class="comment">//lock</span></span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         Binder.restoreCallingIdentity(origId);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     updateRotationUnchecked(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><code>setUserRotationMode(int mode, int rot)</code>：此处是设置property（即Settings数据库），然后会触发到上面初始化的<code>mSettingsObserver</code>对象的<code>onChange</code>函数。</li></ol><p>触发监听<code>SettingsObserver.onChange()</code>， 其中主要调用了updateSettings()和updateRotation()两个函数。</p><p>简单地说，主要的工作是根据需要监听传感器数据，据此判断是否要转屏。如果需要就是<strong>对configuration的各种更新</strong>。过程中会冻结屏幕，同时截屏并以此作为转屏动画。另外还需要将新configuration传给AMS，广播该事件给需要的模块，同时App也会被调度来响应变更。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// User rotation: to be used when all else fails in assigning an orientation to the device</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRotationMode</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">int</span> rot)</span> </span>&#123;</span><br><span class="line">        ContentResolver res = mContext.getContentResolver();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mUserRotationMode and mUserRotation will be assigned by the content observer</span></span><br><span class="line">        <span class="keyword">if</span> (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) &#123;</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.USER_ROTATION,</span><br><span class="line">                    rot,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Settings.System.putIntForUser(res,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION,</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    UserHandle.USER_CURRENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">       @<span class="function">Override <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(boolean selfChange)</span> </span>&#123;</span><br><span class="line">            updateSettings();    <span class="comment">//以下8,9步骤</span></span><br><span class="line">            updateRotation(<span class="literal">false</span>);  <span class="comment">//以下10-步骤</span></span><br><span class="line">        &#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        boolean updateRotation = <span class="literal">false</span>;</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> userRotationMode = Settings.System.getIntForUser(resolver,</span><br><span class="line">                    Settings.System.ACCELEROMETER_ROTATION, <span class="number">0</span>, UserHandle.USER_CURRENT) != <span class="number">0</span> ?</span><br><span class="line">                            WindowManagerPolicy.USER_ROTATION_FREE :</span><br><span class="line">                                    WindowManagerPolicy.USER_ROTATION_LOCKED;</span><br><span class="line">            <span class="keyword">if</span> (mUserRotationMode != userRotationMode) &#123;</span><br><span class="line">                mUserRotationMode = userRotationMode;</span><br><span class="line">                updateRotation = <span class="literal">true</span>;</span><br><span class="line">                updateOrientationListenerLp();  <span class="comment">//传感器相关操作</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>第一个函数<code>updateSettings()</code>如它的名字主要更新设置信息。</p><p>如果UserRotation（朝向信息，如Surface.ROTATION_0）和UserRotationMode（USER_ROTATION_FREE vs. USER_ROTATION_LOCKED）有更新，就设置标记updateRotation为true，表示接下去需要更新rotation相关信息。</p><p>此外，如果UserRotationMode的配置有变，由于需要传感器信息的配合，还需调用updateOrientationListenerLp()来设置或取消监听传感器。</p><p>这里假设设置为自动旋转，那么PhoneWindowManager会通过MyOrientationListener来监听传感器信息。MyOrientationListener是WindowOrientationListener的继承类。它的enable()函数中调用SensorManager提供的registerListener()接口来设置Sensor信息的listener。</p><ol start="8"><li><code>updateOrientationListenerLp()</code>：作用是enable和disable传感器</li></ol><p>其中的<code>mOrientationListener.enable</code>和<code>mOrientationListener.disable</code>是注册传感器回调和去除传感器回调。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrientationListenerLp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mOrientationListener.canDetectOrientation()) &#123;</span><br><span class="line">            <span class="comment">// If sensor is turned off or nonexistent for some reason</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"mScreenOnEarly="</span> + mScreenOnEarly</span><br><span class="line">                + <span class="string">", mAwake="</span> + mAwake + <span class="string">", mCurrentAppOrientation="</span> + mCurrentAppOrientation</span><br><span class="line">                + <span class="string">", mOrientationSensorEnabled="</span> + mOrientationSensorEnabled</span><br><span class="line">                + <span class="string">", mKeyguardDrawComplete="</span> + mKeyguardDrawComplete</span><br><span class="line">                + <span class="string">", mWindowManagerDrawComplete="</span> + mWindowManagerDrawComplete);</span><br><span class="line"></span><br><span class="line">        boolean disable = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mScreenOnEarly &amp;&amp; mAwake &amp;&amp; ((mKeyguardDrawComplete &amp;&amp; mWindowManagerDrawComplete))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needSensorRunningLp()) &#123;</span><br><span class="line">                disable = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//enable listener if not already enabled 启动传感器监听！！</span></span><br><span class="line">                <span class="keyword">if</span> (!mOrientationSensorEnabled) &#123;</span><br><span class="line">                    mOrientationListener.enable(<span class="literal">true</span> <span class="comment">/* clearCurrentRotation */</span>);</span><br><span class="line">                    <span class="keyword">if</span>(localLOGV) Slog.v(TAG, <span class="string">"Enabling listeners"</span>);</span><br><span class="line">                    mOrientationSensorEnabled = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//check if sensors need to be disabled</span></span><br><span class="line">        <span class="keyword">if</span> (disable &amp;&amp; mOrientationSensorEnabled) &#123;</span><br><span class="line">            mOrientationListener.disable();   <span class="comment">//关闭传感器</span></span><br><span class="line">            <span class="keyword">if</span>(localLOGV) Slog.v(TAG, <span class="string">"Disabling listeners"</span>);</span><br><span class="line">            mOrientationSensorEnabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>mOrientationListener是MyOrientationListener对象，而MyOrientationListener类继承父类WindowOrientationListener，从而会调用父类的<code>enable</code>函数。</li></ol><p>该函数中会调用registerListener向SensorManager注册一个监听。</p><figure class="highlight cpp"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">(boolean clearCurrentRotation)</span> </span>&#123;</span><br><span class="line">       synchronized (mLock) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mSensor == null) &#123;</span><br><span class="line">               Slog.w(TAG, <span class="string">"Cannot detect sensors. Not enabled"</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (mEnabled) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (LOG) &#123;</span><br><span class="line">               Slog.d(TAG, <span class="string">"WindowOrientationListener enabled clearCurrentRotation="</span></span><br><span class="line">                       + clearCurrentRotation);</span><br><span class="line">           &#125;</span><br><span class="line">           mOrientationJudge.resetLocked(clearCurrentRotation);</span><br><span class="line">           <span class="keyword">if</span> (mSensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123;</span><br><span class="line">               mSensorManager.registerListener(</span><br><span class="line">                       mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler);   <span class="comment">//mOrientationJudge的回调</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, mHandler);</span><br><span class="line">           &#125;</span><br><span class="line">           mEnabled = <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>registerListener()的具体实现在frameworks/base/core/java/android/hardware/SensorManager.java中。</p><p>然后调用SystemSensorManager.java的registerListenerImpl()，其中会创建<code>SensorEventQueue</code>对象（基类为BaseEventQueue），它是传感器事件的队列，记录需要监听哪些传感器信息。</p><p><code>SensorEventQueue queue = mSensorListeners.get(listener);</code></p><p>同时它也负责与SensorService的连接和通信，可以说是SensorEventListener与SensorService间的桥梁。</p><p>SensorEventListener和SensorEventQueue之间是1:1的关系，它们的映射关系保存在成员mSensorListeners中。如果这里注册的SensorEventListener还没有相应的SensorEventQueue，则新建一个，然后通过addSensor()方法将要关注的传感器进行注册。这个过程中addSensor()调用了enableSensor()，它最终是通过SensorService的enableDisable()方法来完成注册工作的。</p><p>这样，SensorService就开始监听该Sensor，当底层有传感器数据来时，SensorService主线程中会调用相应SensorEventConnection的sendEvents()将之发给对应的Client。</p><p>前面初始化SensorEventQueue时会创建Receiver，它是一个Looper的回调对象，在Client端收到从SensorService来的数据后被回调。</p><p>当有数据收到时Receiver的handleEvent()被调用，继而通过JNI调用到SystemSensorManager::dispatchSensorEvent()。</p><p><strong>接着就调到了<code>WindowOrientationListener的onSensorChanged()函数</code>。该函数计算是否需要转屏。如果需要转屏，将计算结果传给onProposedRotationChanged()。</strong></p><p>比如以下函数的日志打印，在旋转手机，传感器会触发屏幕旋转打印这部分log：</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="comment">// Tell the listener.</span></span><br><span class="line">     <span class="keyword">if</span> (proposedRotation != oldProposedRotation &amp;&amp; proposedRotation &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (LOG) &#123;</span><br><span class="line">             Slog.v(TAG, <span class="string">"Proposed rotation changed!  proposedRotation="</span> + proposedRotation</span><br><span class="line">                     + <span class="string">", oldProposedRotation="</span> + oldProposedRotation);</span><br><span class="line">         &#125;</span><br><span class="line">         onProposedRotationChanged(proposedRotation);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><hr><ol start="10"><li>另一处<code>updateRotation(false)</code>函数会调用到WMS.java，然后调用到<code>updateRotationUnchecked</code>函数。</li></ol><p>最终在该函数中调用<code>rotationChanged = displayContent.updateRotationUnchecked();</code></p><h2 id="屏幕旋转"><a href="#屏幕旋转" class="headerlink" title="屏幕旋转"></a>屏幕旋转</h2><p>假设现在用户转了屏幕，期望转屏事件发生。如上面第九步的代码，<code>onProposedRotationChanged()</code>被调用。</p><p>最后就调用其run函数，run函数先会提升性能（cpu频率），然后调用了updateRotation，这个函数一样就到WMS的updateRotationUnchecked函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOrientationListener</span> <span class="keyword">extends</span> <span class="title">WindowOrientationListener</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdateRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mRotation;</span><br><span class="line">            UpdateRunnable(<span class="keyword">int</span> rotation) &#123;</span><br><span class="line">                mRotation = rotation;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// send interaction hint to improve redraw performance</span></span><br><span class="line">                mPowerManagerInternal.powerHint(PowerHint.INTERACTION, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (isRotationChoicePossible(mCurrentAppOrientation)) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> isValid = isValidRotationChoice(mCurrentAppOrientation,</span><br><span class="line">                            mRotation);</span><br><span class="line">                    sendProposedRotationChangeToStatusBarInternal(mRotation, isValid);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    updateRotation(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onProposedRotationChanged</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"onProposedRotationChanged, rotation="</span> + rotation);</span><br><span class="line">            Runnable r = mRunnableCache.get(rotation, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>)&#123;</span><br><span class="line">                r = <span class="keyword">new</span> UpdateRunnable(rotation);</span><br><span class="line">                mRunnableCache.put(rotation, r);</span><br><span class="line">            &#125;</span><br><span class="line">            mHandler.post(r);  <span class="comment">//发送了一个消息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>updateRotation()中主要是执行两个函数：updateRotationUnchecked()（<code>displayContent.updateRotationUnchecked()</code>）和sendNewConfiguration()。前者执行转屏动作，包含转屏动画<br>等。后者使AMS获取当前新的configuration，并且广播该事件给所有相应的listener。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRotation</span><span class="params">(<span class="keyword">boolean</span> alwaysSendConfiguration, <span class="keyword">boolean</span> forceRelayout)</span> </span>&#123;</span><br><span class="line">        updateRotationUnchecked(alwaysSendConfiguration, forceRelayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//上面settings中设置自动旋转屏幕也会调用到（thawRotation和freezeRotation函数）</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRotationUnchecked</span><span class="params">(<span class="keyword">boolean</span> alwaysSendConfiguration, <span class="keyword">boolean</span> forceRelayout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"updateRotationUnchecked:"</span></span><br><span class="line">                + <span class="string">" alwaysSendConfiguration="</span> + alwaysSendConfiguration</span><br><span class="line">                + <span class="string">" forceRelayout="</span> + forceRelayout);</span><br><span class="line">                ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// TODO(multi-display): Update rotation for different displays separately.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> rotationChanged;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId;</span><br><span class="line">            <span class="keyword">synchronized</span> (mWindowMap) &#123;</span><br><span class="line">                <span class="keyword">final</span> DisplayContent displayContent = getDefaultDisplayContentLocked();</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">"updateRotation: display"</span>);</span><br><span class="line">                <span class="comment">//Step 1</span></span><br><span class="line">                rotationChanged = displayContent.updateRotationUnchecked();</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rotationChanged || alwaysSendConfiguration) &#123;</span><br><span class="line">                Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, <span class="string">"updateRotation: sendNewConfiguration"</span>);</span><br><span class="line">                <span class="comment">//Step 2</span></span><br><span class="line">                sendNewConfiguration(displayId);</span><br><span class="line">                Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong>: 其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的<code>updateOrientationFromAppTokensLocked()</code>方法）。</p><h3 id="updateRotationUnchecked函数"><a href="#updateRotationUnchecked函数" class="headerlink" title="updateRotationUnchecked函数"></a>updateRotationUnchecked函数</h3><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateRotationUnchecked</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oldRotation = mRotation;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lastOrientation = mLastOrientation;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> oldAltOrientation = mAltOrientation;</span><br><span class="line">        <span class="comment">//先调用PhoneWindowManager的rotationForOrientationLw函数来获取rotation，然后与之前的mRotation对比是否有变化</span></span><br><span class="line">        <span class="comment">//没有变化直接返回false。有变化将mRotation重新赋值</span></span><br><span class="line">        <span class="comment">//函数rotationForOrientationLw作用：获取sensor的rotation，然后计算返回我们需要的rotation</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> rotation = mService.mPolicy.rotationForOrientationLw(lastOrientation, oldRotation,</span><br><span class="line">                isDefaultDisplay);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION) Slog.v(TAG_WM, <span class="string">"Computed rotation="</span> + rotation + <span class="string">" for display id="</span></span><br><span class="line">                + mDisplayId + <span class="string">" based on lastOrientation="</span> + lastOrientation</span><br><span class="line">                + <span class="string">" and oldRotation="</span> + oldRotation);</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (oldRotation == rotation &amp;&amp; oldAltOrientation == altOrientation) &#123;  <span class="comment">//没有变化</span></span><br><span class="line">            <span class="comment">// No change.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mRotation = rotation;   <span class="comment">//有变化则赋值</span></span><br><span class="line">        mAltOrientation = altOrientation; </span><br><span class="line">        ...</span><br><span class="line">        updateDisplayAndOrientation(getConfiguration().uiMode);</span><br><span class="line">        ...</span><br><span class="line">        mService.mDisplayManagerInternal.performTraversal(getPendingTransaction());</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateDisplayAndOrientation函数"><a href="#updateDisplayAndOrientation函数" class="headerlink" title="updateDisplayAndOrientation函数"></a>updateDisplayAndOrientation函数</h4><p>还会调用到updateDisplayAndOrientation函数，会把<code>各种数据更新下放到DisplayInfo中</code>，最后调用了DisplayManagerService的<code>setDisplayInfoOverrideFromWindowManager</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DisplayInfo <span class="title">updateDisplayAndOrientation</span><span class="params">(<span class="keyword">int</span> uiMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use the effective "visual" dimensions based on current rotation</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> rotated = (mRotation == ROTATION_90 || mRotation == ROTATION_270);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realdw = rotated ? mBaseDisplayHeight : mBaseDisplayWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realdh = rotated ? mBaseDisplayWidth : mBaseDisplayHeight;</span><br><span class="line">    <span class="keyword">int</span> dw = realdw;</span><br><span class="line">    <span class="keyword">int</span> dh = realdh;</span><br><span class="line">    ...</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> appWidth = mService.mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation, uiMode,</span><br><span class="line">            mDisplayId, displayCutout);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appHeight = mService.mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation, uiMode,</span><br><span class="line">            mDisplayId, displayCutout);</span><br><span class="line">    mDisplayInfo.rotation = mRotation;</span><br><span class="line">    mDisplayInfo.logicalWidth = dw;</span><br><span class="line">    mDisplayInfo.logicalHeight = dh;</span><br><span class="line">    mDisplayInfo.logicalDensityDpi = mBaseDisplayDensity;</span><br><span class="line">    mDisplayInfo.appWidth = appWidth;</span><br><span class="line">    mDisplayInfo.appHeight = appHeight;</span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        mDisplayInfo.getLogicalMetrics(mRealDisplayMetrics,</span><br><span class="line">                CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mDisplayInfo.displayCutout = displayCutout.isEmpty() ? <span class="keyword">null</span> : displayCutout;</span><br><span class="line">    mDisplayInfo.getAppMetrics(mDisplayMetrics);</span><br><span class="line">    <span class="keyword">if</span> (mDisplayScalingDisabled) &#123;</span><br><span class="line">        mDisplayInfo.flags |= Display.FLAG_SCALING_DISABLED;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDisplayInfo.flags &amp;= ~Display.FLAG_SCALING_DISABLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    mService.mDisplayManagerInternal.setDisplayInfoOverrideFromWindowManager(mDisplayId,</span><br><span class="line">        overrideDisplayInfo);</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setDisplayInfoOverrideFromWindowManager会调用setDisplayInfoOverrideFromWindowManagerInternal，然后调用<code>display.setDisplayInfoOverrideFromWindowManagerLocked(info)</code>函数，最后到LogicalDisplay的setDisplayInfoOverrideFromWindowManagerLocked函数中，把DisplayInfo数据放到了mOverrideDisplayInfo中。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setDisplayInfoOverrideFromWindowManagerLocked</span><span class="params">(DisplayInfo info)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mOverrideDisplayInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">             mOverrideDisplayInfo = <span class="keyword">new</span> DisplayInfo(info);</span><br><span class="line">             mInfo = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!mOverrideDisplayInfo.equals(info)) &#123;</span><br><span class="line">             mOverrideDisplayInfo.copyFrom(info); <span class="comment">//拷贝到mOverrideDisplayInfo中</span></span><br><span class="line">             mInfo = <span class="keyword">null</span>;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOverrideDisplayInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">         mOverrideDisplayInfo = <span class="keyword">null</span>;</span><br><span class="line">         mInfo = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="performTraversal处理显示Layer的大小宽高尺寸"><a href="#performTraversal处理显示Layer的大小宽高尺寸" class="headerlink" title="performTraversal处理显示Layer的大小宽高尺寸"></a>performTraversal处理显示Layer的大小宽高尺寸</h4><p>调用到DisplayManagerService.java中，然后调用performTraversalInternal函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">performTraversalInternal</span><span class="params">(SurfaceControl.Transaction t)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mSyncRoot) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!mPendingTraversal) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          mPendingTraversal = <span class="keyword">false</span>;</span><br><span class="line">          <span class="comment">//遍历所有的Device</span></span><br><span class="line">          performTraversalLocked(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// List is self-synchronized copy-on-write.</span></span><br><span class="line">      <span class="keyword">for</span> (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123;</span><br><span class="line">          listener.onDisplayTransaction();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversalLocked</span><span class="params">(SurfaceControl.Transaction t)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Clear all viewports before configuring displays so that we can keep</span></span><br><span class="line">      <span class="comment">// track of which ones we have configured.</span></span><br><span class="line">      clearViewportsLocked();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历所有的Device</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> count = mDisplayDevices.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">          DisplayDevice device = mDisplayDevices.get(i);</span><br><span class="line">          <span class="comment">//step 1：找到那个LogicalDisplay 然后调用其configureDisplayInTransactionLocked函数（看上面的将参数赋值到mOverrideDisplayInfo中）</span></span><br><span class="line">          configureDisplayLocked(t, device);</span><br><span class="line">          <span class="comment">//step 2:调用了各个Device的performTraversalInTransactionLocked，而普通的Device的为空</span></span><br><span class="line">          device.performTraversalLocked(t);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the input system about these new viewports.</span></span><br><span class="line">      <span class="keyword">if</span> (mInputManagerInternal != <span class="keyword">null</span>) &#123;</span><br><span class="line">          mHandler.sendEmptyMessage(MSG_UPDATE_VIEWPORT);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t, DisplayDevice device)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">//设置长宽，旋转角度等</span></span><br><span class="line">      display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF);</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>configureDisplayLocked函数的这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layer。</strong></p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDisplayLocked</span><span class="params">(SurfaceControl.Transaction t,</span></span></span><br><span class="line"><span class="function"><span class="params">           DisplayDevice device,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> isBlanked)</span> </span>&#123;</span><br><span class="line">               ...</span><br><span class="line">       <span class="comment">//step 1. 获取mInfo的数据，而mOverrideDisplayInfo如有数据就要copy到mInfo中去</span></span><br><span class="line">       <span class="keyword">final</span> DisplayInfo displayInfo = getDisplayInfoLocked(); </span><br><span class="line">       <span class="keyword">final</span> DisplayDeviceInfo displayDeviceInfo = device.getDisplayDeviceInfoLocked();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Set the viewport.</span></span><br><span class="line">       <span class="comment">// This is the area of the logical display that we intend to show on the</span></span><br><span class="line">       <span class="comment">// display device.  For now, it is always the full size of the logical display.</span></span><br><span class="line">       mTempLayerStackRect.set(<span class="number">0</span>, <span class="number">0</span>, displayInfo.logicalWidth, displayInfo.logicalHeight);</span><br><span class="line">       ...</span><br><span class="line">       mTempDisplayRect.left += mDisplayOffsetX;</span><br><span class="line">       mTempDisplayRect.right += mDisplayOffsetX;</span><br><span class="line">       mTempDisplayRect.top += mDisplayOffsetY;</span><br><span class="line">       mTempDisplayRect.bottom += mDisplayOffsetY;</span><br><span class="line">       <span class="comment">//step 2</span></span><br><span class="line">       device.setProjectionLocked(t, orientation, mTempLayerStackRect, mTempDisplayRect);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> DisplayInfo <span class="title">getDisplayInfoLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (mInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">           mInfo = <span class="keyword">new</span> DisplayInfo();</span><br><span class="line">           mInfo.copyFrom(mBaseDisplayInfo);</span><br><span class="line">           <span class="keyword">if</span> (mOverrideDisplayInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">               mInfo.appWidth = mOverrideDisplayInfo.appWidth;</span><br><span class="line">               mInfo.appHeight = mOverrideDisplayInfo.appHeight;</span><br><span class="line">               mInfo.smallestNominalAppWidth = mOverrideDisplayInfo.smallestNominalAppWidth;</span><br><span class="line">               mInfo.smallestNominalAppHeight = mOverrideDisplayInfo.smallestNominalAppHeight;</span><br><span class="line">               mInfo.largestNominalAppWidth = mOverrideDisplayInfo.largestNominalAppWidth;</span><br><span class="line">               mInfo.largestNominalAppHeight = mOverrideDisplayInfo.largestNominalAppHeight;</span><br><span class="line">               mInfo.logicalWidth = mOverrideDisplayInfo.logicalWidth;</span><br><span class="line">               mInfo.logicalHeight = mOverrideDisplayInfo.logicalHeight;</span><br><span class="line">               mInfo.overscanLeft = mOverrideDisplayInfo.overscanLeft;</span><br><span class="line">               mInfo.overscanTop = mOverrideDisplayInfo.overscanTop;</span><br><span class="line">               mInfo.overscanRight = mOverrideDisplayInfo.overscanRight;</span><br><span class="line">               mInfo.overscanBottom = mOverrideDisplayInfo.overscanBottom;</span><br><span class="line">               mInfo.rotation = mOverrideDisplayInfo.rotation;</span><br><span class="line">               mInfo.displayCutout = mOverrideDisplayInfo.displayCutout;</span><br><span class="line">               mInfo.logicalDensityDpi = mOverrideDisplayInfo.logicalDensityDpi;</span><br><span class="line">               mInfo.physicalXDpi = mOverrideDisplayInfo.physicalXDpi;</span><br><span class="line">               mInfo.physicalYDpi = mOverrideDisplayInfo.physicalYDpi;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>setProjectionLocked会调用SurfaceControl的SurfaceControl函数。然后在SurfaceControl中调用nativeSetDisplayProjection函数，通过JNI调用到Native层。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/display/DisplayDevice.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setProjectionLocked</span><span class="params">(SurfaceControl.Transaction t, <span class="keyword">int</span> orientation,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect layerStackRect, Rect displayRect)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">            t.setDisplayProjection(mDisplayToken,</span><br><span class="line">                    orientation, layerStackRect, displayRect);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时Java层的<code>updateRotationUnchecked</code>函数分析完。</p><hr><h2 id="sendNewConfiguration函数"><a href="#sendNewConfiguration函数" class="headerlink" title="sendNewConfiguration函数"></a>sendNewConfiguration函数</h2><p>从上面的updateRotation()函数中看到，除了调用updateRotationUnchecked()（即<code>displayContent.updateRotationUnchecked()</code>），还会调用sendNewConfiguration()。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendNewConfiguration</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> configUpdated = mActivityManager.updateDisplayOverrideConfiguration(</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* values */</span>, displayId);</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateDisplayOverrideConfiguration</span><span class="params">(Configuration values, <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        enforceCallingPermission(CHANGE_CONFIGURATION, <span class="string">"updateDisplayOverrideConfiguration()"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (values == <span class="keyword">null</span> &amp;&amp; mWindowManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// sentinel: fetch the current configuration from the window manager</span></span><br><span class="line">                <span class="comment">//Step 1 获取一些配置信息</span></span><br><span class="line">                values = mWindowManager.computeNewConfiguration(displayId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Settings.System.clearConfiguration(values);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Step 2</span></span><br><span class="line">                updateDisplayOverrideConfigurationLocked(values, <span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* deferResume */</span>, displayId, mTmpUpdateConfigurationResult);</span><br><span class="line">                <span class="keyword">return</span> mTmpUpdateConfigurationResult.changes != <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateDisplayOverrideConfigurationLocked</span><span class="params">(Configuration values,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityRecord starting, <span class="keyword">boolean</span> deferResume, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            UpdateConfigurationResult result)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (displayId == DEFAULT_DISPLAY) &#123;</span><br><span class="line">                    <span class="comment">//Step 1:调用</span></span><br><span class="line">                    changes = updateGlobalConfigurationLocked(values, <span class="keyword">false</span> <span class="comment">/* initLocale */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* persistent */</span>, UserHandle.USER_NULL <span class="comment">/* userId */</span>, deferResume);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    changes = performDisplayOverrideConfigUpdate(values, deferResume, displayId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//Step 2</span></span><br><span class="line">            kept = ensureConfigAndVisibilityAfterUpdate(starting, changes);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mWindowManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mWindowManager.continueSurfaceLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.changes = changes;</span><br><span class="line">            result.activityRelaunched = !kept;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">updateGlobalConfigurationLocked</span><span class="params">(@NonNull Configuration values, <span class="keyword">boolean</span> initLocale,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> persistent, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> deferResume)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把Configuration数据保存在mTempConfig</span></span><br><span class="line">        mTempConfig.setTo(getGlobalConfiguration());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> changes = mTempConfig.updateFrom(values);</span><br><span class="line">        <span class="keyword">if</span> (changes == <span class="number">0</span>) &#123;</span><br><span class="line">            performDisplayOverrideConfigUpdate(values, deferResume, DEFAULT_DISPLAY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//会发送ACTION_CONFIGURATION_CHANGED广播，然后获取当前最上面活动的Activity，调用ActivityStack的ensureActivityConfigurationLocked函数和ActivityStackSupervisor的ensureActivitiesVisibleLocked函数。</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_CONFIGURATION_CHANGED);</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING</span><br><span class="line">                | Intent.FLAG_RECEIVER_FOREGROUND</span><br><span class="line">                | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS);</span><br><span class="line">        broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, SYSTEM_UID,</span><br><span class="line">                UserHandle.USER_ALL);</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">performDisplayOverrideConfigUpdate</span><span class="params">(Configuration values, <span class="keyword">boolean</span> deferResume,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        mTempConfig.setTo(mStackSupervisor.getDisplayOverrideConfiguration(displayId));</span><br><span class="line">        <span class="comment">//把Configuration数据保存在mTempConfig</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> changes = mTempConfig.updateFrom(values);</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ensureConfigAndVisibilityAfterUpdate</span><span class="params">(ActivityRecord starting, <span class="keyword">int</span> changes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> kept = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack mainStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        <span class="comment">// mainStack is null during startup.</span></span><br><span class="line">        <span class="keyword">if</span> (mainStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (changes != <span class="number">0</span> &amp;&amp; starting == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If the configuration changed, and the caller is not already</span></span><br><span class="line">                <span class="comment">// in the process of starting an activity, then find the top</span></span><br><span class="line">                <span class="comment">// activity to check if its configuration needs to change.</span></span><br><span class="line">                starting = mainStack.topRunningActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//先后调用两个函数</span></span><br><span class="line">            <span class="keyword">if</span> (starting != <span class="keyword">null</span>) &#123;</span><br><span class="line">                kept = starting.ensureActivityConfiguration(changes,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* preserveWindow */</span>);</span><br><span class="line">                <span class="comment">// And we need to make sure at this point that all other activities</span></span><br><span class="line">                <span class="comment">// are made visible with the correct configuration.</span></span><br><span class="line">                mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes,</span><br><span class="line">                        !PRESERVE_WINDOWS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> kept;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="应用强制设置屏幕方向"><a href="#应用强制设置屏幕方向" class="headerlink" title="应用强制设置屏幕方向"></a>应用强制设置屏幕方向</h2><p>之前提过，其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的<code>updateOrientationFromAppTokensLocked()</code>方法）。</p><p>首先调用AMS的<code>setRequestedOrientation</code>函数，然后调用到ActivityRecord的setRequestedOrientation函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/am/ActivityRecord.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRequestedOrientation</span><span class="params">(<span class="keyword">int</span> requestedOrientation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> Configuration displayConfig =</span><br><span class="line">                mStackSupervisor.getDisplayOverrideConfiguration(displayId);</span><br><span class="line">        <span class="comment">//Step 1</span></span><br><span class="line">        <span class="keyword">final</span> Configuration config = mWindowContainerController.setOrientation(requestedOrientation,</span><br><span class="line">                displayId, displayConfig, mayFreezeScreenLocked(app));</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            frozenBeforeDestroy = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//Step 2：当返回false，就是现在的状态要改变（比如重启Activity）</span></span><br><span class="line">            <span class="comment">//然后就调用ActivityStackSupervisor的resumeTopActivitiesLocked函数来启动最上面的Activity。</span></span><br><span class="line">            <span class="keyword">if</span> (!service.updateDisplayOverrideConfigurationLocked(config, <span class="keyword">this</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* deferResume */</span>, displayId)) &#123;</span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        service.mTaskChangeNotificationController.notifyActivityRequestedOrientationChanged(</span><br><span class="line">                task.taskId, requestedOrientation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中调用到<code>frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java</code>的<code>mWindowContainerController.setOrientation</code>函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">setOrientation</span><span class="params">(<span class="keyword">int</span> requestedOrientation, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration displayConfig, <span class="keyword">boolean</span> freezeScreenIfNeeded)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mContainer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM,</span><br><span class="line">                        <span class="string">"Attempted to set orientation of non-existing app token: "</span> + mToken);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mContainer.setOrientation(requestedOrientation);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> IBinder binder = freezeScreenIfNeeded ? mToken.asBinder() : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//调用WMS的该函数旋转屏幕！！</span></span><br><span class="line">            <span class="keyword">return</span> mService.updateOrientationFromAppTokens(displayConfig, binder, displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该函数调用到WMS的<code>updateOrientationFromAppTokensLocked</code>函数。这个函数先调用另一个updateOrientationFromAppTokensLocked函数，根据这个函数的返回值，返回true代表要旋转，就调用computeNewConfigurationLocked计算Configuration返回。</p><figure class="highlight java"><figcaption><span>WMS.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Configuration <span class="title">updateOrientationFromAppTokensLocked</span><span class="params">(Configuration currentConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            IBinder freezeThisOneIfNeeded, <span class="keyword">int</span> displayId, <span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDisplayReady) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Configuration config = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updateOrientationFromAppTokensLocked(displayId, forceUpdate)) &#123;</span><br><span class="line">            <span class="comment">// If we changed the orientation but mOrientationChangeComplete is already true,</span></span><br><span class="line">            <span class="comment">// we used seamless rotation, and we don't need to freeze the screen.</span></span><br><span class="line">            <span class="keyword">if</span> (freezeThisOneIfNeeded != <span class="keyword">null</span> &amp;&amp; !mRoot.mOrientationChangeComplete) &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowToken atoken = mRoot.getAppWindowToken(freezeThisOneIfNeeded);</span><br><span class="line">                <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    atoken.startFreezingScreen();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            config = computeNewConfigurationLocked(displayId);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOrientationFromAppTokensLocked</span><span class="params">(<span class="keyword">int</span> displayId, <span class="keyword">boolean</span> forceUpdate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> DisplayContent dc = mRoot.getDisplayContent(displayId);</span><br><span class="line">            <span class="comment">//获取上次强制设置的方向</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> req = dc.getOrientation();</span><br><span class="line">            <span class="comment">//如果和上次设置的方向不同</span></span><br><span class="line">            <span class="keyword">if</span> (req != dc.getLastOrientation() || forceUpdate) &#123;</span><br><span class="line">                dc.setLastOrientation(req);</span><br><span class="line">                <span class="comment">//send a message to Policy indicating orientation change to take</span></span><br><span class="line">                <span class="comment">//action like disabling/enabling sensors etc.,</span></span><br><span class="line">                <span class="comment">// TODO(multi-display): Implement policy for secondary displays.</span></span><br><span class="line">                <span class="keyword">if</span> (dc.isDefaultDisplay) &#123;</span><br><span class="line">                    mPolicy.setCurrentOrientationLw(req);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dc.updateRotationUnchecked(forceUpdate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="应用Activity强制设置方向"><a href="#应用Activity强制设置方向" class="headerlink" title="应用Activity强制设置方向"></a>应用Activity强制设置方向</h2><ol><li>Activity：</li></ol><p>如果要强制设置一个Activity的横竖屏可以通过Manifest去设置，跟Activity相关的信息都会保存在ActivityInfo当中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android:screenOrientation&#x3D;[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; |</span><br><span class="line">                                     &quot;landscape&quot; | &quot;portrait&quot; |</span><br><span class="line">                                     &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; |</span><br><span class="line">                                     &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; |</span><br><span class="line">                                     &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot;]</span><br></pre></td></tr></table></figure><ol start="2"><li>Window</li></ol><p>如果是要强制设置一个Window的横竖屏可以通过<code>LayoutParams.screenOrientation</code>来设置。在通过<code>WindowManager.addView的时候把对应的LayoutParams</code>传递给WMS。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowManager.LayoutParams.screenOrientation</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android InputDispatcher获取点击事件</title>
    <link href="https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/"/>
    <id>https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/</id>
    <published>2020-05-20T15:52:00.000Z</published>
    <updated>2020-05-20T16:37:34.618Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。<br>参考上一篇《Android 触控事件分析》：<a href="http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/</a></p></blockquote><!--mode--><h2 id="Input-down-up事件查看"><a href="#Input-down-up事件查看" class="headerlink" title="Input down/up事件查看"></a>Input down/up事件查看</h2><p>在开发者选项打开“显示点按操作反馈”和“指针位置”，通过<code>adb shell getevent -lrt</code>命令，然后点击屏幕可以查看到控制台的打印。</p><p>查看帮助：<code>adb shell getevent -h</code></p><p>打印结果包含Input的down/up事件，以及点击点的坐标（十六进制）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   0000003b            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_X    0000017e            &#x2F;&#x2F;横坐标X&#x3D;382  十六进制转成十进制&#x3D;》 1*16*16+7*16+14*1&#x3D;382</span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_Y    0000032d            &#x2F;&#x2F;纵坐标Y&#x3D;813  十六进制转成十进制&#x3D;》 3*16*16+2*16+13*1&#x3D;813  </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   0000000a            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      000003e8            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            DOWN                </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   ffffffff            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            UP                  </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000             rate 0</span><br></pre></td></tr></table></figure><h2 id="systrace分析"><a href="#systrace分析" class="headerlink" title="systrace分析"></a>systrace分析</h2><p>抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。<br>(参考：<a href="http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">http://wizzie.top/2020/03/17/2020/200317_adnroid_touchEvent/</a>)</p><h2 id="input-debug开关打开抓取日志分析"><a href="#input-debug开关打开抓取日志分析" class="headerlink" title="input debug开关打开抓取日志分析"></a>input debug开关打开抓取日志分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop sys.input.TouchFilterEnable true</span><br><span class="line">adb shell setprop sys.input.TouchFilterLogEnable true</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_FOCUS</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_INPUT</span><br><span class="line">adb shell setprop sys.inputlog.enabled true</span><br><span class="line">adb shell dumpsys input</span><br></pre></td></tr></table></figure><p>然后抓取log可以看到类似<code>InputDispatcher: notifyMotion</code>、<code>dispatchMotion</code>这些日志打印。</p><h2 id="日志打印分析代码流程"><a href="#日志打印分析代码流程" class="headerlink" title="日志打印分析代码流程"></a>日志打印分析代码流程</h2><h3 id="inputReader通过QueuedInputListener"><a href="#inputReader通过QueuedInputListener" class="headerlink" title="inputReader通过QueuedInputListener"></a>inputReader通过QueuedInputListener</h3><p>负责读取触摸事件交给 InputDispatcher 进行事件派发。</p><ol><li>首先在构造函数中new一个QueueListener对象：</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputReader.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mNextSequenceNum(<span class="number">1</span>), mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// M: for nwk @&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *func;</span><br><span class="line">    <span class="comment">/// @&#125;</span></span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><ol start="2"><li>在<code>InputReader::loopOnce()</code>循环等待消息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    ...</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>flush刷新将遍历QueuedInputListener中<code>mArgsQueue</code>的数组元素，触发每一个元素NotifyArgs的<code>notify</code>方法，交给内部InputDispatcher，清空数组。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>结构体NotifyMotionArgs/NotifySwitchArgs/NotifyDeviceResetArgs继承自NotifyArgs，所以执行NotifyArgs的<code>notify</code>函数。调用派发者InputDispatcher的通知notifyMotion，将自己交给派发者。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyMotionArgs::notify</span><span class="params">(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    listener-&gt;notifyMotion(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="InputDispatcher获取数据"><a href="#InputDispatcher获取数据" class="headerlink" title="InputDispatcher获取数据"></a>InputDispatcher获取数据</h3><ol><li>触发InputDispatcher.cpp的<code>notifyMotion</code>函数，读取线程InputReaderThread在处理事务，notifyMotion方法之后会唤醒分发线程，接下来的任务就由分发线程处理。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS   <span class="comment">//打开了input debug log后会打印以下log</span></span></span><br><span class="line">    ALOGD(<span class="string">"notifyMotion - eventTime=%"</span> PRId64 <span class="string">", deviceId=%d, source=0x%x, displayId=%"</span> PRId32</span><br><span class="line">            <span class="string">", policyFlags=0x%x, "</span></span><br><span class="line">            <span class="string">"action=0x%x, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x,"</span></span><br><span class="line">            <span class="string">"edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%"</span> PRId64,</span><br><span class="line">            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, args-&gt;policyFlags,</span><br><span class="line">            args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">            args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; args-&gt;pointerCount; i++) &#123;</span><br><span class="line">        ALOGD(<span class="string">"  Pointer %d: id=%d, toolType=%d, "</span></span><br><span class="line">                <span class="string">"x=%f, y=%f, pressure=%f, size=%f, "</span></span><br><span class="line">                <span class="string">"touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, "</span></span><br><span class="line">                <span class="string">"orientation=%f"</span>,</span><br><span class="line">                i, args-&gt;pointerProperties[i].id,</span><br><span class="line">                args-&gt;pointerProperties[i].toolType,</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">        <span class="comment">// Just enqueue a new motion event. //将NotifyMotionArgs的数据封装为MotionEntry</span></span><br><span class="line">        MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;sequenceNum, args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags,</span><br><span class="line">                args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">                args-&gt;metaState, args-&gt;buttonState, args-&gt;classification,</span><br><span class="line">                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//插入InputDispatcher的mInboundQueue队列中</span></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;   <span class="comment">//需要唤醒分发线程</span></span><br><span class="line">        mLooper-&gt;wake();  <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note：</strong>注意：mLooper属于InputDispatcher，InputManager创建InputDispatcher时，在其构造方法同时创建mLooper，创建的线程是服务线程，并非读取或分发线程<br>这里只是借用了Looper提供的epoll唤醒与休眠机制，在分发线程中InputDispatcherThread中使用mLooper休眠，读取线程负责唤醒。</p><ol start="2"><li>数据封装成MotionEntry，然后作为enqueueInboundEventLocked函数的入参，插入到mInboundQueue队列尾部。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::enqueueInboundEventLocked</span><span class="params">(EventEntry* entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br></pre></td></tr></table></figure><h3 id="InputDispatcherThread分发线程被唤醒"><a href="#InputDispatcherThread分发线程被唤醒" class="headerlink" title="InputDispatcherThread分发线程被唤醒"></a>InputDispatcherThread分发线程被唤醒</h3><blockquote><p>参考：<a href="http://wizzie.top/2020/05/10/2020/200510_android_inputANR/" target="_blank" rel="noopener">http://wizzie.top/2020/05/10/2020/200510_android_inputANR/</a></p></blockquote><ol><li>在InputDispatcherThread线程threadLoop循环中，触发InputDispatcher的dispatchOnce方法。然后调用dispatchOnce方法。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下次唤醒事件，设置无限大</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="built_in">std</span>::scoped_lock _l(mLock);</span><br><span class="line">        mDispatcherIsAlive.notify_all();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mCommandQueue为空时，触发dispatchOnceInnerLocked</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;         <span class="comment">//mCommandQueue为空时是false</span></span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="comment">//计算下一次唤醒时间，比当前时间大</span></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>利用Looper在epoll_wait处进入休眠，休眠timeoutMillis时间仍无事件，threadLoop会一直循环，继续dispatchOnce。<br>当被唤醒时，执行switch循环进入dispatchOnceInnerLocked取出队列中的事件。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPendingEvent的type做区分处理，此处对motion事件分析</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="comment">//如果没有及时响应窗口切换操作</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//事件过期</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻碍其他窗口获取事件</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处执行事件</span></span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong>Looper借助epoll机制实现线程休眠，它本身内部有套接字mWakeEventFd，在rebuildEpollLocked建立时，注册到epoll_ctl监听。因此wake方法就是向mWakeEventFd套接字发送一段字符，促使epoll_wait处的线程能监听到，从而InputDispatcherThread线程被唤醒。</p><h3 id="InputDispatcher事件处理"><a href="#InputDispatcher事件处理" class="headerlink" title="InputDispatcher事件处理"></a>InputDispatcher事件处理</h3><ol><li>InputDispatcher#dispatchMotionLocked处理MotionEntry。此处函数开头会有类似<code>InputDispatcher: dispatchMotion - eventTime= ...</code>的日志打印。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入参：dropReason代表了事件丢弃的原因，它的默认值为DROP_REASON_NOT_DROPPED，代表事件不被丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();   <span class="comment">//systrace抓取</span></span><br><span class="line">    <span class="comment">//*************1**************//</span></span><br><span class="line">    <span class="comment">// Preprocessing. 即标记当前已经进入分发的过程</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundMotionDetails(<span class="string">"dispatchMotion - "</span>, entry);    <span class="comment">//log打印</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*************2**************//</span></span><br><span class="line">   <span class="comment">// Clean up if dropping the event. 如果事件是需要丢弃的，则返回true，不会去为该事件寻找合适的窗口</span></span><br><span class="line">    <span class="keyword">if</span> (*dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">        setInjectionResult(entry, *dropReason == DROP_REASON_POLICY</span><br><span class="line">                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//此时就是事件被丢弃了，分发任务就没有完成！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************3*************//</span></span><br><span class="line">    <span class="keyword">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标窗口信息列表会存储在inputTargets中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt; inputTargets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="comment">//事件处理的结果交由injectionResult</span></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">//1. 处理点击形式的事件，比如触摸屏幕</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. 处理非触摸形式的事件，比如轨迹球</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************4*************//</span></span><br><span class="line">    <span class="comment">//1. 如果injectionResult的值为INPUT_EVENT_INJECTION_PENDING，这说明找到了窗口并且窗口无响应输入事件被挂起，这时就会返回false</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResult(entry, injectionResult);</span><br><span class="line">    <span class="comment">//2. 如果injectionResult的值不为INPUT_EVENT_INJECTION_SUCCEEDED，这说明没有找到合适的窗口，输入事件没有分发成功，这时就会返回true</span></span><br><span class="line">    <span class="comment">//输入事件被挂起，说明找到了窗口并且窗口无响应</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_PERMISSION_DENIED) &#123;</span><br><span class="line">            <span class="function">CancelationOptions::Mode <span class="title">mode</span><span class="params">(isPointerEvent ?</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_POINTER_EVENTS :</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_NON_POINTER_EVENTS)</span></span>;</span><br><span class="line">            <span class="function">CancelationOptions <span class="title">options</span><span class="params">(mode, <span class="string">"input event injection failed"</span>)</span></span>;</span><br><span class="line">            synthesizeCancelationEventsForMonitorsLocked(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**************5*************//</span></span><br><span class="line">    <span class="comment">//分发目标添加到inputTargets列表中    // Add monitor channels from event's or focused display.</span></span><br><span class="line">    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> stateIndex = mTouchStatesByDisplay.indexOfKey(entry-&gt;displayId);</span><br><span class="line">        <span class="keyword">if</span> (stateIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> TouchState&amp; state = mTouchStatesByDisplay.valueAt(stateIndex);</span><br><span class="line">            <span class="keyword">if</span> (!state.portalWindows.empty()) &#123;</span><br><span class="line">                <span class="comment">// The event has gone through these portal windows, so we add monitoring targets of</span></span><br><span class="line">                <span class="comment">// the corresponding displays as well.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; state.portalWindows.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> InputWindowInfo* windowInfo = state.portalWindows[i]-&gt;getInfo();</span><br><span class="line">                    addGlobalMonitoringTargetsLocked(inputTargets, windowInfo-&gt;portalToDisplayId,</span><br><span class="line">                            -windowInfo-&gt;frameLeft, -windowInfo-&gt;frameTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the motion.</span></span><br><span class="line">    <span class="keyword">if</span> (conflictingPointerActions) &#123;</span><br><span class="line">        <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"conflicting pointer actions"</span>)</span></span>;</span><br><span class="line">        synthesizeCancelationEventsForAllConnectionsLocked(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将事件分发给inputTargets列表中的目标</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="InputTarget结构体"><a href="#InputTarget结构体" class="headerlink" title="InputTarget结构体"></a>InputTarget结构体</h4><p>InputTarget结构体可以说是inputDispatcher与目标窗口的转换器。<br>其分为两大部分：</p><ol><li>一个是枚举中存储的inputDispatcher与目标窗口交互的标记，</li><li>另一部分是inputDispatcher与目标窗口交互参数，比如：</li></ol><ul><li><code>inputChannel</code>，它实际上是一个SocketPair，SocketPair用于进程间双向通信，这非常适合inputDispatcher与目标窗口之间的通信，因为inputDispatcher不仅要将事件分发到目标窗口，同时inputDispatcher也需要得到目标窗口对事件的响应。</li><li><code>xOffset和yOffset</code>，屏幕坐标系相对于目标窗口坐标系的偏移量，MotionEntry(MotionEvent)中的存储的坐标是屏幕坐标系，因此就需要注释2和注释3处的参数，来将屏幕坐标系转换为目标窗口的坐标系。</li></ul><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputTarget</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">//此标记表示事件正在交付给前台应用程序</span></span><br><span class="line">    FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//此标记指示MotionEvent位于目标区域内</span></span><br><span class="line">    FLAG_WINDOW_IS_OBSCURED = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inputDispatcher与目标窗口的通信管道</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//事件派发的标记</span></span><br><span class="line">    <span class="keyword">int32_t</span> flags;</span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的偏移量</span></span><br><span class="line">    <span class="keyword">float</span> xOffset, yOffset;<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的缩放系数</span></span><br><span class="line">    <span class="keyword">float</span> scaleFactor;<span class="comment">//3</span></span><br><span class="line">    BitSet32 pointerIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="处理点击事件findTouchedWindowTargetsLocked"><a href="#处理点击事件findTouchedWindowTargetsLocked" class="headerlink" title="处理点击事件findTouchedWindowTargetsLocked"></a>处理点击事件findTouchedWindowTargetsLocked</h3><blockquote><p>参考：<a href="https://www.codercto.com/a/52484.html" target="_blank" rel="noopener">https://www.codercto.com/a/52484.html</a><br>在函数dispatchMotionLocked中，会分别对Motion事件中的点击形式事件和非触摸形式事件做了处理。其中点击事件调用函数<code>findTouchedWindowTargetsLocked</code>。</p></blockquote><p>函数末尾会打印类似日志<code>InputDispatcher: findTouchedWindow finished: injectionResult=0, injectionPermission=1, timeSpentWaitingForApplication=0.0ms</code>，injectionResult=0是succeed，injectionPermission=1是允许。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::findTouchedWindowTargetsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> MotionEntry* entry, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span>* outConflictingPointerActions)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL(); <span class="comment">//systrace</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123;</span><br><span class="line">        <span class="comment">/* Case 1: New splittable pointer going down, or need target for hover or scroll. */</span></span><br><span class="line">        <span class="comment">//从MotionEntry中获取坐标点</span></span><br><span class="line">        <span class="keyword">int32_t</span> pointerIndex = getMotionEventActionPointerIndex(action);</span><br><span class="line">        <span class="keyword">int32_t</span> x = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_X));</span><br><span class="line">        <span class="keyword">int32_t</span> y = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_Y));</span><br><span class="line">        <span class="keyword">bool</span> isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将符合条件的窗口放入TempTouchState中，以便后续处理</span></span><br><span class="line">        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);</span><br><span class="line">        &#125;</span><br><span class="line">        mTempTouchState.addGestureMonitors(newGestureMonitors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Case 2: Pointer move, up, cancel or non-splittable pointer down. */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处说明窗口已经查找成功</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    <span class="comment">//为每个mTempTouchState中的窗口生成InputTargets</span></span><br><span class="line">    addWindowTargetLocked(focusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">        Unresponsive:</span><br><span class="line">    <span class="comment">// Reset temporary touch state to ensure we release unnecessary references to input channels.</span></span><br><span class="line">    <span class="comment">//重置TempTouchState</span></span><br><span class="line">    mTempTouchState.reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    <span class="comment">//日志打印输出</span></span><br><span class="line">    ALOGD(<span class="string">"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, injectionPermission, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dispatchEventLocked向目标窗口发送事件"><a href="#dispatchEventLocked向目标窗口发送事件" class="headerlink" title="dispatchEventLocked向目标窗口发送事件"></a>dispatchEventLocked向目标窗口发送事件</h3><ol><li>上面函数dispatchMotionLocked的末尾，会执行<code>dispatchEventLocked</code>函数，将事件分发给inputTargets列表中的分发目标（目标窗口）。</li></ol><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        EventEntry* eventEntry, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"dispatchEventToCurrentInputTargets"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line">    <span class="comment">//遍历inputTargets列表，获取每一个inputTarget</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> InputTarget&amp; inputTarget : inputTargets) &#123;</span><br><span class="line">        <span class="comment">//1. 根据inputTarget内部的inputChannel来获取Connection的索引</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2. 根据索引，获取保存在mConnectionsByFd容器中的Connection（可以理解为InputDispatcher和目标窗口的连接，其内部包含了连接的状态、InputChannel、InputWindowHandle和事件队列等）</span></span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">//3. 根据inputTarget，开始事件发送循环</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_FOCUS</span><br><span class="line">            ALOGD(<span class="string">"Dropping event delivery to target with channel '%s' because it "</span></span><br><span class="line">                    <span class="string">"is no longer registered with the input dispatcher."</span>,</span><br><span class="line">                    inputTarget.inputChannel-&gt;getName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>开始事件发送，最终会通过inputTarget中的inputChannel和窗口进行<code>进程间通信</code>，最终将Motion事件发送给目标窗口。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(</span><br><span class="line">                <span class="string">"prepareDispatchCycleLocked(inputChannel=%s, sequenceNum=%"</span> PRIu32 <span class="string">")"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str(), eventEntry-&gt;sequenceNum);</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "</span></span><br><span class="line">            <span class="string">"xOffset=%f, yOffset=%f, globalScaleFactor=%f, "</span></span><br><span class="line">            <span class="string">"windowScaleFactor=(%f, %f), pointerIds=0x%x"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags,</span><br><span class="line">            inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;globalScaleFactor,</span><br><span class="line">            inputTarget-&gt;windowXScale, inputTarget-&gt;windowYScale,</span><br><span class="line">            inputTarget-&gt;pointerIds.value);</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><ol start="3"><li>然后调用startDispatchCycleLocked（在函数dispatchMotionLocked末尾处），最终调用两种事件的<code>connection-&gt;inputPublisher...</code>函数，至此，InputDisapatcher结束。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(<span class="string">"startDispatchCycleLocked(inputChannel=%s)"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str());</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source, keyEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">    <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState, motionEntry-&gt;classification,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。&lt;br&gt;参考上一篇《Android 触控事件分析》：&lt;a href=
      
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
      <category term="input" scheme="https://alonealive.github.io/Blog/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>Android Input事件ANR流程</title>
    <link href="https://alonealive.github.io/Blog/2020/05/10/2020/200510_android_inputANR/"/>
    <id>https://alonealive.github.io/Blog/2020/05/10/2020/200510_android_inputANR/</id>
    <published>2020-05-10T15:32:00.000Z</published>
    <updated>2020-05-20T16:37:09.890Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听<code>/dev/input</code>产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。<br>常说的Input ANR超时，都是指的是Input事件分发超时。</p></blockquote><a id="more"></a><blockquote><p>参考：<a href="https://blog.csdn.net/abm1993/article/details/80461752" target="_blank" rel="noopener">https://blog.csdn.net/abm1993/article/details/80461752</a><br>参考：<a href="https://blog.csdn.net/abm1993/article/details/80497039" target="_blank" rel="noopener">https://blog.csdn.net/abm1993/article/details/80497039</a><br>参考：<a href="https://www.jianshu.com/p/f05d6b05ba17" target="_blank" rel="noopener">https://www.jianshu.com/p/f05d6b05ba17</a></p></blockquote><h2 id="问题日志"><a href="#问题日志" class="headerlink" title="问题日志"></a>问题日志</h2><p>从下面的log可以看到超过了5s导致发生Input ANR事件。</p><ul><li>main log：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">04-22 10:49:36.222646  1270  1376 I InputDispatcher: Application is not responding: AppWindowToken&#123;e4f7c16 token&#x3D;Token&#123;8a1cd31 ActivityRecord&#123;21295d8 u0 com.android.PACKAGE&#x2F;.PACKAGE_Activity t10&#125;&#125;&#125;.  It has been 5008.2ms since event, 5005.5ms since wait started.  Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span><br><span class="line">04-22 10:49:36.342164  1270  1407 E TAG     : 82 Tanet</span><br><span class="line">......</span><br><span class="line">04-22 10:49:41.347174  1270  1376 I InputDispatcher: Dropped event because it is stale.</span><br></pre></td></tr></table></figure><ul><li>system log：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">04-22 10:49:31.216699  1270  1376 D PowerManagerService: getScreenOffTimeoutLocked:  isTestFlag &#x3D; false</span><br><span class="line">04-22 10:49:31.216986  1270  1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182 com.android.server.input.InputManagerService.interceptKeyBeforeDispatching:1839 &lt;bottom of call stack&gt; </span><br><span class="line">04-22 10:49:36.224611  1270  1376 I WindowManager: Input event dispatching timed out .  Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.</span><br><span class="line">04-22 10:49:36.341180  1270  1407 W InputManager: Input event injection from pid 6143 timed out.</span><br><span class="line">04-22 10:49:36.342467  1270  1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182</span><br></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="循环读取分发Input事件"><a href="#循环读取分发Input事件" class="headerlink" title="循环读取分发Input事件"></a>循环读取分发Input事件</h3><p>在frameworks/native/services/inputflinger/InputDispatcher.cpp中，流程从<code>InputDispatcherThread::threadLoop()</code>线程循环开始，方法体只调用循环一个函数<code>mDispatcher-&gt;dispatchOnce()</code>。</p><p>如果没有等待的命令，则会循环运行主要函数<code>dispatchOnceInnerLocked</code>不断的读取并分发Input事件：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now(); <span class="comment">//记录事件的当前时间点</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;   <span class="comment">//点击事件</span></span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchDue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isAppSwitchKeyEvent(typedEntry)) &#123;</span><br><span class="line">                resetPendingAppSwitchLocked(<span class="literal">true</span>);</span><br><span class="line">                isAppSwitchDue = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">                dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);  <span class="comment">//执行该函数</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数最后调用了dropInputEvent事件<code>dropInboundEventLocked(mPendingEvent, dropReason);</code></p><h3 id="若case-EventEntry-TYPE-KEY"><a href="#若case-EventEntry-TYPE-KEY" class="headerlink" title="若case EventEntry::TYPE_KEY"></a>若case EventEntry::TYPE_KEY</h3><p>如果是Key事件，则会执行<code>InputDispatcher::dispatchKeyLocked</code>函数。然后在该函数中调用<code>findFocusedWindowTargetsLocked</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchKeyLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span></span></span><br><span class="line"><span class="function"><span class="params">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResult(entry, injectionResult);</span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add monitor channels from event's or focused display.</span></span><br><span class="line">    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数<code>findFocusedWindowTargetsLocked</code>中开始就会进行判断，当<code>focusedWindowHandle == nullptr</code>但是<code>focusedApplicationHandle != nullptr</code>的时候调用<code>handleTargetsNotReadyLocked</code>报出ANR的错误日志。</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::findFocusedWindowTargetsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> EventEntry* entry, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">    <span class="comment">// If there is no currently focused window and no focused application</span></span><br><span class="line">    <span class="comment">// then drop the event.</span></span><br><span class="line">    <span class="keyword">if</span> (focusedWindowHandle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (focusedApplicationHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//monkey test的时候经常遇到类似log的ANR。典型的无窗口，有应用的ANR问题，这里我们就需要了解Android应用的启动流程了，一般此类问题都是Android应用首次启动时会发生此类问题，此时我们应用本身需要检查一下我们的Android应用重写的Application onCreate方法，Android应用的启动界面是否在onCreate onStart方法中是否存在耗时操作。当然不排除系统原因造成的启动慢，直接导致ANR问题发生的情况</span></span><br><span class="line">            injectionResult = handleTargetsNotReadyLocked(currentTime, entry,</span><br><span class="line">                    focusedApplicationHandle, <span class="literal">nullptr</span>, nextWakeupTime,</span><br><span class="line">                    <span class="string">"Waiting because no window has focus but there is a "</span></span><br><span class="line">                    <span class="string">"focused application that may eventually add a window "</span></span><br><span class="line">                    <span class="string">"when it finishes starting up."</span>);  </span><br><span class="line">            <span class="keyword">goto</span> Unresponsive;</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p><code>InputDispatcher::handleTargetsNotReadyLocked</code>执行代码：</p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::handleTargetsNotReadyLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> EventEntry* entry,   <span class="comment">//点击触摸事件</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span>* nextWakeupTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason)</span> </span>&#123;   </span><br><span class="line">....</span><br><span class="line"><span class="keyword">if</span> (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;</span><br><span class="line"><span class="comment">//这里一般是有应用（application已经创建），无窗口，或者有应用，有窗口ANR的情形，一般同一个窗口至进入一次该方法</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">nsecs_t</span> timeout;  <span class="comment">//int64类型秒数</span></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (applicationHandle != <span class="literal">nullptr</span>) &#123;   <span class="comment">//执行这个，有应用无窗口</span></span><br><span class="line">                timeout = applicationHandle-&gt;getDispatchingTimeout(</span><br><span class="line">                        DEFAULT_INPUT_DISPATCHING_TIMEOUT); <span class="comment">//5s超时</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT; <span class="comment">//5s</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;<span class="comment">//超时等待原因</span></span><br><span class="line">mInputTargetWaitStartTime = currentTime;<span class="comment">//函数入参当前时间，此处就是当前input事件的第一次分发时间</span></span><br><span class="line">mInputTargetWaitTimeoutTime = currentTime + timeout; <span class="comment">//设置超时</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//无窗口</span></span><br><span class="line">            <span class="keyword">if</span> (windowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;<span class="comment">//记录当前等待的应用</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//TODO 记录当前等待的应用，针对无窗口，有应用</span></span><br><span class="line">            <span class="keyword">if</span> (mInputTargetWaitApplicationHandle == <span class="literal">NULL</span> &amp;&amp; applicationHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mInputTargetWaitApplicationHandle = applicationHandle;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">//当前时间已经大于超时时间，说明应用有时间分发超时了，需要触发ANR</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123;   <span class="comment">//应该是超时5s</span></span><br><span class="line">        onANRLocked(currentTime, applicationHandle, windowHandle,</span><br><span class="line">                entry-&gt;eventTime , mInputTargetWaitStartTime, reason);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Force poll loop to wake up immediately on next iteration once we get the</span></span><br><span class="line">        <span class="comment">// ANR response back from the policy.</span></span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        <span class="keyword">return</span> INPUT_EVENT_INJECTION_PENDING;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="ANR的函数调用onANRLocked"><a href="#ANR的函数调用onANRLocked" class="headerlink" title="ANR的函数调用onANRLocked"></a>ANR的函数调用onANRLocked</h3><p>最后发生ANR调用<code>InputDispatcher::onANRLocked</code></p><figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::onANRLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> currentTime, <span class="keyword">const</span> sp&lt;InputApplicationHandle&gt;&amp; applicationHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> eventTime, <span class="keyword">nsecs_t</span> waitStartTime, <span class="keyword">const</span> <span class="keyword">char</span>* reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> dispatchLatency = (currentTime - eventTime) * <span class="number">0.000001f</span>;</span><br><span class="line">    <span class="keyword">float</span> waitDuration = (currentTime - waitStartTime) * <span class="number">0.000001f</span>;</span><br><span class="line">    ALOGI(<span class="string">"Application is not responding: %s.  "</span></span><br><span class="line">            <span class="string">"It has been %0.1fms since event, %0.1fms since wait started.  Reason: %s"</span>,</span><br><span class="line">            getApplicationWindowLabel(applicationHandle, windowHandle).c_str(),</span><br><span class="line">            dispatchLatency, waitDuration, reason);</span><br></pre></td></tr></table></figure><hr><h2 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h2><ol><li>抓取systrace分析：可以分析Input事件的部分</li><li>系统的Trace log：系统生成的Trace文件保存在<code>data/anr</code>,可以用过命令<code>adb pull data/anr/</code>取出。</li><li>抓取日志分析</li></ol><h2 id="可能导致ANR的原因"><a href="#可能导致ANR的原因" class="headerlink" title="可能导致ANR的原因"></a>可能导致ANR的原因</h2><ol><li>怀疑是不是在Activty oncreate和onstart耗时太多，导致窗口还未创建好，input事件超时5s<br>应用窗口是在onResume中才去向WindowManager添加注册的。因此在注册添加窗口之前，application或者启动的Activity的生命周期onCreate，onStart的任意方法，做了耗时操作，或者他们加载一起的执行时间过长，都是能够导致<code>无窗口，有应用类型的Input ANR问题</code>发生的。所以实际开发应用的时候，就要尽可能的把耗时的操作，异步处理。具体异步实现思路可以使用<code>new thread + handler，Asynctask，HandlerThread</code>等等，这里推荐使用HandlerThread，因为google封装的接口，使用起来简单。</li><li>可能是UI主线程做了耗时的操作。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听&lt;code&gt;/dev/input&lt;/code&gt;产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。&lt;br&gt;常说的Input ANR超时，都是指的是Input事件分发超时。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
      <category term="input" scheme="https://alonealive.github.io/Blog/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>C++字符串比较函数strcmp和strstr的用法</title>
    <link href="https://alonealive.github.io/Blog/2020/04/14/2020/200413_cpp_strstrTostrcmp/"/>
    <id>https://alonealive.github.io/Blog/2020/04/14/2020/200413_cpp_strstrTostrcmp/</id>
    <published>2020-04-14T15:32:00.000Z</published>
    <updated>2020-04-13T14:12:25.215Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天碰到一个细节bug，使用<code>strcmp</code>来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用<code>strstr</code>函数。</p></blockquote><a id="more"></a><h2 id="strcmp函数比较字符串大小"><a href="#strcmp函数比较字符串大小" class="headerlink" title="strcmp函数比较字符串大小"></a>strcmp函数比较字符串大小</h2><p>设这两个字符串为str1、str2，</p><ul><li>若str1 == str2，则返回零；</li><li>若str1 &lt; str2，则返回负数；</li><li>若str1 &gt; str2，则返回正数。</li></ul><p>测试类：</p><figure class="highlight c++"><figcaption><span>testFunc_strcmp.cpp </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROPERTY_VALUE_MAX 92</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> char1[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> char2[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> isCon[<span class="number">20</span>] = <span class="string">"y"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (con) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Compare two char by func strcmp(char1, char2):"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char1: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char1, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char2: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char2, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Result: strcmp("</span> &lt;&lt; char1 &lt;&lt; <span class="string">", "</span> &lt;&lt; char2 &lt;&lt; <span class="string">"): "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strcmp</span>(char1, char2) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue? y/n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(isCon, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(isCon, <span class="string">"n"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           con = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: wen</span><br><span class="line">Result: strcmp(sun, wen): </span><br><span class="line">-4</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wen</span><br><span class="line">Enter char2: gan</span><br><span class="line">Result: strcmp(wen, gan): </span><br><span class="line">16</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wizzie</span><br><span class="line">Enter char2: wizzie</span><br><span class="line">Result: strcmp(wizzie, wizzie): </span><br><span class="line">0</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Compare two char by func strcmp(char1, char2):</span><br><span class="line">Enter char1: wizzie_test</span><br><span class="line">Enter char2: wizzie</span><br><span class="line">Result: strcmp(wizzie_test, wizzie): </span><br><span class="line">95</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">n</span><br></pre></td></tr></table></figure><h2 id="strstr函数比较字符串是否相同或者存在包含关系"><a href="#strstr函数比较字符串是否相同或者存在包含关系" class="headerlink" title="strstr函数比较字符串是否相同或者存在包含关系"></a>strstr函数比较字符串是否相同或者存在包含关系</h2><p>如果两个字符串可能存在相同，并且可能会有包含关系，则需要使用<code>strstr</code>函数来比较字符串。如果不包含（或相同），则返回NULL。</p><p>测试类：</p><figure class="highlight c++"><figcaption><span>testFunc_strstr.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROPERTY_VALUE_MAX 92</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> char1[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span> char2[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">char</span> isCon[<span class="number">20</span>] = <span class="string">"y"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"*** Determine whethe char2 is in char1. ***"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (con) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Input two char by func strstr(char1, char2):"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char1: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char1, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter char2: "</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(char2, PROPERTY_VALUE_MAX);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Result: strstr("</span> &lt;&lt; char1 &lt;&lt; <span class="string">", "</span> &lt;&lt; char2 &lt;&lt; <span class="string">"): "</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(char1, char2) != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Success: char2 is in char1!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error: char2 is not in char1!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Continue? y/n"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>.getline(isCon, <span class="number">20</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(isCon, <span class="string">"n"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">           con = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*** Determine whethe char2 is in char1. ***</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: sun</span><br><span class="line">Result: strstr(sun, sun): </span><br><span class="line">Success: char2 is in char1!</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sunwengang</span><br><span class="line">Enter char2: wen</span><br><span class="line">Result: strstr(sunwengang, wen): </span><br><span class="line">Success: char2 is in char1!</span><br><span class="line">Continue? y&#x2F;n</span><br><span class="line">y</span><br><span class="line">Input two char by func strstr(char1, char2):</span><br><span class="line">Enter char1: sun</span><br><span class="line">Enter char2: sunwengang</span><br><span class="line">Result: strstr(sun, sunwengang): </span><br><span class="line">Error: char2 is not in char1!</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;今天碰到一个细节bug，使用&lt;code&gt;strcmp&lt;/code&gt;来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用&lt;code&gt;strstr&lt;/code&gt;函数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/categories/cpp/"/>
    
    
      <category term="cpp" scheme="https://alonealive.github.io/Blog/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Android HWC2硬件合成</title>
    <link href="https://alonealive.github.io/Blog/2020/04/01/2020/200401_android_HWC2_Display/"/>
    <id>https://alonealive.github.io/Blog/2020/04/01/2020/200401_android_HWC2_Display/</id>
    <published>2020-04-01T15:32:00.000Z</published>
    <updated>2020-04-01T12:55:07.459Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载夕月风大佬博客： <a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">https://www.jianshu.com/p/824a9ddf68b9</a><br>参考Android P AOSP源码添加修改部分内容<br>参考源码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r14/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r14/</a></p></blockquote><a id="more"></a><h2 id="显示屏Display"><a href="#显示屏Display" class="headerlink" title="显示屏Display"></a>显示屏Display</h2><blockquote><p>显示屏Display是合成的另一个重要单元，系统可以有多个显示设备，并且在正常系统操作期间可以添加/删除显示设备。该添加/删除操作可以对应HWC设备的热插拔请求，或者应客户端的请求进行，这允许创建虚拟显示设备，其内容会渲染到离屏缓冲区（而不是物理显示设备）。</p></blockquote><blockquote><p>可以通过Dump SF查看display的layer信息，同时也可以根据layerstack异同判断多个display是否用的同一个layer。</p></blockquote><p>HWC中，SurfaceFlinger中创建的Layer，在合成开始时，将被指定到每个Display上，此后合成过程中，每个Display合成指定给自己的Layer。</p><p>SurfaceFlinger前端，每个显示屏用<code>DisplayDevice</code>类描述，在后端显示数据用<code>DisplayData</code>描述。而在HWC2的Client端，定义了Display类进行描述。对于HWC2服务端则用<code>hwc2_display_t</code>描述，他只是一个序号，Vendor具体实现时，才具体的去管理Display的信息。</p><p>HWC2提供相应函数来确定给定显示屏的属性，在不同配置（例如4K/1080分辨率）和颜色模式（例如Native颜色或者真彩sRGB）之间切换，以及打开/关闭显示设备或者将其切换到低功率模式（如果支持）。</p><h2 id="HWC设备composerDevice"><a href="#HWC设备composerDevice" class="headerlink" title="HWC设备composerDevice"></a>HWC设备composerDevice</h2><p><strong>Note:</strong><br>注意显示屏Display和合成设备的区别，HWC合成设备只有一个，定义在头文件：</p><figure class="highlight cpp"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc2_device</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*getCapabilities)(struct hwc2_device* device, <span class="keyword">uint32_t</span>* outCount,</span><br><span class="line">            <span class="keyword">int32_t</span>* <span class="comment">/*hwc2_capability_t*/</span> outCapabilities);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">hwc2_function_pointer_t</span> (*getFunction)(struct hwc2_device* device,</span><br><span class="line">            <span class="keyword">int32_t</span> <span class="comment">/*hwc2_function_descriptor_t*/</span> descriptor);</span><br><span class="line">&#125; <span class="keyword">hwc2_device_t</span>;</span><br></pre></td></tr></table></figure><h3 id="HWC合成服务"><a href="#HWC合成服务" class="headerlink" title="HWC合成服务"></a>HWC合成服务</h3><p><code>hardware/interfaces/graphics/composer/2.1/default</code>这个HWC的的默认服务。SurfaceFlinger初始化时，可以通过属性<code>debug.sf.hwc_service_name</code>来制定，默认为default。在编译时，manifest.xml中配置的也是default。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">getHwcServiceName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX] = &#123;&#125;;</span><br><span class="line">    property_get(<span class="string">"debug.sf.hwc_service_name"</span>, value, <span class="string">"default"</span>);</span><br><span class="line">    ALOGI(<span class="string">"Using HWComposer service: '%s'"</span>, value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWC服务分两部分：</p><ol><li>可以执行程序<code>android.hardware.graphics.composer@2.1-service</code>（在目录/vendor/bin/hw/）</li></ol><p>其main函数如下，通过defaultPassthroughServiceImplementation函数注册IComposer服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hardware/interfaces/graphics/composer/2.1/default/service.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// the conventional HAL might start binder services</span></span><br><span class="line">    android::ProcessState::initWithDriver(<span class="string">"/dev/vndbinder"</span>);</span><br><span class="line">    android::ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line">    android::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// same as SF main thread</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> = &#123;</span><span class="number">0</span>&#125;;</span><br><span class="line">    param.sched_priority = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, SCHED_FIFO | SCHED_RESET_ON_FORK,</span><br><span class="line">                &amp;param) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Couldn't set SCHED_FIFO: %d"</span>, errno);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;IComposer&gt;(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应.rc文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service vendor.hwcomposer-2-1 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.graphics.composer@2.1-service</span><br><span class="line">    class hal animation</span><br><span class="line">    user system</span><br><span class="line">    group graphics drmrpc</span><br><span class="line">    capabilities SYS_NICE</span><br><span class="line">    onrestart restart surfaceflinger</span><br></pre></td></tr></table></figure><ol start="2"><li>实现库<code>android.hardware.graphics.composer@2.1-impl.so</code></li></ol><p>hwc的执行程序中，注册的IComposer，将调到对应的FETCH函数，FETCH函数实现及是so库中。FETCH如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IComposer* <span class="title">HIDL_FETCH_IComposer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span> = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGI(<span class="string">"falling back to FB HAL"</span>);</span><br><span class="line">        err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        ALOGE(<span class="string">"failed to get hwcomposer or fb module"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HwcHal(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FETCH函数中，才正在去加载Vendor的实现，通过统一的接口<code>hw_get_module</code>根据IDHWC_HARDWARE_MODULE_ID去加载。加载完成后，创建HAL描述类似HwcHal。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HwcHal::HwcHal(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>)</span><br><span class="line">    : mDevice(<span class="literal">nullptr</span>), mDispatch(), mMustValidateDisplay(<span class="literal">true</span>), mAdapter() &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> majorVersion;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;id &amp;&amp; <span class="built_in">strcmp</span>(<span class="keyword">module</span>-&gt;id, GRALLOC_HARDWARE_MODULE_ID) == <span class="number">0</span>) &#123;</span><br><span class="line">        majorVersion = initWithFb(<span class="keyword">module</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        majorVersion = initWithHwc(<span class="keyword">module</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initCapabilities();</span><br><span class="line">    <span class="keyword">if</span> (majorVersion &gt;= <span class="number">2</span> &amp;&amp; hasCapability(HWC2_CAPABILITY_PRESENT_FENCE_IS_NOT_RELIABLE)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Present fence must be reliable from HWC2 on."</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initDispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是FrameBuffer驱动，通过initWithFb初始化。如果是HWC驱动，通过initWithHwc初始化。我们需要的是HWC2的接口，如果不是HWC2的HAl实现，那么需要做适配。</p><hr><h2 id="Client和Server的通信"><a href="#Client和Server的通信" class="headerlink" title="Client和Server的通信"></a>Client和Server的通信</h2><p>SurfaceFlinger和HWC服务之间，很多函数，并没有直接的调用，而是通过Buffer的读写来实现调用和参数的传递的。所以，Client端和Server端通信，基本通过以下相关的途径：</p><ul><li>通过IComposerClient.hal接口</li><li>通过IComposer.hal接口</li><li>通过command Buffer</li></ul><p>Server端回调Client端，通过IComposerCallback.hal接口。</p><p>hal接口的方式，其本质就是Binder。又加了一个command Buffer的方式，其实这是为了解决Binder通信慢的问题。</p><h3 id="HWC2中Fence的更改"><a href="#HWC2中Fence的更改" class="headerlink" title="HWC2中Fence的更改"></a>HWC2中Fence的更改</h3><p>HWC 2.0 中同步栅栏的含义相对于以前版本的HAL已有很大的改变。</p><p>在 HWC v1.x 中，释放Fence和退出Fence是推测性的。在帧 N 中检索到的Buffer的释放Fence或显示设备的退出Fence不会先于在帧 N + 1 中检索到的Fence变为触发状态。换句话说，该Fence的含义是“不再需要您为帧 N 提供的Buffer内容”。这是推测性的，因为在理论上，SurfaceFlinger 在帧 N 之后的一段不确定的时间内可能无法再次运行，这将使得这些栅栏在该时间段内不会变为触发状态。</p><p>在 HWC 2.0 中，释放Fence和退出Fence是非推测性的。在帧 N 中检索到的释放Fence或退出Fence，将在相关Buffer的内容替换帧 N - 1 中缓冲区的内容后立即变为触发状态，或者换句话说，该Fence的含义是“您为帧 N 提供的缓冲区内容现在已经替代以前的内容”。这是非推测性的，因为在硬件呈现此帧的内容之后，该栅栏应该在 presentDisplay 被调用后立即变为触发状态。</p><p><strong>Notes:</strong> 关于Fence同步机制需要单独拎出来梳理学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载夕月风大佬博客： &lt;a href=&quot;https://www.jianshu.com/p/824a9ddf68b9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/824a9ddf68b9&lt;/a&gt;&lt;br&gt;参考Android P AOSP源码添加修改部分内容&lt;br&gt;参考源码： &lt;a href=&quot;http://aosp.opersys.com/xref/android-10.0.0_r14/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://aosp.opersys.com/xref/android-10.0.0_r14/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>智能健身车</title>
    <link href="https://alonealive.github.io/Blog/2020/04/01/2020/200401_diary_exerciseBike/"/>
    <id>https://alonealive.github.io/Blog/2020/04/01/2020/200401_diary_exerciseBike/</id>
    <published>2020-04-01T13:32:00.000Z</published>
    <updated>2020-07-16T13:57:25.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。<a id="more"></a></p></blockquote><blockquote><p>但是提到顽鹿竞技、zwift，就有很多骑手会用骑行台、自己的自行车等设备在家模拟骑行，智能健身车目前的方向就是将这些一体化，而且更偏向智能、简约、便捷。</p></blockquote><h2 id="智能健身车"><a href="#智能健身车" class="headerlink" title="智能健身车"></a>智能健身车</h2><p>智能健身车可以具备接入互联网（一般都是通过蓝牙）、能够进行独立数据采集处理运算能力的健身车。也就是说，健身车成了像手机、智能手表等等一样的智能硬件。<br>当下的智能健身车一般会具备以下智能体验，最起码包括：</p><ol><li>运动数据检测以及采集、运算、反馈的体验（比如说心率、踏频这些运动数据的获取）；</li><li>在线社交的体验，比如国内的顽鹿竞技，国外的zwift，健身车可以通过蓝牙连接到这些APP，通过数据的传输，模拟骑车，而且能够多人一起竞赛；</li><li>自动调节阻力，能够根据路况调节阻力。</li></ol><h2 id="两千内的智能健身车"><a href="#两千内的智能健身车" class="headerlink" title="两千内的智能健身车"></a>两千内的智能健身车</h2><p>这两天一直想入手一辆智能健身车，下班之余可以在家运动运动。通过一些模拟骑行APP更有趣，边骑车边玩游戏，和VR眼镜打游戏一样，让运动更加游戏性。在网上查了资料，比较倾向于2000以内的几种款型，以下这三种：骑纪智能健身车、小米NEXGIM智能健身车、顽鹿健身车。</p><table><thead><tr><th align="center">-</th><th align="center">骑纪智能健身车</th><th align="center">小米NEXGIM智能健身车</th><th align="center">顽鹿游戏功率健身车（京东众筹）</th></tr></thead><tbody><tr><td align="center">价钱</td><td align="center">1578</td><td align="center">1699</td><td align="center">999（众筹活动）</td></tr><tr><td align="center">尺寸</td><td align="center">长86<em>高110</em>宽44，折叠后长63<em>高54</em>宽44</td><td align="center">长88<em>宽50.5</em>高121</td><td align="center">长85<em>宽54</em>高127</td></tr><tr><td align="center">电源</td><td align="center">插电</td><td align="center">插电</td><td align="center">内置两节5号电池</td></tr><tr><td align="center">重量</td><td align="center">N/A</td><td align="center">28kg</td><td align="center">25.1kg</td></tr><tr><td align="center">阻力</td><td align="center">精密电机磁控,32档智能阻力控制，自动换挡，根据上下坡度自动调节</td><td align="center">自动调节电机阻力</td><td align="center">磁控阻力调节，非自动换挡，8级速度档位匹配</td></tr><tr><td align="center">蓝牙</td><td align="center">智能蓝牙5.0</td><td align="center">蓝牙</td><td align="center">普通蓝牙连接</td></tr><tr><td align="center">心率测量</td><td align="center">有</td><td align="center">无</td><td align="center">N/A</td></tr><tr><td align="center">踏频记录</td><td align="center">有</td><td align="center">测量踩踏功率</td><td align="center">有</td></tr><tr><td align="center">静音磁控</td><td align="center">有</td><td align="center">静音</td><td align="center">有</td></tr><tr><td align="center">实时功率</td><td align="center">有</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">功率精度</td><td align="center">N/A</td><td align="center">50W以上&gt;=90%</td><td align="center">50W以上+-5%</td></tr><tr><td align="center">车身</td><td align="center">车把角度可以调整</td><td align="center">多功能控制旋钮，手动调节阻力大小、档位高低、，可查看时间、扭力、功率、踏频等</td><td align="center"></td></tr><tr><td align="center">飞轮</td><td align="center">全包金属</td><td align="center">全包活飞</td><td align="center">全包</td></tr><tr><td align="center">传动方式</td><td align="center">N/A</td><td align="center">皮带传动</td><td align="center">皮带传动</td></tr><tr><td align="center">游戏模式</td><td align="center">自己微信小程序、zwift,Kinomap,Ride Social,Trainer Road,FulGaz，顽鹿</td><td align="center">zwift,顽鹿，自己的APP-NEXGIM</td><td align="center">顽鹿、zwift</td></tr><tr><td align="center">其他</td><td align="center">卡路里、距离、速度，智能芯片手动升级，可折叠</td><td align="center">N/A</td><td align="center">坐凳可以前后调节</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。
    
    </summary>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/categories/diary/"/>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Android 两种实时获取FPS的方法</title>
    <link href="https://alonealive.github.io/Blog/2020/03/31/2020/200330_android_getFPS/"/>
    <id>https://alonealive.github.io/Blog/2020/03/31/2020/200330_android_getFPS/</id>
    <published>2020-03-31T15:32:00.000Z</published>
    <updated>2020-03-31T13:27:43.706Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过ADB命令实时获取FPS帧率有两种方式，一种是<code>dump gfxinfo</code>，一种是<code>dump SF --latency</code>。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。<br>如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。</p></blockquote><a id="more"></a><h2 id="dumpsys-gfxinfo"><a href="#dumpsys-gfxinfo" class="headerlink" title="dumpsys gfxinfo"></a>dumpsys gfxinfo</h2><blockquote><p>dumpsys是一款运行在设备上的Android工具，将 gfxinfo命令传递给dumpsys可在logcat中提供输出，其中包含各阶段发生的动画以及帧相关的性能信息。但是gfxinfo不统计SurfaceView。</p></blockquote><p>步骤：</p><ol><li>打开开发者选项中的HWUI呈现模式分析，选择“在adb shell dumpsys gfxinfo中”</li><li>在需要测试的界面获取包名，可以使用dump SF/activity获取</li><li>清空后台任务，操作UI滑动，然后执行获取<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt;</code></li></ol><p>framestats信息和frame耗时信息通常为2s收集一次（一次120帧，一帧16ms，耗时约2s）。如果要重置所有计数器重新收集帧率数据，执行<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; reset</code></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>例如测试我的设备一加六滑动桌面的帧率，执行上述的前两步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity top|grep ACTIVITY</span><br><span class="line"> ACTIVITY net.oneplus.launcher&#x2F;.Launcher 5f5af6c pid&#x3D;4077</span><br></pre></td></tr></table></figure><p>然后滑动桌面执行<code>adb shell dumpsys gfxinfo net.oneplus.launcher</code>，获取到128帧的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt; adb shell dumpsys gfxinfo net.oneplus.launcher</span><br><span class="line"></span><br><span class="line">Applications Graphics Acceleration Info:</span><br><span class="line">Uptime: 594308934 Realtime: 1044551416</span><br><span class="line"></span><br><span class="line">** Graphics info for pid 4077 [net.oneplus.launcher] **  &#x2F;&#x2F;表明当前dump的界面和进程ID</span><br><span class="line"></span><br><span class="line">Stats since: 573121582148193ns</span><br><span class="line">Total frames rendered: 17625  &#x2F;&#x2F;本次dump搜集了17625帧的信息</span><br><span class="line">Janky frames: 1735 (9.84%)  &#x2F;&#x2F;有1735帧超过了16.6ms.卡帧率是9.84%</span><br><span class="line">50th percentile: 6ms </span><br><span class="line">90th percentile: 16ms</span><br><span class="line">95th percentile: 20ms</span><br><span class="line">99th percentile: 38ms</span><br><span class="line">Number Missed Vsync: 72  &#x2F;&#x2F;垂直同步失败的帧</span><br><span class="line">Number High input latency: 8269  &#x2F;&#x2F;处理input时间超时的帧</span><br><span class="line">Number Slow UI thread: 482  &#x2F;&#x2F;因为UI线程的工作超时导致的帧数</span><br><span class="line">Number Slow bitmap uploads: 101  &#x2F;&#x2F;因为bitmap加载耗时的帧数</span><br><span class="line">Number Slow issue draw commands: 31  &#x2F;&#x2F;因为绘制导致超时的帧数</span><br><span class="line">Number Frame deadline missed: 544</span><br><span class="line">HISTOGRAM: 5ms&#x3D;7576 6ms&#x3D;2645 7ms&#x3D;1902  ... &#x2F;&#x2F;直方图数据，表面耗时为0~5ms的帧数是7576，同理类推</span><br><span class="line">......</span><br><span class="line">Profile data in ms:</span><br><span class="line"></span><br><span class="line">net.oneplus.launcher&#x2F;net.oneplus.launcher.Launcher&#x2F;android.view.ViewRootImpl@3b33fe6 (visibility&#x3D;0)</span><br><span class="line">DrawPrepareProcessExecute</span><br><span class="line">6.940.402.691.70   &#x2F;&#x2F;四个加起来小于16.6ms属于正常的一帧，超过则是jank（丢帧）</span><br><span class="line">2.860.355.192.36</span><br><span class="line">2.550.321.100.98</span><br><span class="line">2.770.341.391.49</span><br><span class="line">2.160.311.381.34</span><br><span class="line">2.320.301.090.66</span><br><span class="line">2.050.251.040.83</span><br><span class="line">2.130.251.041.16</span><br><span class="line">1.990.301.111.51</span><br><span class="line">3.090.443.012.22</span><br><span class="line">2.340.722.401.68</span><br><span class="line">2.280.362.491.84</span><br><span class="line">2.580.482.901.64</span><br><span class="line">2.310.402.131.78</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>Draw：构建java显示列表DisplayList的时间，也就是执行每一个View的onDraw方法,创建或者更新每一个View的DisplayList对象的时间。</li><li>Prepare：准备函数的执行耗时</li><li>Process：小号在Android的2D渲染器执行显示列表的时间，view越多，要执行的绘制命令就越多，耗时越长</li><li>Execture：消耗在排列每个发送过来的帧的顺序的时间.或者说是CPU告诉GPU渲染一帧的时间,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复。所以这个时间，一般都很短。</li></ul><p>Draw + Prepare+Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保存每秒60帧。</p><h3 id="参数framestats"><a href="#参数framestats" class="headerlink" title="参数framestats"></a>参数framestats</h3><p>如果需要获取详细的帧信息，可以使用Android 6引入的新参数framestats，执行<code>adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats</code></p><p>结果会打印额外的信息，以CSV格式输出。每一行代表应用程序生成的一帧。每一行的列数都相同，每列对应描述帧在不同的时间段的耗时情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---PROFILEDATA---</span><br><span class="line">Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,</span><br><span class="line">0,594399833469194,594399833469194,9223372036854775807,0,594399833992420,594399834015180,594399834093462,594399835255753,594399835397316,594399835719034,594399835808878,594399836632628,594399837228514,96000,146000,</span><br><span class="line">0,594429840570165,594429840570165,9223372036854775807,0,594429841649231,594429841736940,594429841741471,594429842202356,594429845314544,594429847401106,594429847993190,594429853626210,594429854321679,264000,326000,</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解析：</p><ul><li>flags：FLAGS列为’0’的行可以通过从FRAME_COMPLETED列中减去INTENDED_VSYNC列计算其总帧时间。如果非零，则该行应该被忽略，因为该帧的预期布局和绘制时间超过16ms，为异常帧。</li><li>*IntendedVsync：帧的的预期起点。如果此值与VSYNC不同，是由于UI线程中的工作使其无法及时响应垂直同步信号所造成的；</li><li>Vsync：花费在vsync监听器和帧绘制的时间（Choreographer frame回调，动画，<code>View.getDrawingTime（）</code>等）；</li><li>OldestInputEvent：输入队列中最旧输入事件的时间戳，如果没有输入事件，则输入Long.MAX_VALUE。此值主要用于平台工作，对应用程序开发人员的用处有限。</li><li>NewestInputEvent：输入队列中最新输入事件的时间戳，如果帧没有输入事件，则为0。此值主要用于平台工作，对应用程序开发人员的用处有限。然而，通过查看（FRAME_COMPLETED - NEWEST_INPUT_EVENT），可以大致了解应用程序添加的延迟时间。</li><li>HandleInputStart：将输入事件分派给应用程序的时间戳（deliverInputEvent函数）。通过查看这段时间和ANIMATION_START之间的时间，可以测量应用程序处理输入事件的时间。<code>如果这个数字很高（&gt; 2ms），这表明程序花费了非常长的时间来处理输入事件</code>。例如View.onTouchEvent（），也就是说此工作需要优化，或者分发到不同的线程。请注意，某些情况下这是可以接受的，例如发起新活动或类似活动的点击事件，并且此数字很大。</li><li>AnimationStart：运行Choreographer注册动画的时间戳。通过查看这段时间和PERFORM_TRANVERSALS_START之间的时间，可以确定评估运行的所有动画器（ObjectAnimator，ViewPropertyAnimator和常用转换器）需要多长时间。<code>如果此数字很高（&gt; 2ms），请检查您的应用是否编写了自定义动画以确保它们适用于动画。</code></li><li>PerformTraversalsStart：计算<code>PERFORM_TRAVERSALS_STAR-DRAW_START</code>，则可以获取到布局和测量阶段完成的时间。（注意，在滚动或动画期间，希望这应该接近于零）</li><li>DrawStart：performTraversals的绘制阶段开始的时间。这是录制任何无效视图的显示列表的起点。这和SYNC_START之间的时间是在树中所有无效视图上调用View.draw（）所花费的时间。</li><li>SyncQueued：同步请求发送到RenderThread的时间。如果此时间和SYNC_START之间的时间很长（&gt; 0.1ms左右），则意味着RenderThread忙于处理不同的帧。在内部，这被用来区分帧做了太多的工作，超过了16ms的预算，由于前一帧超过了16ms的预算，帧被停止了。</li><li>SYNC_START：绘图的同步阶段开始的时间。如果此时间与<code>ISSUE_DRAW_COMMANDS_START</code>之间的时间很长（&gt; 0.4ms左右），则通常表示有许多新的位图必须上传到GPU。</li><li>IssueDrawCommandsStart：硬件渲染器开始向GPU发出绘图命令的时间。这段时间和<code>FRAME_COMPLETED</code>之间的时间间隔显示了应用程序正在生产多少GPU。像这样出现太多透支或低效率渲染效果的问题。</li><li>SwapBuffers：eglSwapBuffers被调用的时间。</li><li>*FrameCompleted：帧的完整时间。花在这个帧上的总时间可以通过<code>FRAME_COMPLETED - INTENDED_VSYNC</code>来计算。</li></ul><p>这些数据可以直接通过修改开发者选项的HWUI呈现模式分析为<code>在屏幕显示为条形图</code>，如图：</p><p><img src="hwui_framestats.png" alt="帧率条形图"></p><hr><h2 id="dumpsys-SurfaceFlinger-–latency"><a href="#dumpsys-SurfaceFlinger-–latency" class="headerlink" title="dumpsys SurfaceFlinger –latency"></a>dumpsys SurfaceFlinger –latency</h2><blockquote><p><code>adb shell dumpsys SurfaceFlinger --latency LayerName</code>命令主要用于获取游戏/视频应用的fps数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">16666666</span><br><span class="line">597043335926672597043380168807597043346611672</span><br><span class="line">597043352801411597043396837974597043363218234</span><br><span class="line">597043368960943597043413558338597043379891672</span><br><span class="line">597043385568078597043430198078597043396569641</span><br><span class="line">597043405252505597043446885266597043413698495</span><br><span class="line">597043421909328597043463546203597043430320943</span><br><span class="line">597043718620370597043747090734597043725964432</span><br><span class="line">597043729160422597043763770213597043730802818</span><br><span class="line">597043745858911597043780445786597043747847765</span><br><span class="line">597043758497193597043797131620597043764349745</span><br><span class="line">597043775327557597043813810786597043781148963</span><br><span class="line">597043791070734597043830486880597043796912974</span><br><span class="line">597043808038338597043847152140597043813671047</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>第一行数据，表示刷新的时间间隔refresh_period，我的机器打印出来的间隔期是。即Dump SF里面的VSYNC period。<br>剩下的127行（127帧）数据分为三部分，每一列表是一种类型。</p><ul><li>第一列：表示应用绘制图像的时间点</li><li>第二列：SF将帧提交给H/W(硬件)绘制之前的垂直同步时间。</li><li>第三列：在SF将帧提交给H/W的时间点，算是H/W接受完SF发来数据的时间点，绘制完成的时间点。s</li></ul><p><strong>计算方式：</strong>一般打印出来的数据是129行（部分机型打印两次257行，但是第一部分是无效数据，取后半部分），取len-2的第一列数据为end_time，取len-128的第一列数据为start_time。</p><p><code>fps = 127/((end_time - start_time) / 1000000.0)</code></p><p>除以1000000是因为命令打印出来的是纳秒单位，要转为毫秒进行计算，127就是因为命令一次打印出来127帧的数据而已。</p><ul><li>参考：<a href="https://blog.csdn.net/itfootball/article/details/43084527/" target="_blank" rel="noopener">https://blog.csdn.net/itfootball/article/details/43084527/</a></li><li>参考：<a href="https://www.jianshu.com/p/6c0cfc25b038" target="_blank" rel="noopener">https://www.jianshu.com/p/6c0cfc25b038</a></li><li>参考：<a href="https://blog.csdn.net/luoshengyang/article/details/7846923" target="_blank" rel="noopener">https://blog.csdn.net/luoshengyang/article/details/7846923</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通过ADB命令实时获取FPS帧率有两种方式，一种是&lt;code&gt;dump gfxinfo&lt;/code&gt;，一种是&lt;code&gt;dump SF --latency&lt;/code&gt;。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。&lt;br&gt;如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>想把我唱给你听</title>
    <link href="https://alonealive.github.io/Blog/2020/03/26/2020/200326_diary_our/"/>
    <id>https://alonealive.github.io/Blog/2020/03/26/2020/200326_diary_our/</id>
    <published>2020-03-26T12:32:00.000Z</published>
    <updated>2020-03-26T14:33:42.138Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码，查看文章</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="7169b08079e7fa2b8dab9e78959a48d7535e82adca521f2cb422eb645699111f">37fb60dd34e7ed552175bb50ade7970d21da2c4342209e481bf7686949ef4d46b7df9287ee0998d84ea4aed811dcfcc9ed551aeb3226fc1c426207bf595d8c75526882441e35874992132ac6daa6af343b8e71ac5aebea49cd8a472efd24c592bbb931eb82be6882de5483c02987a34ae6fae2198ae9a934ea2832acd2405e927e3d713da80d5f04cb1d58022cbf16b84e7f3f6a6f9011834af8995f5ef4e5f32264251ba7eaa1defb27ed4749a2d4bf8561f4c6feed09ea843a37e137095f0a7fdf096359d225781d2cad0bc92af5886daad8a1bbe0e160477a6582424e90fc28edb4e4e24890864f9064da6d257d0717cdcf4330832175f4e6a3bd1d10d1c67cff6aa2c0a7b5ce53d274184b62d84240b894d60bb67c9e8dbe5244323cb8fc56d671ef8d9c1fa1edaee6963fa1999892775cf4ea8e8969de37c62300895897ed1f21bbab97e4ba0aa1c4ad318095d08b6123d5636101aa6428fb6567813b48ba8734c222d8514172eb76ccf4fecda11f84705719eb2a29ab76a6a576c183b6234ebc1404dd325d38bfc7a0e884fe867cb38278f8c5e1f975682e447375d649270aca7c12bd4db48ab266b25fdee8c8c1b0d3da7c863ec1b396e12601501f726ccf5cbb3b61fac74b97d50bf6decf9560b694e4b90a38ba43088680391a5c9494655d8f5eb245fbe978bb641d855007fc961f6b30acf479d01bc3f5a22c6b1b2cab4fe3cf334a02df9d777014533e536a9286290849a960658edbf72115f13c2154b57b99d88075f495d8752bbd1128c152f0e3370b3820374d510f66a494337e9eb11d1799044cf8ef6704ef2a74dbf4dc769b412adff5af89f94aef5025c859dc317fd9611e61c19f4daa273707327c5c1bc532d99866c20518c2ba075b8d19cff9fd896e1782364da145990811445cad47227bd7e5733173aee525b42b3ea66dd6ca35d3a4ab31dcf8f823ead26e9f862d9efb54317df9a1ef811b33278998cff66f17172b349440ed7f1b97f76ce3604edf14b375521890ec12abf5b16dd7d0c2925ca9f2edb58a35350e40493c90f3d168267b4760927cae8054f1f6f7935dc335df4600efb3fcb2f6ed7ad1798a9a1621369efe694762dc58225793d66aaaba3edc3213cba57a01008328b91c342714f65126a70a0239675c851fea2b7fc530d86a56be782e1bbe5d635e38181d74a89a26bfb36ac550b4722662f614f83e070899ac85f41b2bb64370a9d35cf532742169a503d018f85120214733fec7c017b81f3130aeb3b189bbd223fc49ca14607cf7b5842c3a5a2944e687d5143be7d46b53def4cfbca477936d55976f234c5d2432b6d6d4f12722b1eeff678af4524e3ddfa25726261721341026a2ad70301e90d7eaada5fd494184066ce01368d7f7e36e8899035b07390485d89bb62a8fc8abf4356cd78c8c53cf5eb35cb7d55972c285c092c0ab04bd0d9dfa78d1c527e8ea5e6f8758fc224fe156bc59731d8eb883d643217ba2a78f5c84730fc9be36cbb443218353f8093555188c6001dd3a0b0247b2b2c371ad86a362364887f39cd2952a2cb2cc3787c9f9cae0b0044bf4e37e28df5a8277c1adc15cdea696769d0c813b1520145d544fb5b71ad0d5c1120bfc6cae641a23dcd462aa8e8e5a7b53401e191ea9eb54edc0c9b8cd65877775530a6c4b2bcd8eecf38b7f6674a787db318e065bbe23dcf89b625923b948bf56465a3e4cec71bfcc7d4d61019e267489cb973d68b62e6d41983ffaf2a5c33fac2c0a7a9fd1abea0b06ad4f0db3b71897ca3a5e91eebebc58b3a9390be4e6856509d2b5b6202da6b5867f773ce1b80569b70825e37349321bdf63ba96e6ee4a7e51c1781a73e795408b69a7550b63167d82abd0c392777542e1a09f671776c7c16f9139f8e89dee74627a35c52cfb01f829fee6fdf87fe9ceb7f3ebd8031fdff79812fee6e1ef6a8ebe9ceb42e74fda5b68bca331ccd1d4a155bb932d62c568ddbc1646cd06653aaa03d87a018a5b782a20ace6a57dddb8c919ffc160e4be11bbfd5d6142faaf0038cc3e109cd788bc6dcfad3424abe9d404fd3790e9cce2541d5006dbb098a98848bca1a5928c271aefb382ee7f9561c9be10329affc067f5aec03c85409d458e36ec507a63d822f88b294ca3b42ceb0550b9a7882494215d1ea192598327a1855bde6098741cbd0419584b675bae1d5e03e04d78680f74792fb37854de8628930889aa4561e5c148c625c2775b4a28bd99df94747e3b3e1282355a083d85fb3fb71fff6ff2610c416324b541cae3cedccb2bd811c4e25fd8bc2be09bc6aba77448e697b8223170bb70f3411ff411b2da8ca67674cc1b3cf9d0ef6ef47299ffc030e6abaa08a44a28bbf5e9e59f1b8537aa77fb12f5cf728991cad2c0e1dd04ee16ed82521e6a75b6cd8b122e6dfe554151cee41806584f06b49d5ff51a04117745bd9d66bfe1a71c8230192b5b6c3d4c20c1e78340fa2e23732c7711d74b85d773e91a5ad2a37886ddf37274071a60fae36cda20304a026b5f63d3ea960cf18751fed58a36b8cb2d8c8f393c7e35acd61ae72bb488fe37277b18fc0aa116dd52644d0cc291a02650f2ffda4b1f243a708102801a29d8a0c55858ebb255c3f655b6da56b74432143774edc2840589ac73a0e978b124620f9d0ac550048b0e0c1ad91679631231bac07ea04b7a00d94222d9b1fded1a91389da40473f88d92fabb8bf5f187993d29941fb378bdfd0fdcbab10125681845fb2e80805d58fa172ad50fa16b6165b5dbca38f30ec09f904b8dad0df955b1d76c7fe9fcc91540ec8496780d98638ad790af09919a0f88d1376ae975e05d0737dac0a0003d368e669cd12cd51d9f745bfb75bcbfc05870446064c781203bbceefbf70e23e673b063f973da80cc4cef7b38b9482d426b98cdf96fcb83f988c4ed8356ea245ca74bdff5a7f8ead98365e0716835cfee243f3647eb1c21fa8f3a726619a9cba8ca7e4e3462e7951cd5356e0dad399fea4014dfe1a2ffb358fb1d807924defc12cfc4e850a3edb38777a47018d61b624ceef2b6141d01afdc708d524f2952a5f57dc982297d86239c071daa962a6acbf137a93586d9867629ee1ccd6b93b30bde88fea2b275da06a7d8030adcb7eb9abf545a208ffbcf73ee5c466bd380b8e430110c7ec108f4caeb011a05aa0c61c73370699ca8a87da4ce9a8889ba941bef586596a115e53e11a125b8cfe4cde4105eec37a37ed392ab220aec1fda6a9a701911c8de345d6cc1f4289fb8facd33451c404184ef244a1c7513ec0a209bd0cae0ef22021e48cb1a8511f37f31884aa27595e779190a397c7afbbb4faa4862460509d4aabc22fcf03b0779fb19828cd383ca70cfaa44a693202457ae8d447abf4dc4bd3caccf8e6f81bf39a712ee0418927c416e9ef402d1a95a0262cf3191cc921d78a86c9a291f7ffe3d5e774767c6144dca2cd92df4a70f4bb4073bee29ea23b39598d770824f8f24975ddec1f362168554b222e6faac5dd983b8cbc591e3a63cf7cd87d29964da694a6cd775fba31a6e4daca20f594a500189b4f3fa4e21835649383278e983fe2e98349577ef859508447994762834b20da78839b975984ce3d34e44c71846dad17acb74c19634a1b91ebe3bb3e67097c3e660f7d62fc0a4f2e10d65a2c25c8d80e1aeef4f1fb372d93171721d7bbc9ab06e4b14db254ad9a0453f3d96ea9eaab1e3f247a886a47078176ab4611ffd8fcd4b6a36fa063746aaa368fc3950036e446abcc645c49d65388b4ef179146b81688711aa9e9548822fb4415bc3e1916df167a8e2f7189666a7c22920dcf36c31a5f9ed21272fe4b7f3dccb70b2369ff6b8df825074017b6eb6702d19254023cdbd1762f632df9e93d66d53c803039857dae28c9e217bef8a1b66307e26781d4d66823773fe95734b1e0448da1fc14ce217eb2a82d8704d95125956662704c00d319ba555a3cc555dce7d775d28db47e50043d4c1dbee294f908d2aa0f74d78d99f938d94c398fa7d8cc5af239c1a95f6e65bec080c3edede4036bb3cab3254138db44b051b59f4004ac3769fff170572f377143e7457a39324bf9038953d909762f59f500cb1d51bbdeb6616399d945c494c2bc1b7ca55afbeabd91badfbe5103aee1f4a34d09bf36928acd9f5d6c9a757e23b9e73d859cba7d2b37254a8ecbe17819ae3dbc2e22ee4dc2b47fece08af3ba0a8568aee9ce8e42973734c96db91aaf2ce5c6c1cd30b63bee512751e5b2954c8c2ea72cdd5c73b327dbd175607e4d065173679dde05d699e803cc2d3308b9810c8bc723fa82b453af8c1f20be4a85e43917a11004345dbdd984dbf6d44ab754efff8b5481fc664f98e067cf830b8029f28b0a96d510148dd55a219f2e0bda0e3d823d08de465db820331f28afedb62164017d7f055c76e5668f9ce218cc1b3a06ef581975417dc308960dbaab816f7d4d3364df25e9ee0e60bc453dc0b18ae05bb6153e022cac88ad1f051f06d84a13f76fa2e1db9cf5fa561f78b41b1365297b4d74a7832d93d71f8d2c8bc204bba9921527f1a2afbedfbd2e48dfccdadfef8b4e338ef3a67af78f9b148af758c873974a2754a231ca15f3e5d147844b7b6952b795dd8f4c8fec997a90e8fe9ab92b5fc896a1e46ef11d17b2e4fe08b2d9f8e7088da6fe0b19a81187630055ec44a60b2ecbe0d19e62ac9410ff3cfc46130b382890325abcedd33415bc4253d4674e07408a1bbb64ff7804fe03ca32fec282713212c0d27aae64bdf94d3efdbe1a710c3fceb22667b3c545966c4dfcf2c2cf9f4378dccb755f85a119c161317f67da2c7c81533550bf445d22e0cc659169db074503bf475b0c8b36ade953f396a04494991e38defcc1f204addca4792dcea8d944fef4c8fb5f0b02082d86b76c31f56b553f6f5ee4599a87e516a5d42d11c8e270e9f4fcab5bd5b4552bc3a49ec9e820420154fb1e99c6d442d4288a0f7825c82bd1214dbfc21c786b12238a2b27ee583d1ecbc2a6d1e06683005c9031c7c306d88949d4b199c91d26a704330ecb2d71d3222f74e2e9f14e73176ebc8e1334991eeb285d5875edafad40a853c47c35a4cf8b8cf7341369c70b9e6adfa3ed058276ff1ba031b15e7ec9862ad78a5bbefefc26cd9e486941df76b44d19dad7abdab51670f19a12cfb7c36dfd8622e9915c264c92c70e3e60312511104f8cfcbe89e48d82b57c631e3731e1701a837e0c05477bfc4d32d67402a766f86ecdb71beef49153cbf9a536951ec917a942360126f9513c8f5ab2a4a8557e7a81ce72d0a68f375916a8c476edd957490e0e88799a3933b8430c78a253552b33d9129afbb4be6acf410f7e3b6f5dfc85e53a252ffb8bae8312df57bc0bcfc22acce67f419f2ee0d833b9f2edbc6f379c6cf489cb208233e641858efc4bc9493934a3e734e3f2c5c55c60bbfabc73acc866b72906d5375b085a6ee06eb0610d59c4372f1508b56ca21ac9a9a729ddc517e110647094a5a0bba5de368e3821e7140d3a994583cf36374cfd6856f317c7cee05eee84b2c46c06ecc2b94b7e59c2d78b59775e36b58abe66e549a499667105c47d61c153483a41b7ce871d15a41f3c6dca365e6e522669ca555ee09cb635c9b875b60f3e1462b2746f630ff31f672961a668553296ff7eadb1a84bfa9b89eaf51ec3b7be06281514451e55f6bd43592b019e4816d31a8dca90f04c670b5bf0408f03ea26ff8289bbf6edd1442bd4844277c0cff7d9c1322541196e1ed67210f940bf8a1a83bec422d171b180dac6ce784a8c9e8d0435537cea3cf23f0c2e41c4339f1023be020d4294b0b984b105160940a468e5173981adeec3f1c974176386fe8941fbb44c6163aac22aa511a05afd266ee02b58b638d8d0c10c9d39ab19c5d2534cbdb0b182eaf789eba0486fdfe314282c2134da46e06e663471cdf10bce329db2e5ba658cc78a08c4d2d3b6f9baf4062ebc373e1a60874a2432914f191c8613e548ebc2f6e46f1e4b5f1e595aecdc0fa67a6bfc6b73c26ca7bc14384970c6b7dcd1742c8af2a1197bacbb6bf96a660598cb83659b8fcb61533c21ca82162b2238ef8a93c72982698560f2e855e9667be22c13d8f9f4bb262a691120c0becf62e15ac92c388fc72d53bfa0500504f68b7268dcbb70d456c1f010bc99395debddc1fb92d877fd0b0161d13a2813f982471ff543ef1a0db3787dc4b004b7797cdb7cb186642435dd22b7a9fed5afffbe85c1265b5298c376209be3e1e217b90ab310f1e0b9a520fdb4c257a7d8fd033107005028596ba038556452a918ed2b0f96cdde16e619ba22b9613bec36c1f6ad420a4d7708782b3dc2ca9b34861835c4180031a8bd023e99216c10acc2f7e003dd506a17c5daaa3571921f0f7c7343d1940a54eec9e8d5ffc6f1c54831f4bcdb3f3a8fd074e0951b1a134443d951ac5295adb96886971351f539698dc3a82d8a0b421f566f7b7818651fff767fd3e3159ba79d19e177f644a9e0f1e164bf87da7750340f178c4d33f0a4675fefbcd86d82e9a22e5e62475585ed75923ac09e736c07decf591cc1b9a60c2d521d2c1768a5f6cd7d81be2075e2e10c88dd2f413ab7d06c83423258b55c74185d676a24390c87a8f17e422d9902bb491728d56d0d2b01719e13c3fad6417eba4b5aa9a2bbace73b1afb50a1f8109a2804119923e47b108dbe15c5d49a54220787d4d6a12997d884ecab82be35e5951706ec88f7d104b46cbe7b105873a65840793ebe3af950b5c22392e2108647dfce18fc3c23465c9ffdf053428a17bb2d81280e84e0bb8b48d6ecca461b4039edf1c73c135b121c76faa170d1397706ae72234746e0184e6469017fdf9e0cf660ddfe1d986c89fb8bc791f1a0ac648385c6126395653dd6893ee6b3ba5ac9835d97dfb5b5e72ac6c399ba1acd410239cb70f2665fed4a3b581bec0167f083080a6890feb0b52303be1e6880e0947635fe3ec7d3ca76fc26069dd3cb06e50e0503fbb8c67d605569b7a50f44178532fbb560c110a4fb4aeb436772eb5d68fe210ea60c1c085b8de3b42897a057c2a615bc6008a0ec5e3f8ad9e8a615b6c4f2b43cd291328bfd0aee1895069c7c73ca5e59ed6bd2887c9436d22b000ad67409793d667bb293f14bd18bec7562950e3cf8bb36cb36aea4782fb37726fe0f628e68e0584bd0508ab865c8afec7119f265448697af423ce0dc9df9905db8a6d85ab7d8114246734a64dbb5f26e8d395286e1d050f30d8ba497f318da5c5e55f804205650d55b2f8651af4c25154d34ce2dea9af52516e49545708c10f1f9036696dffea0afcfde8776db3a289abbfcf4a1fae44a933f2b042e9ffd19f9d98946bd417113a2a4b4bcdb2483192f2977a62660904591f50e1041a1bfe4360bf1ff6c85ac6574f29fa25bc2edceed02cd3582cbd6fed1a6fe473a38f81982db6962029d7451030d104186142476ce569a0aba8cb69be0dee46598f56bb08e3197710bece1502251ac22c086a6fa406b2d48fcaf210b0426988ba4b6b21250cf4a75611f29285366b76230ab646e9017c05f83aebff7d7dfecaa56e50cf8b0c2495fcef87f919a3a99f9e882681f2f9e29b22468964f4f7f83c00eebcf52136975b5bc2501471175aa69b1df234908dd9fbba5e16406a03aefaf938859371d53be334a2da5a19b3e7006949c77b511c376c6243276c44a510d29eee5484e294cd91037dc1f4094bf23db75e2c114e4a7033f533f594e38d0c29bdeb2eb8093a6442c4bcc7811616e2fb0e1dc6c3c91ade2db3d808e0a50de4c2af6352b0d120c5f3e7e4270898f9b12b525510fd7e9768605e07513eea792b2c0826dcb385c875b8fb337835cb838632197903b575c0d8aed8757b8aa222d5f0ef93d1cfd4cfac678b7e94a6e7e82b44f85881e8528486e6f6d2f3d1e508387a44380e05aca955978486da3b594926f0f3c3496480af386243b2fbeb21fd5b077f05aee198ff927151150d0154ef909bf39e8f2f911e64678266843154a9a23c7fc8c78810e1a5714027868b58d68b8a7d02deebc221e46071898fafc3273b0c020d3bf8a7b3fb89c58f79f5deb32f47ff13ca8c02e875c70036ca6eaaf8efb50d2678ac7899609248457ae5a403532ca34462b406ab9f5a60c1cc32ca6340e820be08ffb80df7571276cbb27fee3910daaf555cd92b2e92b38f0f6c031ac0ef62b0bd22eef45de18c90ed27c1cdab0a38fb36b8266430d42d1ece77341a28db1b8a61b75b7c9f2083ab7782abc9eadb7bee8bbac5a31c4f883d851b07423c66d5daa0984343184e59fd64fd89d4692f912a61794d0e3de423f097bcbc89debbb1af10099e94d0bf97c51ee20041fe2e4561ec5c86963c77ef8c44cb0037d2b7e56fed371a31252b89e9b113a5d64d04e713aff295987d66ce8c957e6b8379c4ad148368c5376fac15c43a6eb1d476903c83eac372766f0f73eb522b404db7ab042c889a7dfb1ee57f6e071477ca1ad3873b595be641f62d7d585b068aa3155c41f409fee0347407c34681c77535cdc68bbdd8d0c4a315269f814b755419840142068266f8a749c6edaa801312c7a65a6019c331d24a77fb635c256b14d6461e1f70606d9598a7b3b6192d31f99b6332fd0cd0a6139b4bb490779ff87a7c97f767f8d429b62c3c81218820c46167790db23ad00da14ebdd38ed05bd3a6330fbd0b36c138909e410b2aa2b2f1eb79a0be48811f1525997bd03fea1260fa4c6abfc03bcf074cbd7ac7e96ea67e016d72bb28f9e30a268a10d939157cb1b9c67e52446d6fd27c433ea658387f80842266ee0b0c5bb6aff40d35d1aaab4313092e66f883f26c23cc3061c43d84d79075024016f2184eb434d778c892c7c9e65f0f346af9aa85471dfb8646dd6e190175750a261f81266f831f34a296836d8f11069d9665e332583cac6e67d7be7fae6db1a8f56800ea0351f639690218fe394df72c6c2ff6fb6c0955e384a6888a55622b634584428e3183ca14c5b3dbc4d27450eeb5c9f731fabe9ca9151e168ba36f9b10e002022e15ffd99e026c11f622ec26b10725a6cea2402688ae20b3aed2e52e3683b2b5ab7aaf4170e4587d9ef92bb2591acb128f0eff87bfb3518571d600e1aad3d0a2f133a19f6ec12651bbb61773753d17594ff86cdd5783b18ea23a5a6aa70a984e8491de9b207986fce6aac4c9792b3378e9119939e199859396bed31e52180e0010e2bce535fc4f526d29f0fd42181a0d18d5a33a4430df5471b40d41923a6ecbbd226de5045dd7019f266884726663f6683c8ad96930a221c04d8451889e85b5a15fb0be0305cf0beed68974937ba4dc9ab6583aa93aae00da4cfc5f38f914cca6c06d65cb8328505b98008e50d16b664579dac076e1e09576ae1fc820dca5fbd3c7419c0e8a7706b8672d767e7b5aa21d7e5218ec71d8a163be1aa271f11e4ad83ac8d112502baf2268e0d5aa4873c2e8468f5a604bafa8e03e9446b49ec5cdef721ee7d8a2730847729ce893ae5d57833434bdde77f9ee637048f3a08a3598d5930b8fa662bb2b10d92311c91805d23d90a104a8b0985621673d8478b5847bfdc8845aad7ccb2a1d7b0a603010a215755d8098ef3fc64c09878579617be817bbb513b6ef558809e8fec4ea4fa9767b308c179bcd4c19ce9f0ffc7fe89ab312adab3bbefbf0a948cab58b5dd6de935b617f9d69571629fa176e375584bf3e2d342a25ab3994744974f65a2d8327ed5705908e4e75146db42dc8bdfaac5a680410026f4cef5025ed4e89aaf8156160c7578576bd458ce5c4bfca3ffc2c3c05b2093717ca6485026a213415b2fc31fec294d28524f90ea36be60d9e27aab59caa2034351399cfcb9f160ad2e3b50efa6a55802c90a1f9852b52794b7fde1dab128815274f73efaecf4d9b51021da5e40478320ea31f98e47711845925e0ed9fcbe659593ffb6dfdd08f2fa641e94f98a5c5a3f393c53775986596141760423c2568fcbdd3c71d540b5e93ac36b597d1ed764e72bd8a834d59161bb550745ef9e6405926b82dff8e3d2d4510b2d35dd23e7547356615a4cbe219a92408372cc72a516823c22608500f18baefe43644b3287187c5af9766197871ab9d304d92251f479bd8884698e8f5376a3af26ac94ffd118ae04ebfd0086f02f68b098e2254506f1902c0fe2236c71e4a2eabc3e5470da25d9df196fdfee731b76993124c32abebb3aa1eee599150569b3d56dc6e1f8228cd4e99706a59983119cfd4f0b455bff9284bbc52b112f8dfded6af0f71fd2e199ed682b17cb40af4d7c792bbe4ff6c3316ad56dda668eebbbca8d7bddf98adb4ebe72041e92b5c290982af39da7923cebe8a42680418a7804cf93fd87d913adef124698cf4618736496fd05734e8ef6ccde825d5ff037c0147d2cb6fffc183e807ef755b87009cdf97df53bbd9bc5b9183120727ae663fee43f6619e99001d31aec52fb14ee60e05490a0589ab6437da6b3ad2f0dad918f45fbdc1950df6f7452d3d4698242b92780517ed2e033e1b78ae6d765cc720dfdd31d23546918cdd3db1161a1fd958ab51bc47e58f1ac1e708bb095d7c21a608df4966301fae804336bc71aa327448fb791e73dc98d69dbb68e3cb7614cf7c33b780b328a6ce394f2f2c3afc2f1468b8eddc620376c2baddd6cf67adec1093c2939fbe984fe8a835b2bd5afd98b16ab6e54ac0506db5a10e4e2e50e038692e7c6ce94a71065f4c70d98897dae5688a4cab95a6de33f66115a0119f859c7cdbe2e72994dff0b14c75835ee8def0c8eb0b92ae2cae8236073ce4972d192fd2dfe639ba4a2a61e1836c435f2170530b427c65288d34977c9176493dd25e4bdbfdc032e130261337828106a18708b2486d05db8d0c08619bcee81715210a7c7ef02010a092047c4db8747636a8195f4e2a7cfbd50492a77737220c5174ac38f80eacc1e73fbeba6e3e4697dcf4d0db28f26e0c822bd7f762ad4cee718fd04243bad1120df1d89b591390165123d898bd93ca8b6190e87e63f4b410c14473ba16eacc63ecf927944c2f25eebd129f5c3139f94a54a87b409c85c8b5edc2a870b74f4cdce84efe9eeb4308b83382f05cffb8baea2a787b2f802d0825b7b2d10ad2c0f871950d4b4b39bd1c12a0990024d775732ba096533f0272a448f912bc2707675313ea2765933dc6061f215213097233889a7f19b6a2ee19ee6835ffa6f95a8c950b0a5389490b1c77d29aea5ef8b53ab7cab0bdb7d27ae8a365f59fa71b310f7f72beaff26794282c535aeeea37790079cae1b109a14dac981227ef8cdad09b1fd9437f1b2ad895e3ecf905055431b7aa92ecb58906e8a776c7e89c8d2f79c43dd716e93d71ab2ab73a8ecb029ab8d1e71a4a3b28c1513c76963c75dd8a83130b05d2f6da1822f0b4733ad6e890e60d8aa7125f8ffca25a97f0244174fcebae2e991609a32244781398e5cf3ae186006209adf65303211a2c5a2354eca08c34af782f7d14dd4146c7199d37e48dfef97f0bf2421b26763887e3b0671b742aad004a9ff6f8fa3b696be9e236f7623df8c00d3a3368045d94f1f64783b6ac879d24d795f45275e2cf0086fa7a079ecf5c5542778db287121cf10828e17d0d5ea8320fd2c5488b56297b00edb4be69353377b3c09699ad80c9381ae3add3af9721bd87279d71b1425f2a16e642e973c0332655089e66319c7f1c88c142de06e4b06637ef5a879c9f013f82225b5d7f9bb7073f3994ce7d64274057c115b8f1029c663d39333d2b6da9e5396f4c2c9b4b199bd989335aedc35946fe18b4d9106125bc61864639f8ce01c631f09ca16be7e7b6c9edc682cf7e408c626305a3437eae5ec322299910409bb4597a18b0048785a1ca31e580bcc71cb336502cc9726b4ad7247001289d1ac4d6338097faa87c2068a229ae602b08725fd31b0b2c7a469d0e8ab08779a5c1b4b5f904c42192405abb426ad5b8b9994f12e956dc702412d8a9fae2ed4782f46e1db04e154fbdaafac1c627c65c2f5e8bf918c4026656de033cbd797f4ebb38b779f92c2009f478b6fab153299b303bd3e784955e991cd9e9a7d5b311794e64ebc50b121334c463afceddf85ce884673d03fbe78c60f40efed08c0f6807f031d5ccfc1fbea2b659daccce7b5192a80f17e7ebf21c3855e4dee3d8fc61e1e0caa9b783a3f4402dc326a75eaaa8108c52993f9bd1cf25b669c88fbee5b819770ce99f559a758aa426b300e97df59f0c896ac283234192d02fc1bcb59a9e57e8e1b756d264240ab2493a5052e82ca76238353b470f41086607ace8341f2c1bf4583c0b3e8f0269babe2968ffdb82b6d632bf9f052984b82c9121deab7330232fbf7fa127ca805894a3a7049ccfd0634be5437d1c15c8d101e57a032f319b34de475b57dda07a8b6901e5aada74bc790980d9b2b08a649926eaa3adc3b76d8314a15a7ed3a7bbfc8d1d31d5b39d0637b5193e372d0472469213b03f27d2eead4d2e0e06d521007dfede98f1f162e6c80ef8d3d6b31e1e2df70916c29a0485697a923cbdbccb478b1baf93d47bf06e13ea2a209c52505cc7bc48d8f2179bf8b93844462593ecbdc06cd43bebd313e32d6b6b74ed6fee6ef4f9062b6dab34272c9e1c99f9da24e7bb1a6c898c00fa55a94f2f5891f4f5d47e6245a060e6b15b8d1836e92560a8990c4f08ef88b54da97a12eeab71d34dbfa356c01895f1f5a4b2e151de649fb842ccd0713fc77af077d489671af267a754be2fab37de4aee886e0e23dc9bf4f00a8e2a2f81cf68b6652dada91d44ef02602fa3b6bbf4624028ecdbc6fcccdca9f1071d3f95d9dc2bb3a9cf4680be1bfbcdba759b3b7f06ed6df756029252aad00e483e013f11b081dc305f86cffb08199cdb91affd4f892232daee2e4d1235c2f3381681c6d3261809b1d3406cc081f186e9ff534e2168e745748fa34cc57b7ec1c713773089300a3fabd2504e67d87a8b68699b8da709fc2365931edaf36fb6eccdd815d84881f03f2139646a0de4e039536486bf309d5490c3f25b8be750cdec5846012b4ea460e0d44cdc35dfebaa4740015462f054732e5500f926301be2ef18a43e23e2770614d0e1324de8313969e51b500b1031815d076612ece4bc0c37996ae18ed23b63e63fb124c4bf2f64140405275952eb5c2c5e9666e91e8d6e7862bb8c55cf5510371ef1753bd52e8b38b577231c94d1f73da0c3320860b4fc3f95da12f173d272ad00cd1806b9ea53fefa714f12cc56369b3279585897e28736e9ad194e584880dbde7f18708a00645faef40e5c15adc8f572ef3aaea5734131e6016625bd7f7d092c3b90f6e36df661577643de15a7975190259636bc2a40d56de868be870f746918b2f2cb0ffc75f16bff63bf5808aaa101bd808c956ec7bb1135176734a1cd451e62db614c4ff6c5f621732a76ec79c17e399c1735db09d0e2b20b5348f8e0188b36b97e215bc96bb490048fa5c9c5e77493dca56b69a293b3749c0b7b189b990961f626dab9362f03fd4d0a24726043a83272c431a48ecc6fc3558890fab362debb7827fe59ce1fdd74c95511db52cb73d6d6f3b151fbba355870e325eb0de1eb8b9e48dc82893ca194b235a77a89084c09594bb8172467e1ccfd03cdec927a9be407cd05c95f63a116741d84d074b967c91bcabd30a806689c021042c63787a6bc08d09afb8d508c5f8ce1a98ec5e403290d7d0e5124cf31ae9d03ae9bd58adf3e4c6d8a524bac35036e9df5861c7133b1463b07f6db494ee57e34cd2a8585901f70e2e5b8a8300996df3214856f2b9893a8d47abc5cd873af74636294e6fabc7abcb7f47e5718f7883aaad8ca98e6e74044e4b9a73a92400d7b597563c6c73d52e3fc751d30e7bde213e5f89abfd54f09b3ce2ed4cb1d411dfa3a6fcda9924c855b52f88a2f9a9bd5564bf09926e7c6aa83efc9a1a50c71a15da4fbcfa47a2d17cbe779bf9af5d1c233e81a594b22c0cd33738af64e754766804a546006b5e22f64de1c1cfd406e90fb0c864bb3b59ff7a9477d09b3edebab0075899475b58fda544760ddcd56b2f8888ad38d65234990205fa36d1cf08f59d16d889a36c3788da8c3ab454b8dbb8875634c9c599428be93a641a8e09daa5c4e7944bb290ed58f4d521bba22e2c5b5824080f846be7de9b7e29940895d3372d941f43eec455b4969fc0ed34016649051d8ba31d1835afb979ae4bc343153cf6218a9c2352452549e6575c18d07e336108ef1673aae5ccbd15f5ada254423a397ce86ebbe6756a7067efa8e7d21c35f22c042cbfe2e8670e462753f56cd8392efab9520b3cb87dc97af758444503f24811bd9a610006dee0beb97de22a500acf2c5fc4c19747786080d5c9d8c15a094c3dcba701026ae5cdafb9f6cdd8ca2dc840a50191ec68e5efcd4754a9ae597dcb068a7c3e3a25b50488f0e4fb7c255d08918729a4902b89dc4f7d7bdd2981a619a8e1697cb4453ad3f6921f2f638d1991530f42bba6b1e22ec3735dd14e5dbc5683f3b2daafe0fda7436159e8c6f1876848b8d246c86fc8022d46131bd8e961115ae4278bbdc964722490a2dcd7bc273cfe11a62cd47e3c2660f7a397147e86500bcee14fe88c6d5d4939685b47e5a357bd07f455db03c6631fb6579decb1ab02ba6d5c87e718a217921531f7a18be62e9becf6deb591754adf51c28769123c455cb86a2cd05ea8ee3ff7cf1a2bef01712cef67719fd31252abed18dfc051dc0a6ff8f0f53e123706c81d11684a434ee52ea15b1f60bef8813fc8847227673505b343a8304d8698c2279c0c24d0c4dc85dcd3f564de14c0624007210e132ff5a338586afcbed59fa55479731a33c2dfc9ed0a36dbb51c1ef69faad881c5820575d92a49be77fee8085bb780225d758ff848ecc39d4673afb67279af0f50dd2d0d48de1570fd305c8eb146f71ecf4d8d7de92fa036fa1b52993772a1f5eab455be9f12d0b271940f0a611b5520c24ebee7827d690ab61607a1a5e1c5368de4ac00b4a1769b6bb461d1f9f5e81d25e237b1d9ecdb92435ac26eeaf9901205672789ffcab806cf4455828a31bc90ef339abce8fa70761a1f05b53ad50ee9adf2e05ce14ec0b7daeecbb30d477196e4e638b48921436b166c96adb0f1a2e9ed941f124ebbf562acc0634f3bfaefc92c07b66d6cd0cca47f92e659b194dda64f24a39ca21c3e7b556cdef64c1cae08e217e8465f7cd2883d4fee0f12a0272cc348e66407f19b4952133900ef7ac211effb5e9dd7a1e17cf1611f356a5c2b8ed685130cada939fa7fc81a41a5182fadac619d511dce022fcf8fac8d693ab18834c036d5ae46afb2a1303bcbb093a2ae222c0502419fc828ab6c0f6068230c0edfed50e013002b6bed7313b2d3cb3ff4736dc24e6db51e8137f86d1e867c970c3287a2f53d8f17f1c92f46e32b7d371781f4aa47a18d744b9f2814110a84336900a4c0fab5573e1657d7d2edfe57faa4143786bc431189aefa413a52614128e693b8aa58447e932dc75b1e3cdfd0266e84af4c0bb126ee0b12e94ddfb2e190e9fa3123c17ff8e38b7d0b630c54fe8d59e49809e58a21f070721778581740a08f73fb7139ceae7b19bd225cc3835407ef6588e77d43c66e1f47dd7183c35e8dae94fa854da74320d62c2f7a31172bb784dc81d865784f570639dad887c8e1c98ae6e729abd645a4b07732b1f1ce855252b1d996c1b326bb9a44d9e21a52f6849eb8a357c4b730289d3b5f75321c8e0c0c85d003dc4dad59e1cb1aa6cc7eb1620af7e58affb2021ad228c1792d0332de6096b3965fe959bd8e5156b43e67efabd742d2bfba1014da8f3784a2f1c43d1baad423a8ac025c7d5de6a97bbcd2b08d7ea3920028b6832e6d9aa64a83b42f6ce802b301dfa929e5bbebb1133ec324b2ffd3f7b49bdb477786c5890928633aa196b95c3982470d06c5295f38091c0d54058c7d4a85512f36d45a966060bd5fa4f336a5586f3b9b22015260b95793bbdc80e67ca5b2ee7878f055afa0e84a86dafd931e21936e10ae1258c56007b5f2fbf1abd7a4dba306262eb80778dac037df8df79c900417eba28df49be60ae2a3c1a433ee5d52c6467e75f3c9e3aa835c36a1da98e5ea49e4806d26163e65707a56d85547f5f36c22cf4db62817ef6031af7ed66b2fb23b8ad157f48ac4fc5256c50cb95cf736519706b7125388a7ca2ea1cab5eed9cb261a34214d2d02a79dd30ef7ceed27dd9e367b7620c9b3506f725b6b52033214a0a44f852d36fc242ec09b968b4743834903ba9ddc777b3594b6ec13f968b1712cca54a1929ebb2b57cbc94d0595a5e922b2de309fc88cfdabbecdf369a2c9aa17b823690963e6a77c9f34242d9d23eb7724b2955cf451348f1678a09d4c390c421d52caf4f68acc4c5ca18f981d9c880a26c17f87d54ea0d800459a13f94b61be69a4f6450def0ef457d8a89de1beda4d17d28a750364fdd25adefab8597e8975b25a2753b2c13b1c7f19633d9ee0188d6795747a17951d28aa05eeae63d1d56871e14998feda90f04f2ec1dded9b406f49cd86c060855e7d329bbcb6db85026e5095a936db08cb4a42994ad7a5fa40760c2c865eda3f2a0515a1e56d990eafb07fef33063a7f25a86a572e01ae4e8c7380c73c0ce41de95e669c7b9a5d12a589b2e26162b4ab7e8e92ada6cc5f5db5700c3a619f98613ef5d534ff5a6b1bbcc75be554f51b179f143eab90df85f8565c2eec47f0fa681896d3e356c4166ab81a219c11bbc5cb145859e727e59fa35a9bcfbb1718bceb3a7554c99fdcbddd5f2e333b7851f3f94e2cf24ed78f0f7753c33dfe18b071087d3c43d8ec6aa0cf489a16c43966df707f629e6f61e4e1de096b7cbe2876c5f3266c57702679a426144c38b2f202d50e98cd9f2d730b2bea90fce73a23189f583b96fbe20c79c1f403272c58a4df18d5ddac5040c6f156772c3b09ae6970212ac54ea9bc4ad9785cbd3c0d8626ce6a0b012a75a8f83311c26ac87d645e6375138e44eb7058fcd62a38444bb6abd39b73e017db89d92e8eb335ad1d84e1f5edca46865a43775009624046c840e79af80f9fa854b79755d719a3735cebf0d16737ace4297531b6f2bb5780d48c4c866f396358bb1bfd614dd97d090da13a29cbc820a0178a1b6266ff626509beef64fc59725bd834ba8efeb022fd28bde2d037de87172b00232094bc173020f0e025a8e9d867391fd2327a97d051d26cce53ef53c519b60222d4c265ca18c86087aca2657af209b0ef79a8aded5c562170a3f09e0d5b28d68e66a47fb31c7946a518491c07d882a513dc7de4c0ec45b45cee4d1913bb2ab71c37f528216c24e0f1a23032c984eba5db613aea45a2dabe874ba2a2ee3ca16ac87afaae6be682e0cb44081406e02cf54c92c60d5024024b0d4f820247b4432c38174d51f800a454897bb82d30f7ddd5115fcf13b5b16e052979ce090163e86adf0090434effc8494316b40060c5504108f316d6ab26e9964c3efa3b4a404d3971300b56737acf5895b78b182868ff2c15801938b6679f5c3d79323d750da70c4416ae0f0b02d685b7b2242742b119bad4c936adadea9cffc071eb4d29eb282d2a665d559f974d22e089208ead18030e543e6bb20ca99f5d977d1e4f1f09bcf111d811228dee457274fa010925e76756435f700d12afbdfa3fe094b8431202850a7a2df35e76baccd184a85721db06260e5e6692fa90d479489f074c241d229981916765dd769cf13d70d9d30d4bea1fe5d28dda14f7c4199a1945570475273f30cba681628a037749c378b89510b901047ed09928eae1d37ea991e6ff527b7e51612943dd927eec2ce69e46f8550d3c9dc41181eb440c4e23c6714e4244fd2cc129364275ac2c7b913121413ddd8597e72af374ea20008e00eb7aa366518df096d06081ae3f42a78910c8c2f880c58205fb6a553c1efcdb8282dc89b37236afbe584c3d567aa0a2321022ffd75769d7be1d3</script></div><script src="/Blog/lib/blog-encrypt.js"></script><link href="/Blog/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      请输入密码，查看文章
    
    </summary>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/categories/diary/"/>
    
    
      <category term="diary" scheme="https://alonealive.github.io/Blog/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>Android SELinux权限笔记</title>
    <link href="https://alonealive.github.io/Blog/2020/03/25/2020/200325_android_sepolicy_study/"/>
    <id>https://alonealive.github.io/Blog/2020/03/25/2020/200325_android_sepolicy_study/</id>
    <published>2020-03-25T14:32:00.000Z</published>
    <updated>2020-03-25T14:39:15.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在新增一个HIDL Service后，需要对其进行权限配置，不然通过<code>adb shell ps -A|grep NAService</code>会发现该service无法启动，也会通过抓取log发现一堆的<code>avc: denied</code>权限问题。关于SELinux可以推荐文档：<a href="https://www.pianshen.com/article/6549296922/，" target="_blank" rel="noopener">https://www.pianshen.com/article/6549296922/，</a> 非常详细，本文只是作为记录部分常用的笔记。</p></blockquote><a id="more"></a><blockquote><p><code>Android sepolicy</code>，SEAndroid是一种基于安全策略的MAC安全机制。SEAndroid安全机制中的安全策略就是在安全上下文的基础上进行描述的，也就是说，它通过主体和客体的安全上下文，定义主体是否有权限访问客体。</p></blockquote><blockquote><p>例如添加一个service，在<code>.rc</code>文件定义了service，还需要在<code>sepolicy</code>的<code>file_context</code>中添加权限。</p></blockquote><h2 id="selinux相关命令"><a href="#selinux相关命令" class="headerlink" title="selinux相关命令"></a>selinux相关命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看进程的sContext</span><br><span class="line">ps -Z</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看文件权限</span><br><span class="line">ls -Z</span><br></pre></td></tr></table></figure><p>查看selinux开关状态：<code>adb shell getenforce</code></p><p>可能返回结果有三种：Enforcing、Permissive 和 Disabled。Disabled 代表 SELinux 被禁用，Permissive 代表仅记录安全警告但不阻止可疑行为，Enforcing 代表记录警告且阻止可疑行为。</p><p>一般调试通过以下命令关闭SELinux权限（需重启生效）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setenforce 0</span><br></pre></td></tr></table></figure><h3 id="抓取SELinux-Log"><a href="#抓取SELinux-Log" class="headerlink" title="抓取SELinux Log"></a>抓取SELinux Log</h3><ol><li>抓kernel log，<code>adb shell dmesg</code></li><li>抓kernel log，使用命令,可以直接提出avc的log：<code>adb shell &quot;cat /proc/kmsg | grep avc&quot; &gt; avc_log.txt</code></li><li><code>adb logcat –b events</code>,搜索关键字：<code>avc: denied</code></li></ol><hr><h2 id="File-contexts"><a href="#File-contexts" class="headerlink" title="File_contexts"></a>File_contexts</h2><blockquote><p>用于声明文件的安全上下文，plat前缀的文件用于声明system、rootfs、data等与设备无关的文件。Nonplat 用于声明vendor、data/vendor等文件。</p></blockquote><h3 id="domain-te"><a href="#domain-te" class="headerlink" title="domain.te"></a>domain.te</h3><blockquote><p>该策略文件会限制一些特征文件的权限，一般不建议修改。</p></blockquote><h3 id="selinux没有对某个文件的权限（有neverAllow）处理方法"><a href="#selinux没有对某个文件的权限（有neverAllow）处理方法" class="headerlink" title="selinux没有对某个文件的权限（有neverAllow）处理方法"></a>selinux没有对某个文件的权限（有neverAllow）处理方法</h3><blockquote><p>参考：<a href="https://blog.csdn.net/ly890700/article/details/54645212" target="_blank" rel="noopener">https://blog.csdn.net/ly890700/article/details/54645212</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01-01 08:03:22.410000   217   217 W applypatch: type&#x3D;1400 audit(0.0:16): avc: denied &#123; read &#125; for name&#x3D;&quot;mmcblk0p15&quot; dev&#x3D;&quot;tmpfs&quot; ino&#x3D;3364 scontext&#x3D;u:r:install_recovery:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0</span><br></pre></td></tr></table></figure><p>意思是说明<code>install_revovery</code>没有block_device的权限</p><p>只要在install_recovery.te中加入下面权限就可以了。</p><ul><li><code>allow install_recovery recover_block_device:blk_file { open read write };</code></li></ul><hr><h2 id="Service-contexts"><a href="#Service-contexts" class="headerlink" title="Service_contexts"></a>Service_contexts</h2><blockquote><p>用于声明java service 的安全上下文， O上将该文件拆分为<code>plat</code>和<code>nonplat</code>前缀的两个文件，但nonplat前缀的文件并没有具体的内容（vendor和system java service不允许binder操作）。</p></blockquote><h2 id="Property-contexts"><a href="#Property-contexts" class="headerlink" title="Property_contexts"></a>Property_contexts</h2><blockquote><p>用于声明属性的安全上下文，plat 前缀的文件用于声明system属性，nonplat前缀的文件用于声明vendor 属性。ril.开头的属性的安全上下文为<code>u:object_r:radio_prop:s0</code>，这意味着只有有权限访问Type为radio_prop的资源的进程才可以访问这些属性。</p></blockquote><h2 id="Hwservice-contexts"><a href="#Hwservice-contexts" class="headerlink" title="Hwservice_contexts"></a>Hwservice_contexts</h2><p>新增文件，用于声明HIDL service 安全上下文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android.hardware.vibrator::IVibrator                u:object_r:hal_vibrator_hwservice:s0</span><br><span class="line">android.hardware.vr::IVr                            u:object_r:hal_vr_hwservice:s0</span><br><span class="line">android.hardware.weaver::IWeaver                    u:object_r:hal_weaver_hwservice:s0</span><br><span class="line">android.hardware.wifi::IWifi                        u:object_r:hal_wifi_hwservice:s0</span><br><span class="line">android.hardware.wifi.hostapd::IHostapd             u:object_r:hal_wifi_hostapd_hwservice:s0</span><br><span class="line">android.hardware.wifi.offload::IOffload             u:object_r:hal_wifi_offload_hwservice:s0</span><br><span class="line">android.hidl.allocator::IAllocator                  u:object_r:hidl_allocator_hwservice:s0</span><br><span class="line">android.hidl.base::IBase                            u:object_r:hidl_base_hwservice:s0</span><br><span class="line">android.hidl.manager::IServiceManager               u:object_r:hidl_manager_hwservice:s0</span><br><span class="line">android.hidl.memory::IMapper                        u:object_r:hidl_memory_hwservice:s0</span><br><span class="line">android.hidl.token::ITokenManager                   u:object_r:hidl_token_hwservice:s0</span><br><span class="line">android.system.net.netd::INetd                      u:object_r:system_net_netd_hwservice:s0</span><br></pre></td></tr></table></figure><h2 id="te语法"><a href="#te语法" class="headerlink" title="te语法"></a>te语法</h2><ul><li><code>allow signal</code>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allow domain domain : process signal; # 每个进程都能向它自己和其它进程发送signal  </span><br><span class="line">allow domain self : process signal;   # 每个进程都能向它自己发送signal</span><br></pre></td></tr></table></figure><hr><blockquote><p>参考文档：</p></blockquote><ul><li><a href="https://blog.csdn.net/ch853199769/article/details/82501078" target="_blank" rel="noopener">https://blog.csdn.net/ch853199769/article/details/82501078</a></li><li><a href="https://blog.csdn.net/innost/article/details/19299937" target="_blank" rel="noopener">https://blog.csdn.net/innost/article/details/19299937</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在新增一个HIDL Service后，需要对其进行权限配置，不然通过&lt;code&gt;adb shell ps -A|grep NAService&lt;/code&gt;会发现该service无法启动，也会通过抓取log发现一堆的&lt;code&gt;avc: denied&lt;/code&gt;权限问题。关于SELinux可以推荐文档：&lt;a href=&quot;https://www.pianshen.com/article/6549296922/，&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.pianshen.com/article/6549296922/，&lt;/a&gt; 非常详细，本文只是作为记录部分常用的笔记。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android RC文件分析</title>
    <link href="https://alonealive.github.io/Blog/2020/03/20/2020/200320_android_rcFile_study/"/>
    <id>https://alonealive.github.io/Blog/2020/03/20/2020/200320_android_rcFile_study/</id>
    <published>2020-03-20T15:32:00.000Z</published>
    <updated>2020-03-25T08:43:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Android中最熟知的RC文件就是<code>init.rc</code>了，而在Hal接口服务定义中也会创建<code>.rc</code>文件。<code>init.rc</code>的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。<code>.rc</code>文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用<code>.rc</code>资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。</p></blockquote><a id="more"></a><h2 id="android-rc文件分析"><a href="#android-rc文件分析" class="headerlink" title="android rc文件分析"></a>android rc文件分析</h2><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><ul><li><p>结构：service关键字声明了你要定义一个service，而test就是这个service的名字，至于后面的目录则是这个service对应的可执行文件在系统中的位置（<code>adb shell</code>，即编译后的系统目录）。</p></li><li><p>init是分段(section)解析init.rc的，在<code>keywords.h</code>中可以查看关键字的定义。结合init.rc的内容，可以看出，init是以on 和 service来分段标记的。</p></li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   &lt;option&gt;</span><br><span class="line">   <span class="keyword">...</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">service test /system/bin/vold \</span><br><span class="line">        --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \</span><br><span class="line">        --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0</span><br><span class="line">    class core</span><br><span class="line">    socket vold stream <span class="number">0660</span> root mount</span><br><span class="line">    socket cryptd stream <span class="number">0660</span> root mount</span><br><span class="line">    ioprio be <span class="number">2</span></span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><p><strong>关键字解释：</strong></p><table><thead><tr><th align="center">语法</th><th align="center">关键字</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>SECTION</code></td><td align="center">on</td><td align="center">触发条件</td></tr><tr><td align="center">同上..</td><td align="center">service</td><td align="center">解析service</td></tr><tr><td align="center"><code>COMMAND</code></td><td align="center">chdir</td><td align="center">更改当前工作目录</td></tr><tr><td align="center">同上..</td><td align="center">chroot</td><td align="center">更改参考的根目录位置</td></tr><tr><td align="center">..</td><td align="center">class_start <serviceclass></td><td align="center">开启class start all services(启动某个设置了class名称的服务)</td></tr><tr><td align="center">..</td><td align="center">class_stop <servicelass></td><td align="center">停止某个设置了class名称的服务</td></tr><tr><td align="center">..</td><td align="center">domainname <name></td><td align="center">域名</td></tr><tr><td align="center">..</td><td align="center">exec [ <seclabel> [ <user> [ <group> ] * ] ]  – <command> [ <argument> ] *</td><td align="center">调用程序并转移进程(Fork一个进程然后执行命令)</td></tr><tr><td align="center">..</td><td align="center">export</td><td align="center">提交变量</td></tr><tr><td align="center">..</td><td align="center">hostname</td><td align="center">主机名</td></tr><tr><td align="center">..</td><td align="center">ifup</td><td align="center">激活网卡</td></tr><tr><td align="center">..</td><td align="center">insmod</td><td align="center">挂载模块(安装一个module)</td></tr><tr><td align="center">..</td><td align="center">import <filename></td><td align="center">引入init文件，比如etc下的一些rc文件，和java中的import差不多</td></tr><tr><td align="center">..</td><td align="center">mkdir <path> [mode] [owner] [group]</td><td align="center">建立目录</td></tr><tr><td align="center">..</td><td align="center">mount</td><td align="center">挂载文件系统</td></tr><tr><td align="center">..</td><td align="center">setkey</td><td align="center">从源码看，应该是设置一个命令的关键字缩写，比如可以将domainname映射为dn</td></tr><tr><td align="center">..</td><td align="center">setprop</td><td align="center">设置一个属性</td></tr><tr><td align="center">..</td><td align="center">setrlimit</td><td align="center">设置当前程序可以打开的最大文件数到系统规定程序可以打开的最大文件数</td></tr><tr><td align="center">..</td><td align="center">start</td><td align="center">启动服务</td></tr><tr><td align="center">..</td><td align="center">stop</td><td align="center">停止服务</td></tr><tr><td align="center">..</td><td align="center">symlink</td><td align="center">建立软链接</td></tr><tr><td align="center">..</td><td align="center">sysclktz</td><td align="center">设置基准时间</td></tr><tr><td align="center">..</td><td align="center">loglevel</td><td align="center">Log输出级别，低于这个级别的就输出</td></tr><tr><td align="center">..</td><td align="center">restart <service></td><td align="center">重启服务,类似stop 但是不会disable service</td></tr><tr><td align="center">..</td><td align="center">bootchart_init</td><td align="center">开启bootcharting</td></tr><tr><td align="center">..</td><td align="center">chmod <octal-mode> <path></td><td align="center">改变文件执行权限</td></tr><tr><td align="center">..</td><td align="center">chown <owner> <group> <path></td><td align="center">改变文件的owner group</td></tr><tr><td align="center">..</td><td align="center">enable <servicename></td><td align="center">将一个disabled的service变成enabled。且start</td></tr><tr><td align="center">..</td><td align="center">load_all_props</td><td align="center">加载system vendor的属性</td></tr><tr><td align="center">..</td><td align="center">load_persist_props</td><td align="center">加载data下面的persist属性</td></tr><tr><td align="center">..</td><td align="center">mount_all <fstab></td><td align="center">挂载fstab中的设备</td></tr><tr><td align="center">..</td><td align="center"><code>mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt; ]* [&lt;option&gt;]</code></td><td align="center">挂载设备</td></tr><tr><td align="center">..</td><td align="center">powerctl</td><td align="center">对sys.powerctl属性的respond</td></tr><tr><td align="center">..</td><td align="center"><code>restorecon &lt;path&gt; [ &lt;path&gt; ] *</code></td><td align="center">恢复文件到sercurity context在file_contexts配置的</td></tr><tr><td align="center">..</td><td align="center"><code>restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]*</code></td><td align="center">递归的恢复目录中的文件到sercurity context</td></tr><tr><td align="center">..</td><td align="center"><code>trigger &lt;event&gt;</code></td><td align="center">触发触发器</td></tr><tr><td align="center">..</td><td align="center"><code>wait &lt;path&gt; [ &lt;timeout&gt; ]</code></td><td align="center">poll for 给定的文件 或者 timeout时间到。如果时间没有设定，默认为5秒</td></tr><tr><td align="center">..</td><td align="center"><code>write &lt;path&gt; &lt;content&gt;</code></td><td align="center">打开文件，write string到给定文件。没有文件会被创建。有的话，会truncated</td></tr><tr><td align="center"><code>OPTION</code>(用来初始化Service的)</td><td align="center">capability</td><td align="center">能力，也就是系统对进程的一种权限控制。</td></tr><tr><td align="center">同上..</td><td align="center">class</td><td align="center">设置class name</td></tr><tr><td align="center">..</td><td align="center">console</td><td align="center">启用控制台</td></tr><tr><td align="center">..</td><td align="center">critical</td><td align="center">是否关键，也就是4分钟之内重启超过4次的话，重启之后就进入recovery模式</td></tr><tr><td align="center">..</td><td align="center">disabled</td><td align="center">当它的class启动时，Service不会自动开启。必须显示的started by name(用其名字)</td></tr><tr><td align="center">..</td><td align="center">group <groupname> [ <groupname> ]*</td><td align="center">组归属（改变username当执行这个Service之前）</td></tr><tr><td align="center">..</td><td align="center">oneshot</td><td align="center">只启动一次，意外退出后不必重启</td></tr><tr><td align="center">..</td><td align="center">onrestart</td><td align="center">执行一个命令，当Service重启时</td></tr><tr><td align="center">..</td><td align="center">setenv</td><td align="center">增加环境变量</td></tr><tr><td align="center">..</td><td align="center">socket</td><td align="center">申请socket资源</td></tr><tr><td align="center">..</td><td align="center">user<username></td><td align="center">用户归属（改变username当执行这个Service之前）</td></tr><tr><td align="center">..</td><td align="center">ioprio</td><td align="center">io调度优先级</td></tr><tr><td align="center">..</td><td align="center">writepid &lt;file…&gt;</td><td align="center">当fork一个子进程时，写子进程的pid到一个给定的文件。是给cgroup/cpuset使用</td></tr><tr><td align="center">..</td><td align="center">Triggers</td><td align="center">Triggers被用来匹配事件，然后加入执行队列。</td></tr><tr><td align="center">..</td><td align="center">boot</td><td align="center">当init开启时，这是第一个执行的trigger</td></tr></tbody></table><h3 id="class-lt-name-gt"><a href="#class-lt-name-gt" class="headerlink" title="class &lt;name&gt;"></a><code>class &lt;name&gt;</code></h3><blockquote><p><code>class &lt;name&gt;</code>意思是为该服务定义一个类名，所有在这个类名下的服务都将一起启动和停止、<br>如果没有定义class选项，则默认<code>class deafult</code>。</p></blockquote><p>定义为核心service，当<code>class core</code>服务启动时，这个vold启动。<br>如果是定义<code>class hal</code>，是不会自动启动的。可以定义为<code>class main</code>能够自动启动。</p><p>通过<code>adb shell ps -A|grep 关键字</code>查看进程服务。</p><h3 id="on-lt-name-gt"><a href="#on-lt-name-gt" class="headerlink" title="on &lt;name&gt;"></a><code>on &lt;name&gt;</code></h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on &lt;trigger&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br><span class="line">   &lt;command&gt;</span><br></pre></td></tr></table></figure><p>on属于行为。</p><ul><li><code>on early-init</code>: init之前、加载完所有rc文件后即执行，在miui的rom中，init.rc在early-init执行的是<code>start ueventd</code>，根据keywords.h的定义，start是个命令(COMMAND)。</li><li><code>on init</code>: 加载propety各项属性文件之前执行，在init变为propety service之前都属于init阶段。            </li><li><code>on early-boot</code>: 启动属性服务后即执行。</li><li><code>on boot</code>: boot的时候执行。</li><li><code>on property:xxxxx=x</code>: 当某个属性设置为预期值时执行。 </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Android中最熟知的RC文件就是&lt;code&gt;init.rc&lt;/code&gt;了，而在Hal接口服务定义中也会创建&lt;code&gt;.rc&lt;/code&gt;文件。&lt;code&gt;init.rc&lt;/code&gt;的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。&lt;code&gt;.rc&lt;/code&gt;文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用&lt;code&gt;.rc&lt;/code&gt;资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android 触控事件分析</title>
    <link href="https://alonealive.github.io/Blog/2020/03/17/2020/200317_adnroid_touchEvent/"/>
    <id>https://alonealive.github.io/Blog/2020/03/17/2020/200317_adnroid_touchEvent/</id>
    <published>2020-03-17T14:32:00.000Z</published>
    <updated>2020-05-20T16:39:48.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们常见的触摸事件除了按下，弹起，移动之外还有很多，诸如长按，双击，Scroll，Fling等，他们是怎么判断的，还有这些长按，双击等事件的时间能否自由设置。可以在开发者选项中打开“显示点按操作反馈”和“指针位置”，同时可以打开inputflinger模块的log开关做一些调试，分析TP报点。</p></blockquote><p>一般当我们需要处理触摸事件时有两种方式：</p><ul><li>委托式 ： 将事件委托给监听器来进行处理。即定义一个<code>View.onTouchListener()</code>子类的监听器，由其<code>onTouch()</code>方法来处理。</li><li>回调式 ： 通过重写View类自己的<code>onTouchEvent()</code>方法来处理，在执行时会回调该方法，在其中执行自定义的代码。</li></ul><a id="more"></a><p><strong>关于主触点，副触点</strong>：发送触屏事件的时候，除了此触屏事件所对应的触点之外，如果当前触点多于一个或者等于一个，则此事件为副触点事件，发送此事件的触点叫做副触点。否则为主触点事件，发送此事件的触点为主触点。</p><h2 id="MotionEvent对象事件处理"><a href="#MotionEvent对象事件处理" class="headerlink" title="MotionEvent对象事件处理"></a>MotionEvent对象事件处理</h2><p>在<code>MotionEvent.java</code>中,ACTION动作事件定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ACTION_DOWN = <span class="number">0</span>;</span><br><span class="line">ACTION_UP = <span class="number">1</span>;</span><br><span class="line">ACTION_MOVE = <span class="number">2</span>;</span><br><span class="line">ACTION_CANCEL =<span class="number">3</span> ;</span><br><span class="line">ACTION_POINTER_DOWN = <span class="number">5</span>; <span class="comment">//A non-primary pointer has gone down.</span></span><br><span class="line">ACTION_POINTER_UP = <span class="number">6</span>;</span><br><span class="line">ACTION_SCROLL = <span class="number">8</span>; <span class="comment">//the most event contains relative vertical and/or horizontal scroll offset.</span></span><br></pre></td></tr></table></figure><p>（1） 首先当点击下屏幕，触屏事件从<code>View.java</code>的onTouchEvent()开始处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">    <span class="comment">// a short period in case this is a scroll.</span></span><br><span class="line">    <span class="keyword">if</span> (isInScrollingContainer) &#123;</span><br><span class="line">        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">        <span class="keyword">if</span> (mPendingCheckForTap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingCheckForTap = <span class="keyword">new</span> CheckForTap();</span><br><span class="line">        &#125;</span><br><span class="line">        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setPressed(<span class="keyword">true</span>);</span><br><span class="line">        checkForLongClick(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>（2） 事件响应是先有按下才会有后续事件。因此先查看<code>ACTION_DOWN</code>。在此case中判断如果是在scrollingContainer中则等待一段时间执行检查是否为Tap事件。因为可能按下之后可能会有scroll操作，如果有将丢弃长按检测。而如果不在container中，则立即执行长按检测。</p><figure class="highlight java"><figcaption><span>view.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckForTap</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_PREPRESSED;</span><br><span class="line">            setPressed(<span class="keyword">true</span>);</span><br><span class="line">            checkForLongClick(ViewConfiguration.getTapTimeout());</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>（3） 在其中执行了<code>setPressed()</code>操作，其后执行<code>checkForLongClick()</code>，即等待500ms-180ms 来执行longPress操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postDelayed(mPendingCheckForLongPress,</span><br><span class="line">         ViewConfiguration.getLongPressTimeout() - delayOffset);</span><br></pre></td></tr></table></figure><p>在其中执行<code>performLongClick()</code>。在该函数中处理长按需要做的事情，例如长按监听器中流程，显示contextMenu，处理长按震动反馈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handled = li.mOnLongClickListener.onLongClick(View.<span class="keyword">this</span>);</span><br><span class="line">handled = showContextMenu();</span><br><span class="line">performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);</span><br></pre></td></tr></table></figure><p><strong>Note</strong>: 此处有两个时间数据： <code>tapTimeout</code> 和 <code>longPressTimeout</code>。</p><p>定义在<code>frameworks/base/core/java/android/view/ViewConfiguration.java</code>，时间是可以自定义的，但最好采用google提供的，这是经过大量积累得来的数据。而此处的longTimeout是设置辅助功能界面中’触摸和按住延迟’选项可设置的，如果没有设置那就是用默认的500ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TAP_TIMEOUT = <span class="number">180</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DOUBLE_TAP_TIMEOUT = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_LONG_PRESS_TIMEOUT = <span class="number">500</span>;</span><br></pre></td></tr></table></figure><h2 id="MotionEvent底层事件获取（触控事件分发机制）"><a href="#MotionEvent底层事件获取（触控事件分发机制）" class="headerlink" title="MotionEvent底层事件获取（触控事件分发机制）"></a>MotionEvent底层事件获取（触控事件分发机制）</h2><p>（1） 在onResume时会将view显示出来，跟踪代码到执行时会调用<code>ActivityThread的handleResumeActivity()</code>。可以看到获取window的DecorView，即整个window的顶层View。<br>调用流程为:（创建窗口）</p><ol><li>WindowManager.addView()；</li><li>在实现类WindowManagerImpl中实现addView()；</li><li>最后一行通过root.setView()；</li><li>在ViewRootImpl中实现setView()；</li><li>在其中调用windowSession.add()。</li><li>windowSession为客户端，而服务器端为<code>Session.java</code>,在Session中转而调用WindowManagerService的addWindow()来实现add方法。</li></ol><p>（2）<code>WindowManagerService中addWindow</code>这里实现了事件信息传递和交互的通道，内部采用socketpair，通过<code>InputChannel</code>来实现。</p><p><strong>Note</strong>：openInputChannelPair(), 在其中创建socketpair,一个匿名的已连接套接字，一个为发送端，一个为接收端，可以进行双工通讯（UNIX网络编程）。</p><p>获取InputChannel, 一个置为Input，一个置为output。RegisterInputChannel中调用nativeRegisterInputChannel。</p><p>（3）在<code>WindowManagerService</code>中创建InputManagerService类（InputManagerService.java）对象，并start。</p><p>之后通过JNI流程在native中执行，并执行InputManager的start方法。</p><p>（4）在创建InputReader时会将dispatcher传入。即InputReader的成员变量mQueuedListener为dispatcher的执行者，具体代码分析flush函数，关注Args，例如MotionArgs, flush执行后，将调用<code>dispatcher-&gt;notifyMotion()</code>;</p><p>如果只关注Motion的话，那么就是调用<code>InputDispatcher-&gt;notifyMotion()</code>。</p><p><strong>从抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。</strong></p><h2 id="systrace查看Input事件流程"><a href="#systrace查看Input事件流程" class="headerlink" title="systrace查看Input事件流程"></a>systrace查看Input事件流程</h2><blockquote><p>参考： <a href="https://www.jianshu.com/p/427b084b0d77" target="_blank" rel="noopener">https://www.jianshu.com/p/427b084b0d77</a><br>参考： <a href="https://mp.weixin.qq.com/s/Q2k6pLEyXhHZvZOIiU5ucA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q2k6pLEyXhHZvZOIiU5ucA</a></p></blockquote><ol><li>触摸屏每隔几毫秒（如果是60刷新率，则一秒扫描屏幕120次，大概8ms扫描一次）扫描一次，如果有触摸事件，那么把事件上报到对应的驱动。</li><li>InputReader 读取触摸事件交给 InputDispatcher 进行事件派发。</li><li>InputDispatcher 将触摸事件发给注册了 Input 事件的 App。</li><li>App 拿到事件之后，进行 Input 事件分发，如果此事件分发的过程中，App 的 UI 发生了变化，那么会请求 Vsync，则进行一帧的绘制。</li></ol><h3 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h3><p>所以systrace从InputReader开始：（前面还有一点很短的“binder transaction”的时间）</p><figure class="highlight java"><figcaption><span>frameworks/native/services/inputflinger/InputReader.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dispatch pointer down events using the new pointer locations.</span></span><br><span class="line"><span class="keyword">while</span> (!downIdBits.isEmpty()) &#123;</span><br><span class="line">    uint32_t downId = downIdBits.clearFirstMarkedBit();</span><br><span class="line">    dispatchedIdBits.markBit(downId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dispatchedIdBits.count() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// First pointer is going down.  Set down time.</span></span><br><span class="line">        mDownTime = when;</span><br><span class="line">        <span class="comment">/// M: for input MET systrace  @&#123;</span></span><br><span class="line">        <span class="function">ScopedTrace <span class="title">_l</span><span class="params">(ATRACE_TAG_INPUT, <span class="string">"AppLaunch_dispatchPtr:Down"</span>)</span></span>;</span><br><span class="line">        <span class="comment">/// @&#125;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后会到InputDispatcher的dispatchMotionLocked函数，并且InputDispatcher会从InboundQueue中取出Input事件派发到各个App(连接)的OutBoundQueue(OutboundQueue区域oq)</p><figure class="highlight java"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool InputDispatcher::dispatchMotionLocked(</span><br><span class="line">        nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="comment">// Preprocessing.</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundMotionDetails(<span class="string">"dispatchMotion - "</span>, entry);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后到deliverInputEvent，说明APP UI Thread被Input事件唤醒；（起始点可以看到当前APP的Launcher是1，value=1表示有一个input事件，如果主线程卡顿没法及时处理Input事件，这里的Value会堆积）</p><p>之后则是APP的UI线程启动，然后再触发APP的绘制线程进行绘制等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我们常见的触摸事件除了按下，弹起，移动之外还有很多，诸如长按，双击，Scroll，Fling等，他们是怎么判断的，还有这些长按，双击等事件的时间能否自由设置。可以在开发者选项中打开“显示点按操作反馈”和“指针位置”，同时可以打开inputflinger模块的log开关做一些调试，分析TP报点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般当我们需要处理触摸事件时有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;委托式 ： 将事件委托给监听器来进行处理。即定义一个&lt;code&gt;View.onTouchListener()&lt;/code&gt;子类的监听器，由其&lt;code&gt;onTouch()&lt;/code&gt;方法来处理。&lt;/li&gt;
&lt;li&gt;回调式 ： 通过重写View类自己的&lt;code&gt;onTouchEvent()&lt;/code&gt;方法来处理，在执行时会回调该方法，在其中执行自定义的代码。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
      <category term="input" scheme="https://alonealive.github.io/Blog/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>Android Systrace如何抓取分析问题</title>
    <link href="https://alonealive.github.io/Blog/2020/02/22/2020/200222_android_systrace_study/"/>
    <id>https://alonealive.github.io/Blog/2020/02/22/2020/200222_android_systrace_study/</id>
    <published>2020-02-22T12:32:00.000Z</published>
    <updated>2020-03-08T10:26:39.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI流畅平滑的systrace"><a href="#UI流畅平滑的systrace" class="headerlink" title="UI流畅平滑的systrace"></a>UI流畅平滑的systrace</h2><h3 id="Systrace获取："><a href="#Systrace获取：" class="headerlink" title="Systrace获取："></a>Systrace获取：</h3><p>Android\Sdk\platform-tools\systrace</p><p>systrace.py：<br><code>python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal  res dalvik bionic power pm ss pdx sched freq idle load  binder_driver binder_lock</code></p><p>默认Tag with: <code>sched freq idle res ss gfx input view am</code></p><a id="more"></a><p>常用：<br><code>./systrace -t 3 -b 10240 -o test.html sched freq idle res ss gfx input view am hal power wm</code></p><h3 id="需要开的Tag"><a href="#需要开的Tag" class="headerlink" title="需要开的Tag"></a>需要开的Tag</h3><table><thead><tr><th align="center">需求</th><th align="center">tags</th></tr></thead><tbody><tr><td align="center">cpu信息</td><td align="center">sched/freq/idle</td></tr><tr><td align="center">测试列表滑动，桌面滑动等流畅性问题</td><td align="center">gfx/view/input/hwui</td></tr><tr><td align="center">测试app launch，点击某个应用，点击进入某个界面</td><td align="center">gfx/view/input/dalvik/disk</td></tr><tr><td align="center">怀疑有power问题（亮灭屏，电量相关）</td><td align="center">gfx/view/input/res/am/wm/power</td></tr></tbody></table><h3 id="time和buffer-size"><a href="#time和buffer-size" class="headerlink" title="time和buffer size"></a>time和buffer size</h3><p>一般我给的是<code>-t 3 -b 8000</code></p><ul><li>如果抓5s，-b可以给20480（kb）</li><li>如果时间再长，-b可以给30720（kb）</li></ul><h3 id="视频获取"><a href="#视频获取" class="headerlink" title="视频获取"></a>视频获取</h3><p><code>动画过程</code>:指手机画面开始动的前一帧到画面停止动(完全显示，最后一帧)的过程，所以动画过程时间，依据动画不同，记录的时间也会不同。<br>在播放高清视频时，影格数就表示画面所更新的次数，需要仔细观察视频画面。其中一影格就是手机更新画面时动一次，一般在fps为60的平台上，通常是一帧画面就会动一次，也就是一影格，而对于fps为30的平台，通常是两帧表示一影格。</p><p><code>FPS</code>:表示每秒刷新的帧数，是画面流畅性的一个重要指标,那它是如何计算出来的呢（影格数除以动画时间）</p><p><code>FPS</code>:特定的区段时间内,每秒平均更新画面的次数。</p><ul><li>数值的高低不能代表画面的流畅度</li><li>流畅度还是会跟画面的内容有关系（例如分辨率）</li></ul><p><strong>目前常用的FPS计算方法：</strong></p><ul><li>systrace所录到的<code>queuebuffer</code>个数计算区段时间内的刷新次数</li><li>高速摄影机在区段时间内的刷新次数</li></ul><p>从绘图流程的角度来看,这些FPS的意义是类似的：<br>如果只有单一图层更新的情况,表示从<code>APP画图</code>到<code>display显示</code>的频率。</p><p>常见<code>FPS TestCase</code>：</p><ol><li>App 界面滑动换页的流畅性</li><li>browser浏览网页的流畅性</li><li>包含列表控件(list menu)界面卷动的流畅性</li><li>Contact list界面卷动的流畅性</li><li>Launch app 过场动画流畅性</li><li>Status bar下拉的流畅性</li></ol><h2 id="systrace查看绘制过程是否有问题（FPS）"><a href="#systrace查看绘制过程是否有问题（FPS）" class="headerlink" title="systrace查看绘制过程是否有问题（FPS）"></a>systrace查看绘制过程是否有问题（FPS）</h2><p>如图：<br><img src="systrace1.png" alt="systrace查看绘制"></p><ol><li>首先查看VSYNC周期是否正常，是否有进行vsync tunning；</li><li>查看是否queuebuffer成功？ 绘制之前调用dequeuebufffer从BufferQueue获取一个buffer，绘制完成会调用queuebuffer放回BufferQueue。</li></ol><ul><li>如果正常queuebufffer,则查看SF合成</li><li>如果queuebufffer不正常，则查看是否是queuebuffer阻塞？</li><li><ul><li>如果queuebuffer阻塞，则看GPU</li></ul></li><li><ul><li>若不是，查看HWUI绘制是否成功？</li></ul></li></ul><ol start="3"><li>如果HWUI没有绘制，则检查UIThread（UI线程）</li></ol><ul><li>如果UIThread调用了runnable，则查看SS（不清楚具体表示什么？）</li><li>如果skia耗费太长时间，则查看skia的代码（绘制API）</li><li>如果是view耗费太长时间，则查看view模块的代码</li><li>如果UI线程状态正常，则查看第三方APP是否有问题？</li></ul><ol start="4"><li>如果HWUI绘制了，则检查UIThread和RenderThread（绘制线程）</li></ol><ul><li>UIThread同上</li><li>如果HWUI耗时过长，检查是否阻塞在GL？（openGL）</li><li><ul><li>如果是，则检查GPU</li></ul></li><li><ul><li>如果不是，则检查HWUI模块</li></ul></li></ul><hr><h2 id="上层到底层的模块图-Buffer流程"><a href="#上层到底层的模块图-Buffer流程" class="headerlink" title="上层到底层的模块图(Buffer流程)"></a>上层到底层的模块图(Buffer流程)</h2><p>如图：<br><img src="systrace2.png" alt="上层APP到底层Driver顺序模块"></p><p>从APP开始  –》  然后到View（触发setView，测量布局绘制等操作） –》  然后到绘制，如果是软件绘制就是skia，如果是硬件绘制就是到HWUI，再到OpenGL  –》  接着绘制完成，通过BufferQueue，调用queuebuffer函数  –》  触发SF合成  –》 查看合成方式，如果是GPU合成还是观察OpenGL，然后两种合成方式再调用到HWC模块  –》  然后到底层驱动Display Driver模块  –》  然后到硬件LCD Panel屏幕</p><p><strong>Note:</strong> queubuffer的查看可以分两部分分析：  </p><ol><li>Queue的速度有没有达到预期值？是否时间太长，一直在Queue？</li><li>时间点是否正确，是否绘制完成？是否下一个时间点开始触发SF模块合成流程？</li></ol><hr><h2 id="FPS问题关注点"><a href="#FPS问题关注点" class="headerlink" title="FPS问题关注点"></a>FPS问题关注点</h2><p>如图：<br><img src="systrace3.png" alt="systrace截图分析"></p><ol><li>APP在收到SW Vsync之后，开始产生新的frame</li><li>查看抓取APP的UIThread， 首先是<code>Choreographer#doFrame</code>进行绘制之前的测量、布局，以及reDraw重绘的判断，然后触发HWUI绘制；</li><li>查看DrawFrame部分，开始调用<code>dequeubuffer</code>获取buffer，以及其他GL Function；</li><li>绘制完成后调用<code>eglSwapBuffers</code>，然后再调用<code>queuebuffer</code>将Buffer放回<code>bufferqueue</code>；</li><li>SF在收到下一个SW Vsync之后，从<code>bufferqueue</code>取出buffer，调用onMessageReceived，然后在函数<code>latchBuffer</code>到更新纹理<code>updateTextImage</code>（纹理数据可以通过<code>GAPID</code>工具抓取trace查看），再到<code>acquireBuffer</code>取Buffer；</li><li>合成完成后，HWC将SF传下来的工作排进内部thread（可以查看Dispatcher_0和DispSync）</li><li>HWC处理合成之后，传到底层驱动display driver，然后触发驱动driver（可以查看OverlayEngine_0）</li><li>然后查看当前的<code>DispSync</code>，在当前的<code>sen_sw_sync</code>结束后将frame送到<code>LCD</code></li></ol><h2 id="Vsync周期是否正常"><a href="#Vsync周期是否正常" class="headerlink" title="Vsync周期是否正常"></a>Vsync周期是否正常</h2><p>如图：<br><img src="systrace4.png" alt="systrace截图分析"></p><ol><li>如果是标准60fps刷新率，查看VSYNC的周期是否是<code>16.6ms</code>，绘制是否在这个周期内完成？</li><li>绘制queuebuffer和下一帧合成的时间是否正常？</li></ol><h3 id="底层硬件的FPS是否正常"><a href="#底层硬件的FPS是否正常" class="headerlink" title="底层硬件的FPS是否正常"></a>底层硬件的FPS是否正常</h3><p>如图：<br><img src="systrace5.png" alt="systrace截图分析"></p><p>如果是标准60fps刷新率，查看底层的FPS（HW_VSYNC）是否是16.6ms正常的周期？</p><h2 id="查看queuebuffer周期是否规律"><a href="#查看queuebuffer周期是否规律" class="headerlink" title="查看queuebuffer周期是否规律"></a>查看queuebuffer周期是否规律</h2><p>如图：<br><img src="systrace6.png" alt="systrace截图分析"></p><p><code>hasClientComposition</code>对比<code>hasDeviceComposition</code>两种合成方式。</p><hr><h2 id="硬件绘制和软件绘制如何查看"><a href="#硬件绘制和软件绘制如何查看" class="headerlink" title="硬件绘制和软件绘制如何查看"></a>硬件绘制和软件绘制如何查看</h2><h3 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h3><blockquote><p><code>HWUI draw</code>会有<code>Record View#draw()</code></p></blockquote><p>如图：<br><img src="systrace7.png" alt="systrace截图分析"></p><h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><blockquote><p><code>SWUI draw</code>会有<code>drawSoftware lockCanvas</code></p></blockquote><p>如图：<br><img src="systrace8.png" alt="systrace截图分析"></p><hr><h2 id="view耗时太久"><a href="#view耗时太久" class="headerlink" title="view耗时太久"></a><code>view</code>耗时太久</h2><p>如图：<br><img src="systrace9.png" alt="systrace截图分析"></p><p>可以分别查看测量、布局、以及软件/硬件绘制的过程。</p><hr><h2 id="Draw绘制太长"><a href="#Draw绘制太长" class="headerlink" title="Draw绘制太长"></a>Draw绘制太长</h2><blockquote><p><code>注意</code>：systrace (don’t turn on <code>hwui/gfx tag</code>)</p></blockquote><p>如图：<br><img src="systrace10.png" alt="systrace截图分析"></p><p>查看<code>Choreographer#doFrame</code>时长。</p><p>如图：<br><img src="systrace11.png" alt="systrace截图分析"></p><p>然后查看<code>draw</code>的耗时（注意是软件绘制SWUI）</p><h3 id="DrawFrame耗时"><a href="#DrawFrame耗时" class="headerlink" title="DrawFrame耗时"></a><code>DrawFrame</code>耗时</h3><blockquote><p><code>注意</code>：systrace (don’t turn on <code>hwui/gfx tag</code>)</p></blockquote><p>如图：<br><img src="systrace12.png" alt="systrace截图分析"></p><p>如果是标准60FPS帧率，则该函数耗时不要超过16.6ms</p><hr><h2 id="OpenGL-API绘制是否正常"><a href="#OpenGL-API绘制是否正常" class="headerlink" title="OpenGL API绘制是否正常"></a>OpenGL API绘制是否正常</h2><p>需要以下的函数被systrace抓取到，则需要开启<code>GL trace</code>开关：</p><ol><li>adb shell setprop debug.egl.trace systrace</li><li>adb shell stop</li><li>adb shell start (or make sure your app restart)</li><li>Run systrace (<code>需要加上tag：view,input,freq,res,hwui/gfx</code>)</li></ol><p>如图：<br><img src="systrace13.png" alt="systrace截图分析"></p><hr><h2 id="查看systrace的进程状态"><a href="#查看systrace的进程状态" class="headerlink" title="查看systrace的进程状态"></a>查看systrace的进程状态</h2><p>如图：<br><img src="systrace14.png" alt="systrace截图分析"></p><h3 id="选中一个函数的区域（使用箭头）查看进程状态"><a href="#选中一个函数的区域（使用箭头）查看进程状态" class="headerlink" title="选中一个函数的区域（使用箭头）查看进程状态"></a>选中一个函数的区域（使用箭头）查看进程状态</h3><p>如图：<br><img src="systrace15.png" alt="systrace截图分析"></p><blockquote><p>可以选择整个function的process state并确认统计信息,判断是否有runnable/sleep(D/S)过长的现象。</p></blockquote><p>如图：<br><img src="systrace16.png" alt="systrace截图分析"></p><hr><blockquote><p>以下是确定是哪个部分异常，进一步详细调查的方式。</p></blockquote><h2 id="APP-Owner（view模块异常）"><a href="#APP-Owner（view模块异常）" class="headerlink" title="APP Owner（view模块异常）"></a>APP Owner（view模块异常）</h2><blockquote><p>如果已经确定Measure/Layout 占的时间很多。</p></blockquote><ol><li>adb shell setprop debug.view.systraceMeasure true</li><li>adb shell setprop debug.view.systraceLayout true</li><li>adb shell stop</li><li>adb shell start (or make sure your app restart)</li><li>抓取systrace again</li></ol><p>例如下面的例子， 可以发现ListView layout耗时过长。如图：<br><img src="systrace17.png" alt="systrace截图分析"></p><h2 id="APP-Owner（HWUI模块异常）"><a href="#APP-Owner（HWUI模块异常）" class="headerlink" title="APP Owner（HWUI模块异常）"></a>APP Owner（HWUI模块异常）</h2><blockquote><p>到这一步已经没有异常耗时的draw operation, 所以主要是分析<code>APP画图</code>的行为。抓取方式：</p></blockquote><ol><li>adb shell setprop debug.hwui.log.systrace 1</li><li>adb shell dumpsys gfxinfo</li><li>抓取 systrace again (<code>must turn on view,input,freq,res,hwui/gfx</code>)</li></ol><p>如图：<br><img src="systrace18.png" alt="systrace截图分析"></p><hr><h2 id="App-owner-Consult-SS"><a href="#App-owner-Consult-SS" class="headerlink" title="App owner (Consult SS)"></a>App owner (Consult SS)</h2><blockquote><p>进入此状态大多是因为当下系统资源不足而导致，需要case by case 确认可以解决的方案。</p></blockquote><p>如图：<br><img src="systrace19.png" alt="systrace截图分析"></p><ul><li>系统配置信息：</li></ul><p>需要先确定对比机和测试机的系统配置信息<code>CPU cores/freq</code> 可以直接参考systrace (需确认<code>CPU_FREQUENCY event</code>有打开)</p><p>如图：<br><img src="systrace20.png" alt="systrace截图分析"></p><hr><h2 id="App-owner-Consult-SF合成"><a href="#App-owner-Consult-SF合成" class="headerlink" title="App owner (Consult SF合成)"></a>App owner (Consult SF合成)</h2><blockquote><p>需要看trace判断具体问题方向，例如以下几种问题：</p></blockquote><h3 id="Buffer是新的，但是内容还是和上一帧相同"><a href="#Buffer是新的，但是内容还是和上一帧相同" class="headerlink" title="Buffer是新的，但是内容还是和上一帧相同"></a>Buffer是新的，但是内容还是和上一帧相同</h3><p><code>Mali GPU</code>有种<code>smart partial update机制</code>（局部更新）, 不会整个buffer重刷。可以利用<code>debug property</code>先关闭, 视觉上比较容易看：</p><ul><li>adb shell setprop debug.gpu.hwcrc_disabled 1</li><li>adb shell stop</li><li>adb shell start</li></ul><p>如图：<br><img src="systrace21.png" alt="systrace截图分析"></p><h3 id="检查buffer-fence-time同步时间"><a href="#检查buffer-fence-time同步时间" class="headerlink" title="检查buffer fence time同步时间"></a>检查buffer fence time同步时间</h3><p>如图：<br><img src="systrace22.png" alt="systrace截图分析"></p><h3 id="强制GPU合成检查"><a href="#强制GPU合成检查" class="headerlink" title="强制GPU合成检查"></a>强制GPU合成检查</h3><p>在开发者选项中打开GPU强制合成，如果关掉就正常, 问题方向转回到 HWC/driver。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UI流畅平滑的systrace&quot;&gt;&lt;a href=&quot;#UI流畅平滑的systrace&quot; class=&quot;headerlink&quot; title=&quot;UI流畅平滑的systrace&quot;&gt;&lt;/a&gt;UI流畅平滑的systrace&lt;/h2&gt;&lt;h3 id=&quot;Systrace获取：&quot;&gt;&lt;a href=&quot;#Systrace获取：&quot; class=&quot;headerlink&quot; title=&quot;Systrace获取：&quot;&gt;&lt;/a&gt;Systrace获取：&lt;/h3&gt;&lt;p&gt;Android\Sdk\platform-tools\systrace&lt;/p&gt;
&lt;p&gt;systrace.py：&lt;br&gt;&lt;code&gt;python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal  res dalvik bionic power pm ss pdx sched freq idle load  binder_driver binder_lock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认Tag with: &lt;code&gt;sched freq idle res ss gfx input view am&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android LCD背光驱动节电技术LABC/CABC</title>
    <link href="https://alonealive.github.io/Blog/2020/01/05/2020/200105_android_lcd_cabc/"/>
    <id>https://alonealive.github.io/Blog/2020/01/05/2020/200105_android_lcd_cabc/</id>
    <published>2020-01-05T12:32:00.000Z</published>
    <updated>2020-03-08T10:24:30.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCD背光驱动节电技术LABC-CABC"><a href="#LCD背光驱动节电技术LABC-CABC" class="headerlink" title="LCD背光驱动节电技术LABC/CABC"></a>LCD背光驱动节电技术LABC/CABC</h2><blockquote><p>手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。<br>主要了解一下背光驱动节电技术CABC的概念和功能。<a href="https://blog.csdn.net/sinat_30545941/article/details/72874775" target="_blank" rel="noopener">参考博客</a></p></blockquote><a id="more"></a><hr><h2 id="OEM和ODM"><a href="#OEM和ODM" class="headerlink" title="*OEM和ODM"></a>*OEM和ODM</h2><p><strong>Note:</strong></p><ol><li>OEM：自主加工，英文全称Original Equipment Manufacturer，即原设备生产商。原始设备生产商(OEM)是指拥有自己的产品或产品理念，但有时会为了开发和/或制造这些产品而购买某些服务的公司。</li><li>ODM：自主设计，即ORIGINAL DESIGN MANUFACTURER，意为“原始设计制造商”，是指一家公司根据另一家公司的规格来设计和生产一个产品。例如，计算机公司如HP公司可能会就其想推向市场的一款笔记本电脑作出具体规格。它们会具体地列明产品的外观要求，如屏幕的尺寸和技术要求、输入/输出端口、键盘的前倾度、电脑包的外形和颜色、扬声器的位置等。它们还通常会具体列明对产品的主要内部细节如CPU或视频控制器的规格要求。但是，它们并不设计图样，不具体列明电源用的交换晶体管的型号，也不对背光变流器频率加以选择。这些都是ODM的工作。ODM根据计算机公司提出的规格要求来设计和生产笔记本电脑。有时候，ODM也可根据现有样品来生产。ODM方式往往更加注重合作，而在OEM的情形下，购买方对产品的具体规格基本不参与意见。</li><li>OBM：自主品牌</li></ol><p><strong>OEM和ODM的区别:</strong></p><p>OEM和ODM两者最大的区别不单单是名称而已。OEM产品是为品牌厂商度身订造的，生产后也只能使用该品牌名称，绝对不能冠上生产者自己的名称再进行生产。而ODM则要看品牌企业有没有买断该产品的版权。如果没有的话，制造商有权自己组织生产，只要没有企业公司的设计识别即可。</p><p>在工业社会中，OEM和ODM可谓司空见惯。因为出于制造成本、运输方便性、节省开发时间等方面的考虑，知名品牌企业一般都愿意找其他厂商OEM或ODM。在找别的企业进行OEM或ODM时，知名品牌企业也要承担不少责任。毕竟产品冠的是自己的牌子，如果产品质量不佳的话，少则有顾客找上门投诉，重则可能要上法庭。所以，品牌企业在委托加工期间肯定会进行严格的质量控制。但代工结束后，质量不敢保证。故此，当有的商家告诉你某件产品的生产商是某大品牌的OEM或ODM产品时，绝不要相信其质量就等同于该品牌。你唯一能够相信的，是这家制造商有一定的生产能力。</p><hr><h2 id="背光节电技术"><a href="#背光节电技术" class="headerlink" title="背光节电技术"></a>背光节电技术</h2><p>显示屏在移动设备里一直的是耗电大户。目前手机背光节电技术，即对应性背光控制技术（Adaptive Brightness Control- ABC），主要有下面2种：</p><ol><li>LABC：(LightAdaptive Brightness Control) <code>环境光侦测适应背光控制</code>。根据环境光的变化来控制背光亮度。需要一个光传感器，感应环境光强。</li><li>CABC：(ContentAdaptive Brightness Control）<code>显示内容对应背光控制</code>。根据显示内容来调节背光和gamma值，从而降低了背光LED的功耗。其中C是内容的意思，驱动IC新增了一个内容分析器电路。</li></ol><h2 id="LABC"><a href="#LABC" class="headerlink" title="LABC"></a>LABC</h2><p>LABC技术需要搭配光传感器实现，主机端处理器读取光感数值，然后处理器对数值进行处理，直接控制PMIC(MT6329)输出PWM控制背光的亮度。在比较暗光线下，降低背光达到省电效果</p><h2 id="CABC"><a href="#CABC" class="headerlink" title="CABC"></a>CABC</h2><p>CABC功能需要在LCD驱动IC内新增一个内容分析器(imagecontent analyzer)电路，当手机处理器传送了一张图片数据到驱动IC，内容分析器会计算并统计图片的数据后依据设定与算法自动的将其灰阶亮度提高30%（此时图片变亮），再将背光亮度降低30%（此时图片变暗）。由于我们事先已经将图片经过分析器电路补偿亮度，因此使用者可以得到与原先电路相差无几的显示效果，但减少了30%的背光功耗。</p><p>简单来说，CABC功能就是根据<code>显示内容</code>来降低背光，然后通过调<code>节gamma</code>(gamma越高灰度越低图像越暗)来补偿显示亮度。CABC就是通过增加内容灰阶标准同时降低背光亮度来达到省功耗的目的。</p><p>CABC主要有四种状态：</p><ol><li>Off Mode，CABC功能全部关闭；</li><li>UI Image Mode，优化显示UI图片时的功耗，尽可能的保证图片质量的同时可省10%的功耗；</li><li>Still Image Mode，优化显示静态图片时的功耗，该模式下图片质量损耗在可接受的范围内，同时可省30%的功耗；</li><li>Moving Image Mode，优化显示动态图片时的功耗，该模式下会最大限度的降低功耗，但是会带来图片质量的损耗，可省30%+的功耗。</li></ol><p>自然对应Off Mode，标准对应UI Mode，照片对应UI Mode，电影对应Still Image Mode。用户可根据实际情况自行选择。</p><p>三种模式省电级别依次降低: <code>UI mode &lt; Movie mode &lt; Still mode</code>， 也就是说Still mode是最省电的模式。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>工作流程如下：</p><ol><li>使能PMIC(MT6329)CABC功能;</li><li>设置LCD驱动IC的相关配置(使能CABC和配置gamma参数，需要FAE协助)；</li><li>CABC模块分析显示内容输出LED_PWM信号给PMIC，PMIC通过一定算法控制driver模块BL_DRV信号的输出波形；</li><li>预期结果是背光亮度降低，LCD驱动IC降低gamma值以补偿屏幕亮度。</li></ol><p>CABC模块分析显示内容输出<code>PWM波形</code>，占空比越大，表示需要输出的电流越大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LCD背光驱动节电技术LABC-CABC&quot;&gt;&lt;a href=&quot;#LCD背光驱动节电技术LABC-CABC&quot; class=&quot;headerlink&quot; title=&quot;LCD背光驱动节电技术LABC/CABC&quot;&gt;&lt;/a&gt;LCD背光驱动节电技术LABC/CABC&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。&lt;br&gt;主要了解一下背光驱动节电技术CABC的概念和功能。&lt;a href=&quot;https://blog.csdn.net/sinat_30545941/article/details/72874775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="display" scheme="https://alonealive.github.io/Blog/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android SurfaceFlinger和HWC2概述</title>
    <link href="https://alonealive.github.io/Blog/2019/12/22/2019/191222_android_HWC2/"/>
    <id>https://alonealive.github.io/Blog/2019/12/22/2019/191222_android_HWC2/</id>
    <published>2019-12-22T15:32:00.000Z</published>
    <updated>2020-03-08T10:22:18.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载夕月风大佬博客： <a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">https://www.jianshu.com/p/824a9ddf68b9</a><br>参考Android Q AOSP源码添加修改部分内容<br>参考源码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r14/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r14/</a></p></blockquote><a id="more"></a><h2 id="SurfaceFlinger概述"><a href="#SurfaceFlinger概述" class="headerlink" title="SurfaceFlinger概述"></a>SurfaceFlinger概述</h2><p>大多数APP在屏幕通常显示三个部分：</p><ul><li>屏幕顶部的状态栏</li><li>底部或者侧边的导航栏</li><li>应用的界面</li></ul><p>有些应用会显示更多或者更少的层。例如主屏幕会有一个单独的壁纸层；全屏幕的游戏可能会隐藏状态栏目。这些可以通过<code>Dump Surfacelinger</code>查看BufferLayers部分的信息来获取具体信息（<code>adb shell dumpsys SurfaceFlinger</code>）。从Dump结果看，layer呈树形结构(<code>Tree</code>)分布。</p><p>每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。</p><h3 id="SurfaceFlinger类定义"><a href="#SurfaceFlinger类定义" class="headerlink" title="SurfaceFlinger类定义"></a>SurfaceFlinger类定义</h3><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> <span class="keyword">public</span> BnSurfaceComposer,</span><br><span class="line">                       <span class="keyword">public</span> PriorityDumper,</span><br><span class="line">                       <span class="keyword">private</span> IBinder::DeathRecipient,</span><br><span class="line">                       <span class="keyword">private</span> HWC2::ComposerCallback</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>继承BnSurfaceComposer，实现ISurfaceComposer接口；实现ComposerCallback；继承辅助类PriorityDumper，主要提供SurfaceFlinger的Dump信息，并且提高提供信息的分离和格式设置。</p><h3 id="ISurfaceComposer接口实现"><a href="#ISurfaceComposer接口实现" class="headerlink" title="ISurfaceComposer接口实现"></a>ISurfaceComposer接口实现</h3><p>ISurfaceComposer是提供给上层Client端的接口（Bp端），此处的SurfaceFlinger是Server端（Bn端）。接口内容包括：</p><figure class="highlight c++"><figcaption><span>frameworks/native/include/gui/ISurfaceComposer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposer</span>:</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposer)</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">/* returns information for each configuration of the given display</span></span><br><span class="line"><span class="comment">     * intended to be used to get information about built-in displays */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getDisplayConfigs</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector&lt;DisplayInfo&gt;* configs)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>接口在SurfaceFlinger中都有对应的方法实现。Client端通过Binder跨进程调到SurfaceFlinger中。获取Display的信息，其实现就是SurfaceFlinger的<code>getDisplayConfig</code>函数。</p><h3 id="ComposerCallback接口实现"><a href="#ComposerCallback接口实现" class="headerlink" title="ComposerCallback接口实现"></a>ComposerCallback接口实现</h3><p>ComposerCallback是HWC2的callback接口，包括以下接口：</p><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HWC2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement this interface to receive hardware composer events.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// These callback functions will generally be called on a hwbinder thread, but</span></span><br><span class="line"><span class="comment">// when first registering the callback the onHotplugReceived() function will</span></span><br><span class="line"><span class="comment">// immediately be called on the thread calling registerCallback().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls receive a sequenceId, which will be the value that was supplied to</span></span><br><span class="line"><span class="comment">// HWC2::Device::registerCallback(). It's used to help differentiate callbacks</span></span><br><span class="line"><span class="comment">// from different hardware composer instances.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerCallback</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onHotplugReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Connection connection)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRefreshReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onVsyncReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int64_t</span> timestamp)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ComposerCallback() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>Callback提供了注册接口<code>registerCallback</code>，在SurfaceFlinger初始化的时候注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(  <span class="string">"SurfaceFlinger's main thread ready to run. "</span></span><br><span class="line">            <span class="string">"Initializing graphics H/W..."</span>);</span><br><span class="line">....</span><br><span class="line">mCompositionEngine-&gt;getHwComposer().registerCallback(<span class="keyword">this</span>, getBE().mComposerSequenceId);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此处<code>registerCallback</code>的<code>this</code>就是SurfaceFlinger对ComposerCallback接口的实现。</p><ul><li>onHotplugReceived： 热插拔事件的回调，显示屏幕连接或者断开时回调。</li><li>onRefreshReceived： 接收底层HWComposer的刷新请求。在<code>repaintEverythingForHWC</code>中，<code>mRepaintEverything</code>为<code>true</code>的时候，将触发一次刷新，重新进行合成显示。重新绘制说明底层配置、参数等有变动，SurfaceFlinger前面给的数据不能用，需要重新根据变动后的配置进行合成，给适合当前配置的显示数据。</li></ul><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onRefreshReceived</span><span class="params">(<span class="keyword">int</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="comment">/*hwcDisplayId*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sequenceId != getBE().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    repaintEverythingForHWC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onVsyncReceived： Vsync事件上报，接收底层硬件上报的垂直同步信号。此处可以通过抓取<code>Systrace</code>的方式查看具体的Vsync的信息（底层硬件、SurfaceFlinger、APP三部分的Vsync，一般Android版本升级的时候会进行<code>vsync的tuning</code>）</li><li><strong>显示周期Vsync</strong>： 设备显示会按照一定速率更新（一般是一秒60帧，即16.6ms刷新一次）。如果显示内容在刷新期间更新，则会出现撕裂现象，因此必须在周期之间更新（<code>这也是vsync tunning的必要性，保持SurfaceFlinger和draw frame都在vsync周期里面，并且不重叠</code>）在可以安全更新内容时，系统便会接收来自显示设备的信号。</li></ul><p>刷新率可能会随时间而变化，例如一些设备的刷新范围在58fps至62fps之间，具体视当前条件而定。对于连接了HDMI的电视，刷新率在理论上可以下降到24Hz或者48Hz，以便和视频匹配。由于每个刷新周期只能更新屏幕一次，因此以200fps的刷新率为显示设备提交缓冲区并没有必要性，因为大部分桢不能被看到（人眼合适的是60fps）。SurfaceFlinger不会在应用提交缓冲区时进行操作，而是在显示设备准备好接收新缓冲区的时候才会唤醒。</p><p>当Vsync信号到达的时候，SurfaceFlinger会遍历层列表，以寻找新的缓冲区。如果找到会获取该缓冲区，否则会使用以前获取的缓冲区。SurfaceFlinger总是需要可显示的内容，因此会保留一个缓冲区。如果在某个层没有提交缓冲区，则该层会被忽略。</p><p>此处会在合成调用到<code>handlePageFlip</code>函数，函数中先调用<code>latchBuffer</code>从BufferQueue取Buffer，然后等待Vsync信号更新到FrameBuffer。</p><ul><li><strong>合成方式</strong>： 目前SurfaceFlinger支持两种合成方式：一种是Device合成，一种是Client合成。SurfaceFlinger在收集可见层的所有缓冲区之后，便会询问HardwareComposer应该如何进行合成。</li><li><ul><li>Client合成：之前称之为GLES合成，也可以称之为GPU合成，该合成方式是相对于硬件合成来说的，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件Client合成采用RenderEngine进行合成。</li></ul></li><li><ul><li>Device合成： 用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Device合成的抽象。</li></ul></li></ul><p>合成方式可以从Dump SurfaceFlinger中查看到Layer的具体合成方式，GPU合成一般可以通过开发者选项中启动，强制GPU合成；而Device合成在Dump信息中一般显示成SDE合成。</p><p>GPU合成数据后，作为一个特殊的Layer传给显示硬件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Display 0 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Comp Type |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> com.android.systemui.ImageWallpaper#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"> net.oneplus.launcher/net.oneplus.launcher.Launcher#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> StatusBar#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> GestureButtonRegion#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0 2216 1080 2280 |    0.0    0.0 1080.0   64.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlay#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0    0 1080  106 |    0.0    0.0 1080.0  106.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlayBottom#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0 2198 1080 2280 |    0.0    0.0 1080.0   82.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">| Idx |  Comp Type |   Split   | Pipe |    W x H    |          Format          |  Src Rect (L T R B) |  Dst Rect (L T R B) |  Z |    Flags   | Deci(HxV) | CS | Rng |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">|   6 | GPU_TARGET |    Pipe-1 |   94 | 1088 x 2288 |           RGBA_8888_UBWC |    0    0 1080 2280 |    0    0 1080 2280 |  0 | 0x00000002 |   0 x   0 |  0 |   0 |</span><br><span class="line">|   4 |        SDE |    Pipe-1 |  103 | 1088 x  112 |           RGBA_8888_UBWC |    0    0 1080  106 |    0    0 1080  106 |  1 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|   5 |        SDE |    Pipe-1 |   92 | 1088 x   96 |           RGBA_8888_UBWC |    0    0 1080   82 |    0 2198 1080 2280 |  2 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br></pre></td></tr></table></figure><ul><li>SurfaceFlingerBE: 从Android P上分离出来，定义上看是将Surfacelinger分离为前后端。</li><li>消息队列和主线程： 和应用进程类似，SurfaceFlinger也有一个主线程，主要是进行显示数据的处理，即合成。Surfacelinger是一个服务，将会响应上层的请求，各个进程的请求都在SurfaceFlinger的各个Binder线程中，如果线程很耗时，那么应用端就会被block。主线程将他们分离开来，各干各的。</li></ul><p><strong>Note：</strong></p><ol><li>SurfaceFligner有两个状态，Layer也有两个状态，一个是mCurrentState，一个是mDrawingState。</li><li>两个EventThread，一个是给SurfaceFlinger本身使用，一个是为了给应用分发事件的。</li></ol><hr><h3 id="mCurrentState和mDrawingState"><a href="#mCurrentState和mDrawingState" class="headerlink" title="mCurrentState和mDrawingState"></a><code>mCurrentState</code>和<code>mDrawingState</code></h3><ol><li>这两个成员是Layer类中<code>Layer::State</code>的类型。</li></ol><figure class="highlight c++"><figcaption><span>Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    Geometry active;  <span class="comment">//计算后的实际尺寸</span></span><br><span class="line">    Geometry requested; <span class="comment">//用户设置的尺寸</span></span><br><span class="line">    <span class="keyword">int32_t</span> z; <span class="comment">//Layer的Z轴值，值越小位置就越靠小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> layerStack;  <span class="comment">//和显示设备的关联值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unit8_t</span> alpha; <span class="comment">//Layer的透明度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> flags;  <span class="comment">//Layer的标志（如果上次绘制后用户改变了Layer）</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int32_t</span> sequence; <span class="comment">//序列值，Layer的属性变化一次就会加一（例如setAlpha,setSize,setLayer等）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// the transparentRegion hint is a bit special, it's latched only</span></span><br><span class="line">    <span class="comment">// when we receive a buffer -- this is because it's "content"</span></span><br><span class="line">    <span class="comment">// dependent.</span></span><br><span class="line">    Region activeTransparentRegion; <span class="comment">//实际的透明区域</span></span><br><span class="line">    Region requestedTransparentRegion;  <span class="comment">//用户中的透明区域</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Surfacelinger创建Surface的时候，会调用<code>createLayer</code>，然后调用<code>addClientLayer</code>函数，这里会把Layer对象放在<code>mCurrentState</code>的layerSortedByZ对象中。</p></li><li><p>Surfacelinger合成的时候，调用<code>preComposition</code>函数，会先调用<code>mDrawingState</code>的layerSortedByZ来获取上次绘图的Layer层列表（并不是所有layer都参与屏幕图像的绘制，因此通过State对象记录参与绘制的Layer对象）</p></li><li><p>Layer对象在绘制图形时，使用的是mDrawingState变量；用户调用接口设置Layer对象属性时，设置的值保存在mCurrentState中。这样就不会因为用户的操作而干扰Layer对象的绘制了。</p></li><li><p><code>Layer::doTransaction</code>函数会比较这两个成员变量，如果有不同的地方，说明上次绘制后，用户改变了Layer的属性，要把这种变化通过flags返回。</p></li><li><p><code>layerStack</code>字段是用户指定的一个值，用户可以给DisplayDevice指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备输出。这样的好处可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放的Surface窗口，但是不显示Activity窗口。</p></li><li><p><code>Layer::doTransaction</code>最后会调用<code>commitTransaction</code>函数，就是将mCurrentState赋值给mDrawingState。</p></li></ol><hr><ol start="8"><li>以上的是在Layer.cpp中的两个成员变量，而在<code>SurfaceFlinger.cpp</code>也有同名的<code>mCurrentState</code>和<code>mDrawingState</code>两个成员变量（定义在SurfaceFlinger.h中），定义不一样，只是名字相同。</li></ol><figure class="highlight c++"><figcaption><span>SF.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit State(LayerVector::StateSet set) : stateSet(set), layersSortedByZ(set) &#123;&#125;</span><br><span class="line">    State&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> State&amp; other) &#123;</span><br><span class="line">        <span class="comment">// We explicitly don't copy stateSet so that, e.g., mDrawingState</span></span><br><span class="line">        <span class="comment">// always uses the Drawing StateSet.</span></span><br><span class="line">        layersSortedByZ = other.layersSortedByZ;</span><br><span class="line">        displays = other.displays;</span><br><span class="line">        colorMatrixChanged = other.colorMatrixChanged;</span><br><span class="line">        <span class="keyword">if</span> (colorMatrixChanged) &#123;</span><br><span class="line">            colorMatrix = other.colorMatrix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid;</span><br><span class="line">    LayerVector layersSortedByZ;  <span class="comment">//保存所有参与绘制的Layer对象</span></span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays; <span class="comment">//保存所有输出设备的DisplayDeviceState对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> colorMatrixChanged = <span class="literal">true</span>;</span><br><span class="line">    mat4 colorMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInReverseZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="9"><li>SF.cpp中的<code>handleTransactionLocked</code>函数会根据<code>eTraversalNeeded</code>标志决定是否要检查所有的Layer对象。如果某个Layer对象有这个标志，将会调用他的<code>doTransaction</code>函数。<code>Layer::doTransaction</code>函数返回的flags如果有<code>eVisibleRegion</code>说明这个Layer需要更新，就把<code>mVisibleRegionDirty</code>设置为true。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Notify all layers of available frames</span></span><br><span class="line">    mCurrentState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;notifyAvailableFrames();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Traversal of the children</span></span><br><span class="line"><span class="comment">     * (perform the transaction for each of them if needed)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">        mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">            <span class="keyword">if</span> (!trFlags) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......<span class="comment">//这部分代码是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看LayerStack是否和DisplayDevice的layerStack相同）的TransformHint（主要指设备的显示方向orientation）</span></span><br><span class="line"></span><br><span class="line">    commitTransaction();</span><br><span class="line"></span><br><span class="line">    updateCursorAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> <code>handleTransaction</code>的作用是处理系统在两次刷新期间的各种变化。Surfacelinger模块中不管是SurfaceFlinger类和Layer类</p><hr><h2 id="硬件合成HWC2概述"><a href="#硬件合成HWC2概述" class="headerlink" title="硬件合成HWC2概述"></a>硬件合成HWC2概述</h2><p>Hardware Composer HAL(HWC)是指硬件完成图像数据组合并显示的能力。</p><p>SurfaceFlinger是一个系统服务（系统启动时启动），作用是接收来自多个源的Buffer数据，并进行合成，然后发送到显示设备进行显示。</p><p>SurfaceFlinger和HWC的相互配合，实现Android系统的合成和显示（非GPU合成）。</p><hr><p>Android 7.0包含新版本的HWC（HWC2），Android需要自行配置。</p><p>Android 8.0，HWC2正式开启，并且版本升级为2.1。（<code>/frameworks/native/services/surfaceflinger/DisplayHardware/</code>）</p><p>HWC2是SurfaceFlinger用来与专门的窗口合成硬件进行通信（Device合成方式）。SurfaceFlinger包含使用3D图形处理器（GPU）执行窗口合成任务的备用途径，但是此路径并不理想（GPU合成方式），因为：</p><ol><li>通常，GPU没有针对此进行优化，因此能耗可能大于执行合成所需的能耗；</li><li>每次SUrfaceFlinger使用GPU合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是GPU进行合成。</li></ol><p>GPU（Client合成）和HWC（Client合成）两种方式对比：</p><table><thead><tr><th align="center">合成类型</th><th align="center">耗电情况</th><th align="center">性能情况</th><th align="center">Alpha处理</th><th align="center">DRM内容处理</th><th align="center">其他限制</th></tr></thead><tbody><tr><td align="center">Device合成（HWC）</td><td align="center">耗电低</td><td align="center">性能高</td><td align="center">很多Vendor的HWC不支持Alpha的处理和合成</td><td align="center">基本都能访问DRM内容</td><td align="center">能合成的Surface层数有限，对每种Surface类型处理层数有限</td></tr><tr><td align="center">Client合成（GPU）</td><td align="center">耗电高</td><td align="center">性能低</td><td align="center">能处理每个像素的Alpha及每个Layer的Alpha</td><td align="center">早期版本GPU不能访问DRM的内容</td><td align="center">目前的处理层数没有限制</td></tr></tbody></table><p><strong>Note:</strong></p><ol><li>Alpha处理： 图片的透明度（0～255或者0.0f~1.0f），数值越小透明度越高</li><li>DRM内容处理：（Digital Rights Management）一种业界使用广泛的数字内容版权保护技术。</li></ol><h3 id="HWC常规准则"><a href="#HWC常规准则" class="headerlink" title="HWC常规准则"></a>HWC常规准则</h3><p>Hardware Composer抽象层后的物理显示设备硬件可因设备而异。但是一般来说，遵循以下规则：</p><ol><li>HWC应至少支持4个叠加层（状态栏、系统栏、应用、壁纸/背景）</li><li>层可以大于屏幕，因此HWC应能处理大于显示屏的层（例如壁纸）</li><li>应该同时支持预乘每个像素Alpha混合和每个平面Alpha混合</li><li>HWC应能够处理GPU、Camera、视频解码器（Video Decoder）生成的相同缓冲区，因此支持以下某些属性会很有帮助：</li></ol><ul><li><ul><li>RGBA打包顺序</li></ul></li><li><ul><li>YUV格式</li></ul></li><li><ul><li>Tiling,swizzling和步幅属性</li></ul></li></ul><ol start="5"><li>为了支持受保护的内容（Secure layer），必须提供受保护视频播放的硬件路径</li></ol><p><strong>Note：</strong></p><ol><li>RGBA是一种颜色值</li><li>YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。他与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。从字面意思理解，YUV的含义:Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，如YUV422这是大部分镜头出来的数据，还有许多（yuv420,yuv444等）</li><li>Tiling简单来说就是将image进行切割，切成<code>M * N</code>小块，最后用的时候再进行拼接，类似铺瓷砖</li><li>swizzling是一种拌和技术，这是向量的单元可以被任意的重新排放或重复</li></ol><p>HWC专注于优化，智能的选择要发送到叠加硬件的Surface，以最大限度减轻GPU的负载。<strong>另一种优化是检测屏幕是否正在更新；如果不是，这将合成委托给OpenGL而不是HWC，以节省电量。但屏幕再次更新时，继续将合成分发给HWC</strong>。</p><p>为常见的用例做准备，比如：</p><ul><li>纵向和横向模式下的全屏游戏</li><li>带着字幕和播放控件的全屏视频</li><li>主屏幕（状态栏、系统栏目、应用、动态壁纸）</li><li>受保护的视频播放</li><li>多显示设备支持</li></ul><h3 id="HWC2框架"><a href="#HWC2框架" class="headerlink" title="HWC2框架"></a>HWC2框架</h3><p>从Android 8.0开始的Treble项目，对Android架构做了调整，让制造商以更低的成本更加轻松快速的将设备更新到Android系统。这就对HAL层有了很大的调整，利用提供给Vendor的接口，将Vendor的实现和Android上层分离开来。</p><p>这样的架构也使得HWC架构变得复杂，HWC属于<code>Binderized</code>的HAL类型。<code>Binderized</code>类型的HAL将上层Android和底层HAL分别采用两个不同的进程实现，中间采用Binder进行通信，为了和前面的Binder进行区别，这里采用<code>HWBinder</code>。</p><p>可以将HWC分为以下几个部分：</p><ul><li><p>Binder 1：</p></li><li><ul><li>SurfaceFlinger Service</li></ul></li><li><ul><li>HWC2 Client</li></ul></li><li><p>Binder 2：</p></li><li><ul><li>HWC2 Server</li></ul></li><li><ul><li>HWC2 Vendor Impl</li></ul></li></ul><p><strong>具体解释：</strong></p><ol><li>Client端：Client就是指SurfaceFlinger。不过SurfaceFlinger采用前后端设计，以后和HWC相关的逻辑应该会放到后端（<code>SurfaceFlingerBE</code>），即<code>/frameworks/native/services/surfaceflinger/</code></li><li>HWC Client端： 这一部分属于SurfaceFlinger进程，直接用过Binder通信，和HWC2的HAL Server交互。在SurfaceFlinger中采用<code>namespace HWC2</code>的命名空间，即<code>frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</code>。</li><li>HWC2 Server端: 这里将建立一个进程实现HWC的<code>Server端</code>。服务端再调用底层Vendor的具体实现。并且，对于底层合成的实现不同，此处会做一些适配（<code>适配HWC1.x</code>），和FrameBuffer的实现。这部分包含三部分：<strong>接口、实现、服务</strong>，以动态库的形式存在：（<code>hardware/interfaces/graphics/composer/2.1/default/</code>）</li></ol><ul><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1.so">android.hardware.graphics.composer@2.1.so</a></li></ul></li><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1-impl.so">android.hardware.graphics.composer@2.1-impl.so</a></li></ul></li><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1-service.so">android.hardware.graphics.composer@2.1-service.so</a></li></ul></li></ul><ol start="3"><li>HWC Vendor实现： 这部分是HWC的具体实现，由硬件厂商完成，（<code>例如高通QCOM</code>），代码一般是<code>hardware/qcom/display/</code>。HWC必须采用<code>Binderized HAL</code>模式，但是不一定要实现HWC2的HAL版本。HWC2的实现需要配置，以Android 8.0为例，包含：</li></ol><ul><li><ul><li>添加宏定义<code>TARGET_USERS_HWC2</code></li></ul></li><li><ul><li>编译打包HWC2相关的so库</li></ul></li><li><ul><li>SELinux相关的权限添加</li></ul></li><li><ul><li>配置<code>manifest.xml</code>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.graphics.composer&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;IComposer&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">&lt;/hal&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="HWC2数据结构"><a href="#HWC2数据结构" class="headerlink" title="HWC2数据结构"></a>HWC2数据结构</h3><ol><li>HWC2的一些常用接口定义在头文件<code>hardware/libhardware/include/hardware/hwcomposer2.h</code>中，一些共用的数据定义是HAL的接口中:</li></ol><ul><li><code>hardware/interfaces/graphics/common/1.0/</code></li><li><code>hardware/interfaces/graphics/composer/2.1/</code></li></ul><h3 id="图层Layer"><a href="#图层Layer" class="headerlink" title="图层Layer"></a>图层Layer</h3><p>每个Layer都有一组属性，用来定义和其他Layer的交互方式。他在每一个模块（层）代码定义的实现不一样，但是Layer的理念是一样的。</p><ul><li><p><a href="http://aosp.opersys.com/xref/android-10.0.0_r14/xref/frameworks/native/services/surfaceflinger/" target="_blank" rel="noopener">SurfaceFlinger中</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger</span><br><span class="line">├── Layer.h</span><br><span class="line">├── Layer.cpp</span><br><span class="line">├── ColorLayer.h</span><br><span class="line">├── ColorLayer.cpp</span><br><span class="line">├── BufferLayer.h</span><br><span class="line">└── BufferLayer.cpp</span><br><span class="line">|__ ...</span><br></pre></td></tr></table></figure></li><li><p><a href="">HWC2中</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;DisplayHardware</span><br><span class="line">├── HWC2.h</span><br><span class="line">└── HWC2.cpp</span><br></pre></td></tr></table></figure><ul><li>在HAL中实现时，定义为hwc2_layer_t，是在头文件hwcomposer2.h中定义的:<code>typedef uint64_t hwc2_layer_t;</code></li><li>HIDL中定义为Layer，这个Layer和<code>hwc2_layer_t</code>是一样的：<code>typedef uint64_t Layer;</code></li></ul><h4 id="Layer按照类型划分"><a href="#Layer按照类型划分" class="headerlink" title="Layer按照类型划分"></a>Layer按照类型划分</h4><p>大致分为<code>BufferLayer</code>和<code>COlorLayer</code>（在SF中createLayer中），<code>BufferLayer</code>就是有Buffer的Lyaer（Bufferueue，GraphicsBuffer），需要上层应用Producer生长；<code>ColorLayer</code>可以绘制一种制定的颜色和透明度Alpha（取代之前的Dim Layer）。</p><h4 id="Layer按照数据划分"><a href="#Layer按照数据划分" class="headerlink" title="Layer按照数据划分"></a>Layer按照数据划分</h4><p>大致分为<code>RGB Layer</code>和<code>YUV Layer</code>，前者是RGB格式，比较常见的就是UI界面的数据；后者的Buffer是YUV类型的，平常播放Video，Camera预览等，都是YUV类型的。</p><h3 id="Layer属性"><a href="#Layer属性" class="headerlink" title="Layer属性*"></a>Layer属性*</h3><blockquote><p>Layer的属性定义他和其他模块（层）的关系，和显示屏（DeisplayDevice）的关系等。Layer包含的属性类别如下（上述也有部分内容）：</p></blockquote><h4 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h4><blockquote><p>定义层在其显示设备上的现实位置，包含层边缘的位置和其相对于其他层的Z-Order等，并且还定义了很多个<strong>区域Region</strong>：</p></blockquote><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    ... ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// regions below are in window-manager space</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line">    Region coveredRegion;</span><br><span class="line">    Region visibleNonTransparentRegion;</span><br><span class="line">    Region surfaceDamageRegion;</span><br></pre></td></tr></table></figure><p>Region中是很多个Rect的集合，即一个Layer的visibleRegion可能是几个Rect的集合（rect对象用来存储一个矩形框的左上角坐标、宽度和高度。描述矩形的宽度、高度和原点）</p><p>SurfaceFlinger中定义的Region都是从上层（WMS）传递过来的。而在HWC中，是用的下面的结构描述：</p><figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer_defs.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r;</span><br><span class="line">    <span class="keyword">uint8_t</span> g;</span><br><span class="line">    <span class="keyword">uint8_t</span> b;</span><br><span class="line">    <span class="keyword">uint8_t</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_float_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r;</span><br><span class="line">    <span class="keyword">float</span> g;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_float_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_frect</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> left;</span><br><span class="line">    <span class="keyword">float</span> top;</span><br><span class="line">    <span class="keyword">float</span> right;</span><br><span class="line">    <span class="keyword">float</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_frect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_rect</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_rect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_region</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> numRects;</span><br><span class="line">    <span class="keyword">hwc_rect_t</span> <span class="keyword">const</span>* rects;</span><br><span class="line">&#125; <span class="keyword">hwc_region_t</span>;</span><br></pre></td></tr></table></figure><ul><li>Transform，这个在SurfaceFlinger中定义的一个重要的结构，意思是变换矩阵，是一个<code>3*3</code>的矩阵。</li></ul><p><strong>联系流程：</strong><br><code>Rect &lt;- Region &lt;- Layer &lt;- State &lt;- Geometry &lt;- Transform &lt;- mat33</code></p><ul><li>Layer的两个状态：mCurrentState和mDrawingState，前者是给SurfaceFlinger的前段准备数据，后者是将数据给到合成。每个状态有两个Geometry的描述<code>request</code>（上层请求的）和<code>active</code>（当前正在使用的）。每个Geometry中有一个Transform矩阵，一个Transform包含一个mat33的整列。</li></ul><p>Transform中包含两部分，一部分是位置Postion，另一部分是真正的2D的变换矩阵。通过下面两个函数设置：（对应Layer中的setPostion和setMatrix函数，这是上层WMS设置下来的）</p><figure class="highlight c++"><figcaption><span>frameworks/native/libs/ui/Transform.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> tx, <span class="keyword">float</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">0</span>] = tx;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">1</span>] = ty;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isZero(tx) &amp;&amp; isZero(ty)) &#123;</span><br><span class="line">        mType &amp;= ~TRANSLATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mType |= TRANSLATE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> c, <span class="keyword">float</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mat33&amp; <span class="title">M</span><span class="params">(mMatrix)</span></span>;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">0</span>] = a;    M[<span class="number">1</span>][<span class="number">0</span>] = b;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">1</span>] = c;    M[<span class="number">1</span>][<span class="number">1</span>] = d;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;    M[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    mType = UNKNOWN_TYPE;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h4 id="内容属性"><a href="#内容属性" class="headerlink" title="内容属性"></a>内容属性</h4><blockquote><p>定义显示的内容如何呈现（即Buffer）。Layer的显示，除了之前的几个区域Region描述，还有很多结构进一步描述才能显示，例如裁减（用来扩展内容的一部分以填充层的边界）和转换（用来显示旋转或者翻转的内容）等信息。HWCInfo结构体中包括了一些这样的信息：</p></blockquote><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputLayerCompositionState</span> &#123;</span></span><br><span class="line">    <span class="comment">// The region of this layer which is visible on this output</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, client composition will be used on this output</span></span><br><span class="line">    <span class="keyword">bool</span> forceClientComposition&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, when doing client composition, the target may need to be cleared</span></span><br><span class="line">    <span class="keyword">bool</span> clearClientTarget&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The display frame for this layer on this output</span></span><br><span class="line">    Rect displayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The source crop for this layer on this output</span></span><br><span class="line">    FloatRect sourceCrop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The buffer transform to use for this layer o on this output.</span></span><br><span class="line">    Hwc2::Transform bufferTransform&#123;<span class="keyword">static_cast</span>&lt;Hwc2::Transform&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Z order index of this layer on this output</span></span><br><span class="line">    <span class="keyword">uint32_t</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * HWC state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hwc</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Hwc</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer)</span> : <span class="title">hwcLayer</span><span class="params">(hwcLayer)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC Layer backing this layer</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC composition type for this layer</span></span><br><span class="line">        Hwc2::IComposerClient::Composition hwcCompositionType&#123;</span><br><span class="line">                Hwc2::IComposerClient::Composition::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The buffer cache for this layer. This is used to lower the</span></span><br><span class="line">        <span class="comment">// cost of sending reused buffers to the HWC.</span></span><br><span class="line">        HwcBufferCache hwcBufferCache;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The HWC state is optional, and is only set up if there is any potential</span></span><br><span class="line">    <span class="comment">// HWC acceleration possible.</span></span><br><span class="line">    <span class="built_in">std</span>::optional&lt;Hwc&gt; hwc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; result)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关系图：</p><p><img src="Layer_Struct.png" alt="Layer显示结构图"></p><p>解释：</p><ol><li>Layer区域和屏幕区域，就是Layer和屏幕本身的大小区域</li><li>sourceCrop：剪切区域，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。</li><li>displayFrame：显示区域，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。</li><li>visibleRegion：可见区域，displayFrame 区域不一定都能看到的，如果存在上层Layer，那么displayFrame区域可能部分或全部被盖住，displayFrame没有被盖住的部分就是可见区域visibleRegion。</li><li>damageRegion 受损区域，或者称之为更新区域。damageRegion表示Layer内容被破坏的区域，也就是说这部分区域的内容变了，所以这个属性一般是和上一帧相比时才有意义。这算是对合成的一种优化，重新合成时，我们只去合成damageRegion区域，其他的可见区域还是用的上一帧的数据。</li><li>visibleNonTransparentRegion：可见非透明区域。透明区域transparentRegion是可见区域visibleRegion的一部分，只是这一部分透明的看到的是底层Layer的内容。在SurfaceFlinger的Layer中定义visibleNonTransparentRegion，表示可见而又不透明的部分。</li><li>coveredRegion：被覆盖的区域。表示Layer被TopLayer覆盖的区域，一看图就很好理解。从图中，你可以简单的认为是displayFrame和TopLayer区域重合的部分。</li></ol><p><strong>注意：</strong> 这里之所以说简单的认为，这是因为HWC空间的区域大小是SurfaceFlinger空间的区域经过缩放，经过Transform旋转，移动等后才得出的，要是混淆了就理解不对了。</p><h4 id="合成属性（确认用哪种合成方式）"><a href="#合成属性（确认用哪种合成方式）" class="headerlink" title="合成属性（确认用哪种合成方式）"></a>合成属性（确认用哪种合成方式）</h4><blockquote><p>定义层应如何与其他层合成。包括混合模式和用于Alpha合成的全层Alpha值等信息。总的说来，合成分为两个大类：<code>GPU合成</code>和<code>HWC合成</code>。根据具体的情况，分为下列几类：</p></blockquote><figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Composition</span> :</span> <span class="keyword">int32_t</span> &#123;</span><br><span class="line">    Invalid = HWC2_COMPOSITION_INVALID,</span><br><span class="line">    <span class="built_in">Client</span> = HWC2_COMPOSITION_CLIENT,</span><br><span class="line">    Device = HWC2_COMPOSITION_DEVICE,</span><br><span class="line">    SolidColor = HWC2_COMPOSITION_SOLID_COLOR,</span><br><span class="line">    Cursor = HWC2_COMPOSITION_CURSOR,</span><br><span class="line">    Sideband = HWC2_COMPOSITION_SIDEBAND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>释义：</strong></p><ol><li>Client 相对HWC2硬件合成的概念，主要是处理BufferLayer数据，用GPU处理。</li><li>Device HWC2硬件设备，主要处理BufferLayer数据，用HWC处理</li><li>SolidColor 固定颜色合成，主要处理ColorLayer数据，用HWC处理或GPU处理。</li><li>Cursor 鼠标标识合成，主要处理鼠标等图标，用HWC处理或GPU处理</li><li>Sideband Sideband为视频的边频带，一般需要需要硬件合成器作特殊处理，但是也可以用GPU处理。</li></ol><p>在合成信息HWCInfo中，包含成的类型。通过Layer的setCompositionType方法进行指定：</p><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::setCompositionType</span><span class="params">(<span class="keyword">int32_t</span> hwcId, HWC2::Composition type, <span class="keyword">bool</span> callIntoHwc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBE().mHwcLayers.count(hwcId) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"setCompositionType called without a valid HWC layer"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcInfo = getBE().mHwcLayers[hwcId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = hwcInfo.layer;</span><br><span class="line">    ALOGV(<span class="string">"setCompositionType(%"</span> PRIx64 <span class="string">", %s, %d)"</span>, hwcLayer-&gt;getId(), to_string(type).c_str(),</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(callIntoHwc));  <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (hwcInfo.compositionType != type) &#123;</span><br><span class="line">        ALOGV(<span class="string">"    actually setting"</span>);</span><br><span class="line">        hwcInfo.compositionType = type;</span><br><span class="line">        <span class="keyword">if</span> (callIntoHwc) &#123;</span><br><span class="line">            <span class="keyword">auto</span> error = hwcLayer-&gt;setCompositionType(type);  <span class="comment">//合成方式</span></span><br><span class="line">            ALOGE_IF(error != HWC2::Error::None,</span><br><span class="line">                     <span class="string">"[%s] Failed to set "</span></span><br><span class="line">                     <span class="string">"composition type %s: %s (%d)"</span>,</span><br><span class="line">                     mName.<span class="built_in">string</span>(), to_string(type).c_str(), to_string(error).c_str(),</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定合成类型分成三步：</p><ol><li>SurfaceFlinger制定合成类型，此时<code>callIntoHwc=true</code>，将类型制定给HWC</li><li>HWC根据实际情况看SurfaceFlinger制定的合成类型是否可以执行，如果不满足，作出修改</li><li>SurfaceFlinger根据HWC的修改情况再作出调整，最终确认合成类型，此时<code>callIntoHwc=false</code></li></ol><h4 id="优化属性"><a href="#优化属性" class="headerlink" title="优化属性"></a>优化属性</h4><blockquote><p>提供一些非必须的参数，以供HWC进行合成的优化。包括层的可见区域以及层的哪个部分自上一帧以来已经更新等信息。也就是前面说到的visibleRegion，damageRegion等。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>本篇主要是SurfaceFlinger概述，和HWC2的概述，还有Layer的属性和类型，合成方式的内容。<br>另外还有关于HWC的内容，和Display显示设备的信息重新划分单独的一篇学习。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载夕月风大佬博客： &lt;a href=&quot;https://www.jianshu.com/p/824a9ddf68b9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/824a9ddf68b9&lt;/a&gt;&lt;br&gt;参考Android Q AOSP源码添加修改部分内容&lt;br&gt;参考源码： &lt;a href=&quot;http://aosp.opersys.com/xref/android-10.0.0_r14/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://aosp.opersys.com/xref/android-10.0.0_r14/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder实例</title>
    <link href="https://alonealive.github.io/Blog/2019/11/24/2019/191124_android_binder_example/"/>
    <id>https://alonealive.github.io/Blog/2019/11/24/2019/191124_android_binder_example/</id>
    <published>2019-11-24T07:59:40.000Z</published>
    <updated>2020-03-08T10:18:54.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点：</p></blockquote><ol><li>用驱动程序来推进进程间的通信；</li><li>可以通过共享内存的方式来提供性能；</li><li>可以为进程请求分配每个进程的线程池；</li><li>针对系统中的对象引入了引用计数和跨进程的对象引用映射；</li><li>可以方便的进行进程同步调用。</li></ol><a id="more"></a><blockquote><p>以下简单的Binder实例参考一位大佬。</p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmds&#x2F;helloWorld&#x2F;Android.mk                 | 29 +++++++++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;BnHelloWorldService.h      | 16 +++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;BpHelloWorldService.h      | 12 ++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;HelloWorldService.h        | 17 +++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;IHelloWorldService.h       | 21 +++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;main_helloworldclient.cpp  | 36 ++++++++++++++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;main_helloworldservice.cpp | 22 +++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;Android.bp                 | 38 ++++++++++++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BnHelloWorldService.cpp    | 24 +++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BnHelloWorldService.h      | 16 +++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BpHelloWorldService.cpp    | 25 ++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BpHelloWorldService.h      | 12 ++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;HelloWorldService.cpp      | 33 ++++++++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;HelloWorldService.h        | 17 +++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;IHelloWorldService.cpp     |  8 +++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;IHelloWorldService.h       | 21 +++++++++++++++++</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-Android-mk"><a href="#cmds-helloWorld-Android-mk" class="headerlink" title="cmds/helloWorld/Android.mk"></a><code>cmds/helloWorld/Android.mk</code></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright 2019 The Android Open Source Project</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">LOCAL_PATH:= <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_SRC_FILES := main_helloworldservice.cpp</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES :=\</span><br><span class="line">libutils \</span><br><span class="line">libbinder \</span><br><span class="line">libhelloworld</span><br><span class="line"></span><br><span class="line">base := <span class="variable">$(LOCAL_PATH)</span>/../../libs/helloWorld</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := helloworldservice</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_SRC_FILES := main_helloworldclient.cpp</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES :=\</span><br><span class="line">libutils \</span><br><span class="line">libbinder \</span><br><span class="line">libhelloworld</span><br><span class="line"></span><br><span class="line">base := <span class="variable">$(LOCAL_PATH)</span>/../../libs/helloWorld</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := helloworldclient  //编译结果so文件</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-BpHelloWorldService-h"><a href="#cmds-helloWorld-BpHelloWorldService-h" class="headerlink" title="cmds/helloWorld/BpHelloWorldService.h"></a><code>cmds/helloWorld/BpHelloWorldService.h</code></h2><blockquote><p>客户端Service头文件，声明<code>BpHelloWorldService</code>函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpHelloWorldService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-BnHelloWorldService-h"><a href="#cmds-helloWorld-BnHelloWorldService-h" class="headerlink" title="cmds/helloWorld/BnHelloWorldService.h"></a><code>cmds/helloWorld/BnHelloWorldService.h</code></h2><blockquote><p>Bn服务端Service头文件，声明<code>onTranscat</code>接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnHelloWorldService</span> :</span> <span class="keyword">public</span> BnInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span> <span class="params">( <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span> )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-HelloWorldService-h"><a href="#cmds-helloWorld-HelloWorldService-h" class="headerlink" title="cmds/helloWorld/HelloWorldService.h"></a><code>cmds/helloWorld/HelloWorldService.h</code></h2><blockquote><p>Bn服务端实现类的头文件，声明<code>helloworld</code>和<code>onTransact</code>函数，和私有类构造函数和析构函数<br>和另一个库的文件同名，继承Bn服务端接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> :</span> <span class="keyword">public</span> BnHelloWorldService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HelloWorldService();</span><br><span class="line">    <span class="keyword">virtual</span> ~HelloWorldService();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-IHelloWorldService-h"><a href="#cmds-helloWorld-IHelloWorldService-h" class="headerlink" title="cmds/helloWorld/IHelloWorldService.h"></a><code>cmds/helloWorld/IHelloWorldService.h</code></h2><blockquote><p>Bp和Bn端的中间接口头文件</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IInterface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IHelloWorldService</span>:</span> <span class="keyword">public</span> IInterface &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(HelloWorldService);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-main-helloworldclient-cpp"><a href="#cmds-helloWorld-main-helloworldclient-cpp" class="headerlink" title="cmds/helloWorld/main_helloworldclient.cpp"></a><code>cmds/helloWorld/main_helloworldclient.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"main_helloworldclient"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/ProcessState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/RefBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unused(x) x=x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ALOGI("HelloWorldService client is now starting");</span></span><br><span class="line">unused(argc);</span><br><span class="line">unused(argv);</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">sp&lt;IBinder&gt; b;</span><br><span class="line">sp&lt;IHelloWorldService&gt; sHelloWorldService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    b = sm-&gt;getService(String16(</span><br><span class="line"><span class="string">"android.apps.IHelloWorldService"</span>));</span><br><span class="line">    <span class="keyword">if</span> (b!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//ALOGI("helloworldservice is not working, waiting ...");</span></span><br><span class="line">    usleep(<span class="number">500000</span>);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">sHelloWorldService = interface_cast&lt;IHelloWorldService&gt;(b);</span><br><span class="line">sHelloWorldService -&gt; helloWorld(<span class="string">"hello, world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-main-helloworldservice-cpp"><a href="#cmds-helloWorld-main-helloworldservice-cpp" class="headerlink" title="cmds/helloWorld/main_helloworldservice.cpp"></a><code>cmds/helloWorld/main_helloworldservice.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/ProcessState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unused(x) x=x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   unused(argc);</span><br><span class="line">   unused(argv);</span><br><span class="line">    HelloWorldService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">//ALOGI("HelloWorldService is starting now");</span></span><br><span class="line">    <span class="comment">//ALOGI("HelloWorldService is starting now   tempChar = %s", tempChar);</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="libs-helloWorld-Android-bp"><a href="#libs-helloWorld-Android-bp" class="headerlink" title="libs/helloWorld/Android.bp"></a><code>libs/helloWorld/Android.bp</code></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Copyright (C) 2010 The Android Open Source Project</span><br><span class="line">//</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the <span class="string">"License"</span>);</span><br><span class="line">// you may not use this file except in compliance with the License.</span><br><span class="line">// You may obtain a copy of the License at</span><br><span class="line">//</span><br><span class="line">//      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">//</span><br><span class="line">// Unless required by applicable law or agreed to in writing, software</span><br><span class="line">// distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">// See the License for the specific language governing permissions and</span><br><span class="line">// limitations under the License.</span><br><span class="line">cc_library_shared &#123;</span><br><span class="line">    name: <span class="string">"libhelloworld"</span>,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"BnHelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"BpHelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"HelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"IHelloWorldService.cpp"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libcutils"</span>,</span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">        <span class="string">"libutils"</span>,</span><br><span class="line">        <span class="string">"libbinder"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    include_dirs: [<span class="string">"frameworks/base/cmds"</span>], //上面创建的库</span><br><span class="line"></span><br><span class="line">    cflags: [</span><br><span class="line">        <span class="string">"-Wall"</span>,</span><br><span class="line">        <span class="string">"-Wextra"</span>,</span><br><span class="line">        <span class="string">"-Werror"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BnHelloWorldService-h"><a href="#libs-helloWorld-BnHelloWorldService-h" class="headerlink" title="libs/helloWorld/BnHelloWorldService.h"></a><code>libs/helloWorld/BnHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnHelloWorldService</span> :</span> <span class="keyword">public</span> BnInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span> <span class="params">( <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BnHelloWorldService-cpp"><a href="#libs-helloWorld-BnHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/BnHelloWorldService.cpp"></a><code>libs/helloWorld/BnHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BnHelloWorldService::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Parcel &amp;data,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Parcel *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">    <span class="keyword">case</span> HW_HELLOWORLD: &#123;</span><br><span class="line">        CHECK_INTERFACE(IHelloWorldService, data, reply);   <span class="comment">//检查接口</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">        str = data.readCString(); <span class="comment">//读取数据</span></span><br><span class="line">        reply-&gt; writeInt32(helloWorld(str)); <span class="comment">//写入数据</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags); <span class="comment">//服务端接口接收数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BpHelloWorldService-h"><a href="#libs-helloWorld-BpHelloWorldService-h" class="headerlink" title="libs/helloWorld/BpHelloWorldService.h"></a><code>libs/helloWorld/BpHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpHelloWorldService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BpHelloWorldService-cpp"><a href="#libs-helloWorld-BpHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/BpHelloWorldService.cpp"></a><code>libs/helloWorld/BpHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BpHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpHelloWorldService::helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(</span><br><span class="line">IHelloWorldService::getInterfaceDescriptor());</span><br><span class="line">    data.writeCString(str);  <span class="comment">//写入数据</span></span><br><span class="line">    <span class="keyword">status_t</span> status = remote()-&gt;transact(HW_HELLOWORLD, data, &amp;reply); <span class="comment">//远程传输数据</span></span><br><span class="line">    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">        ALOGI(<span class="string">"print helloworld error : %s"</span>, strerror(-status));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = reply.readInt32();  <span class="comment">//读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpHelloWorldService::BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">: BpInterface&lt;IHelloWorldService&gt;(impl)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-HelloWorldService-h"><a href="#libs-helloWorld-HelloWorldService-h" class="headerlink" title="libs/helloWorld/HelloWorldService.h"></a><code>libs/helloWorld/HelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="comment">//继承Bn服务端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> :</span> <span class="keyword">public</span> BnHelloWorldService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HelloWorldService();</span><br><span class="line">    <span class="keyword">virtual</span> ~HelloWorldService();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-HelloWorldService-cpp"><a href="#libs-helloWorld-HelloWorldService-cpp" class="headerlink" title="libs/helloWorld/HelloWorldService.cpp"></a><code>libs/helloWorld/HelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloWorldService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"android.apps.IHelloWorldService"</span>), <span class="keyword">new</span> HelloWorldService());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HelloWorldService::helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldService::HelloWorldService()&#123;</span><br><span class="line">    ALOGI(<span class="string">"HelloWorldService is created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldService::~HelloWorldService()&#123;</span><br><span class="line">    ALOGI(<span class="string">"HelloWorldService is destroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HelloWorldService::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BnHelloWorldService::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-IHelloWorldService-h"><a href="#libs-helloWorld-IHelloWorldService-h" class="headerlink" title="libs/helloWorld/IHelloWorldService.h"></a><code>libs/helloWorld/IHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IInterface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IHelloWorldService</span>:</span> <span class="keyword">public</span> IInterface &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(HelloWorldService);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-IHelloWorldService-cpp"><a href="#libs-helloWorld-IHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/IHelloWorldService.cpp"></a><code>libs/helloWorld/IHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BpHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line">IMPLEMENT_META_INTERFACE(HelloWorldService, <span class="string">"android.apps.IHelloWorldService"</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;用驱动程序来推进进程间的通信；&lt;/li&gt;
&lt;li&gt;可以通过共享内存的方式来提供性能；&lt;/li&gt;
&lt;li&gt;可以为进程请求分配每个进程的线程池；&lt;/li&gt;
&lt;li&gt;针对系统中的对象引入了引用计数和跨进程的对象引用映射；&lt;/li&gt;
&lt;li&gt;可以方便的进行进程同步调用。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android Graphics 调试技巧（十一月份更新）</title>
    <link href="https://alonealive.github.io/Blog/2019/11/23/2019/191121_android_debug2/"/>
    <id>https://alonealive.github.io/Blog/2019/11/23/2019/191121_android_debug2/</id>
    <published>2019-11-23T15:52:00.000Z</published>
    <updated>2020-03-08T10:18:54.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新adb"><a href="#更新adb" class="headerlink" title="更新adb"></a>更新adb</h2><ul><li>更新命令：   sudo apt-get install android-tools-adb</li><li>查看当前adb指令的目录: which adb</li><li>查看版本：adb version</li></ul><a id="more"></a><h2 id="adb-shell相关"><a href="#adb-shell相关" class="headerlink" title="adb shell相关"></a>adb shell相关</h2><h3 id="ps（正在运行的进程）"><a href="#ps（正在运行的进程）" class="headerlink" title="ps（正在运行的进程）"></a>ps（正在运行的进程）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER 进程当前用户</span><br><span class="line">PID 进程ID</span><br><span class="line">PPID 父进程ID</span><br><span class="line">VSZ进程的虚拟内存大小，以KB为单位</span><br><span class="line">RSS 实际占用的内存大小，以KB为单位</span><br><span class="line">WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从&#x2F;root&#x2F;system.map文件中获得的。</span><br><span class="line">PC 计算机中提供要从[存储器]中取出的下一个指令地址的[寄存器]</span><br><span class="line">NAME 进程状态及名称</span><br></pre></td></tr></table></figure><h3 id="top（CPU使用率）"><a href="#top（CPU使用率）" class="headerlink" title="top（CPU使用率）"></a>top（CPU使用率）</h3><blockquote><p>top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用，内存使用和执行时间对任务进行排序。</p></blockquote><ol><li><code>VIRT</code>：这个内存使用就是一个应用占有的地址空间，只是要应用程序要求的，就全算在这里，而不管它真的用了没有。写程序怕出错，又不在乎占用的时候，多开点内存也是很正常的;</li><li><code>RES</code>：resident memory usage。常驻内存。这个值就是该应用程序真的使用的内存，但还有两个小问题，一是有些东西可能放在交换盘上了（SWAP），二是有些内存可能是共享的;</li><li><code>SHR</code>：shared memory。共享内存。就是说这一块内存空间有可能也被其他应用程序使用着;</li><li><code>DATA</code>：数据占用的内存。这一块是真正的该程序要求的数据空间，是真正在运行中要使用的。</li></ol><h3 id="vmstat（显示系统信息的）"><a href="#vmstat（显示系统信息的）" class="headerlink" title="vmstat（显示系统信息的）"></a>vmstat（显示系统信息的）</h3><p>vmstat是一个显示系统信息的命令。例如，它显示主存储器的可用容量和CPU的操作状态。<br>如果按原样执行vmstat命令，则会显示有关当前进程，内存，交换，设备，中断和CPU的信息。此外，如果附加“ - d”或“ - p”选项，将显示分区和磁盘上的读/写状态等。指定“-f”选项时，从系统启动到命令执行将显示创建进程的次数。</p><p>如果在vmstat之后指定以秒为单位的时间间隔，则每隔指定时间显示一次系统状态。此外，当您指定次数时，会显示指定的信息次数。</p><p>对于容量，可以使用“-S”选项指定单位。指定“-SM”时，容量单位以M字节显示。</p><p>例如：<br>以10秒为间隔显示内存和CPU信息三次： <code>vmstat 10 3</code></p><h3 id="meminfo（内存系统信息）"><a href="#meminfo（内存系统信息）" class="headerlink" title="meminfo（内存系统信息）"></a>meminfo（内存系统信息）</h3><p><code>cat /proc/meminfo</code></p><h3 id="free（显示内存使用情况）"><a href="#free（显示内存使用情况）" class="headerlink" title="free（显示内存使用情况）"></a>free（显示内存使用情况）</h3><blockquote><p>可以知道当前的内存使用情况。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b以字节显示容量（默认）</span><br><span class="line">-k显示容量，以千字节为单位</span><br><span class="line">-m显示容量，以MB为单位</span><br><span class="line">-h  显示容量单位，包含Ｇ、Ｍ</span><br><span class="line">-t还显示物理内存和交换内存的总和</span><br></pre></td></tr></table></figure><h3 id="strace（跟踪进程执行时的系统调用和所接收的信号）"><a href="#strace（跟踪进程执行时的系统调用和所接收的信号）" class="headerlink" title="strace（跟踪进程执行时的系统调用和所接收的信号）"></a>strace（跟踪进程执行时的系统调用和所接收的信号）</h3><blockquote><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。<br>在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p></blockquote><p>通用的完整用法：<br><code>strace -o output.txt -T -tt -e trace=all -p 12345</code></p><p>上面的含义是跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p><h3 id="time（linux命令，ADB通用）"><a href="#time（linux命令，ADB通用）" class="headerlink" title="time（linux命令，ADB通用）"></a>time（linux命令，ADB通用）</h3><blockquote><p>测量从调用指定命令到结束所花费的时间，用户CPU时间和系统CPU时间。在指定命令的输出结果之后，将测量结果输出到标准错误输出。命令代码实际使用CPU的时间是用户CPU时间。因此，如果将不存在的命令作为time命令的参数，则用户CPU时间变为0。睡眠时间不计算在内。</p></blockquote><p>例如：<br>显示ls命令的执行时间： <code>time ls -a</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m0.006s</span><br><span class="line">user0m0.006s</span><br><span class="line">sys0m0.000s</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><blockquote><p>显示一个目标文件或者链接库文件中的目标文件的各个段的大小(可执行文件段的大小,默认为a.out)</p></blockquote><p>例如（linux下）：   <code>size libui.so</code></p><p>text表示正文段大小，data表示包含静态变量和已经初始化（可执行文件包含了初始化的值）的全局变量的数据段大小，bss由可执行文件中不含其初始化值的全局变量组成。</p><h3 id="file（辨识文件类型）"><a href="#file（辨识文件类型）" class="headerlink" title="file（辨识文件类型）"></a>file（辨识文件类型）</h3><blockquote><p>file确定并显示文件类型，例如可执行文件或文本或其他数据。</p></blockquote><p>例如：<br><code>file libui.so</code><br>或者 <code>adb shell file ……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b以简单模式显示</span><br><span class="line">-i使文件成为mime类型字符串</span><br><span class="line">-z还要检查压缩文件</span><br><span class="line">-v显示版本</span><br></pre></td></tr></table></figure><hr><h2 id="fastboot相关"><a href="#fastboot相关" class="headerlink" title="fastboot相关"></a>fastboot相关</h2><ul><li>重启进入Recovery界面： adb reboot recovery</li><li>重启进入bootloader界面： adb reboot bootloader</li></ul><h3 id="进入Recovery模式"><a href="#进入Recovery模式" class="headerlink" title="进入Recovery模式"></a>进入Recovery模式</h3><ol><li>查看设备： adb devices</li><li>adb root</li><li>adb shell</li><li>进入fastboot： adb reboot fastboot</li><li>fastboot devices </li><li>查看当前使用分区： fastboot getvar current-slot</li><li>接着擦除分区和用户数据，然后flash烧录</li></ol><p>如果不能识别或者没权限，优先检查lsusb添加序列号到<code>/etc/udev/rules.d/</code></p><p>如果出现错误:<code>no permissions fastboot</code></p><p>用fastboot命令查看设备提示无权限，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot -l devices</span><br><span class="line">no permissions         fastboot usb:1.2-1</span><br></pre></td></tr></table></figure><p>因为权限问题，是fastboot没有权限， 解决步骤：</p><ol><li>将fastboot的所有者属性改成root,用<code>which fastboot</code>命令找到fastboot所在的目录，然后进入此目录</li><li>用命令chown改其属性:<code>sudo chown root:root fastboot</code></li><li>将其权限更改一下：<code>sudo chmod +s fastboot</code></li></ol><p>还存在一种可能性，就是<code>adb</code>版本过低。</p><h3 id="部分参数"><a href="#部分参数" class="headerlink" title="部分参数"></a>部分参数</h3><table><thead><tr><th align="center">fastboot [options]</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">-w</td><td align="center">清空用户数据分区和缓存分区.相当于recovery中的”wipe data/factoryreset”</td></tr><tr><td align="center">-s &lt;串口号&gt;</td><td align="center">指定要操作的设备的串口号</td></tr><tr><td align="center">-p &lt;产品名&gt;</td><td align="center">指定要操作的设备的产品名.比如hero,bravo,dream…</td></tr><tr><td align="center">-c &lt;命令行&gt;</td><td align="center">用命令行替换系统的启动命令行</td></tr></tbody></table><hr><h2 id="解析so文件addr2line"><a href="#解析so文件addr2line" class="headerlink" title="解析so文件addr2line"></a>解析so文件addr2line</h2><p><code>addr2line [address] -e test.so -f</code><br>或者<br><code>readelf -a [.so/.bin]</code></p><h3 id="根据解析结果查询函数"><a href="#根据解析结果查询函数" class="headerlink" title="根据解析结果查询函数"></a>根据解析结果查询函数</h3><p>C++在linux系统编译后会变成类似<code>_ZNK...</code>的修饰名。使用<code>c++filt</code>获取函数的原始名称：</p><p><code>c++filt [_ZNK...函数修饰名]</code></p><hr><h2 id="跳过开机向导"><a href="#跳过开机向导" class="headerlink" title="跳过开机向导"></a>跳过开机向导</h2><p><code>adb shell settings put global device_provisioned 1（默认是0）</code></p><h2 id="Android-10-AOSP源码打开模拟Vsync（Systrace可查看）"><a href="#Android-10-AOSP源码打开模拟Vsync（Systrace可查看）" class="headerlink" title="Android 10 AOSP源码打开模拟Vsync（Systrace可查看）"></a>Android 10 AOSP源码打开模拟Vsync（Systrace可查看）</h2><ul><li>源码： Android 10的AOSP</li><li>方法： 修改<code>surfaceflinger/Scheduler/DispSync.cpp</code>的<code>static const bool kEnableZeroPhaseTracer = false;</code>为<code>True</code></li><li>另外在查看<code>ZeroPhaseTracer</code>还需要打开<code>mTraceDetailedInfo</code>，即<code>const bool mTraceDetailedInfo = true;</code></li></ul><h2 id="对比文件和文件夹区别（可用于git解决冲突）"><a href="#对比文件和文件夹区别（可用于git解决冲突）" class="headerlink" title="对比文件和文件夹区别（可用于git解决冲突）"></a>对比文件和文件夹区别（可用于git解决冲突）</h2><p><code>meld 文件/文件夹</code></p><p>比较文件: <code>vimdiff a.txt b.txt</code></p><h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><blockquote><p>Android代码包含几百个git库，下载和管理都需要一个方便的工具，Google开发了repo用来管理多个git库，通过manifest.xml文件将一个个的git库管理起来,形成一个系统。</p></blockquote><h3 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h3><blockquote><p><code>Gerrit</code>是Google开发的一个代码审核工具。它是一个Web工具,它靠git来存放代码,靠repo这个接口来提交和下载修改。 提交到Gerrit时,每个Git库的修改都会变成一次提交,每个提交可以有一个或多个人来review和verify。当你的修改被批准之后,Gerrit会把修改真正提交到指定的分支中。</p></blockquote><p>Gerrit上代码提交的三种状态：<br><code>Open、Merged、Abandoned</code></p><ol><li><code>Open</code>: 状态的代码需要经过Review,Verify,Submit操作后才会真正入库,即成为Merged状态</li><li><code>Merged</code>: 状态的代码已经入库,不能再Abandoned,只能Revert</li><li><code>Open</code>: 状态的代码由于各种原因不能入库的可以放弃,即Abandoned状态。Abandoned 状态的代码不能再入库,如有需要,可以“Restore”。</li></ol><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>一个持续集成工具,一个运行任务的平台。能实施编译、监控集成中存在的错误，提供详细的日志文件和提醒功能。能用图表形象地展示项目构建的趋势和稳定性。</p><h3 id="repo链接指定版本的manifest-xml"><a href="#repo链接指定版本的manifest-xml" class="headerlink" title="repo链接指定版本的manifest.xml"></a>repo链接指定版本的<code>manifest.xml</code></h3><p><code>repo init -m manifest_TEST.xml</code><br>然后可以在目录查看结果，再同步代码。</p><h2 id="ssh生成publickey（指定邮箱）"><a href="#ssh生成publickey（指定邮箱）" class="headerlink" title="ssh生成publickey（指定邮箱）"></a>ssh生成publickey（指定邮箱）</h2><p><code>ssh-keygen -t rsa -C ****@mail.com</code></p><hr><h2 id="Git相关命令"><a href="#Git相关命令" class="headerlink" title="Git相关命令"></a>Git相关命令</h2><h3 id="git用户设置"><a href="#git用户设置" class="headerlink" title="git用户设置"></a>git用户设置</h3><ul><li><p><code>git config --global user.name ***</code></p></li><li><p><code>git config --global user.email ****@mail.com</code></p></li><li><p>查看config： <code>git config -l</code></p></li></ul><h3 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h3><p><code>git format-patch -1 [最近的提交CommitID]</code></p><h3 id="生成指定某个commit提交的补丁"><a href="#生成指定某个commit提交的补丁" class="headerlink" title="生成指定某个commit提交的补丁"></a>生成指定某个commit提交的补丁</h3><p><code>git format-patch abc123d^..abc123d</code></p><h3 id="获取补丁"><a href="#获取补丁" class="headerlink" title="获取补丁"></a>获取补丁</h3><ol><li>申请生成在本地，但是没有加入暂存区： <code>git apply [PatchA]</code></li><li>直接申请生成提交： <code>git am [PatchB]</code></li></ol><h3 id="git-add用法"><a href="#git-add用法" class="headerlink" title="git add用法"></a>git add用法</h3><ul><li><code>git add .</code>:提交所有修改的文件,包括新增文件,不包括删除文件</li><li><code>git add -u</code>:提交所有修改文件,包括删除文件,不包括新增文件</li><li><code>git add -A</code>:提交包括新增和删除文件的所有文件</li></ul><h3 id="从暂存区域移除等其他命令"><a href="#从暂存区域移除等其他命令" class="headerlink" title="从暂存区域移除等其他命令"></a>从暂存区域移除等其他命令</h3><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">git rm</td><td align="center">从暂存区域移除,并连带从工作目录中删除指定的文件</td></tr><tr><td align="center">git rm -f</td><td align="center">如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项<code>-f</code></td></tr><tr><td align="center">git reset HEAD <file>…</td><td align="center">取消对文件的修改,把之前版本的文件复制过来重写此文件。</td></tr><tr><td align="center">git checkout – <file>…</td><td align="center">取消已经暂存的文件</td></tr><tr><td align="center">git clean</td><td align="center">删除未暂存的文件</td></tr><tr><td align="center">git diff</td><td align="center">查看尚未暂存的文件更新了哪些部分(和暂存区中)</td></tr><tr><td align="center">git diff –cached</td><td align="center">看已经暂存起来的文件和上次提交时的快照之间的差异</td></tr><tr><td align="center">git log –graph</td><td align="center">显示图形表示的分支合并历史</td></tr><tr><td align="center">git log –since=2.weeks</td><td align="center">列出所有最近两周内的提交</td></tr><tr><td align="center">git log –p</td><td align="center">以patch形式显示提交</td></tr><tr><td align="center">git log -p -2</td><td align="center">常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</td></tr><tr><td align="center">git log –stat</td><td align="center">仅显示简要的增改行数统计。</td></tr></tbody></table><hr><h2 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h2><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">bt</td><td align="center">查看各级函数调用及参数</td></tr><tr><td align="center">bt full</td><td align="center">详细堆栈信息</td></tr><tr><td align="center">bt PID</td><td align="center">查看PID信息</td></tr><tr><td align="center">frame</td><td align="center">选择栈帧</td></tr><tr><td align="center">info locals</td><td align="center">查看当前栈帧局部变量的值</td></tr><tr><td align="center">info registers</td><td align="center">可以看函数入参</td></tr><tr><td align="center">thread n</td><td align="center">切换到线程n</td></tr><tr><td align="center">info threads</td><td align="center">查看线程</td></tr><tr><td align="center">disassemble</td><td align="center">反汇编（默认范围是选择帧的pc附近的函数）</td></tr><tr><td align="center">info frame</td><td align="center">选择堆栈帧</td></tr><tr><td align="center">info args</td><td align="center">显示函数参数和局部变量的内容</td></tr><tr><td align="center">info reg（或者i r）</td><td align="center">查看地址</td></tr><tr><td align="center">disas</td><td align="center">反汇编查看函数（包含地址信息）</td></tr><tr><td align="center">i proc m （info proc mappings 的简写）</td><td align="center">核查零是不是有效地址</td></tr></tbody></table><h3 id="Bt"><a href="#Bt" class="headerlink" title="Bt"></a>Bt</h3><blockquote><p>跟踪堆栈的信息: <code>bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-I ip] [-S sp] [pid | task]</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bt 无参数则显示当前任务的堆栈信息</span><br><span class="line">Bt –a 以任务为单位，显示每个任务的堆栈信息</span><br><span class="line">Bt –t 显示当前任务的堆栈中所有的文本标识符</span><br><span class="line">Bt –f 显示当前任务的所有堆栈数据，通过用来检查每个函数的参数传递</span><br></pre></td></tr></table></figure><h3 id="mod命令"><a href="#mod命令" class="headerlink" title="mod命令"></a>mod命令</h3><blockquote><p>用来加载调试符号，有时一些结构或者函数的符号信息不在调试版本内核里面，需要用<code>gcc -g</code>选项编译自己的模块，然后用mod命令加载里面的调试信息。这样<code>sym</code>和<code>whatis</code>命令就能正确解释我们自己模块里面自定义的结构等信息。</p></blockquote><hr><h2 id="ffmpeg-转换jpg和png格式"><a href="#ffmpeg-转换jpg和png格式" class="headerlink" title="ffmpeg 转换jpg和png格式"></a>ffmpeg 转换jpg和png格式</h2><p><code>ffmpeg -i test.png test1.jpg</code></p><h2 id="远程服务器使用ssh链接并且映射"><a href="#远程服务器使用ssh链接并且映射" class="headerlink" title="远程服务器使用ssh链接并且映射"></a>远程服务器使用ssh链接并且映射</h2><p>在用户根目录的<code>.bashrc</code>添加：</p><ol><li>链接：<br><code>alias sshTest=&#39;function _ssh() {  echo &quot;提示信息&quot;; ssh -p 端口 服务器用户名@IP; unset -f ssh; }; _ssh&#39;</code></li><li>映射：<br><code>alias sshreferenceTest=&#39;echo &quot;提示信息&quot;;sshfs -p 端口 -o cache=yes,reconnect 服务器用户名@IP:/home/服务器映射目录 /home/user/本地映射目录&#39;</code></li></ol><p>执行<code>source .bashrc</code>生效</p><blockquote><p>如果服务器映射报错<code>bad mount point</code>/mnt/‘: Transport endpoint is not connected`</p></blockquote><p>解决方法：</p><ol><li><code>sudo  umount  --all</code>（或者指定目录）</li><li>重新mount，即<code>sudo mount --all</code></li></ol><h2 id="linux下修改图片尺寸（jpg、png…）"><a href="#linux下修改图片尺寸（jpg、png…）" class="headerlink" title="linux下修改图片尺寸（jpg、png…）"></a>linux下修改图片尺寸（jpg、png…）</h2><ol><li><code>sudo apt-get install imagemagick</code></li><li><code>convert example.png -resize 200×100 example.png //按照原有比例缩放</code></li><li><code>convert example.png -resize 200×100! example.png</code></li></ol><h2 id="查看网络地址情况"><a href="#查看网络地址情况" class="headerlink" title="查看网络地址情况"></a>查看网络地址情况</h2><p><code>route -n</code></p><h2 id="文件压缩、解压"><a href="#文件压缩、解压" class="headerlink" title="文件压缩、解压"></a>文件压缩、解压</h2><ol><li>zip文件：<br><code>zip -r   a.zip  /dir</code></li></ol><p>直接unzip解压</p><ol start="2"><li>tar.bz：<br>Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。<br>但同时在压缩，解压的过程却是非常耗费CPU时间。</li></ol><ul><li><ul><li>打包压缩格式，举例：<br><code>tar -jcvf file.tar.bz2 dir #dir目录</code></li></ul></li><li><ul><li>解压，举例：<br><code>tar -jxvf file.tar.bz2</code><br><code>tar -jxvf file.tar.bz2 -C /temp</code></li></ul></li></ul><hr><h2 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h2><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">ls -a</td><td align="center">列出文件下所有的文件，包括以“.“开头的隐藏文件（Linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。</td></tr><tr><td align="center">ls -l</td><td align="center">列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。</td></tr><tr><td align="center">ls -F</td><td align="center">在每一个文件的末尾加上一个字符说明该文件的类型。”@”表示符号链接、”</td></tr><tr><td align="center">ls -s</td><td align="center">在每个文件的后面打印出文件的大小。  size(大小)</td></tr><tr><td align="center">ls -t</td><td align="center">按时间进行文件的排序  Time(时间)</td></tr><tr><td align="center">ls -A</td><td align="center">列出除了”.”和”..”以外的文件。</td></tr><tr><td align="center">ls -R</td><td align="center">将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现</td></tr><tr><td align="center">ls -L</td><td align="center">列出文件的链接名。Link（链接）</td></tr><tr><td align="center">ls -S</td><td align="center">以文件的大小进行排序</td></tr><tr><td align="center">ls -h</td><td align="center">显示文件大小</td></tr></tbody></table><h2 id="firefox修改中文"><a href="#firefox修改中文" class="headerlink" title="firefox修改中文"></a>firefox修改中文</h2><ol><li>打开浏览器，在地址栏中输入<code>about:config</code>，然后按下回车。</li><li>在列表中找到“general.useragent.locale”，然后双击，将内容改为”zh-CH”</li><li>重启之后就会默认为中文了（注：如果想改回英文就改为:  en-US )</li></ol><h2 id="Ubuntu系统log路径-var-log"><a href="#Ubuntu系统log路径-var-log" class="headerlink" title="Ubuntu系统log路径/var/log"></a>Ubuntu系统log路径<code>/var/log</code></h2><p>查看: <code>ls -tl</code></p><h2 id="hidl接口生成命令"><a href="#hidl接口生成命令" class="headerlink" title="hidl接口生成命令"></a>hidl接口生成命令</h2><p><code>hidl-gen</code>是Android架构HIDL编译工具，可以手动将哈希加到<code>current.txt</code>中，也可以使用以下命令添加：<br><code>hidl-gen -L hash -r .../interfaces -r android.hidl:...</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新adb&quot;&gt;&lt;a href=&quot;#更新adb&quot; class=&quot;headerlink&quot; title=&quot;更新adb&quot;&gt;&lt;/a&gt;更新adb&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更新命令：   sudo apt-get install android-tools-adb&lt;/li&gt;
&lt;li&gt;查看当前adb指令的目录: which adb&lt;/li&gt;
&lt;li&gt;查看版本：adb version&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="graphics" scheme="https://alonealive.github.io/Blog/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android @hide接口注释</title>
    <link href="https://alonealive.github.io/Blog/2019/11/03/2019/191103_android_hideDoc/"/>
    <id>https://alonealive.github.io/Blog/2019/11/03/2019/191103_android_hideDoc/</id>
    <published>2019-11-03T04:32:00.000Z</published>
    <updated>2020-03-08T10:18:54.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hide和-hide"><a href="#hide和-hide" class="headerlink" title="@hide和{@hide}"></a>@hide和{@hide}</h2><p>类或API是否开放是通过doc的注释｛＠hide｝来控制的</p><p>比如android.media.Metadata这个类就是android没有公开的类</p><p>因为在frameworks\base\media\libmedia\Metadata.java文件中，定义Metadata类之前有/<em>*｛＠hide｝</em>/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类</p><a id="more"></a><p><strong>google 给了两个选择：</strong></p><p>在你添加的API或者变量前面增加javadoc 注释＠hide，但是要注意并不是简单写个＠hide或者 /<em>@hide</em>/就可以了，这些都是错误的javadoc注释格式。标准的javadoc都是这样的 /** <em>/ 而且对于 format 变量应该加上 { }，所以我们应该这样写/*</em> {@hide} */</p><p>想要生成的javadoc里面出现这个方法或者变量，你必须输入:<code>make update-api</code>。但是如果修改的是google没有开放出来的类，比如RIL、PhoneFactory，就不会出现这个问题。</p><h2 id="访问被-hide的API（android-如何引用-hide（隐藏）的类，方法和常量）"><a href="#访问被-hide的API（android-如何引用-hide（隐藏）的类，方法和常量）" class="headerlink" title="访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）"></a>访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）</h2><h3 id="直接将-hide标记去掉，将重新编译了的android-jar包换掉"><a href="#直接将-hide标记去掉，将重新编译了的android-jar包换掉" class="headerlink" title="直接将@hide标记去掉，将重新编译了的android.jar包换掉"></a>直接将@hide标记去掉，将重新编译了的android.jar包换掉</h3><p>不过强烈的建议不要这样做，别人隐藏起来的类或者方法肯定是不安全的，如果你把@hide放出来可能引起一些程序不可预知的错误。</p><h3 id="利用反射机制使用-hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜"><a href="#利用反射机制使用-hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜" class="headerlink" title="利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜"></a>利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜</h3><h3 id="修改android-mk文件"><a href="#修改android-mk文件" class="headerlink" title="修改android.mk文件"></a>修改android.mk文件</h3><p>删除LOCAL_SDK_VERSION := current</p><h3 id="将LOCAL-SDK-VERSION-注释掉之后提到服务器编译出现了代码混淆错误。"><a href="#将LOCAL-SDK-VERSION-注释掉之后提到服务器编译出现了代码混淆错误。" class="headerlink" title="将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。"></a>将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。</h3><p>这个时候可以在android.mk文件中将LOCAL_PROGUARD_ENABLED := disabled加上。LOCAL_PROGUARD_ENABLED := disabled不使用代码混淆的工具进行代码混淆,如果不设置，默认使用LOCAL_PROGUARD_ENABLED := full.即将该工程代码全部混淆。</p><h2 id="Android-10的变化"><a href="#Android-10的变化" class="headerlink" title="Android 10的变化"></a>Android 10的变化</h2><p>在Android 10对非SDK接口进行了限制，因而<code>@hide</code>注释的方法被列入黑名单，外部不能访问。</p><p>但是可以通过<code>adb shell settings put global hidden_api_policy  1</code>命令打开权限访问。</p><p>通过<code>adb shell settings delete global hidden_api_policy</code>解除设置。（<a href="https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hide和-hide&quot;&gt;&lt;a href=&quot;#hide和-hide&quot; class=&quot;headerlink&quot; title=&quot;@hide和{@hide}&quot;&gt;&lt;/a&gt;@hide和{@hide}&lt;/h2&gt;&lt;p&gt;类或API是否开放是通过doc的注释｛＠hide｝来控制的&lt;/p&gt;
&lt;p&gt;比如android.media.Metadata这个类就是android没有公开的类&lt;/p&gt;
&lt;p&gt;因为在frameworks\base\media\libmedia\Metadata.java文件中，定义Metadata类之前有/&lt;em&gt;*｛＠hide｝&lt;/em&gt;/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/categories/android/"/>
    
    
      <category term="android" scheme="https://alonealive.github.io/Blog/tags/android/"/>
    
  </entry>
  
</feed>
