<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->






    <link rel="dns-prefetch" href="//cdn1.lncld.net">


<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>C++11/14/17/2特性 | sunwengang blog</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/Blog/img/favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/Blog/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #8E354A;
    }

    a:active, a:focus, a:hover {
        color: #8E354A;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #8E354A;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #8E354A;
    }

    .navbar-link:hover {
        color: #8E354A;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/Blog/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/Blog/css/highlight/arduino-light.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/Blog/css/highlight/arduino-light.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/Blog/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="sunwengang blog"><meta name="msapplication-starturl" content="https://alonealive.github.io/Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sunwengang blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="C++11&#x2F;14&#x2F;17&#x2F;2特性 | sunwengang blog"><meta property="og:site_name" content="sunwengang blog"><meta property="og:type" content="article"><meta property="og:url" content="https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/"><meta property="og:locale" content="zh-CN"><meta name="description" content="C++11&#x2F;14&#x2F;17&#x2F;20部分新的特性语法 - sunwengang - sunwengang blog"><meta name="keywords" content="cpp"><meta property="article:published_time" content="2021-06-16T13:42:00.000Z"><meta property="article:modified_time" content="2021-06-16T07:42:05.000Z"><meta property="og:updated_time" content="2021-06-16T07:42:05.000Z"><meta property="article:author" content="sunwengang"><meta property="article:tag" content="cpp"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/">

    <meta name="generator" content="Hexo 4.2.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/",
    "@type": "BlogPosting",
    "logo": "https://alonealive.github.io/Blog/img/favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/"
    },
    "headline": "C++11/14/17/2特性 | sunwengang blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://alonealive.github.io/Blog/img/favicon.ico"
    },
    
    "datePublished": "2021-06-16T13:42:00.000Z",
    "dateModified": "2021-06-16T07:42:05.000Z",
    "author": {
        "@type": "Person",
        "name": "sunwengang",
        "image": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/head.jpg"
        },
        "description": "developer | android display/graphics"
    },
    "publisher": {
        "@type": "Organization",
        "name": "sunwengang blog",
        "logo": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://alonealive.github.io/Blog/Blog/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "cpp",
    "description": "C++11/14/17/20部分新的特性语法 - sunwengang - sunwengang blog"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/Blog/">sunwengang blog</a></h1>

    <p class="text-center header-slogan">
        
            
                developer | android display/graphics
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/Blog/" class="navbar-link">首页</a>
    
    
        <a href="/Blog/archives/" class="navbar-link">归档</a>
    
    
        <a href="/Blog/search" class="navbar-link">搜索</a>
    
    
        <a href="/Blog/tags" class="navbar-link">标签</a>
    
        <a href="/Blog/html/nav.html" class="navbar-link">导航</a>
    
        <a href="/Blog/links" class="navbar-link">友链</a>
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=sunwengang blog&url=https://alonealive.github.io/Blog&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=sunwengang blog&url=https://alonealive.github.io/Blog&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog&title=C++11/14/17/2特性" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=C++11/14/17/2特性&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog&text=C++11/14/17/2特性" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACKUlEQVR42u2aQW7DMAwE/f9Pt9cikLhDx0ATcXQJ3MryJBDp5VLXzxeMS0ghhRTyAyCvYvyd8/q5m5/Wo/OEnA253LQLyHS9W+v1B8HPFXI0ZLXBd2C7v63uqb7Y9h4hhSwgV2C7e6sXhZBCPgFJAyJ9wSRWhBSSvOhXAUGCqCta3lJBQh4HSQunpz8fqxaFPAoymkZBJKyuabA95qoJeRRktZGror5jEHQFsZCzIakIIMk3BWBHsAgp5MqcrxJ7MkdTkk8FmZCzIXeAyTBIRkBlvpL5QgqZgiM9uJpPBEs7cIQ8EpIkZrrxq4DomFZCzoYkSZeaUOR/VcOgTOZCjoGsiqpkUHVM2NTAitEt5BhIsqmpWUqLMXIt5FxImpCrB76TvEtjVsjxkOQBlfig5j4OUCFHQ3ZELUnw3aY8Ps0i5PGQdwooKkLSvbFxKuRoSGI4RYMJio70AwkpJDlkTIQwWfN2MhdyJGQy4SsziqwVzYDUERNyLGQyS+nhprebBEKOhOyYoOQQHD3shIJNyNGQVxjkoB0xAchcIYWkJmglQpKZUBZcQgpZNJtIYz01nqqkTgozIWdDpkEaSumgMhHT2FUT8njItKETaFfU3i7EhBwFmYQDTeakmXQ7cIQcB1kVSd0GFC3GUpEnpJAE8olDeBUcdjCEHA1JTYA7Qrhshgo5GjI1P6lhT43SW4Ej5BhI+uLvBEc6EJLWEHIu5CcPIYUUUsh/HL8fkpa1RkWYbgAAAABJRU5ErkJggg==" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">C++11/14/17/2特性</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/Blog/img/head.jpg" src="/Blog/img/suka-lazyload.gif" alt="sunwengang's Avatar">
        <span>2021-06-16</span>
        
            <span class="suka-devide-dot"></span>
            <a class="category-link" href="/Blog/categories/cpp/">cpp</a>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=C++11/14/17/2特性&url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=C++11/14/17/2特性&url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/&title=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=sunwengang blog&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/&text=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACKUlEQVR42u2aQW7DMAwE/f9Pt9cikLhDx0ATcXQJ3MryJBDp5VLXzxeMS0ghhRTyAyCvYvyd8/q5m5/Wo/OEnA253LQLyHS9W+v1B8HPFXI0ZLXBd2C7v63uqb7Y9h4hhSwgV2C7e6sXhZBCPgFJAyJ9wSRWhBSSvOhXAUGCqCta3lJBQh4HSQunpz8fqxaFPAoymkZBJKyuabA95qoJeRRktZGror5jEHQFsZCzIakIIMk3BWBHsAgp5MqcrxJ7MkdTkk8FmZCzIXeAyTBIRkBlvpL5QgqZgiM9uJpPBEs7cIQ8EpIkZrrxq4DomFZCzoYkSZeaUOR/VcOgTOZCjoGsiqpkUHVM2NTAitEt5BhIsqmpWUqLMXIt5FxImpCrB76TvEtjVsjxkOQBlfig5j4OUCFHQ3ZELUnw3aY8Ps0i5PGQdwooKkLSvbFxKuRoSGI4RYMJio70AwkpJDlkTIQwWfN2MhdyJGQy4SsziqwVzYDUERNyLGQyS+nhprebBEKOhOyYoOQQHD3shIJNyNGQVxjkoB0xAchcIYWkJmglQpKZUBZcQgpZNJtIYz01nqqkTgozIWdDpkEaSumgMhHT2FUT8njItKETaFfU3i7EhBwFmYQDTeakmXQ7cIQcB1kVSd0GFC3GUpEnpJAE8olDeBUcdjCEHA1JTYA7Qrhshgo5GjI1P6lhT43SW4Ej5BhI+uLvBEc6EJLWEHIu5CcPIYUUUsh/HL8fkpa1RkWYbgAAAABJRU5ErkJggg==" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-11被弃用的主要特性"><span class="post-toc-number">1.</span> <span class="post-toc-text">C++11被弃用的主要特性</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#char修饰符"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">char修饰符</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#智能指针之unique-ptr"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">智能指针之unique_ptr</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#move-函数"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">move()函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#函数传参"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">函数传参</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#make-unique-函数创建对象"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">make_unique()函数创建对象</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#unique-ptr-类的成员函数"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">unique_ptr 类的成员函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#register关键字弃用"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">register关键字弃用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#bool类型的-操作弃用"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">bool类型的++操作弃用</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#noexcept"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">noexcept</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#C语言风格的类型转换被弃用"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">C语言风格的类型转换被弃用</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#static-cast关键字"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">static_cast关键字</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#const-cast关键字"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">const_cast关键字</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#reinterpret-cast关键字"><span class="post-toc-number">1.6.3.</span> <span class="post-toc-text">reinterpret_cast关键字</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#dynamic-cast关键字"><span class="post-toc-number">1.6.4.</span> <span class="post-toc-text">dynamic_cast关键字</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常量nullptr"><span class="post-toc-number">2.</span> <span class="post-toc-text">常量nullptr</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常量constexpr"><span class="post-toc-number">3.</span> <span class="post-toc-text">常量constexpr</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#if-switch变量声明强化"><span class="post-toc-number">4.</span> <span class="post-toc-text">if&#x2F;switch变量声明强化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#decltype"><span class="post-toc-number">5.</span> <span class="post-toc-text">decltype</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#if-constexpr"><span class="post-toc-number">6.</span> <span class="post-toc-text">if constexpr</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#区间for迭代"><span class="post-toc-number">7.</span> <span class="post-toc-text">区间for迭代</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#外部模板"><span class="post-toc-number">8.</span> <span class="post-toc-text">外部模板</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考"><span class="post-toc-number">9.</span> <span class="post-toc-text">参考</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <blockquote>
<p>C++11/14/17/20部分新的特性语法</p>
</blockquote>
<a id="more"></a>

<h2 id="C-11被弃用的主要特性"><a href="#C-11被弃用的主要特性" class="headerlink" title="C++11被弃用的主要特性"></a>C++11被弃用的主要特性</h2><h3 id="char修饰符"><a href="#char修饰符" class="headerlink" title="char修饰符"></a>char修饰符</h3><p>不再允许字符串字面值常量赋值给一个<code>char *</code>。如果需要用字符串字面值常量赋值和初始化一个<code>char *</code>,应该使用<code>const char *</code> 或者<code>auto</code></p>
<p><code>char *str = &quot;hello world!&quot;; // 将出现弃用警告</code></p>
<ul>
<li><ul>
<li>auto，不指定变量类型，编译器将把变量的类型设置成和初始值相同</li>
</ul>
</li>
<li><ul>
<li>const，限定符</li>
</ul>
</li>
</ul>
<p>PS：另一个限定符Volatile关键词，易变的。所谓的易变性，在汇编层面反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>
<hr>
<h3 id="智能指针之unique-ptr"><a href="#智能指针之unique-ptr" class="headerlink" title="智能指针之unique_ptr"></a>智能指针之unique_ptr</h3><p>auto_ptr被弃用,应使用<code>unique_ptr</code></p>
<p>C++11提供了3种智能指针类型，它们分别由unique_ptr类、shared_ptr类和weak_ptr 类定义，所以又分别称它们为独占指针、共享指针和弱指针（均定义在头文件<code>#include &lt;memory&gt;</code>）</p>
<p>智能指针是一个可以像指针一样工作的对象，但是当它不再被使用时，可以自动删除动态分配的内存。智能指针背后的核心概念是动态分配内存的所有权。</p>
<p>智能指针背后的核心概念是动态分配内存的所有权。智能指针被称为可以拥有或管理它所指向的对象。当需要让单个指针拥有动态分配的对象时，可以使用独占指针。对象的所有权可以从一个独占指针转移到另一个指针，其转移方式为：对象始终只能有一个指针作为其所有者。<strong>当独占指针离开其作用域或将要拥有不同的对象时，它会自动释放自己所管理的对象。</strong></p>
<p>共享指针将记录有多少个指针共同享有某个对象的所有权。<strong>当有更多指针被设置为指向该对象时，引用计数随之增加；当指针和对象分离时，则引用计数也相应减少。当引用计数降低至0时，该对象被删除。</strong></p>
<p>智能指针实际上是一个对象，在对象的外面包围了一个拥有该对象的普通指针。这个包围的常规指针称为裸指针。</p>
<h4 id="move-函数"><a href="#move-函数" class="headerlink" title="move()函数"></a>move()函数</h4><p>C++ 提供了一个move()库函数，可用于将对象的所有权从一个独占指针转移到另外一个独占指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>; <span class="comment">//定义并初始化</span></span><br><span class="line">*uptr1 = <span class="number">15</span>;  <span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptr3; <span class="comment">// 正确</span></span><br><span class="line">uptr3 = move (uptr1) ; <span class="comment">// 将所有权从 uptr1 转移到 uptr3</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *uptr3 &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印 15</span></span><br></pre></td></tr></table></figure>

<h4 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h4><p>不能直接通过值给函数传递一个智能指针，因为通过值传递将导致复制真正的形参。如果要让函数通过值接收一个独占指针，则在调用函数时，必须对真正的形参使用move()函数：</p>
<p>结果将打印来自于函数fun()中的10</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数使用通过值传递的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; uptrParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *uptrParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    *uptr = <span class="number">10</span>;</span><br><span class="line">    fun (move (uptr)); <span class="comment">// 在调用中使用 move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果通过引用传递的方式，那就不必对真正的形参使用move()函数了。示例代码如下：</p>
<p>结果将打印数字15：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数使用通过引用传递的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp; uptrParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *uptrParam &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">uptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    *uptr1 = <span class="number">15</span>;</span><br><span class="line">    fun (uptr1) ; <span class="comment">//在调用中无须使用move</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="make-unique-函数创建对象"><a href="#make-unique-函数创建对象" class="headerlink" title="make_unique()函数创建对象"></a>make_unique<T>()函数创建对象</h4><p>从C++14开始，有一个库函数<code>make_unique&lt;T&gt;()</code>可用于创建<code>unique_ptr</code>对象。该函数分配一个类型为T的对象，然后返回一个拥有该对象的独占指针。例如：</p>
<p><code>unique_ptr&lt;int&gt; uptr(new int);</code></p>
<p>现在可以替换成：</p>
<p><code>unique_ptr&lt;int&gt; uptr = make_unique&lt;int&gt;();</code></p>
<h4 id="unique-ptr-类的成员函数"><a href="#unique-ptr-类的成员函数" class="headerlink" title="unique_ptr 类的成员函数"></a>unique_ptr 类的成员函数</h4><table>
<thead>
<tr>
<th align="center">unique_ptr成员函数</th>
<th align="center">描 述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">reset()</td>
<td align="center">销毁由该智能指针管理的任何可能存在的对象。该智能指针被置为空</td>
</tr>
<tr>
<td align="center">reset(T* ptr)</td>
<td align="center">销毁由该智能指针当前管理的任何可能存在的对象。该智能指针继续控制由裸指针ptr指向的对象</td>
</tr>
<tr>
<td align="center">get()</td>
<td align="center">返回该智能指针管理的由裸指针指向的对象。如果某个指针需要传递给函数，但是 该函数并不知道该如何操作智能指针，则get()函数非常有用</td>
</tr>
</tbody></table>
<hr>
<h3 id="register关键字弃用"><a href="#register关键字弃用" class="headerlink" title="register关键字弃用"></a>register关键字弃用</h3><p>register关键字被弃用,可以使用但不再具备任何实际含义</p>
<h3 id="bool类型的-操作弃用"><a href="#bool类型的-操作弃用" class="headerlink" title="bool类型的++操作弃用"></a>bool类型的++操作弃用</h3><p>bool类型的++操作被弃用</p>
<h3 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h3><p>C++98异常说明、unexpected_handler、set_unexpected() 等相关特性被弃用,应该使用<code>noexcept</code></p>
<p><strong>C++11新标准引入的noexcept运算符，可以用于指定某个函数不抛出异常</strong>。预先知道函数不会抛出异常有助于简化调用该函数的代码，而且编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//不抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> x)</span></span>;  <span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>

<p>noexcept可以接受一个可选的实参，该参数必须能转换为bool类型:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>;  <span class="comment">//不抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="C语言风格的类型转换被弃用"><a href="#C语言风格的类型转换被弃用" class="headerlink" title="C语言风格的类型转换被弃用"></a>C语言风格的类型转换被弃用</h3><p>即在变量前使用<code>(convert_type)</code>,应该使用<code>static_cast</code>、<code>reinterpret_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>来进行类型转换</p>
<p>为了使潜在风险更加细化，使问题追溯更加方便，使书写格式更加规范，C++对类型转换进行了分类，并新增了四个关键字来予以支持，它们分别是：</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">static_cast</td>
<td align="center">用于良性转换，一般不会导致意外发生，风险很低</td>
</tr>
<tr>
<td align="center">const_cast</td>
<td align="center">用于const与非const、volatile与非volatile之间的转换</td>
</tr>
<tr>
<td align="center">reinterpret_cast</td>
<td align="center">高度危险的转换，这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，但是可以实现最灵活的C++类型转换</td>
</tr>
<tr>
<td align="center">dynamic_cast</td>
<td align="center">借助 RTTI，用于类型安全的向下转型(Downcasting)</td>
</tr>
</tbody></table>
<p><strong>这四个关键字的语法格式都是一样的：</strong></p>
<p><code>xxx_cast&lt;newType&gt;(data)</code></p>
<p>老式的C语言转换类型（已弃用）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scores = <span class="number">95.5</span>;</span><br><span class="line"><span class="keyword">int</span> n = (<span class="keyword">int</span>)scores;</span><br></pre></td></tr></table></figure>

<p>C++新风格：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> scores = <span class="number">95.5</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(scores);</span><br></pre></td></tr></table></figure>

<h4 id="static-cast关键字"><a href="#static-cast关键字" class="headerlink" title="static_cast关键字"></a>static_cast关键字</h4><p><strong>static_cast 是“静态转换”的意思，也就是在编译期间转换，转换失败的话会抛出一个编译错误。</strong></p>
<p>static_cast（静态转换）只能用于良性转换，转换风险较低，例如：</p>
<ul>
<li>原有的自动类型转换，例如 short 转 int、int 转 double、const 转非 const、向上转型等；</li>
<li>void指针和具体类型指针之间的转换，例如<code>void *</code>转<code>int *</code>、<code>char *</code>转<code>void *</code>等；</li>
<li>有转换构造函数或者类型转换函数的类与其它类型之间的转换，例如<code>double</code>转<code>Complex</code>（调用转换构造函数）、<code>Complex</code>转<code>double</code>（调用类型转换函数）</li>
</ul>
<p>static_cast不能用于无关类型之间的转换，因为这些转换都是有风险的，例如：</p>
<ol>
<li>两个具体类型指针之间的转换，例如<code>int *</code>转<code>double *</code>、<code>Student *</code>转<code>int *</code>等。不同类型的数据存储格式不一样，长度也不一样，用A类型的指针指向B类型的数据后，会按照A类型的方式来处理数据：如果是读取操作，可能会得到一堆没有意义的值；如果是写入操作，可能会使 B 类型的数据遭到破坏，当再次以 B 类型的方式读取数据时会得到一堆没有意义的值。</li>
<li>int和指针之间的转换。将一个具体的地址赋值给指针变量是非常危险的，因为该地址上的内存可能没有分配，也可能没有读写权限，恰好是可用内存反而是小概率事件</li>
<li>static_cast也不能用来去掉表达式的const修饰和volatile修饰。换句话说，不能将const/volatile类型转换为非const/volatile类型</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Complex(<span class="keyword">double</span> real = <span class="number">0.0</span>, <span class="keyword">double</span> imag = <span class="number">0.0</span>): m_real(real), m_imag(imag)&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_real; &#125;  <span class="comment">//类型转换函数</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">double</span> m_real;</span><br><span class="line">        <span class="keyword">double</span> m_imag;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//下面是正确的用法</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">        <span class="function">Complex <span class="title">c</span><span class="params">(<span class="number">12.5</span>, <span class="number">23.8</span>)</span></span>;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(m);  <span class="comment">//宽转换，没有信息丢失</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(m);  <span class="comment">//窄转换，可能会丢失信息</span></span><br><span class="line">        <span class="keyword">int</span> *p1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;( <span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)) );  <span class="comment">//将void指针转换为具体类型指针</span></span><br><span class="line">        <span class="keyword">void</span> *p2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(p1);  <span class="comment">//将具体类型指针，转换为void指针</span></span><br><span class="line">        <span class="keyword">double</span> real= <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(c);  <span class="comment">//调用类型转换函数</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">//下面的用法是错误的</span></span><br><span class="line">-        <span class="keyword">float</span> *p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(p1);  <span class="comment">//不能在两个具体类型的指针之间进行转换</span></span><br><span class="line">-        p3 = <span class="keyword">static_cast</span>&lt;<span class="keyword">float</span>*&gt;(<span class="number">0X2DF9</span>);  <span class="comment">//不能将整数转换为指针类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="const-cast关键字"><a href="#const-cast关键字" class="headerlink" title="const_cast关键字"></a>const_cast关键字</h4><blockquote>
<p>const_cast用来去掉表达式的const修饰或volatile修饰。换句话说，const_cast就是用来将const/volatile 类型转换为非const/volatile类型。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//&amp;n用来获取n的地址，它的类型为const int *，必须使用const_cast转换为int *类型后才能赋值给 p</span></span><br><span class="line">    <span class="comment">//由于p指向了n，并且n占用的是栈内存，有写入权限，所以可以通过p修改n的值</span></span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(&amp;n);</span><br><span class="line">    *p = <span class="number">234</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"*p = "</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reinterpret-cast关键字"><a href="#reinterpret-cast关键字" class="headerlink" title="reinterpret_cast关键字"></a>reinterpret_cast关键字</h4><blockquote>
<p>reinterpret_cast 这种转换仅仅是对二进制位的重新解释，不会借助已有的转换规则对数据进行调整，非常简单粗暴，所以风险很高</p>
</blockquote>
<p>不建议使用</p>
<h4 id="dynamic-cast关键字"><a href="#dynamic-cast关键字" class="headerlink" title="dynamic_cast关键字"></a>dynamic_cast关键字</h4><blockquote>
<p>dynamic_cast用于在类的继承层次之间进行类型转换，它既允许向上转型（Upcasting），也允许向下转型（Downcasting）。向上转型是无条件的，不会进行任何检测，所以都能成功；向下转型的前提必须是安全的，要借助RTTI进行检测，所有只有一部分能成功。</p>
</blockquote>
<p><font color=red>dynamic_cast与static_cast是相对的，dynamic_cast是“动态转换”的意思，static_cast是“静态转换”的意思。dynamic_cast会在程序运行期间借助 RTTI进行类型转换，这就要求基类必须包含虚函数；static_cast在编译期间完成类型转换，能够更加及时地发现错误。</font></p>
<p>dynamic_cast的语法格式为：</p>
<p><code>dynamic_cast &lt;newType&gt; (expression)</code></p>
<hr>
<h2 id="常量nullptr"><a href="#常量nullptr" class="headerlink" title="常量nullptr"></a>常量nullptr</h2><blockquote>
<p>nullptr出现的目的是为了替代NULL。在某种意义上来说,传统C++会把NULL、0视为同一种东西,这取决于编译器如何定义NULL,有些编译器会将NULL定义为<code>((void*)0)</code>,有些则会直接将其定义为0</p>
</blockquote>
<p>C++不允许直接将<code>void *</code>隐式转换到其他类型。但如果编译器尝试把<code>NULL</code>定义为<code>((void*)0)</code></p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法通过编译，将会去调用 foo(int),从而导致代码违反直觉</span></span><br><span class="line">foo(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用foo(char*)</span></span><br><span class="line">foo(<span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，C++11引入了nullptr关键字,专门用来区分空指针、0。</p>
<p>而nullptr的类型为<code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型,也能和他们进行相等或者不等的比较。</p>
<p><font color=red>因此NULL不同于0与nullptr。所以,请养成直接使用nullptr的习惯</font></p>
<hr>
<h2 id="常量constexpr"><a href="#常量constexpr" class="headerlink" title="常量constexpr"></a>常量constexpr</h2><p>C++本身已经具备了常量表达式的概念,比如<code>1+2</code>,<code>3*4</code>这种表达式总是会产生相同的结果并且没有任何副作用。<strong>如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时,将能增加程序的性能</strong></p>
<p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式</p>
<p>**</p>
<h2 id="if-switch变量声明强化"><a href="#if-switch变量声明强化" class="headerlink" title="if/switch变量声明强化"></a>if/switch变量声明强化</h2><p>在传统C++中,变量的声明虽然能够位于任何位置,甚至于for语句内能够声明一个临时变量int,但始终没有办法在if和switch语句中声明一个临时的变量。</p>
<p>C++17消除了这一限制,使得我们可以在<code>if(或switch)</code>中完成这一操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在c++17之前</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr2 = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (itr2 != vec.end()) &#123;</span><br><span class="line">*itr2 = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*****************</span></span><br><span class="line"><span class="comment">//C++17</span></span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype关键字是为了解决auto关键字只能对变量进行类型推导的缺陷而出现的。它的用法和typeof很相似:</p>
<p><code>decltype(表达式)</code></p>
<p>有时候,我们可能需要计算某个表达式的类型,例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a>if constexpr</h2><p>C++11引入了constexpr关键字,它将表达式或函数编译为常量结果。</p>
<p>如果我们把这一特性引入到条件判断中去,让代码在编译时就完成分支判断,岂不是能让程序效率更高?</p>
<p>C++17将constexpr这个关键字引入到if语句中,允许在代码中声明常量表达式的判断条件</p>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在编译时，实际代码会表现为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="区间for迭代"><a href="#区间for迭代" class="headerlink" title="区间for迭代"></a>区间for迭代</h2><p>C++11引入了基于范围的迭代写法,我们能够写出像Python一样简洁的循环语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="comment">//std::find可用于查找容器中是否存在某个特定值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>); itr != vec.end()) *itr = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">        element += <span class="number">1</span>;       <span class="comment">// writeable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="外部模板"><a href="#外部模板" class="headerlink" title="外部模板"></a>外部模板</h2><p>C++模板的哲学在于将一切能够在编译期处理的问题丢到编译期进行处理,仅在运行时处理那些最核心的动态服务,进而大幅优化运行期的性能。</p>
<p>传统C++中,模板只有在使用时才会被编译器实例化。换句话说,只要在每个编译单元(文件)中编译的代码中遇到了被完整定义的模板,都会实例化。这就产生了重复实例化而导致的编译时间的增加。并且,我们没有办法通知编译器不要触发模板的实例化。</p>
<p>为此,<strong>C++11引入了外部模板,扩充了原来的强制编译器在特定位置实例化模板的语法,使我们能够显式的通知编译器何时进行模板的实例化:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;;</span><br><span class="line"><span class="comment">// 强行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>书籍：《现代C++教程：高速上手 C++11/14/17/20》</li>
<li><a href="http://c.biancheng.net/view/1478.html" target="_blank" rel="noopener">C++智能指针unique_ptr详解</a></li>
<li><a href="https://blog.csdn.net/shang_0122/article/details/102208507" target="_blank" rel="noopener">C++函数传参三种形式（包含形参与实参）</a></li>
<li><a href="https://www.jianshu.com/p/08a53d8c9670" target="_blank" rel="noopener">C++11：noexcept关键字</a></li>
<li><a href="http://c.biancheng.net/cpp/biancheng/view/3297.html" target="_blank" rel="noopener">C++四种类型转换运算符：static_cast、dynamic_cast、const_cast和reinterpret_cast</a></li>
<li><a href="https://www.cnblogs.com/god-of-death/p/7852394.html" target="_blank" rel="noopener">C/C++ Volatile关键词深度剖析</a></li>
</ul>

                    </article>
                    
    <blockquote class="post-license">
        <p>
            <strong>本文作者&nbsp;:&nbsp;sunwengang</strong>
            <br>
            <strong>
            
                本文使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)</a> 协议
            </strong>
            <br>
            <strong>本文链接&nbsp;:&nbsp;</strong><a href="https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/">https://alonealive.github.io/Blog/2021/06/16/2021/210616_cpp_cpp11_1/</a>
        </p>
    </blockquote>



    <blockquote id="date-expire-notification" class="post-expired-notify">本文最后更新于 <span id="date-expire-num"></span> 天前，文中所描述的信息可能已发生改变</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2021-06-16");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2021-06-16T13:42:00.000Z" itemprop="datePublished">2021-06-16</time>

</p>
<p class="post-footer-info mb-0 pt-2">

<span class="post-categories-list mt-2">

<a class="post-categories-list-item" href='/Blog/categories/cpp/'>cpp</a>

</span>



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/Blog/tags/cpp/" rel="tag">#&nbsp;cpp</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/Blog/2059/01/01/2021/590101_android_display_graphics/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android Display/Graphics自绘UML图[置顶]</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/Blog/2021/06/07/2021/210607_android_debug3/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android Display/Graphics调试技巧（六月份更新）</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                        <div class="card-footer post-comment">
                            <div id="vcomments"></div>

<script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' === 'true';
    var verify = '' === 'true';
    new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        appId: "vhY87VAxwU991O4b7vDREoC7-gzGzoHsz",
        appKey: "CftrDkclI3ylGGjiQeD8C2xz",
        placeholder: "Just go go",
        meta: guest_info,
        pageSize:'10',
        avatar:'identicon',
        lang:'zh-cn',
        guest_info: guest_info,
        visitor: false
    });
</script>

                        </div>
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="https://alonealive.github.io/Blog">sunwengang blog</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};

(function() {
    var copyrightNow = new Date().getFullYear();
    var copyrightContent = document.getElementById('copyright-year');
    var copyrightSince = 2019;
    if (copyrightSince === copyrightNow) {
        copyrightContent.textContent = copyrightNow;
    } else {
        copyrightContent.textContent = copyrightSince + ' - ' + copyrightNow;
    }
})();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/Blog/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->

    
        
    


<!-- ### Custom Footer ### -->

    </body>

</html>