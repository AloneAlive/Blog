{"meta":{"title":"sunwengang blog","subtitle":"wizzie","description":"","author":"sunwengang","url":"https://alonealive.github.io/Blog","root":"/Blog/"},"pages":[{"title":"404 Not Found","date":"2021-05-22T11:20:01.758Z","updated":"2020-03-08T10:43:36.165Z","comments":false,"path":"/404.html","permalink":"https://alonealive.github.io/Blog/404.html","excerpt":"","text":".article-header { padding: 0; padding-top: 26px; border-left: none; text-align: center; } .article-header:hover { border-left: none; } .article-title { font-size: 2.1em; } strong a { color: #747474; } .article-meta { display: none; } .share { display: none; } .ds-meta { display: none; } .player { margin-left: -10px; } .sign { text-align: right; font-style: italic; } #page-visit { display: none; } .center { text-align: center; height: 2.5em; font-weight: bold; } .article-entry hr { margin: 0; } .pic { text-align: center; margin: 0; } .pic br { display: none; } #container .article-info-post.article-info { display: none; } #container .article .article-title { padding: 0; }"},{"title":"about","date":"2021-05-22T11:20:01.746Z","updated":"2020-03-08T10:31:28.909Z","comments":false,"path":"about/index.html","permalink":"https://alonealive.github.io/Blog/about/index.html","excerpt":"","text":"About This Web 博客园的Blog（旧）： https://www.cnblogs.com/1996swg个人导航页： http://wizzie.top/html/nav.html Doing 整理文档 Android Graphics相关的技术(阅读Android Q AOSP) 可参考学习夕月风博客： https://www.jianshu.com/u/f92447ae8445技术书籍： 《深入理解Android系统》（代码变动大），《精通Android5多媒体开发》（很多代码变动大），《Android三维程序设计》（未读）调试书籍：《软件调试实践》，《软件调试的艺术》 SurfaceFlinger合成的细节 Vsync（Tuning，Prooerty，Offect，requestNextVsync） Angle FrontBuffer&amp;BackBuffer双缓冲 Fence同步机制 gpu（opengl java -&gt; opengl c++ + Adreno -&gt; kgsl） opengl API熟悉 hwui工作原理 SurfaceFlinger opengl的应用 Gralloc和hwcomposer的工作原理 View子系统 CPP Planing 图形基础 阅读《计算机图形基础》，主要了解二维图形和三维图形的概念 OpenGL了解和学习 目前还不清楚怎么学习，因为Opengl在Adndroid很常用，但是Vulkan又是新起的API库，通过Angle了解到这个渲染库一定程度上更高效。 vulkan学习 书籍：《Vulkan应用开发指南》参考博客： https://www.cnblogs.com/heitao/tag/Vulkan/default.html?page=2awesome资源链接 http://www.vinjn.com/awesome-vulkan/#apps博客园翻译博客 https://www.cnblogs.com/bitzhuwei/p/bitzhuwei-cnblogs-com-index.html如何学习： https://www.jeremyong.com/c++/vulkan/graphics/rendering/2018/03/26/how-to-learn-vulkan/实时渲染： http://www.realtimerendering.com/遍历图形管线： https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-indexLearn Computer Graphics From Scratch: https://www.scratchapixel.com/opengl案例： http://ogldev.atspace.co.uk/ 3D图像学基础 渲染机制和案例 renderdoc分析渲染流程（了解原理pipeline, renderpass, swapchain …） TipsAndroid Graphics debug调试技巧 adb shell dump SF 抓取systrace fastboot 源码堆栈debug调试 Surface创建 硬件加速 软件绘制 CTS/VTS（GSI） 测量，布局，绘制 BufferQueue Handler消息处理机制（MessageQueue） Color Mode（色彩空间） Surface销毁（析构） WMS View子系统 Android系统 Binder跨进程 JNI init进程（system进程，zygote进程） Android Property Android Q中的Java注释变更@hide Makefile"},{"title":"categories","date":"2019-05-08T14:40:04.000Z","updated":"2020-03-14T15:20:13.706Z","comments":false,"path":"categories/index.html","permalink":"https://alonealive.github.io/Blog/categories/index.html","excerpt":"","text":""},{"title":"category","date":"2019-05-08T14:40:04.000Z","updated":"2020-03-14T16:38:17.872Z","comments":false,"path":"category/index.html","permalink":"https://alonealive.github.io/Blog/category/index.html","excerpt":"","text":""},{"title":"links","date":"2020-03-14T16:50:32.000Z","updated":"2020-03-14T16:56:44.828Z","comments":false,"path":"links/index.html","permalink":"https://alonealive.github.io/Blog/links/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-07-13T13:48:21.000Z","updated":"2020-03-08T12:27:19.475Z","comments":false,"path":"others/index.html","permalink":"https://alonealive.github.io/Blog/others/index.html","excerpt":"","text":"HELLOSome pretty and wonerful personal Blogs. Welcome to visit! Website sign remarks WJUP’s blog 积极向上又好看的老王 hexo next communicator 博采众长 不怕万人阻挡，只怕自己投降 hexo next communicator 交换友链，请电邮: 1332963488@qq.com"},{"title":"search","date":"2019-07-30T12:43:56.000Z","updated":"2020-03-08T06:31:14.373Z","comments":false,"path":"search/index.html","permalink":"https://alonealive.github.io/Blog/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-08T14:38:33.000Z","updated":"2020-03-08T07:03:00.944Z","comments":false,"path":"tags/index.html","permalink":"https://alonealive.github.io/Blog/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-22T11:20:01.726Z","updated":"2020-04-22T14:32:21.038Z","comments":true,"path":"html/nav_old.html","permalink":"https://alonealive.github.io/Blog/html/nav_old.html","excerpt":"","text":"wizzie nav ul { padding: 0; } li { list-style: none; } a:hover,a:active,a:focus { text-decoration: none; } body { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAGQCAIAAAAP3aGbAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoV2luZG93cykiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjE3N0NCNjU1N0I3MTFFOUJCQ0FBNEMzRDU0NzhDNUMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjE3N0NCNjY1N0I3MTFFOUJCQ0FBNEMzRDU0NzhDNUMiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyMTc3Q0I2MzU3QjcxMUU5QkJDQUE0QzNENTQ3OEM1QyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyMTc3Q0I2NDU3QjcxMUU5QkJDQUE0QzNENTQ3OEM1QyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PlAkwtsAAMvPSURBVHja7L0Ns+U6ciSGKoC8rd9qKxzh/an2hizbu1bsWvoLnj4kCkbWBwDefjOj3Z0nSiP09PS7fe85JJE8XSxUZWXSP/zT/5laS0lS/3/rX7ZERKl/IUTMxPh+Ek7+RWr4SvCj/hZOTaR/t1XOOeFdjRJxfz/hr/MXTtG/qadp0t/UD4DvtZZL0Z/qmfoLWmN9qfi7+uH7uajed6KWM1f8IGXOCYe0w9LjFC3emlpfSqu6EGZfY0r+1ViIvgsLafiDMts14qj9nbguSv6atLHaWG2sXsQq/+3/+j/1v1W8F1CJ/lzq3Vddcq4KIOs1ES6c+hmof4saOQzUYeoX1BdTcsEB8Gp9ia0EV9bwpr4IavGmviaRWksp/Xz90KR42XmarjT+TuM0/RRSpeOFs3f8WovDYfENd7QvMumV4aamvpD77hejC/ETkB5QPw16ZwEo/toRyMT9Iut95b4iuxO0LARraxurjdXG6kWsOOvfeay8B7v77rG8FJwgzcXp2S3Ic8vLVXY8sWamz/XBK3Bqu177SsHQd3GsnGtfWjq/vsiCLkKuP2j0LXoSfUY0f0tHh8/jR1/ffeHyeiiuScM4rg3X37/Z9CyGsy0k6UKagelHtsvTJ1fW6x3PhYSF9JtxXVfymO9/9lN0KDdWG6uN1btYMbJJS9KQ9rHcSPf6GSw/1N9+dPJw2+JCmzia+OIoP3ruVz+3w+EY9dXeAQHZk6SD26N0whpy84RSV90TVL2yZkFd0gBdX3L3+3GeX8hQa1VwNRvGUvE9fQOeTv0UHYT+GizkLA5NisfS/AQkXYL9KZGs9qfHiSfJpyZfvv0X6fHGamO1sXoXK42h9jfOuIiUynkaBBbbBHBiV139svoGs28x80gUq56vR9C+kn5R2Oh60MXFia+/w9O4nyJpFnqcmUuTWxPippha8CUL2PpGzWI5FWx+8TjpOW9/wXGcuKT+CNIniT4IaOyk7TlQK+5mXwhLipvaF2LI2muRgGff5Rvu7Elnaudx2kHEb3PTW1w3VhurjdXLWGlYR+itcvejlXJ4NSyCt8Vj0UNbkGv+fU8U7RCipb+jnGTRN1ngxnojlc39B/fn7vttzUIrrs+isV9lbajutf6b4gRNRnxXRPRZ1PFKfSVSrVpnzwHdBff7QbU/oJrkcpBYdWAk234kkpb8BgO7eHxZvmqlv3r0vFSfdc0ronaQjdXGamP1Jlb0D//49/2/fQ39GP0immWosZuNnNC3vsLJv8kjKPpFiOdt6AZg/9mfEkdJfrkatjuEV08py3FkXTNpWG5Ld0FaHI/SqPX1SC+6BpTzql20hv/7vvoN0MAvcd/68lAUPI5DHzttHIztOSPWCmliDzWcMN6qtUxcsCe6SM4/142nRCnaOCHWGsDGamO1sXoPK6K7fyvVnoP1kyJI88xFrVCHpbIuW6womHBooOaxV2YrARAXtFdFt+JR/OtQfVD5P49cbxm71mZ7eL9wrIb0KaEbXVkvwzJhi8RV0WHK/ajIb60u6Ej1XPegiZTv0PWUei+wEO8PAyl7lFWsWsZe3a856UL6MwmfHu1wbKw2VhurN7HivqZ+eUc59Kh1NhH8P7raGmdqM172EySOoyPyGXB2+n4aZXbUW7kiTa5Pj8OFi9UXAxw8FexX03yy6iLZV0nRmk1aCOy7Z0WmX7l+v6e1pYd2bNeFehZ63f322PJuP8uCF5NCQ7YQ0T91e970lkWy2hdiNBUnliTk54pXf2xtrDZWG6t3saL/9F//Y+b+A5YRBdMIplYCowBwNB8jW+QRD33/iZCra2YL+XePkNTXgK5Bvx+WnbLVEe2GND+CscqwBkGHIbUlx0y+QxdvLugNwE+LtksE5Uisp6emfW9eZX06RRWPRotUGXh+KF4350ZiWxcyOSbWE2ltY7Wx2li9iBUjaKUi0tL3Xy04GYOJO1LOQKpaJFaSrm07RTsO2tTQxDVf/9/P/vpy/kDTgUf/VCGQ5jkhKyFuLEAGDVZ4btCbNyM4HiT6YOJS+vt+/vyJYJ9zG0iNax5NCWXlJbsd/h3xMt98as2FoGyoDx7cvZz7Ld9Ybaw2Vi9j9X//l/+9n0U3nOIN0gFWBMgo8NGM7q3NkD9Q1J/qo8K4GyTX1U/Yj4/QyOzce3900PPeeFnR9tKKSFTjxLgeIxSTp5eR1kq9rM+AhNdSTe+i0Nx6j0i/fjkXQoN68qg2apFP0+lbKwe0sdpYbaxexArnuO+PEiB0ezlOMCCjEZHbIyldIU0z9ovjSvX+2UjOr69UuN6X0eF8nRQdEA234l8YeayN8SqP6I5Rk+/gYragXj87Rkc/C/F9/5QVxzj+WIh4dziS6BHU23r/mj/T2LutOlsgRykbq43VxupdrHo2d/a/X+DaK0eMVhqqEUHEyabfrrYtBTUfibKEjvSAn/7FUb4aiGE9VTyUW2sDnN/ieuS0RDIOFw8ZEZuiGnReuyR/Sz8LIQkt/alx5IKexefSbTY7KWTc6RgZRUXPmjDfhkKdsGYzn3arsEvvN6Anpvn46ovYWG2sNlbvYgUq/tf5gxvfV9VD1rns5Hx6SfItqk62/oi+NJoaeFz07ecBtq4HzL7/BNMMu9G2XNYY8vZHysofG1+IbddtuEkxTZmltusPf2AqBwYFvDjZnyQ90ku9/R7KrEsunLWFZ+ILGe0IKzI2Y8Ags62ffrR+5dnGAjZWG6uN1btY9UhWpZbz0Lz04rHsBwtE8Qo+rJfwZ8nfGfXGpVUixn2ePyjNyUmNlrk/S2q9EOPH5pkDMuZZohtHttobjcg+1td60O1BvSM12hZWM+S+EO4h+VrKk/NM3DQdJR7fl2dW7WObDdoZ933X6y7HDyoczYyN1cZqY/UmVqzKO9iIHiA7CNgTmdMvVT/+vmH+XuwTPYEJVpxff0O+IzdGrJXRhJEw9uh7ifPvY+JyJWJEsc0eK2yFwyXxZcZunDmfXz+CHqJL0DtA0ko+wcetWIj8eqn0WB06Hom/Lyqrok+tx48fPV+v/rDbWG2sNlYvY8W8IFDKgQHrHhoNwDiBaNUfHcYYYzSBrm+kMPQ4r4sBOrXY9JLzZbGqfhTb5V7Xz7S0PHy/2lYxMyvONfvNg/nfIzdmDuj4OjVPbUNeR5sfzlop5cTVXh+mZdqcko9bNZvBtNGrZ1rdvOtx9/eWQyet+mbbxp1kY7Wx2li9jJX4/KWxI6jj1bPT2IIqp7XJIHaxDwGIIxg0WYvuQCofJes4+KJ60fwLnLWKlAMzjf1qVFFxtD+eRcSlDsdOB9GbdN39OvN5dghvB9DmJyXWKlbZO7AQsYUo10Q7raMBQnMIYFmIE3+xEO7Jc1+ID4sn/7hsrDZWG6s3sWKnNnDIEuZ85BNT4xIN0ORdBdT2icceVnVLxfJDnKzeHehSstH2n30IMgkxlbPRx8hxMNQLL63KBbBp9hS86JgmVQSyGCqFkY+v7PmqqWfMKaq8vL9f1XF84U5WMfY/Nx+r4qGxE1NZOqSlp1BCbb/lx3H226PiYjSvbWO1sdpYvYoVh1SOjX9DeQdxrXyBCN9iy6jbTk1BhQ1YG/chV8bomV9Hqp/CKBjsE95p0Uuccq72n3KcTScnQWcjCukenTQKxUOhiTb0xhLWz8txmkswfuv0uoQQ42HVnwPQ5XHdHr3lSvcVa6/ybEzYQu4O8nkeqo5GdhPqyFM3VhurjdWrWCHs+SCQZ5x4T4/xPcI122di35iic4EvJc7hs0eCcJhL7sdxRNNI9loQ8lOb8j3G9UjlPDpMUuXZ+HCsIZIRbVfB0GXPY4+YJkgya4MS224euSabPCtauf3GH97BHWMJ8ZLBalEybc+Vr8J8lqILER0/aNUfBM5/21htrDZWL2LFw68j23hRbGTRTaDSahO/DLG0Mza0fuKG8EzHUaqpTDCPAt6zz0ETJHuMGF5ctJtwPylk5DfSdRJr6xeqGoyakfp1Lpz/tm6489LOaIoXyGxVRjOER5OCeWjMdqSIcsF0qIpdG9b6BvI7kTZWG6uN1btYGSENga7NdXqVHnhBg0ZHKbOJ0muWyN6tvD4fAk/3qNLmjnTS+Y2oOo/Z2PsRElqIeF5A6IsgvYpEVHz+oFmCqmo7Tfqm3uaJsrmGuCxsc/H8qNt9S0pNLrrqQrjflTYT3ckrUX7HfV2EUfbDr2kKDHmNQRUhaWO1sdpYvYuVLb/J5MIvfQIEawwdOQ1fQq9G+7BSL+R6+RAbsH4GcklNfpkdEKv52UZWvDHLysHVhm1/Yoz9uks4S+q5boGWhaiDUKjn2LVIyMKGtL61IKLtIVHo0720HvV2ycN4hvXX9GcLHlAlu+SYyzaC8luNdau9XwVhY7Wx2li9i5Wei92PMQQAaxvSFnxk3cGKSqxamkaXNh1L+aG41bn9tSZt8gtl9kg/1qMuPctAlERvIJdoiChWOXeksKHtcb0/SVC0M3vGZrqLg1xryhh28SYSS3YbzA2pL6TCGAREkn4giKVV1zjUiXa5exZKYOuiTRETmWIPGjDv4ObohnGysdpYbazexYp9CFskDTWvZuGMfHaxrxYrgWmPxd5brn6+fgJyIiw9BwQG+4NWLS7XNYx5yiUphPANphrR9UCJMav5mNy1J4gqm68zRSRpjI1zOKy5oI9S/dnPkqYsGJxzYcToWWjDLbESI2lDWPftRZFSXktY5frxG8cTiniw+DZWG6uN1WtY8fBmlOTOYJGCTQkxFYePIcUK71gdAWftO0YqOCcXJ/lDjOZlIZ9juEDaHIy0SKvjBDDa1poicsL75nwo70PGtJPIqlBIc6vvZt6+3a0jb562tyZJhpuHsxgpV5lupXyRXmGoYNC4mzKXEHBsrDZWG6tXseI2R5WC3dHoyTjD+DhCXS73fTdMTn/pyatfwSJ9P2M52w5Z9DXDkohinFI1qtncYrVbYTtkFObK/Yc/cO4bWhWfZvtR8ysUrdrxN3EM4wKjoft4aIQBCPtzBgJpeByVU4nEVzkOG2dQUCYtOPQ0SEzqvx+2iqWkG6uN1cbqRayUqipt0XXWfsWgobZhFY0ITOR8MHVbtL0x8WyVOi0sdtFt0Zn2zkUa5JHsNUQa8Z71LFXV7GvTrohuh2tfSGPmeVckzb266SKGZtjYA0NViJwhrIa28V7VQ0y6K5YmQ8RMTw+WGtov5u7NJuTaQpFoY7Wx2li9jJVFQmJLI/30zaYePQtrZgbbr/nKx5HPE21Oi7tTUNVJqGFPRBM7GcqExOwShV6x09/NWRmEbfOFcQTszCFPcQ82rZiumLSphjG+dikwX4IuMuYwHRYtEFLTU2Q1rL0wwPD1A3v06tXKrK+QhWKnk0tkbNycYX20sdpYbazexYptlTJCrcXmKa7Vs1Bd3nXncmQumY+eMVaIGRqNrU0mvsVymUR9WUK7cEyERwaYOKzJ9BWfz6f/7ThQXOz78/6q6756hlnIr8oJdea2yBpsnWjH9rQRd5j1Z4XCRVO4muEHWS/Y3vastx+lHHrj661CHCLWTOHkPo7xRBCfFE8bq43VxupdrFyq3i0U05TsGuOLiOtobXaYilbJGmao1cEiGg4UoqveCRAv7y1yq45jG2NRcVcMO5X7au08TlJ/IW2qHsks2zwRbeLXFhtds5DVfqpZgLhJUR0Ej5FLN4I5bbs+d4axx+FO39xvfVZTjmoiPZgmkCGwbwIdnMJpcmO1sdpYvYsVWBpLH9SaELPyj0Ge66IebcGXn9NDaHaWjtdtahHfQXkIRdtEY4u2QlpIY16NuyuQ+upIcW5mPKZ93SMX0VZuHpXC9b1sCmVJHuoVzcK5jWB580KJbnd/QHE+zrMt2jsl9WdWvmt1YxAVD+LxEUrxPevkbKw2Vhurd7FKlJ6agI/if71qP8EJvrxlaORJas8S2eQp6hwjmB2KNPJSFO34W08h5iVZZTEqhiqPo++Z3ZpNWWjZ+Pil35KWLrjX8mIYOQp+DpCJWjCnwej3AU4n8nJHinHPD53LahRqHlAi6je+43XV0UOmx+30zoutfGO1sdpYvYgVh7C8zS02DmoYru2q/YT5+NIavZArUHj9v2ElPUeF+E4ORZ40DTksL00PufzmbQuOfa/Kl8kJaZ4SppFETrZoOu6NJ4vPo39nkUQbeJ1017O4dpBr7ZDR7fCAYvfdtrVouLaFHD0vVQ8ktDBaaGXzMP7uq28bq43VxuplrIa8gwZTK5vZDBFOwEr3ICWxBlKC4Ecxu2S29xXqzcmob98EnKtI6Az6KZwgp6SP/qNsWai71HI4eNiTxLe+JZ8qA1Z5kYM2Wu7YtMf+HJcp2Ok2r2Vib5xKtoU0Ut9adwLBsACZ4mN/WBVKatbozRqbImerS/arbbKx2lhtrN7FihceKg++mUoEIq5qU0H4u1t2slKfUUeyGlULhq31GE+irbtupLXVqhwQTFreGHfkHCmiSY4Z4VW7oDgL6YOFS1H1jFs0iaUpoNFX5ZXFeXRMIakejw+ag5wGvhpNR8cwOYoxAs1LC5wgr48V/MS1He2T0YYgxsZqY7WxegsrJZGmmeNphMYPzr6hxaXrLPZaaeNZECP3PKTjLP3std7oVXAezkGeEnJahC/6V9mutvBpjQOalkOjuuYmHMZC0ahcjuOUet+1UsyaS+zM2TumEZi1y6o6h8kWIt59tYWoPaM7n9mF2ueAyon5T9BPfCEkU/aMNlYbq43Vu1hZlzAFcQsiW0nDoWZ4NiCgB9JLCU9F/y1OCMMKj/NLEOIvmiZkJsbcFv2bpvvtho4AYfm2Mx/a0TF35NaOTZyZYmkw6CdfaJRo8msSOUreVwsOW79ohxVfpKq57mH8Dvw0OrjAVEfAw6XbFmIMulS+zlDnaaNPTLrR3lhtrDZWL2M1NqRoN1RTmD9dgiI4F5oWNhsEUMExD70uO8ZeDjz7G1u6BI7b2alpLbQNm9fS4L94gUTC0BUk8w9iWbweUVvTCahG5tsdTVYVe4YpNvy2Ba2ThzKZUzZSf0m9e+racjnIhhjEYr/qzepCfCoJa+gYkG3ubcfcvzjPLyzk/oTMvs0byMZqY7Wxehcrb0dgD6xk/4yyF2tJTwNeuCS6iLObYzRDOOsxlDRhO2o6yqk6GdVcYBVJXjbNakOkXLGFLqLPDRy/Nt/N+l7aR5bcWpvseZLBn8tJG7F6SDDrmE0SOmXMEwDKI+eQvW7Rz1Ae8FiIbdpDKiy5vZrtqOlkVYO9b3eoFBmSrhurjdXG6i2sWFVHuSpSSsk3bzBxPebF5NAcE8WM0iwXDfarZaSiyqnHcajS1m2jjHacrHqud8W+NJ8q5hVkWPYQLfp2Ma/I8FhsUZyTtnjfFij39Gu+1c5ojib03bg2RCqXQlq2NCpuihvPMWZpAbsmGTpkzbl3KB70pwcWUk5UCG2cijWZ3VhtrDZWr2KlBT65exhjJG+sVH/1x3CdB498oUcPeS1JcxbcMsA6ebUY04T9ocnIp7ExVuI/xKPPFuKHFVc2RHDGqnDf4jutBYtMHPTkKWUuqeAsNDNGLFIXkouL+Ej1u97sdIuppBN848gOdx2eIoxNeMmsdtniow8bq43VxupVrFiqIQW1+0hQnS+78Dm8Kmcz19lajM5JM6KEzxlVcW1AViWdioCNBSpSPfAXE1jkMfHkIVZC094bpeYfG6lpWyTI2qggonbYt8pK8SBTMrtvzXWz9WIlWrkyFHliXU0WcfsQug5R6ma+2M2oLlkbxlWFhzZWG6uN1atYcautQAFQ5w95mREPgR4ZsoTq1RHW0mQ1M3d0neoWZFoShHkAPWk/Q88Pk4Asqyr35Jfespi6qzmptSFLODom+vQQGiyVQMofNRDN0dXhSdKDMHbmRZGqSRbJ6kW42u9TSIVNy6PYRcftH3po2JgX1iaGbKw2Vhurd7GyGlYxKXwbAQrmvR1aFsku16ip40r8aUBDyzQcbC0P7PtZ/vz82QGC+6t3EJqZBAXBRCZVJEkJo0ee1oyPh8wyxIRT6Nh66S/4/PyDLqpYTqtWky7XIbblT8b8sCdIszJBRb6qixYTt6fxabAnmr4Rxyk2Zbqx2lhtrF7FikOCkEyhWcy3R8RFlxPyvDk6NMw8po6X1wedrmFLsDYrKvz96QGHjDZtsiEXbZ0Id6YNar8MryJpkR86YbeKdl2FYultJpb9f7W2aeeI9q6XC00i22uOrtJjiM1peP+A0Cx0inkbTa81/Ow2zsjGamO1sXoTK9TsLxDh01A4TelbPBWZNbI0hfFDa9oTUQnfxJj8Eblqvc8fPziX675aGCtao7OKa2iIlf8U4jp7I1ODPoCdVbpQ7c/KLsPFn3/zI4Ey9wm/jedCaODSvs1ZabCf2kNh4NjMTM3mSK8qd71g3Lax2lhtrF7Fiks+tVJ22dF41aBY95gtzvTQ7YnvTCPZ+Em9+9LBKGHnYtzXLUOzemgSjj/b+KuEEo5nk6rF6CVAw43dkgM6QVpHPLQtcrTW7um4TSHmmKY9Ja3DWMsXYyHyRFOtRKR+VP6ibKw2Vhurd7ECc/9QUmnPM9Xc9QnHumkVeQjU1JbaI+oOJO4e1e+fCIZ926zsDZDZIBct/hBYr6l9ny7XMl96CDHO3blEobEj9bMfqEB5g2048zhPe3Bw+m7pMe/LuLPr6RYoVUbWRfQFc1OfAjGiU10hN1Ybq43Vq1j1VJMSlePAnhEaXc/Mk9LkgjxTO1mSPZl1fp0yr1ePtWCvxZi1Dg2UjtcNQsVyrezj5SnTM1WkZcrctrzBvLWd+dV3tC1/naSa1ia7gQ5FPtBNwEIWaspjIcsphiwizfyapwWbik+XUnQhuIyN1cZqY/UqVqyDlZXUjKxWDADF4M4jLkoYcMQ0YvDwbT6pRd2uH+v+IDXEHKb5f6Rg/ace7RtRvapLaowG7liNLcaBc16sb2+N06sb576dbU3OH1/9AaJsFBr+Qr6QjpbOdv5WgI/RLZvr1J7pQ9dwLuRKuT8xvlqaVdGN1cZqY/UiViZOiMqZZo+HUlxbys9zMH/P6J5lwXEtqm5R1EHbvYNcBJ9tJZRVbMx3uZmchmZPC4qJovQoInodLmQWVV0HNkRAKrhnHp1jGD1nTHX259VcSAup/lVko/0iS9tmx5YI4tM+Gc9DTXFjtbHaWL2GFXNkfZCILpgQkvpBD3OQ0ZRAy9921G09h5isjdR+AlVBVVYuReZKi2ds7ngdR7OMMdgf4pU56vC54XX2oSWJfJftHK1noRXy+zqyRL/WJ/XtBWlp7qdwjkmaC/EHCP3mHRdXpK4Q8SmoI/qIljU3NlYbq43V21iRLkZcFaefpOdzVeewHwGPfvnNw5qIRbfNGDiHRxCGg8jySBUea/YKY8cCL0jq98NCo8s0LfBnzHVnn802/oalvDqpFHKuMGA8zF+IvMfgetIUg5qSVLinL+SuMjgunlFzWrXMIhH2hahobMItP3WCQeU1ZMy0b6w2VhurN7FimVtYlzDsl0JZQ2PyYW/XKf2tmr9FVxD/EbVLqEGTS9vww8BDFBLFq1/MAWaYysCyW8UqwiER65U3a79iLlws4hbsmX3dspQB6dslCpXzxExTX4iZYLencixN0MQXQmZA0rNQE80gF11cHwUbq43Vxuo1rJ6hLnLQHuOhReGU2eBctGcu6tKmQApbcPhqgEHrfdCpNy1DUDpziO9AQbXkr0MJt0pyjYGp2ODSYtwIz7IOaw/rbEaSKvU8VyzfSHRTOBH6YY+FyG+koW20JKC802+jDTpUd8oN+u468rSx2lhtrN7ACi1USYMP38iHA2AfxE3VWsU7jkxLX9OvjVRcgtS3Q/Vu2N2BRPUoVEvQ00WoXkhgp3ySgnZlAX9DxJyCjMvv9DmxmfL+R21yq/xO9hx35I9zptyY/zaRMDgrzXyQUHZEw2IpCthLRh9XFwKJ63KYrmLoqpmYj/p8mM7rxmpjtbF6ESvjrZoqherUyJC35yMnZpnlMVWA966qpqnI9IAU2xTlpMe6TGJMCrTxXVrYu5gahxCFzmHLYJopXtxMvAIdk+vOGSU89bPWspuzblvo88dZvMVB4xnk6oz9yeNKaS4P7YVC270Dyrsh1/3i0HhNobFvc6VtPBI2VhurjdV7WA1qF0VOONal4zwwf9XOZuYla1X1P2x9kSL2d96Iw9kMf0IEx6+VFvo/in889rrNnyqIvlmCPhuNU5cohMS1IhrENTj/BPWsVbdYpDZVL/A8qcvQk/HtoN6RVEKDaQ4lKKOkVjBK+v2glO94iulLXbijGS0Y/91Ybaw2Vm9ixWNYe5pcp0neRyTNZKGY9UJ7XMw9HivJtcC9p8fh+uhKzoTPVLjc8bGZosVsGIQ9hzSTg4Z5mehXbmeGoaSMjPWo3nEd/Nw5mNTMa8jbHxJ9Cvdf1GsQbz9kHmmsnhTfkRsz4GCUlOwL8aeALC1lBafJxmpjtbF6Fyu24hwvLP+1HKahEbavyrUXzeL4gobrnU/0LCfpbcLe+LtwzgDmwdpl56I1o8wVMnFYMGURoU1gsBQTYG0+YZW0FOeH4RjTzOMGiCwVTC3aiXJMzD82q2xrNS0LVhHtWmwhYguZ5BZx1cfoura0sdpYbazexYqDlZ9knfHhtLZC2SSi9XpFNZt7XM9oFkhsm8kxYpJHa5PS4H1NCZ8mcxJ81Odgh41VqXizXFpHzIclghRmit8PPdJnf4aocI/plvn002OKKetNMbMggF7v/ujIfIi0dYbU3ND4GweGN1Ybq43Vy1jxOuS9tExpDXLwwEAbAop/PeiCNVZyKOk8TjOCuIRiRRpYLCvluDk8AU39HKVvwilfn6v/Xec2/Y1tbq3T0K7+1g6OYW/6/g0eC6E6pAtrk+uCsEd/eog5kaw39dF0rcsI58ZqY7WxehGrQfcnH1OUKabFaYnxSto3xVIESBsD4GVy3AVe27Ikj8hhm5FG4Cdnqam9R7B9jYmL58N9jVckU7ZPoqr7VGMaM/kChpTZ1N3g6WtEaelWeCdXF9IDuzY7cos8eix3GEOKy2aTlz+bbKw2Vhurd7GKGtjIP5lizJKGjSJrY/Wqn9yTt3Lcnw/ZplTMo5EtauZJvKdQGxw54eCGrCMG6/QRDlXV7Oj8cYrqmanbtRpky6DO+cac4w4ttUM2WZ2hpNPYPHFjpF0ri/2Srvujs5lHD/BqdYZ+cNYD6UJ61oqOcShbJ18abaw2Vhurl7HywUU2vGQdBhe3C9IrhlR+4qP0JPHs34OFtJgL61LH10VosGx1bkHbmCkYO9IW+WRoRiBpVPNr6Rli5rOUE0XFu3K0e1uU3wKjvqSW45Ysw+wjQTXUXIaR50KQ60IpCNObfSHXGAqoo5bg41GydG1gnrax2lhtrN7FatSwxi6Yl4Zl1ALVefWE/yKOYjtb9TY0N9emXC+czBJLGkKFSX4Nw2FF24aWD/irqL5dJ5j/J5JPCMcW1aHvXyuDbVgYeTFvPCIQjGWeghahs0djhJKx7NLxddrcQOk3XrUZRdLCIkk1HkqxkNaW5HxjtbHaWL2FFTs9jekp8EyhNIh57v7nF+R1wvE1YaaRHS/5ll6yTzMNVUQr7NF6K0b9X5XK1KS7yoFctwTJtaeOuaCV2wbHZLFFs+MMgsmQBdMZca9E2vLG9p7Af5N0fp3mtGunOcoJ6Otl95XXbovOWylvDZlwHVS+jdXGamP1ElbsrNdK3HjlknkQrUgIOzRNlSWi+ofA3DNTxauNZeQ0OfTjxNk7kU0WYeqYLEBgRmp6XwWS0ycYtEtTAaqJWbsJoH0MdcVvel+4nhwGs6sO2DCbtYX0yz++vvRJIlEVhHIFFgJNshpdWomF+N0dD4d/A1jdG6v9ufqrxkpmzxFVOdeqMbYqkkHJp1JpFSkaw5dIB/tSigkDeixcQm8knBYtR4pYZWGuuYVZvx89kJt2vZb9WIcRjA0HDUYwzQxrHvpAQxCsTUNt5aoYe1/9y/JC5O3n0bvLzsTVD4lRX2xwFHgZG45pOpOw79WttPnHseLfDyv6b8Kq/OvHan+uNlb//Vhp74G1W7pW5szUECc4yYTBXPZCTGlMyfa1n7JnkGZvNkbMY+fsPQ/dfLY5zDlbnkrPv6GUeKixR5Oge7h2tA0+Cnhm0JC+RfNSGw6oSyAXGw7wr9ko//ZNsTmEVvUYKj/mRUoj3InmmYjrGHbH/Gc1RX3xuN6mFL+NBfw2VvVXrLQ1/RfAqv2CVXKskgldP7E6/tJYuUakOvP+RbD6K/5c0V/6c7Wx+o5V/l/+w//sDBDIO/TLbI1IC20CnQdW9x57DxllpIVWhe5eGd1TUPh7TkhFxydb/x45q8QrcDQLgTTy0Z4hqsK0KswDerLmRVMenFJrO3563ZxVtKdmpYzgWz3uO0KkmhN2RpU9DItbJaKBFZwLPLQh56opCzU9hemZYd04IP7bU/K7NjzioHCG19hMlZ5CkaeJlQrafsOqijU1cNObz7X+ZbE6vKvjziWNMPmgcoxgAeLmcQfGsQp7E8fKTvQrVmKVAscKg2oTK/voNp/J1y3EPwurFiIo/94/V/pvc2CVN1b/g1jpaWSYx0JMRwcVdQJSS3HRX2whfppGAAZvrV8BRr253rcp3ltz0wJwFORMCMPZGRo4MyzYQnIseL1tqOHrG/WOiFXdWkZlju96i7jJRvOaH1Go/ySbauc2k8m76kKKp5pT0dXPml0DEQ1d9SjK9XOLz4vzaN9qApwNK9dFk2atnd/CSp5YWeiaWN2KFf/zsEoTq2yRRSsWzTvG7ujWwkWzJ/w1F+283NVKuX8Oq+hAG1b8Dau21IH/+Vj9VX+u0p//XLFj1e/LipX8rljd/w6w0mjJKuunrFMl3grGlsBAXaWkR9CkEKwIfoQ06ELkAsdqGbtcp641r/a3VVNRq2upZB80pyXwD0VUik0uhVB0hkGuemlEBXEIcbC3dY3J4kQ15Lp9852962EFyMBXBaqdVVLHGENPr5Ff3KqO6KVKivtBhhU7Vv3tqjKGX49TWF/WND3UCOA7VqVjdX/E0/XvWLlO7ZjPUKz62mkIHmG1QyHEah6L0Ld+7s989nXemmfJn8GKVQNA9J6vC0ntYXLgFZAHVuVXrNKK1b/lz1VbsEqPz1Xzz9XCbJpkAvtc6ULq6PqRY6WODL8bVuWvDavf+lwNNr22EuAEpgE6R2eRrNjW/J+6f5qb0y68tdn/ADEE3YQaQhkqKe2k+xG29Yqx364YqoxxJs8anPjf/4odl2jWoBtuLTSKjSChLlhV6zpPChyNaUm8Q3/dKtLIR8FHYVmI7vNrU89cdsStq+KbahSuid0CwH3QDOU6xgVMeDHdA6v2K1bpgRWNwS70U/ra+xKv+49hNbvOOtjeX0+ehw+Tb1JnAX3GaunBS7UWvFRFJIOzk66rpqkl0toyWSrmbMda6exvPoqkKKM4VkNMcogrpQdW5Qis6m9i9a/tc5X8c9X+Gz9XLT5XpKaB+FyZ3MnyubKbW1uE+7jp7vugWGUlIVT5fbDK/yr+DS5Yyf8gVr/xueKQ18Lf1fgQJojmVB3N0RYfXwo9sMmaF9+l4uXKW1Xvw9jAPsRS+1tKv+JbWkcKrtkt1AvHv1LXr2CzIetvaE2mxL2VFRkE3IT9jv5jY++ITO5GR/a+7v7UAIVEvFsx3IcAnKRYCBAPItzMUvNRtCB1a340acGGlQ4N5EugasZ4dNBivO1Ypfg8EeoLzEuX16bSj3z2D8BvYtXslhfGtdfKjlVtTzYe0AObrw0is2KlW33Vw85a80ISiJx8YEVPrHLHShQrLdI2XjQwm9vSiWHFkzQ458ICq/qbWP1FP1f3n/5cpX/G58qxYvr+ueJfP1e0pjbZP1cVexsVQhm1pPG5Iicfod5ET6UBcqzgyDCwan8eK/9cqZB5S38Oq/Yv82+QCST49kexspwIWDVgJf+9WK2fq4kV+aedLrmQIvJhNHt5UipYWohftCoLlPHsrardxT0XgNqpjNqHDCcjfZJj0Jyz1hGrhX/XwgDcNdpenuV6QiE6JBmyFWw0X3XjphhQGhuo/p0qEAvKkDe0f4HuI+kma8vq9NHmi7KdFOk/oYo8KxOarF4F0BQ3Daz6KWAfko/kmtZpIQEDK/rjWPGg7Zbyp7Dqn9wLWKHGqRm4YkXWedQnzyKfpHcnTL8DK9V7w1MXd/23sOK+kJ4x1COwSn8SK/EJjD+NVfqG1V/uc8V/+nOV/xmfq6j3yffPlfzW52r+9puOzxXnhST5wCpoR1jI/fxcNccK+yN0qSVabH8Gq7HjG75bfwor+Zf5N6j5e4+Mfwyr/p37+W/wvw+r9XM1sfp//vH/SJaS9FiQz/T4d+DFMCvcOliTj0vJm5fTo0fR17gILcRsavbmEWTEf0JvM4d+q/PQ2lwtLx9nLzYN3VVatDL6qu52aXwvEnmBTpnf1ltJUxqRpgoQJ9/vqKNkGpPucf2/sRABRSW+qYPsupX7y2GlCU7fjoUTt2N1XUSQEPnjWI1ywMBq8GK+YVXvBg8o1vrIL1hl63z/Hlj9S36ujp68/H6fK+Shv+/n6q/n3+DvixWK07flYPzdhZU8KMqD3Y88USi0eB6cV/e6ZuNbLMMBfc97ffoGpH+qJHYZ43cb6aglft4WcS3qpdcWMtLaQYAKtdj+QncW9i+wPz3UdeMh5DrTUfKFWHIpKly95qtTgSgWYjnsIPLpP/LfAav6HavcN1t/Gqv0C1b0R7Bixar+Eaz498PqX/JzVX/Xz5X87p+rv55/g78nVqDDm91YaA+aYmvzo+gRH5TT0Ayb/2os/MsDZzzM653AoNX072fPF/iEnKt4K13m5JFE18CLvqGtYVXGxdVIC5Zi+bO256BnhlHvHn5r31Lft1XDq6nNulNI80Etfkw82aMp+vXkkLFr74+HDJ5G/Yc3pGl/H6xIsaq/J1btV6zk3yRW+3P17x0r+r/+y/9WcuGYP5JEz2g3+okKXB07j5g3ksHgWBLXFHvwWyFGgYC1R2teY79kgBZIPSR7bXnUntiZbzKUNzhEYLPudYOAVHPGtrfKkoU+VByj8s1mQrKqr3IaDTIzikuUXatMDY3MG6QnuhurjdXG6j2ssFkAJVJmDf85ZjTO4sznyBwVqfoYdHQGhgSHUbu09+eD+nQ5vLw9WlG2g5VF+kdCFz95+zmJuBvtzC2HthmodRWO29gqX/dP5aHk9kBhtK3aTGzdv2gVovW6eQhGq16a2Ly7lzlhUnLXjdXGamP1MlawHRtTR99+TTHounBTH7YePGcUabgSDc5uz0gJUZJvuXQs0l7zpBosiSIvIqr2I+Y4hb2Fh82INx2UfFAzFGPb7ZWgNjH6dUXjmy1NmbB53haFgDZlsVO7wCGmjdXGamP1LlZoiWILOoQBZ/VtYfykp1WQc+uRmsrSrRhlO4bZWN9zfiq18+ur70BRNFGm2aBPPp4n4jMfoWHWRqfCHJDS88Vi4wvqm1bvD3r35w8QOWvf5raH6OsUwKBF1749zLLT2v1Y63+6EJ3v6Q8NnWDYWG2sNlZvYsUlq6TOfWvTgRa9rTQ3wsldYJdMNaXHWds4tegsCPhv0kDWUOYkoq9on0rTPr+4MQlndKi2NOylzYgeK/zFGKRCEBoCG8h1IeuKbku13e9CLI8rHOTNIeXYlu6tMUjWRWk58L6vVttxnpAy21htrDZWr2LV94w9bn2potPNJkQj7Zm/mQzg96tdgmAQvhyvfsUf1BHPr74S074pkKI+RRH8Hn1HFkoky5jtkNHhudFti9ZzB+oij+tGm6Tj+MKNv+5JS6KBtT+HzN72kX2vH4KZgSOvvvsD6q7HcZB2zTdWG6uN1ctY+WLOQyydU3qFjEyNjUYrq8PhM/ynMRvDzQ2CWhXotwKpRiGQiGGTUrDdrTHwiB4DOVyZ7PqWzgJ587WNaK0degLnree3mfMJyTGPzPZS3HjyAfeYWU4c1yhx78dCTPR6kC5lzPyiwncBqfOLYQBnGiwbq43VxupNrCA+oJo0OmWqgjdmX/2kcangBfEi6DwZqpPFSui59hB+9D0zyGkSI4tkwgUYRsF8H7jdKaehU+j6ghRtEZsS12tHtLao7zGY+w653T2u09fXlw5D+TSASYIpawPiPsCLnxYk1kAhXheiXiE8XsRjugATeECqlEMvF3XLjdXGamP1LlacfaRbe419l1sxFLI4S2sIJCN5aYdz9Wpsc0eqs9x3322WDroiFR2ONjoWYrvccChSdsWkkH3TFIi5IlMiaB53uVVMxvTM82zxaCKXs2tjprfkE7XAz81TrSzJupCg+IrIw9rD1iv9dlx8HAAE4rM6+kdtY7Wx2li9i5XpPlhcBZG0L7WCd1uNJybWSZDhOM2Rv2lj1H6LnQAGPuD9s7P1h2JOiy8gPS+tZ6XghlyflMQFP9JzfNJbqG3muq4IJjrH1/J5mIwcTZG5Fufqf4La2/frWIa2RaKtYTIbYkaTo2HqyzQSii/kgg7Dt4VYgXJjtbHaWL2HVQjgswe3/qLzOEQHDpP1LX0eHAolYpQxY6KGJgSb0LRcpZy61TT/jHWTjQdIdiUp1To8sLvuEVQbGhwz3iZINzaxOhXudTvItFgXtsf1oh620eegKScUe29dCPXdta6jGvVXle6SkUq88aqoOTcFDyjVH5VbzRwOW0geC9EGzsZqY7WxehGrwVg1RR4dSMyahlVVfWATm7SWhH/BEeads8owt4bmVs/f9EWmIlJTEFVnl3K6p2nWCulVNs2o2csc6PBC4iAjpJntYuicuDDQYj00MGBToUbWiqgtLtrjiiZiN4nn0mwhCQsBW/fLCoN29XXObW2sNlYbqzexMgOZsEkMEU7GRNDZTJpGVShYVbw0dQz5HcvrVFMa04noPrhGuMxG6bCZpWlyGxJf5fiipoplD9rr8CuLGAxy2t0vpm9oY3QK1xmHHRt1Wrbg/njJsJE5xlA6+2WnqPn5QtgEPZGFFhXxcdmz4bI9Gr0bq43VxupFrDi5B7TpcJKMiAp1uWyh0dM2ntmpWBqpVAzO2BDrNlpkisZ78JeV0/qcDkdlDkX/VgdetEhZBDu275n7JWb15q6pypPxmx60ueekAsYZ0LUtVLyyF2qvi0SiK3b0e9bvxOktD0i1h29t8uyaaGO1sdpYvYsVT59rDXCTi9bXDScORown18y1JqUai6lzdL3ARoN814PlZuxYGaSLQWodcmVDwT6TC31BVtyaINHU7H+HfSPGlA5oe+JRks2TI8TFvdwYKXU8WKZDt49NocJYxiQ8t7kTtmS2Xh+2XNf5ef780perDZNJVG6sNlYbq1exYnXHbjJTr0XwQTyEN5fUmfau0I2uN2RWM8tzXihEmQdRJPGQM5+Z6lQg1Dns3JR+4k+PMSdVL3yznEoFiSbtJKi4+LT1EfjbhKW4sKFNr+twgt3mSQxRBxzS6VBW4c10p5XZQm7YNxaysdpYbazexUqvQkJdO3zs69S1yEdWf0dn32qFn+p9daSO84c8FG3SKi3IMzP0IWydtI5wvE5zQr63PBDPUAzvKSLGrODxUVNYuYjfianWOPbMCrd1e72Upx4kLSuvpCjvTP2s/ORqgnI1ouP8MqmNtcbIQnYQmtMFG6uN1cbqTaw4wu2ibjFGEK2jibzUeo3V3lvlpkaln2CFI4Tig9Dm/DDT65EpHPGYKRovxki2+U2ZSTcGzSG0mjI7y3fQ+V2DcQZdU4n2myASQhmDyEagzelQe1HPSFcCI7rv2hqmn7zrkiYtJJnw6/CtlBbjmhurjdXG6jWs/GxOPrPxSgrF0tEpwFaWPXusd8//yvFDXyoaRmkyPpif2l1WU9T1s2s5x4IXtr7qhEFZNVu/s9UbPVp8J8wBEdz58UDwk4qYvpeyS8zVI2TMkt/10TEh1SMehiCwRTrNSFK96sY4E7uSGC8yxt7U2FhtrDZW72HFbpMxtscSAZtWUS0g0kNjrbXvpYsK3yS3IJ2csYdYov1NVSaCqztYX+M5YAFe64jIdV0i+vrDT3jqwUhmTV0pksgx+u1ukaYJazt2GnwQSfwcYRI8l0TN2A9RBu5xnhSfC1ExobVY6IGex2NCNlYbq43Vu1jxpJN5Rkb8GAafgVvcdpidvqYRmh8jT2Mok6b6Kk/l1jRoueyyzdqwJJm7VEb6yjaXJDyEECWEWU1mjGlWFmd9sbGdjodcGPNYgz8amvcxRGimx6EQNKV6mpv0cXJvkiYP6t3GamO1sXoDK+XWu1IXeRR05vwiT6NXed9XPs5ynhAYdLxMpoci7JLF2thFtzmE7bKqY1KTTZpLpiNlMz0gmGidf6O+sreTNFrjtrhrDEXEcTPsXO4N4iUBMtlqthjP7Cr7GUf+YKiy/PjRT9EfVjrILjaAWpXDS564LnQSshHzjdXGamP1Jlb0n//x7/Qyh848fSOFoQ6XBC6PuRxqY9dRq/WmIxeASJLk0aEQUke0p22GWfdwDFnOUp+vAYKLGESAVD4kJKRd909MD/TU0Y/PUeSjEY4lzZzWstTsPrPNM0kJk2NTdE3t+lyZSzlhMX/D7epCN1WBrqNeKGRs4/796lRcojjYxmpjtbF6Cytn3kuI0Cxy9M5k08Fpne6BCirS1/4lQt/tzmOeRvrvUfnTCl+Yqdml+7KZZsqqXxBam3eDnOuZzUGbk5LZYJuoxJCyIOU5p8lVOGeWwfkHM0VbKd620IeXVfGU94+4nilnuGwnPR0kogUB3j3Ws807sWvvN2+1kEy/743Vxmpj9RpWMCob2l/fuBm2na6XhsOC2piI60gch0pY3DpcGSNLHBKFQ9zevuN+kJEoLkReHzi6rqvVdB4dqdw3tqTRmuCfmFErHEMDTOlbBzcG3J3Xa2dpS8XOh8SRUEJehyHiQ9NyqPVb0mN7f3aJbdehEYsBcduZy1iUWSZtrDZWG6tXsdJOoTxGInlmkqmqwnw+DuNBmG20bnybtjxprmS1fozdsg4+8fOJMRTJNAD3k1cAcp5fzCW0FjOxh2SkoxAevO3Uy00NiR3tHWRVxLCandE9vF3sk6Ppvj5oTZQv7MVtY++Dlf1hdXJWJ3cZivxPG0v9a9ZxzY3Vxmpj9SJWPMN587KfaRcCiFvTQnC6SPsFPDHVClqBhXRJt2h5jMMkjYZ0DVj4o4GaaKivcpQDlURST31WGNuEY6yc9AX9t8pZiGuULU1ZTnEbZlM3tOt1CoDGQi5RpI6mYhrEPkmp4Rqppt74YpQ5aN3zqBg2CYZtbMc3VhurjdVrWNE//L9/149eXUuZwr2aEsTw+chFTanFv+nkLi3Zs0t+qW5hf6mOX94SG2aKroctrHlJbrRItevRrw8iProxJe+qLgHcCnpaPrxvhGfO7A1U2zbrVlnYJXYoRGCTst3cXxsOlAnub8tCWlqMSfxqe+L9EYiT5SZTKz9Muvt7NDXdWG2sNlYvYiU0FMTYqv3qLIZFl1xMs7kxzQzNCBo+Ra3irrlon/KDMSHPPHlR1uGQU2wj9mdDqlYIJOoEE81HDMVIZdLUkTUeEypzoJqJDxmBC4d5SiSvRmRzGX1vABstFk7aPVktRdsMtsnGgVHEM8mySU3pz7HSPwDX52Ny+jp1yuL2j83EHjdWG6uN1YtYqV8H0UItw4a2/+DIXxY/Q2Zr7lpbajHp6BdwlKJz3T9NaXA0OHhKFk4uGaPI2C/AvMbYNO7TMkowtVrFpIKQQ6oK2JdUaOxnpL5j8JLHZfgKbcfczyIY/D7yqdA2N04KLkmLhSi3uF8D3MJ10IlAcoGerC+kmUhrB3BjtbHaWL2LlRi3QakZ2Z02VKlrlOjE5eWbjMJ+moLztgfXyj9ifP3QaEwgNLre1hiaNFGLvuBEpd8R64smXqXDTPveLbfNEMho/wxXtbMhYottnk0xp/KQ4XHyLsTMUn+VFE2nnScyLMCF+nODTGxVTDNfXdV0x1zOr/7yq34WFzg27tzGamO1sXoXK0sWNUXsOVsPhwIV1BhotGaksyq0MSEPNq0RJOz7rAIRPZ0TNdVQQR0OfwzPLjUDBMkVPLFDDytWhGuBlNo9unE1ea7Y35V1HurOJefzULPJmuGPFuxeHp5ocItE6a5WIMu+xzZF6FiIWRdph2QsJJ5d/QtdCF+ak+sTTrszSTZWG6uN1dtYmbSz+cGCkl9I/aopAm3Ys3pzwTTtBzWixbZUcaSjnKCmuYYqXlliu2uj158Lcq45mX9Hk1CEVeVqFzsceheaJWoEjnzV4jpi9qcSbkmWKa2vGj6wuu0pa+V8kHvajlfosqIQUC3S8xhKiBKgXoMl2NKPgyPXhRqzsdpYbaxew4r+4Z/+Hu0IEC1usP5VGZpGZhhbWpoiz6qQv2aQzwtCGLxvDbfZEkuOgXJllCR10XAW2OKKvQ4lUBytucGk2sXaUow2K7X2tLTD5vKpXgYEYe4Opn+bymZjfmoYzn5bSFuWbE8tRP1aLzz7cm7u48gbq43VxupNrPqpUfe/LzhbuJOPRT4Zss2L+49b+lAac0/fBOuVLVYyLDZcmIKskCj1gn/GcVZshZUg5tzbuVu2LW6NBsVsVWhflHxJeA70BaRSlOZL40r6Qq7rU04MWOnZ+2K0oRoj4LwoyMZC1lV4YdJEp/uP+wULWL7V2xQbq43VxupVrLAI+dzFRpOUNyExarhIUgymP9URcSWNWqBEtyDeSanoabCbBVj352NDlWnxezXSXPWdut8Sp/bb0W0/rH2E7GrUpm1BWp7kVHLFoJMxUppcn9zXh97E6LyGi5CLdLTQ9zH0p7RYCtck07VokWCnXCCEAUXtjdXGamP1MlYFms0FJ8DSeAlz8l1dUGxiIOpqrFGQ/TpcRb+/K6PfgZ0tFlGNcobhyVxyQE4+1S3BMZvCOs6dk7hJ5O1bWnTAaExg5sRVH07Qn74xy154SI41WTTRloUkWwgHZ4RD0Cc9VPTjO0iZSz+Fck42VhurjdWbWCkVi4vW7ttif0ijBiZD+8Yl4FXKNZJAeZq+GvPVQjQAyvnz82e/ehQCY0OuGWCP1v5kQPoqM6V8Cuk3l+2aC3aObPO2q6DTQen++QfWjuvo9c5RgeqqPU7ZVckhYX9khYpQG0Q4OxdNISIg2D9OUNHeWG2sNlavYlWwzSV2G1YTAETNz65EeRIo0rcpOF+1vsY+ncQ8ngM2ByAhIIhz1L6/7d8oHL62Nlig+aSKZrBMjQsBMw3VO1k1FtO0Y4sdtTkUSbjHVjMOUigszSVOMfQk02TNb0lzY5Jh+yFDy1U5u+LJagrvpJ5RM7bQtTaijdXGamP1IlZY9H1/fG86PBqDk+Feaa3NC6dFE9oUC1vzk/m+t6kaGN1y1XqdX1+c+XN9molz6Vma1hTjQttj/6zxODzapqUa28ZZrN/Rgs7bbIrq68cPyI9BIHEspIXT7GpmG4nt6NrWQb1NLnptnF23A+g/oOuu131lDElsrDZWG6s3seKjp3PgxF8ptLgeEhQt+ptKqX2YnrmyRJj5SNg0smtitFrz14F2RU9LOV8XmGZsHVZ2pw09bg0noqj2UTAy7DVKGAtzbRU2lFDe+HxAllOZsb55TqD53jE2Res0lcb+Fll2W4bjYyH2Mr+kqAIyXX17fn9yPricG6uN1cbqXazA1TiPL423t7qSpd/YyVIMe8/O6SLKSsOYzP9790uu13EcuXxZhC2gx5Ye7v1wtT2Ov5JJbJcd4+I+YzQpctrOwP2Q6+cfUIs7TlV7hkPRcagXdhVejD2+nyhE7n00PS07d8tpB79FDWmlfiCPeJ5gt2ysNlYbq3ex6peiuoKHykdUk/paPc3cY2gt29Pi69G+KyTaCVjVbWCMoR2NBiLvkTJBVzCJDWk7bY2GTeO8aG7h7aHyrRGJw14NYmAXKLxwNMsBJWR0sBCl2bIxXBbKR0pL4I6/zFHxMQkvAym57g+0p7++DI6N1cZqY/UuVqwzABV9ir6X7vvEWnUBz7hIMUr5VAGcbUrdOGMZTUVzeup2fsniQAuRip5Vlh4jgdd09JEwiZTmfDSnjbWFt9Ye9ynZEdrx9QOaO6mZfaNx27AQDGRhojzn/AsLmOefDx/JZ2NEF1JtIeVoQ9ZjY7Wx2li9ihWP4KYJI9wN77s5Xgs5g39td6YndUMX3AMiIuzXlwnoIDK74CHGBSDWUw6ivilVvHJU2jieJnY/+uv1RywRivVQCgpjh9zj+vGlT4/F2dal9UFmy1hhveo17K/jWSQPnkdbGB/DYM29bCuu9eto6tzWnGW7sdpYbaxexUqlVcn2qSjC912uXHI3D2UeZHk9kIvkLEONfdk9re1PBtLym6iNGYWwM/boYqo3YPEepRA6C/eMluKqOCEk7fMIMs/n4vlyox+CWXbOGBYP4pk/p0JkJ2M284AEGuYGeFHNj111jpYLTUWN5Kkv9TS0X0Y5DoIIhpC4IdLGamO1sXoXK453eMsRRmdZZbfqvFRXv3i6nHkU1OlsgfLNjZJbPuxKdHAxhYSrSZxS9Sjal3Ka4c8QSEUU1nsmPPS9VF5av4Y5LcT2VeseKtZlzDQ9RMeEorXQzGWkuUBiGlJAnotGb5hXpolNLKDHQVlZdnbZj3x1Y7Wx2li9hxUvNS+yMSXOJ2Wu92XhNvQteG1YjM2v6dhUxPWixh60eBU1eXgBoZmKSK+MNXQWNGV0QVjTel6lEYd9kD4+QE3rDwcXn/ZSYfNElJI9Heb7cRl8FMpHf46olRKNQaX0W9vmsZD+56kLGfqPbc3FN1Ybq43Ve1iZ5F8LCrwJg7W+bmKdbLJvLjbajyzUTnDd/ZKP41hVVptpNkfNr+n+mWbbAJCqPVnSmK1x1c4lce+CotYfGrchpaaLJLMW2Kb+xqMxSjHTcGAQ0+yDTLOfH91iWhU1CEMSZMobwRVhAycue2O1sdpYvYqVWkeHEZgsghLlKLqTlDnq+OwT2GsR1117bJhnjOEjr/O5XldgNxQkYHmWs7oHGUItmGnzwWEToElzXZ23qkazteNQuMVGK8TmpJ5dlKPgidLDdpO1zbFKXCtSldRryNAQdqUxlTdrKcxoN1Ybq43Vm1jFWKPvWgdHQp3CTkwbNS/18eClpWb69ECKWk/eorUwqv8wbl06ovposDr/kL/RcQOYqx1Z+bQyZ5di9rxvgUX1dYBUyT1hdZh4kPz1OMO2KFlvlZaioUblcritNgWPZLzF7ZTuDow6685rGFa61qxNwzR3Y7Wx2li9hBUPjnxoyM+SPy4j6yC3ykULixvStthqUkM/ArvuIEg4tC4nJjEX7uhwcln7aG/ahWsHQ5ZuZ2SnqrxBGYMFyYdBkzvW2ngkGh/i98OZ/zhKjbJAOJrBB2ksRL0jW9BA1PZW/bL7D2rspDmmqAIKcUm1jdXGamP1HlasRPsW8g7ReBQfI+pfQKhHu57qwEHGi5V6U+tx/UvDo45SxgLGachD45h6sq5qe+5cVTsflDnWUKv2HPZ/Sdfngkc355qmYmwbfDaxXHqmny6dIXOXbCL8tpzCHB6RbCU+znRXyDKeP74S6ojC8wqFl/Ig+5E2VhurjdWbWLFtVpfVBl/egrVphuWM6KuCW4AMw+G1nCeDdvZNg2ImpfNBELObaeo5fxP9STkdDFnralISDSY/FzFllddhFTMcD4r2nLB6nmI8rIaUT1MTJHtYZZ1LF7a2SF9Hk3weDPGxb1NVq+pjCDFurDZWG6tXsWL315FFv2L0Jq0PKn0lWaOvaVPUJvdxnuS6gs0NFw0jq5M9uatDbTqWElU9vyCvH6KVkPhWeMF/Iz7Ow54JZAszglvs8GmZoQwFe0oumkGmgCELL00Rw9R66DK2Wu+OVOEjFjIKgi0mtVJ8nxJtrDZWG6u3sXLf1jlDOWyFYv5Q5b5YtSPg3fO583FAbEehqa76/GDaSwieGkz0XIxftwz5VMcRGq4FD4zPz5/cIJDYXNyHguJKo+krz9u6SPQTLzv2yVdx1xCUFRHj+9k/kNfJOglF4TiUHlYl/i7/C8nGamO1sXoXK/aWJOuieCpppaG7yq4iqPlbVVUKto1vDSzaUESVNGxikwvo2FW3NahTNETIeRVa+BPVAzPHavPY1h27Hlzy0/WIp6mbNXGnin5Ix/ZU1q9kzgW4ML4W+eDiaAtp7ftC0EYRt2tLLnudNlYbq43Vy1jRf/7Hv2tDetXjLT8oYP2YBdmg3Ghtat+gluOM1xtRQjgamTU9JrDlQb2PrBUo2E6bKfbDPVe85aPi0+WCqxqI/SpObdo62dbKz2OOnDb9xklJZqOXdP+v0mNwOtNB0SoFI1HQJqO4K2MhbTkRRQ68sdpYbaxexIpD92sU/OhhwWoDRH3rfN/9IAVKDz0XpfuqnrW6sZAzQxZ/V09KF88MTxRpuGZ7YLaZ8nTL1XHBlBLotCqpIze5+I4T/0OZgjQAj307jUi8uH2klYOnC0GgrzolAJ2xcnLm+7qsz9oWzfxYiF1hEEnGyNXGamO1sXoJKzYZHfEgu9S8nAqBoxjx/zx+GAtDZSUg0CWzc8nhd032ljiUiO+T3Q07x1ODPWSKKUOrVSJsbzMXsbHJfGBTK2r/6uTdtDq1WXt1QDYSUQ6A+CGkj9fc99X/A+lCvUjomTGEyCQaK+wLaYsWhq2IPHffWG2sNlYvYvWLVsWqaYpXQIWrI6Wz3RT+F2BmdMBqFS/IzU6quBmZJ4HevAxVriXosvsLMV1QAJID5bejubdtAy0EHdAG5XwegmZtaU/QKPWxQ6P9DtiXtUmKi0/ApfL4sAIHvr6QI39hIfc1FWBlLsSF/a3qOUDfWG2sNlYvYcWiLFfMGBJNyoNNPKqGFtSg0UBVEXq2JDCpomthE4JI3kYd000heGMHcUl907yvPmrkc9hoU/Zf94VE9zyj8EZGRVMyW0bcF5O1J/lln2xp5NL+gAwQeyNjpME914VBUDkPEEzEz2LvyT0vpdyfLeKpsszHBU8xfNpYbaw2Vm9jVdhHoTUAc2x3TYRQleTzqYp/yiWbXDErwR0l3bUDqo1Jax9wlOW8DmdJY3BK6sh4yV4sUPjqe1nVJ3S2BSSocZNYv8ZZ71p1f19SqtmPOVSC2iDGek1RfCEUPA6dKJCMeauiTm8U/Qjv1GIhKsMDGTTm1Ro3Qr4PQm2sNlYbqxex8i0hh0yXugZJ9saF5AydVDQddZxb7V6V3yY2TElgmiH6GvD27TbKckF+dfkwo7RFkxWvq+hEgJVhcwNtzEt6AVLU5hW90VvdPtSN26aQyOgeNIkk5OjYBCkusoV8f+13Q+9BXLyuyPbkNdV+54rK9etCslgzeN4CmunwxmpjtbF6D6v8t//hbznyuqREWj1oq+DOlx5d1WXW6F+ttmYiO9qBRBrYdJDIFQJTRlTmFBJi5KYgrjZtaj5O5ejf7XGdiAqUutQTLXy5m5JLsGXVZNCQ0dWhz2rba1x+GyoWThXhofhlbWL0HaRecB/CREObbBQd2hRTgCUfjYLuq0A8rPUI30zskShFFTCKfxurjdXG6jWsXA9rcCisf6l8NOxeJWKtXZYre7HZ07pJbFZubP35aSLR/rTbYFXE4Ndz48myNVdXPD283OiSrBJK9CZYQcN3kc9DnYVuHzJSplkNGWlrLrQYpBpORHLrWGcmdb62SSi/Qq0amC22xXj0XLGQGxl2Il6Eh6BjxmljtbHaWL2NlSx21fpXNEuhp2zuPV7hZ5eF5vCGHbRaa5T2rJXz3QOpMWW93kajeeGzSKOLoRrP5fyhtAoZEq4hikqhbkGjyJcTneXL8GLPbN1YMk6hV8WmkaiDB8hgVZ8sjfYwL05p/V4NP24P+Rm/ilrX2nDmzHWj1bqx2lhtrF7Dikdcz5bq3RUMsn6CGA4wEodmmE6fj/fQKsaqvNsMB8eYiwzeal0kKdQdpOq1lWyX3ly/VQFxBw47l3c4VBcRAPf3ghSLLm9NwSvhORnQ3CtJ2yjw6uBUSg5iiC2ktaFRHV2MtIqEKV6cS1VF2HV89F6egRurjdXG6h2saOxvYW99IW4q3WMdwlbXWRc91L5jBrarsrQi1ONoBxya9o/2aswH6Zg2DDR61npi4rHvk9vg4Ro6omrz6jnrJFxJBUdACbLi2cHc70q/oOujLmmTk+aMW7X+uED879dzqOf1MjRgTkGiXtr6QKCFJDJ6tGfHmBh1THc+siaLbKw2Vhurd7HisR4YK1I/QUkPTr1vevsJVMZG3ymL8unUr0GrMqMR0AMxynemmiqTVpthEPmpjK4Haop2ZFin2RSC6Cjl6AuMeXN7vkTjgdV2TVslNcbAPRc1yOqNemHGei2nDduhGAaNAS7rs8SUvBYEbI39NVhIznK3GmLb8RDYWG2sNlavYcXKl6ALhkJy5EODvcgQduhv1peYvY7NLkGn1RRQpS2yzaQa+M39zqSGKLNV+2Cb0ZeBmlpPRPG4kJZWDQ2wabX014Lv7xtjmSwPckNHSO4fPeGsSpwVrwtiU92/o6Obh11PzKYn9+zWCmezpoOQ1y0VKfu6hS4t7OEY0+ngqOh8qZYYN1Ybq43Vm1ghw7pQ9m8w/EH5rT14rN5x0AjLYyzI/X8GSX+w3ap9ndkGyodwKtgV16dnq6cNf1tTMw23oBa2s/r6WwZ2Yx+eFh+OapoYZN5BMgav5Lox/A3if3+NzN29qUSzX7YrZ3OUFQf7JNh646GEhRgRJZ4uG6uN1cbqRaxYu6ei1tVkon9OKJMIqZB+b1NtVYz1rydgmvY+4vQKlXMmqFD33XHt4VzJbNdHNaPz1OXyJwNE7GuITFfTKuRBb6U2J6qMSCamdNFUnB9tFAW8P6Dqhbjez+sLseuXoSKWZprNKch1MRZPcyHhztasGYzhTG+p0MZqY7Wxehcr+k//9T9m9tJ7cn1p3VSDRdumTuGqKUjxdx7WjvNpwGPS2lJOVvsgSAzqULoK4jwmklwJCC1coIaLzVOr0Fw1EotLmNlffSq9KHI4j+oiFuqb3g79N0vvkfbSN1XGmCoIZWr9FNjAlnLwuFqeynABt+NtrDZWG6sXsTJ9w9ykpWciGrY9o9Ww/HR8XUfBLzwX3erDvgM6//XzA7eM7MbTaRXJ9z2tM9ZGjJ+S0SBihF22qfQzmZqsGYrc6O92xOrVnx6wp81tINUiyZyeSaOxu7ootQW7NI20xWi4Ta07+oGzOmhvrDZWG6s3sYJQ6Y1FxxRSa/M0K3APPwsT7mk+rjniaBvUDV/hLTcku8Bnu1c7EPRSZblqGQja48JNaO0hILJMVkq44/ooJ93X1U/a02nR01lt8nHjh6lHi/Je+vbBaN72rZF+D4B1vKsf+bou6on2xmpjtbF6FSslu9+3DwHJoGgtgRxO1yLrGR6Rfi7YMlPR3TNKbuh6tPL11be5EI7AX6OISEuiWM2GsUWLc6HCiSnsTN3CEbbZmg0Y+oRo7Pl1gsNi0oVDu5XS+j6TODMK3sNPKK2UN+9mhAhkxvTWfQGfo2ysNlYbq3ex4qP/H3S1W/O97LlYWmhcZrPoJb1FEHHkqN+cypTf8elBV1I5oH2TNZ3DJhcxXpusMy1s0+eRKPgZy+ZZYt57KpCFxms/XA+6OHYBty2rD1I/hUtrkHODKYK622izC1TT0B0ariIxGqqsXdul90S3vx8mJSVvrDZWG6t3serJForwwAt7afOPbTOhC9NFmdrQj3g5d8QWGsGGpc/n05AinsS2MwcHrJRTPLA+a4SjbwvZr4WgqwVFo1+4dM9YHyiwHagPQUXny0fPEx0qA4Zt9biLM7rLSGaZFguPtBLrohQQt6denx7qVTS2Q9w2VhurjdW7WLF6SKe+FMwwaQL561qGbtZv//I0z1JHSJ328H6eCIcWpEPpovRADB3WWufl5qEdsehSaHzleTdoXbfyMqBmzbkc51dTyQoaAthYCPUcdWy/03DaCNrHt/tk8v+Lw5qfpaPR4E1yEBaiF7ex2lhtrF7FikfbUpmpDar2efVbjCnrFjFelpDZnrvojPJhx+L4OtE4iO04jRchZSxNhzNVbuI3cJ/ZqUlE62DmTI/Bdu1YdKT4PL+IicTUMKZZCOej/+fqD6s8OHffnkXGm5Mk8v0CfCFqmlbhpNQffToZgINtrDZWG6t3sWIVADNjjJ6Xlgbrs2uI4Uv0B8Rref6FTLtqL4/1xYOnj2UcOgQgTicbYl2a6/aQTITAibdlDuraIi8RDQIdbPLJKR68MyzhwgNHuWTNmXIUymc2IUk5H9To7lvfNrsiMk60CP3r0kSmcr8pb2DioKe6/QEl0SHWuYiN1cZqY/UmVhz7V+0wwAq7qNzg7blcC7/YZFJgKhetE+Mc7U5zacWwZa1Zma8m5RoGIG4ENBqioK8R3fcnVV+A/LIhN7VDb98GP069tNGaRfkNY0qN3MN6fdboWKgaQEJWwwedYoZBkqtmE0fzVGyfrpem1UGVesw6b2ULyauTycZqY7Wxeg8r9p1qjB1qvf9QAQrTu2G3oYWvB6iuzEuOSlHzb3hHf2NCaMfR+bEL982nXVc/UMlqkqF+ir6hpchbyff1fnuGcEUi1U7tMffI0fyk2blwgbExto4xJzhBYjTB9fpbiFg0qyQORbDwsuy3WcevqN/xcnDYlsyWzcZqY7WxehWr8IsVGm1LyOTks8fR5nQKCQKt8FIkC2UtHXhSt9h8FJYWRj1B7wh+Kz2V8NWfGuL5PMc2NakMyB4yO0g8K2xvj1NFC71f0mLa6Lmh99EEWKwdR9P5J+ZxZtOcVSWf5Lde5gxm7en0eRafz9Q31ZSmS8jGamO1sXoPK/PHNmFmP43W+WH7OlRwkN/5fDVPuldTakhTPwx4BJUxWyDrZjRicPuluIesknTyc6G/QkjDlrW0Nk3cxxgl0QFtYZ02NAm5LU0Ne2SocuExRDJ4DLePFolW/uxutXoXymf2IQlmQ2ZpzG6sNlYbq1ex4gjtLcuk7WsBr6hxhf7VLdA4+f80LyU2RpsmfsWFb1RQPxqZ7ZvtYo7p8HCmJRN7ttQ32iJTytU33f0503qeWwR7ZnPSGETa1H7pl+Q075ka5KoIhmnC2kJ4SnQ4cFBjvGEfgluuDmqqds9+QL1/xoLbWG2sNlbvYcWTJeFM2iXwlx7sQJm1faaR9K0xAT6rlt8w+JiP7wo+IrOaqL2J0SOVtBJ44aQGqkjgtTQ5m4ss1gprNjjcZrYex6KVg9dHtdDOIoPEYlmy6rByoX7vvUOhmvs8iLsqJlbBW+lb5lNv1JSdJaE8lMnGNOjGamO1sXoJK9tAosdQ/Qy0LLhBCZFU2oZjqS4zAaR0pSWuapzDSSPsys3zV43AzJZGisV4qPSYLis3XqJuU3MQwXPGzY600zEavKHlKimGl56UDi/XsSlVONl/sF6sV4urqhbXdfbKh9Gth0Ft+HWI7Z83VhurjdW7WLUYUDJGhasWhr5XQ7V+BGwf4U4YnVYp+lMP/dDmWuK774DtqeH60yIrIT9iPFQpbH/rE0YZ7cxar54f9idJz0IRveH+0cSlv8aGmxaFMGEfCY/de9XDqxIsuwPkePKYaRqQAv+tcHtKWTtBT2Jb7xSVjdXGamP1GlZsKoIsOsHEjwXHAVXvRhX/LDDffauZCEjZ2h8E1ZFRkkRO6OIY/RSRporPgNMQVGR1ULw1nOvQEJRXQRszPUMO09cUAwiKyxC4GHnyzGc5agGNzIYRZDaOZ5EpU4tZs32RPl7g+r0sR0LYbJBgNlYbq43Vu1jxWJgLM5vSjc0GJVeo0d6jKyvftfYfHvD50aCrUhYzieUVO5JBy2e3J4rxx8ddMfVp4HJofogwXhn0tzygV1vuOIXj1RZ1Ht3cIuk0KpzlzM2ch+ogvdljhIL321IpJ2EhYyCdfJ/PoaphGSkPxY+N1cZqY/UaVgwWiOkNOquMuD0Jr7E9ZihIwCXoOL4SF1PKkcVLNpodHAKGAZnrtFJaZx5rmFmLXZxaYugv0PlTvx/FbyAHQ05WKq4/PXhEd39AzbPMwp6/Hg0O1kEnPDxudIJJO8eDDZzmU2K0hEl7KiD0baw2Vhurd7EyWkObNFLWUw/NwMZTLVAh0/pfk7AbUt4Xj3R05rSe6s5mAA9qHOhiqpWjLcqsRkZOU4PDkLNtqzJlk2pKaJvB1MJamG04CVd9sZOXJGXRjkalkmMInWH/MVCDSEWC0mMaw1Z231z9BwZwNiAfevhg61q7d2O1sdpYvYcVDhkJYYh1Ma1jQWq1w7qfvUHJP78g6HrfOoUpseNuHoBXVWnXrGghfkFezRuejDJUcHyyqCe7/YfH+QXO630PKcKHCBBPOVf9eliAsM5T9eX5NTRrqTS7qTgIduYYeLjQWTm/1KbttuQ760VWfZmNnqtmGtkzgnV6fmO1sdpYvYtVaSktK0zhkpjGrjWZ50a9y1EKstD+plSvu6etxVqhU54rNFXZAjaH+1iKeccUxhchfa/FN7XPbiKX8k5Kv8CjcL0/d099VVtHQ7iMGVGD3q01ogkaJ6K4FHMfcScSVdKgCj3XO4PHBl3aIq2fJN0tg4fiCvx2/9lHTbl667Uv1ya7NlYbq43Va1iFHYbHSM9Ih2SX1vlEBSswFeQMtx4bc063OY8Ndx52dS3Wo2lCu+hAkzma8XCaZRrZqb7laq2dBSI+2sjF2CRqilX0GnhWEyWGqcR34D7KoASSqqOT0bYgVhKLJpxIa+Vz6ZzA6QwQDFjCGXvI8UOu355yOuZkj7anIdLGamO1sXoNK9gqMrc0HavbjO4apGvF5HRfhnFwrSqG0/TgeKvr4nPocZUU4zmauTgpTjsj8/Ygtb1NanubfRxAnwIHVpLuWvM4uLRAS9NmbqNfu9xyL1LKomlYVa8DEj59IWJq+3hlf0AdudyapJpZW7bUNFktc4ou9nVurDZWG6t3seLB958Cg1OgB0hlpgN8ecwHKO/LtJ0bVKg7mmppbe3Wp8qp5aUaL2fDgmQwccUVMyA9Advbr8KHkfy5547G94CkDshsF1ZC30i0IfwF+HKoVMQiQ5UCe3UdHJcLnOByaE+meSXQng/lcNkdaW2kyvOWx5znMhuxsdpYbaxewYqXeaM2HaX12/0aISd2qMI8LpcnptpeBAWWoQJBmrg+DT1oeAPNHLL5Y4RdP5BsyPEsBwbNp06F293qghnxWP2xmWfJcNYXeTUYoSgQkv6s2ZWqgAaQQmFT4G1mk5R2tzCDzkPYsPatduOnfpDodl02VhurjdXLWI2IrFX5YeWIt90g/h+HNVOnbDxMPsytER1WRF9O9daJgtHynIGRLGr6hBSlua9m/1Hfzqqxh3VovTtLuoX2r7FfP/XFdYhvhGqZ354aUdlGukUhaMozM8kxjIAzaainKOchI42FKF59oVcVrwE01RVSsVc2ZGRjtbHaWL2LFc/g6xkgaX8BJPl8FA3IKq0V1NTQQG3RbpXSA7xONmmMJ3eyXvauIYzY0qIrqDL0gnFHLnbRY9oyNM10SB3LVbxKwVVpK3fp42JJzPQQd1URHdFynyKFhYSh7djqhytbEP+BF5TzWUCZ6x8OEh6yZGQzqBurjdXG6l2sQJiQuR21rSYsgHI+/XIR4mhuKTmIbKJTjBpf8wm8IBDhG9OZkYYG8+qbYZR924Fnjd+Lq4fr8ZC5BtlsKPT50U3QGA89DV2G0VX0vca1bUO1WqVYrV+cc6HQnB4LIQ/zzUXGXIWaygmrpeu+UyxEJnWPNlYbq43Vu1hpd8KrfA22qpAV7CewZkELD7HWlkuJLM5TSI3BVL5OsGHvSnPNHDIYs4LoofmGxjPzaWYhY4bIoYJEq9tmm1G3flMOlXmGrH00HywdVf6Irx8hGYLWZDI9PWAj1zV0gjBizt+2Csu9xWuHag+HgdKxECsHKAGX2sZqY7Wxehkr3Rlb6MoaDhviOo5Yg2phe2JztJApVa8cVqOvQvMw8YFdbl/JzehKMi/sW/G5R5W7uSp8s7kvu5I1BXj2YpUA4jdDe5ikv20gs/bNds8tqzqvqUBPHJan+aSi01/Qd+bFFyIW+w0VMwNpZAVD3SJL+EYi9U18lq/kbh+NvbmiRJGN1cZqY/UqVtG6BKcLCqtI3rR7STI2ye7RQzbPo8mb5nKUkx29cbQwCur8Pi9J5rnmUolkXY37urEzByFNNDX054Me2Qafxl7ahO8h3NW8sIdLzBC7zij+6c5ZnEjCOigFeHtgvmstOdsDyu+YhPQ0Llh1yyRGwG3GCk8AEyerSpnLquZR2byHRAZzbmO1sdpYvYUV/cM//T3kKxCUdXLatG/s0hbR1THaZHPdyPnksSeOVqyCDFcfyszh1dEzOR3XrPAUOs7TNXIek+NWgTOBaxp1Nt/66hyA6bFmNCZghK3hNofphlN3a7rlqv1BU7gMMbCQpzbiWdJc19gokl02v9Hi0p3cDqQ/h+7+434sKx7YDdlYbaw2Vq9h1S8skDqYzc3Q7VuHWP1oHJA6Gkqy4Wx/Tf//PQt1SmyDhk5tk3ercVvdYlVyrKmMmJ+l+ZimPxCQ9vlfZZBGRgtD63wqwpiLjoNWSnP4AAu57o7UwaZjL2MhyQ1pl829Hm3o508DE/YiX4/xBZ8kSFqH7cjGamO1sXoTKzC6cAJVG2xqg6bnljbVKky5dbL+s58jJcdrjgVUS0CV0CrQFmu29ZX66ZvdA80CboMnglnGJkbpd8Hp4ZbtXU/rg5JrpQo5fDgXVPELm7yODgiIisZiZz5l8RfbXDty/MRNimjaG9nLyOjCbh2Onbk6O1ZzKNlYbaw2Vm9ihREeKDZjR3q7DbbrwjfJi3ShC9P0fSSZh4/uXTX6hYSFmGMs2x41JxQQxWW91CNIW7DjLClLat9F602WcAwQOf2khWXjqm6vT5msoj3QRtRBJHjmJh004DGjvqTKuhA1gJQwQhtHmoNXjwQcxkp9BXdFPtw2VhurjdWbWGE7yUdp4W8fB7Wo50zToTZvjQaVoidvRj5NXy2SawjtQbcw0edzKTntHH7W5IllG7xYFnIGWloEW2euOxbse2rttuIU0NCBQIXUnz9B/A+Wnd65IMXWFhKuOlrlkmPJ/CcX+zbd/IfiNc0tvXZb+lnqvbHaWG2s3sWqoD8gj5fO+p19X/gxPj6ST2xANYiuWhNcQwdfxQyrCk7TseyljYEGVoW5mLH4WKZoouvDTUyy6FM3dyvSloWrXAyryMg9m0+Ka5dYHvJAJtrRd+3NioaUFlNc8anRELk24gkP63DwX5Jt6vPGamO1sXoTK8S1+74Gg3ZWvmioUGhp7/uvVWuiTZ0ca1WahM991Spf51fP6K7raiHbLE4YWx3NbHfcqr29fdfJf8hUpJjeVB2M+/70XfDxNz8EdkGfVYffkZry/C1Npkia1x+OIMFSEd9ms0ltU8fnui81QdpYbaw2Vm9iBc/YHr/uemu2pmF3bFTb3MLOGaaH6kOLRLXJMDtTqn5Hqi89n+jRok1LYH+YtSwPgbG0uG54tNXoS6Pm5zGV3VnbnH583hLJ5HXpUOXRj1j6zhnCPXfI8pObvg1t/oHUuPdq2jEVY9tsqg59j0v6Zd+YDu3J7sZqY7WxehUrKNEfx4nTo2pGY8m//Iru6mCDPHqmwwJb09rPDRVUMDFO2zOf56k1RbGscmWXLInh8uSQNly8l2eLaa5a0a4j9WkYhvoin2WHjCEicl1Huh8ZdBoOZ+uVt2Uhuu2WcHnse2aVHDsBkbqqbaw2VhurN7ESMwo7DnE9wEeyFnFdHsPfkXimdQsawoBg7NcP5R5zjzitDjod4Jjcd/Xkc5kjN2HU502icURelWTJ0e1xvSOVz1OnIVtcLABDSntXl95fF/IbN4bnQp7dDy1c9kdUz0LLeR5jPH5jtbHaWL2IlbZCTePmOPoq0Z1cDTtmLpfSqvRAPIUfbKcZpLO+iSWc4MtmGckGHXWbjWkApnrV7MwSZ7ROeR277kyRGRKnUXez46u6PmRh0/HjRzbivzoRjdYvl1J7nqmznb+16xf/vm/PhyB1rEV8k96RopwPLMQ0qmljtbHaWL2LlRK+bAyIc19MtbHt/C0IPjx+fuPrsVZIjpVyfqUxOemOGT4VVTRSXmjlClw0JFJBt64eMd6aI0s3xBUvGPRdkXJ8cRD/KcYI7FmRwQQ5tK97A/dHgZLXxxS3lH4dfNAEFeyVnM+vEJ/mMVm1sdpYbaxew4p55oSt73gp64hQzxlHfmh9zG8wrZkemqbG/UdAdeK/uLOYZqjDoxHEVlVQbP1BQuGhJhzBm10EGov0PutQStViZLs7CmXsxmc6u9w9wULyUeS+wV/jRaMiiobjcfJMT10BFsw6Mivw6NaI37KN1cZqY/UqVqSLcdvFdjBUePpSYPS64kLi5zP/sVA0dJqII9WTt0PbA8hQSUjnuJUjK0aWbaai3/Hqf4VGl2jXYJVmpaFkNhhx4IlAZweSFjoNwMWH0dm7Jm3eleRMM+gjnrgntT2iO60diLm1HnwX3XvTeRxDh4yEBmgbq43VxupFrFjmu8h0UXvs7PtGEHAnNLwkimlYYVu2KP2BAIFEO4EZkIE4a73QSS0R0+4xTlrPfK3EWDXJIzNZhNTYsPfgqWrWX1OVEtthzqoGa+t+ppO0sHGVUHsUvfExFupCs84PWUqKwcjLkMXohz0R17nFQgayG6uN1cbqXaxMwGbxvNe3ghii1tihnDW9PNb2pArD9wzx7rE3H1/B1l9GJ63mp7qojTH6ZLqrRrTFXrpfj9o0qoJPmhE0zBSNAaeeZQLCCpAyHdmh4tomKW0KS5sORjoKWhi6kJGO/lICDOaKKhxyxubfRBqb80/cVSltrDZWG6t3sVKrIPGxbPFKXziF9ffc1RsQnijSozYG7kXt13VkXYOYPg8eEZgRF3FpL/Hozi6Z6O+GgaKavkoyA0VZhqFSPFaU3gZ+StZHQHWh1RAMap67jtH2Fqy7xsPyrOMF7zbhxumbtvUYaRAMocKVW1s2El5oFcKvEurYG6uN1cbqZaySie+YoavN/LjBYilOQA0uxqJtb7qA6MV6YcwatB5f5cHZsNEhn8huNIcqlX+iIhhavTODIw3zeBTgh2oHa5T84uNU3BT1JsNu0W7mnAencRFVi4mYfrABhhAa47AnsbXobHlT+2xqi8t2EvnGVdlYbaw2Vi9iNWpYkI7XLW6TZWTRT6NH5Jiotm4CJLV6vgbNZq5uH9SGTITK2ZDG+Af7wjJG6z1U95iFGqrujpe2h4ypKFizKdfDmr19MWPbLPYMSa4NZF+QPOhvZHGac7GJqNlktXnLzGC+dEyhvJFr6GEM4X7T5akqqbax2lhtrN7FCuJhK2HeY5mY4rIai+UMPWeNqd4WABHj7gc5zq9w8mkeKUMa4peupThT1/NGHvbTtkNGIIf4DwePQ8eUENdLzmcL0MVmkCQ29LJMIenuPU7ls6DZLJH0+7oQazr4JGe/T/d9Y7bg6werbP6jvTo1erzMsLHaWG2s3sXKuqFa2FpY/rJ8BdvVbBmjr+oGjPU4+760UNhJO9dfGi/jQxYayVsJQvPki+iP73JLvwdVhSsyqoNUtdyYbUOrbwkLxqlkqE0KBTecta2+GGYhrsvjgdwWou5nStLju7ZWazmPkooZEI0xdFPzSZOBkgzgjdXGamP1Ilbs6aG0h37FaGdCkiZBPaufRqM4vHvq3bea5EQMEzmdpTNZBHQWVXlKywR6DeqYuCI9vsou5FqRUmJ0IJXsJNd+AXXK8q9Pj7GkublvMbkQu3HNtM30TReSoOiqEj5y56+zzIUM80lvR3BUEMk23RurjdXG6l2sgghBU2VC2lrE1wzwVpJrua8q15XPUkoxXn0NYr+OWHtolEciZ11PN9puy941zVBquocEai/xdX36MnM5yfWk6f9n7213LLmR7VBGMDOr510N/7mPemEYsHEAwxf2O6h2MuJyxQfJrG5ppBlJW2eGPQ1NddWuncmVuZlBxvpIAgaluGkIKNdMjjhK1qJrE9jPisy21b2uFQM5D8v4xnMjrfKz7PVwo0ydVX/jjdXGamP1Vqy4+RzJo2e4znFpwCwuGqC+1FSPe7QQNDfmyipxtW2mnMXdKiN0mcMyouYCug4Jkq3Zbf3MClY+m2JT3ZjHGg2UK/7xrCiLOay2UXkGXr5DyYtCtPhmgRHnxAI8TDEqz/U+3mqlllCa52+sNlYbqzdjRf/xf/6774E9DR+0jFWoZOux3W5+fyvyiBzEfiows7BZM06TaRAxUjIUPx0OGFS8qYH6kPJlfQwIetXGtd5388ZE8703oFLDzjWd7dcUNi7rE8lfMC6Dpig0pFLy+kSPlst9S39MBWfOzmRcFY9mk2lxrUq28bmx2lhtrN6HFVNZjiyrmUV4hfkKGyLGAr4Gw2Se4egq44Qmt9VsvTRJrq4m8PHQEBENO0XbrkMn1V7UV+UvpG7QUfni44JmwLJevbTVIRJI3Hnx3pfloZQLeG3h/Zp2rrYChkEiwXuD2b2BbhYIl+ghJo3tw7zGpg9Q2VhtrDZW78WKp8tDbPzzyvyPV7/u/qWpe/BWpgWHQFFMSJlvSm2Wi7F+FjNmXhqVg+Xq8/EItkXsdX/D6zjh/lXkQCv1tHhqqREtu/YLogx2hMzZx7f3SCbfpAwd1Xh64BpTuUD8xx/kVhKYxIaoyjKQ7InEQB5ago3Vxmpj9Sas2FaQlEodms72HPMl5j8cwKm0kf4KvIxlKzPOetJqPZKMl/qQl9DtbFjEGtViHe/+v/M6K5/5LiYoRwfUFsZTNTD99mcWx7wMVuLKakQ2tOGlIaSbOlJuw+Fu+PU8+3+kvSQK0fFueCKp+EDMvda9ezZWG6uN1RuxEu8UNuJxAkmzqCXyEM0MLFNYPUIadqsXIIANWAyjximO8zb+CII1hoG0b575zhyZSRkE2Xe7z8PNp4vvw7mPDwGvWhrya83QkAYJmJY2bX8w1WTEsudNii52ihjtbbYY5weQ6j9NCH0gptiCxCEiveuwcZyg20z/F8GKN1b7vvo3xcp+ybbozItiTsnYvcfcLefH4eqeGICrhGzzrNpaug++5rGTfFFyVz8dJ9xoNe317U38DfvM3o5eex7XoHKQdUA8bxb6pT7H3543NJwpdFk2l8XOnsezxfogsW53tcPpoESgEKfcCSgAL0gTmpOIh3WGpXinalT/Mlhdv4DVubHa99W/MFa+Oa9c06jCGLfVM82MiIGK1ci2msFhZprfv8KMC404DAjFmg5L9KOtaSk9Inj2ON1DJ2zxmzl1gYiBtbJmWawLG1/ZBOW9Kvaak2wzsgU2zpejlkWsuAbKuHNWTNo5t9YxN4+Lpky00EY06cH98VJsi5GYozsr017MHizyF8CqOGnlD8Cq/Mthte+rf0GsjobcWVJ3v5nRjCD+GzMtZEqwLszdfvJgWN9KMyH2/Wq2KxdMXA6qfiyVm8XJWnA1P1hkZrZ/YIcPuLmWXEJL6bO3M+Iw36Pf2l5Hrc4nYZOJpnMhe5VbvRvC0QkGubbc8oIzNJecvIUyyxHbBu6S78PvV61X1zeXSL6Nb1vDBXt9cJTtWLW/jxX/sVhZcW47tP1YzY5bUuWvgdX96o/FJ1b6i1iVH2KVj9DfipUZ/P7b3VchAN5Y/XFYMadtc7DKOJyhQRorvDDBHm6mY4JsouaXythOC/klW6fAPk74y0n9H3yKfn7VksvEClrKpqwhNZPPsjVqisqK5TqD5uuTt1DKlLBxmBeBljhv762Ic0lk5JMk8dc8zLy4JVtUY17HQF4viRSQwVvBQCp0C0sDemDVWkms5CFhHZ1m/Q6rO7GigVX5MVZ211nKW2Blhbk1fhRLCI+qYxo7H5DLnlc/pYFVkcFvJpqijYFVGIN0rMC0gbzUsQoDtkzpdL/LJ1afP4fVv+d95SdW0gxmY/UHYCWeYe8TqzmlCloStdZD5wePyvwIBp9Vxt5ex6vCNfV+fWbkdFm865WnnU3ycW137Ty/+YxOc5kdNj+2/UjGuuCxcWdeOfjdarNuC7edINxyOPXjIRTBtvftcW+5F7hygt14X62C9dBbmzIqDBXb63bnHocymW/0xIoCK0Z6dtiVJTV5GCTatVUZcxmw6oeowMqsiMYMSIkVxRo+z9OwgnAsVFyU91AScHhsf1LeCuVKrDwzxbDSFpflC1Z4rrlPLriIC/nlC1b+CH1gdfxKrP4d7quRyE72Or+vwg7BsZJ7Y/XPYrXk7bj5aJ+kmd25JjisIW0kLWPX7UvUEM4VkY19Em1t0F+t+1AcWSenianA8Qns61B8yF2A7USS4N/adSArIjQzgYw4Z+fheIGMO/cm0/0+Fd6YovsPG+oFPg+Nq4sK06i91EKsNZO/JXx8bLluLtStuaQhOMEl1/wli2HsJoJR4ljpEyseSoiykPqyn6KB1evHWJUgKFOvod2vqF/wTK/Lc7YhzppdVIMg6MkobWB1YyZasSpPrMi6M0ZIPA+b1OyuEgetLPmW0fR5YHWc32FFK1Z/tftK477SX3FfiT5mbb+vaNxXZQjf4r6aIsDxAcsBBlb9yeZYyW/Gyq3y/rKfwT8Qqy/3lfc7gwZm/VG2ZbNoGlx4JHVbJmAjifFgoPrWWv+LFgCxjUTr4miTPQ+Uew3NBvHtNyih3Ok5nxUALsBV8wFSXcI1zDMRrdx+cvf96W/IKRzVUaEw3dboxScQ5y68qD01otZclIAnie9N8kIvPs++TjdTMfGtR98X1IEVlfpC+d1RPZ5mIIFVXgaXv8fsEnm5MDl6YEXzARVJ3RJYxS6GYSVr9K8mRG6dKzyslXw4hhUj7wnjf2BFEyvjHa9Y5TvFXKWuLsMTFGPPBtaKlSRW94KVrlj9fvdV++X7qvyK+4q8DLAV9OO+4h/dV2XcV3bRcV95tXvkh1mX+0otMEZtH0fzvipzW0Dk4Os3YqUy2JKhavklrOSP+QyWH2JVfgmr/vXASv4JrOTxGYxy0gla/VHsn8CzfI2/Tlcw8WW2tFAMaHpg2NrH3Mb67xM4YKJe5S6CRmtn9lV2w2uwFG2D7B9RG9JizZEBbPE8jN1Fp8NZN8ECuGFlnRCk6ytW75AXqGAqkUm0HekcPn7v+KpoeSrXPU3IcpC8o6EtjMpiTnAlRIu76lzU6jIfOGakbZsImlgNvxA3hMQOlGFFiRV9h1W/IDc2OnE/NN9R4ljSGlYyzNMWV8doWrOvRtm6xXZlWiaaDKyKYYUTBNHmx1iVFSv9JaxqYuW2R2W5r9rvdF+Vn7+v7t94X+nX+0q+v68o91li5269rwaTe8VqFKTO7RzPv8yK0VtaNayKYaV/H6us0+VXYSV/zmfQ9q7O4/o5rKyuf3wG/zGs+n3F+RkcWHFoERGtUw5f3YgMvxv3ebZ5tCybf7oajJVlKY6rjvWLQz+cMVCc9kVp/9MXqAxjnWYVg1I4sao3FbylKvF5EP+O5BBpEa+jr9GPgSfJwvGFd2N/fOGnmjtHoRWQiGH0hbd1YZw7q7JsampMAxjgVc1OW27Ps5WMorRHvfxGrPQ7rOwTUq+fxep1Ey7YgeTyB1ZlYhWV/MBKJS0ff4TV64kVy+tGDspRSwq+fgYrTqzWFeKvwar8rvfVz2N1N8Ih/v59hQLBAhV+631l5faX+2rU1o/7ioWTA/WQBcbnc8Gq/HqsYgf6PZ/B8h1WPsX8/Gew+U//SaziU/bEqk+kdEOmJLata+Xl3GKjGYrhR/JQMbaksHxn38Vdw6f7IgFnB6ETJXMVH5iD64XHS0ljVl9qxU0/baejkyq0fM51tiyoWZWULtQOA1i4921JRMdpvdKH56ykLfZsffgHxg9rNosyVkS5gW0DweMsTw5Y9edS/d2wKj+LVa0XCh9NrESnN8iUyT6xotWkzbGyipK+xwpK2sCKfgtW+luwspkdRt1/MFZ2X8mvuK9KttJ/+33VfuV9Jf/gffWLWHH5y30GPcj157CqfxRWKKfBQMV0iNEvLNsyfcVaeqLqEuTYzKZn9i9lmG4Vf1AYKY3ZuPyvV0WFd+jSL4sHezxByD85bemPOlkjewq2k2zgGO0N3vUd/YIJHntbaFeBsMujwn/4ZAclb/hJD1mp5o5hLLD8YzkeZL7us21pGliV3x8r/dVYSWJV/hmsZGKlfyhWf9p9Vf7Y+6r+CffVv8pn8A/ECkM6j4OGh1YeRrQsBg9aBgHfp9boqieInFXl9Oky68L+FH/ZDh+snCOWI1knq1YotZXxZXXRtj8zB0tl2HwNhST2lUtfrutLccn7FYKhj4zEocWNhzKQMjY4Pa2IF56eN0wo7YemCLVfFfQ77JIaVvRurOg/D1b7vtpY/Z5YWYQYGKgPx8I5NerSP5VF6uhlasttWmxJBKnSuhU+hcNZzIghOUeuphlcokUb9DDJ9TJLTPuasRlLi4Epsl/tsQAlgaVmt/sntk7wso8+bPJTUp6timH1L0Fko/nUkgyAQwKSRkED53xs822sNlYbq/dixXaGjZhkRFs/DjdaimvOGH11GhvbZW3tBuiNRDOEpt3tpWOeNluw8vXPQm/LM/b+R6zfRZduehCC+xVqDZZj9TzFJABJjdN5zivhXJeK2kenOplSbeFJjtYekOnV9G173BurjdXG6p1YocK675ez0STMHvSxTiaV0R6a3/Zj0KOcW2hjaNx+fvY3O6+P43BvsFtWwv5Y4oIIIjhRc4odPePxNMl+yfTnF+eIWyZtB8uYtB9uGyQD6Od1XDryEsV2+cEe8OxljIH0F3/efbjHdWysNlYbq/dixSebq4PVWixGRXu04GVO46OLukK5RGYEWcQeFC800c1jzP1uzAYMPP2yuEqs6E+yhmHUdIxszLVxYTRbFR2a+0Ww6zn76MFfZGS3ZR72mObzStNahX7J+0gbMh3PAX8W6ev1qRjIB/jmG6uN1cbqrVgxoQN6FrfXUjd914WPyMaIFv5SOZZ1No+zYXMDQ1nX53XFAShEKi5Tu9KUIpn6Udkqa/r8DEXnwjvn1S8s0j3IWrSfWDFfZ0n9+mkSUDM8G3FEoxwdXv6DG5/KOpWsuh88I1yO12dHv19yJ5FurDZWG6v3YsXONPW61FxKp3JyOUOWkpIM+oraemzslL1e/Vyvjw8j/quJR8j4aZXPA/y7W3i0uTg7DvCQUFZdWLn0ha8fZtKVnVLSgepVaNrpc8TPmpwKfhZue6jLQZJ6Mo/+jG0sZQwdJ3u/QClBFDjuFuvjbqw2Vhurt2LF5jKDae0KsoNpZZ/5FZHEMZaxQVgtK//DNvIZRHPV8wMHUJODLBLwXuxW6LAFtP1SaVLVaNl1m2m15h2L/0xb+2KGgzeqUP64vpWIc6RUuGEgRlozTdaXgYTVCpfnKHh6/pd0jiWjAbc+kP5Uuq2RweHIs7HaWG2s3oYVbA4pVOBw/MMi9/OOLbxcwIrXcindTSVHEX2yQMzH3nSbdaxRTWEkoR/ucyTkJrWP1m2kfDEsToEbpA3NtbS66gtmiUE86cfoSPVFM8yn3SBRI4xbnHyGY5k0gW646oTNgQn85kBCkuU909mOkGmddt/I8wB/unFcQN1Ybaw2Vu/Fis3NIakdXCrwam5rH2vO4WBKZTgBZC6ZyzGNcw/uR+slIodTV2isJbcHPWrR5CBHn+VxiDBTFVkZ/FMIOTXDxcWY0Ga2PpOfH1eKMCn7vQF6nCxD9Iszul/RgdV0RtHIalt2MgM+R9uoJVAdG1LrQMrGamO1sXovVhAk8VBRWxOxnpf5mrgVcPq3cKiXOJXdYxWKPTYzKKz15APO0LU8U2ytKK1paODmzTHHa1lWs+Qe0TPXjJJvQubobGYk53mZxaqOCMkxOddFoca+lu5X3kxg3aTK33/RaXmwI8f16OjEQPoFvWwgVEc5bc6dG6uN1cbqjVil/ZE4FR7OqrAIqIeEen+y0yTEiYsSlkL306u3fgBGJMagYITY7QsZg8MlBrxbqlhj4yxrDnxkfBDxan+o5bZsWDMPG0m0ngf7CF/LBT3OCuahMPC3gjZTbzFGGwjPGFu/KrgV+kCoI+WWLPmwaQuHbWO1sdpYvRErdr13W/SW4r5bfJpVSXP7MA7g+klwuHsrrJqtwEQehs3rzUFvs9LTpMGFvVyZq2Q6D9+Za9NPYgE05uNgbbhhxWW/u5BhU/CZhuiasbShdaroihzF/Xz6CacAMxK8w1PIehYd0vvVL9sFbYEnCoU1Gi88kY3Vxmpj9UasZih2lfJQVyP1vqrv83lNCpliGB1aHAZjasaaGeQLcQefOSePROyZDUsyakVvOpD73cALdbg8qz74bBr2Om60CnVRvLkur9Yhr7KidC7Hm/NPuMZGANnUPhu6nDwXi6ikjtSljmuGjnDYkuXzZ2O1sdpYvQ8rzyyzmB2nwK/CxQqBt6pJKSsPNTeQqjhqa58VO2Pnw7oz/Tkj52dx59IpBg8vHtuZO9x4czQ+imdxm32xmLficVaPnK1l2hm1oqvzl0wP8sVryS3PK3GtuVXJk+bikR1mjAvv6fNaBBHq5x9WnzIOsbHaWG2s3oaV24271aQ+zGtsWWwMfvJKrKSBnPsENvN7ZU/RSM3RKAifgVeD9R/e1TwVSTa7HtVNFq0GXFQCcLAUc+Mnt6hUH2v8YrRDwzGjPA0xxSkkVkkLohu9eB72iuPqNUFCyWXGmy2B9II2q3RbwQOEjdXGamP1Xqz8WFZ3ZYydL1Ezl/NAVkMIGn2C72f7+qxUz+tjMSosD7GAe4SzxhnleDhcL+YWXZhg2Ow7GwcV/Yj+XME+YvVf8uwQzYxGfRJj/Ulifvt5GdjF361U55XE40LCOMgaInK3fjf0gRioY71O8deW1eRLeZWN1cZqY/VerDiXozItDof4kGJDzeZXyLJ9Br2RdldNVGkbgOW58I5DUlSHLWNdRMp0/Bn2g4mscy6sHK5m3tyr3WqMEnf5KiOzNmLXdOoGmHJB/rDFkJEdhIHjkQIym7E87Fe1RbDHN6fooe8rq+Q0xqJp4bix2lhtrN6LVbyxc7biRW6LOgwfrBa1ADsPaerToZ6oQql5Pei9yrmFNutS2//LroT7tJaRSDYD2bxViXKxWppZ/9/dS0kLWbPeBCfrN5soi9jKroH4kdlTPZbAWkqLfY5ASrYtxmHKysfl6tC2hIZa6oKnWoXkFA3eIdTaWG2sNlZvwsqI+RHAGetjfogqKaZDKB4PaS9t93l+qCXl2fhJnsLu9CRMi+ZqpWxGziyFa1hzedvDDTEYoch0//TZ5/TzOpbVeBLsljNLXgY5781P0sK944lRn8QQwdWFt0atl7S7vV4nNhJ5bCHqmkckw9TDmiwtXTU2VhurjdX7sDKB9Qh9jeQlDuxKpnym3RcZXTZzh7yOHSGISeta5l1eAkp4TOdxCC5BfKMYps/DIP4H29UV5KCctUhUn46uJUJwbTVs9mPAXWf7NrrAHrfHpdGgFePpgX1Mamn1Y06MHLQ5QcpjdW9GP0eUr/2ht7HaWG2s3owVO+2ew8t5LBVHc8GIrO59c9990Vyvq5mpILb9JdgcM7cnmG1zFZ0K7/HcoGEJNhhuQxqAVKI+K2NlzhY+FkRYSxQaTwQtsuTALwz/cGzMybrxaEY4zY4sl7HJJ0SVh6kf+rA0YiCh54po2TzPuQnJ05Z2Y7Wx2li9C6sjky/LytWYRVzFSTg2fIFnj/L0UuDFkA/k6WTR6Lyu2MkLK3untUokbtPC2GDHFLt6EJlDJHmcoN7ycVjm48sYZyxlOLeOctTMM8IQzNkrOJDmYwTSctZQYRatGIhFBPs+IuTsxr57Wah3PUJaiTV/9GKFO1iMNq9fDPWl/MZqY7WxehtWTLoy8GlZ+lLuBUrH5qjHxZeVfVK5LzuPiMzwWTN2B2koOL2gnbwSTyJzdqzvAkbFG674fTnbf3L1pwdXKw4LEonRAb1tDLUEwzezgMIciJjTXIeVV5eM/k/8lEMGb0Foct8nPMeMSit6gsNygCks3kdRK5QpyvISucdSQla+sdpYbazeixXz3KibSYaL15b2gs2V05plZB9MNVGjDUQGa3actCTtzd49k10tTV0ePJEA7n7BfLojZW4S2LSjvlQvbImMLG6cz87LKM9oRh3+OuyEWtGoSUfRa7/bivaHhUlKL02fILhQFwtrgwljf1xZY0ZcIeHKANcf2L4olY3Vxmpj9W6sYJU83B6cV5Zdhr4ElRusteMUN+3haJniMHyyrauDjhEQ0CRLuL9EbB/S1Bv5y0RtNy6ElzBaNe8b23as/nqCDTUIuHe7va1bVsKbpK1Zf+Bg8qaIMKKxE+nydtMfvXpl26fyU4JHF5uaNqgLzRfjn1DY+ugiQ429gOontLHaWG2s3ocVL9O5z7gUltL9ixtzLHwerK3qSA3/HZvjD2RHtzv20r5YNLN5iE1LRJqbc9kTsYANuU5Y86h1PbyyTXdB4Gkn4Glrww5Ho6Hil0GeSUIWtmE/UPfgEESzwYJf7XlFvIjWbZMPfmZHP93baMXceOwR5rUJM4yN1cZqY/VOrDh9nMmmr4FUn+pe0FjXi0wUwLNRio6jp7gS7CZAwO2VXkjIo29KC/PCxZzpvsrpTe1PBoHFFwEpsW5JLfnOxL4diJG7N5B7MM4z4dFYYaOW4cQ8ybo/IxoeH+6l2GBxcZ6W7ibm8cPiGtNwVERLta/b+1u/XreyRkS25Jo9zlk2VhurjdV7sQJLQ3WwwoKo6ibKHQiyA+SEarbQHCvPrCyxvd9/6f58VfcbZN/2y1Vu2CVS7Lr5lGoZGFiynkcvd/3d6NHIHQG4McL+yvRgjN04bz4wxvn0DgslgXtp4PFRz8NQt0I1CL4aE/xy6MMSivpAgpnCTm8Je1Y3e9xYbaw2Vm/EistgWIRVKpfWLFrjg3KuVn7YCQqPDqr4e/XZF/v5lndYg93qEzRluMdIdvXWJkhpJ6pQO5tggzlJjtbEn3guiFZPVUOT4Y6GiPtaRxsVhaV6dqM9i7iEd/0J4j/5KNNbQylt/8eGp42fbCC9Dn+Ngfhlw01AtLHaWG2s3ouVabmtbEMXs5gnDrQ+h9uj0sxg9WWtc1s1fEuTr9YPU69LrDMKM4oEpQwHwnBCVduZg7FgoV6FnpplYcllsxZdmf8RyMG+QQgnDbUKU8pgmlA0JsxmR9gNos182iSjXutSmuB7TwTpaxZZ6UKA5gor+w4ocxQDWYLTKFIqN1Ybq43VG7GaeiWbDjssFeFopEufwipSf3cZzqY+Vyp71xHhGef5wegmNAMF/jXpYhFGP7ZNKP08DmvJos4Ul3WO4tV8wyRCOOxHZHO/n0af12u9Dii8pR2Fx9MDvH0eIvc+kBu/feAlkSeEud+HoHZaXo6akiD5LxrKBarnRz/Z+24SjpB2TcMBcWO1sdpYvQ2rsIHvVRimTBFHiqy5GLFk01Ye32ljsrca0pWXrnuExum43AYsp8NsbQb7q9zW2uzztBveuK1hjKFIXqHYg6Thviqe9Ihh1l4q919vvtfnRH6XGEHh3r9AQFITBq+2zv6ojGTIHIgfNMyl5xxu4WnlMhdqVOY+64tkdO3GamO1sXobVvS//u//QA4PzAsbVo982LCHcnroGKlESmLQ5wvHpE2LDb0JFVVMkG0hrSXg8FbF/eovhS2GMSs8ICT3BtPgy9fq4rYUQl4DG1U/Bm2xP83ibU3DGWN0fJsFMILu1pGSQk9vaglcNAeitvU41u3T+roKNzwYPvtL+nv5yUG+sLHaWG2s3oeV+c/r3Wf2sy81Iy1W9eE/genT+xRpKYYNs2bEVpqLXh+1Wer092kvY2hMP3x8h7Eyj+gMeZDYSrRUMcW3oiO6emz4jXQ0Pz2C8giXmKQ2DsMcFKntdZ6odVsMhFYzMA5EAlm3RtQv2i1TdRG7Nh1yKttcYBc/bKw2VhurN2KFfoS8GswGS/V18uK4Ol240hgfc22NnT/fIRvi8nA1VH8UGGsDw0ZNWCCh1FKtRxv2FB5TzfZgccGQgd5kONn7Bp0HYQ8za6ta7aB2ytSvNDvTrD99XnftUzHXQfwfUbaSbd1hdK05o8vjZbazWHxHE88WT3aE0yNukI3Vxmpj9U6sjlsFWuxywKGGV7ptGP0llcOk3rbrFbt95hzGcR6cR0Iyox2vGoNXbTXdGJEZlUyoSXNF/UU3NWNpM4lMZuTrfObQYOyjLkUprECql9O2Mh8XVkZG4yNNxNORtAzd95LgllyVsdi2ehVvDjtr2VhtrDZWb8XK+PP11MwzLBFYRsF+cIdnGZO3e6HKSPiQSUgrw+veBeVsJtGfr58EMqVz9CnCWD/EmbZdJ+7cqlMClSejMdGO8URn1/YIm7Fjj36C908/2UR8eGtDllkcrwpLfON82KPCWbnhggY6Ww7crD4kl/TxGAE3hPuKfWO1sdpYvRcr40LYCYV4MmVH3j9Fi0FJkvoR7zDk2hJdSBkVaQq0XbLY7qbGzm/SwmHaexmZ5jjtXKdZF5VHPq3/ykQwLXncPpUbGistQoAiRReTt6lJEyN7MHCcZxxUkm4b0bJ5JiFrR1cCTxf/t2AVrRurjdXG6r1YYe35uj/j2OxJaJI7ZQnBugFIU/oYGgI7/3Q4tJmRK54O7XXLfXx89En39boTr5jAm6R5s/9+JsdKyZCP9F3kMQHjsaKjMeJ9WdtHpOP61l/+ul/FM4hi8laZUtApM5jnP1gjIYZIAYQIT8ZaecHGrFVo1jdWG6uN1TuxAtm+/8YNTaO7bVF5aoqilakyI6l12t1PW5t0j/ekbJy3yHFdMEjs2DHKuQxfcyl25HbEdNuCcBvmzZFXK/5UCc35SFvLCMf2+dnXtHDT6XhBAqq3Z2p7Rc1fUymjcFZ9pCJJ2N1b1TuHB6MfLi+5UYieZ0dqY7Wx2li9FyuwvS5jmsF53uMN9WHQmh1InqRZB6eVNZWn5HxoBj2f7TYq7XH6o8HbnNjndz7bGqutUr78ieUyjUbFSM4IiqynFX3+hC+vy2i20lfP53GBrdFuGiYYX972cWVHPq6Wxfw6HnGpZe8DOetlkUplY7Wx2li9GSsxT9I+NWKGbXfh5Si0QPPIHVpBnC0AJ2LIjfKtwwTCbiyV+xKcjhMk/T5VBlM3TFOzX1F5MbPP9bMnVlPAFD9yov/L+G8fH+Ct5Jn1xwgfJwYCcWbJRu2PBvJlMDRvEZ4D6avmzz4KfwC6YGpjtbHaWL0RKzanndYP2QFrvSrtc3yl2XPIVqNkak/yanktWVlHIIf2pSbX67o+Qg/JlgnJdjDgRe3zLvWLDRiVyeC1aTX6Euk3uAyPYDkGmdIBg8Qj0mhdUy7mIH2cDYLyxku4ZL6Bp4pwPiiWlsi4A1o6Pb5e5j19zUfDxmpjtbF6K1Y80tCgDzpPadpaWESsk9/KDsl253fzPUraG2/Tq1AXNMIZ2mn4vleH9i31771s9q20VIlahsWgA2eqSBnO1tWcJRiCgP5+5/WBDb9w0klnDBtkNS4v1AFyL+FuSzhbmQvkOcIlLBKLd9w0/W0++nNJeGXrbqw2Vhurt2Hl1l5k2kLYrR5Hxc5cM6uLIWPSbBfQD6s5KebfdSPlkc96wjgCIiWimZQWuqf+H1jqaLlfjUdrYJj11OSzhcHgSF4s4fzVkP/KFwwSBb1Tou/XxyLVdjINrpYaAEdBfniNF+MxY7G0hlq3V6FodqRRj3sKbaw2VhurN2IF6nv0FVGfgblfGWfUpmwx6rfpuer+qcMnmi3YoxVzmJ9C80IZ5UFmnBpKTkIH9EJQhxErMMfLLPZkmtvPDTpWCDKtJ9uqmT+7WX1KybOwXqRPeFk9+mmV1p7l6HOKz4ZrDIQ9wDYsxwgaVB1qrI3Vxmpj9V6sJvlew+9Gj3rWWkHT8orRoRnm98vSOuIaGdNhRYPgHI6FVsWFsGBcFrewV9tiPE+4sgbtwq1PvT9SqayO0f51Be0NCobjOrBmLm4LnXuOw6aeZg5lvzznhayRW2Jn0U+Bn2SWZSBGTmvWTwFSkgN5TP8bq43Vxup9WPFsLcweYzH5IpthoI4pV5aJlJcpUm8Ub5YWO1n8OlqjC70NoWNm2WU7c7VeJwbVnI8fEdXRIIgojsikjdjbA0QMDbWnXzX6Ub+hpJkGAs9sIBJqTfmZItRHaZqAE760KXoIwtxKDNlYbaw2Vm/DiiMGMXkP1uHEgOt5YmprEeER/x2QJiTuGYasMVM8WbfAt/nVfcXSsBmHZJmYW3rt0Z8j7oQfhtajHpV45pizD9i1bq9T0EwZdF7fm9PBNHPDw5mDZLCiLULsS2L2DcUxkErTWSOQwiW38wl9gLd/yVw6NlYbq43Vm7HyM2shEMJv+BiRUFFP63VKarNpdi7cOb/FAUIkNBfcMrqv3ukcVaLFyY6NxIYOaC99TcvpfH9Dp3jmdQeoNARJMoUE3Hq06vp0mf78Q0QwzPY1hU44kCVu0+JFy5lTpD6QFkhdOZASglJ3IFopdhurjdXG6n1Y8aCjiS9fx46bGZLidD1ysXrkjg6yGQ5AiD+0EGr3DNNoR6SjYHPd5OIpsbJbm62eGWz7agKDdWI22i6cNxoRSteRaquhU7CLZQFtxbM3Qg9KwrN/yq7bxFEOd+aI9NhhWIaBoFRleP5zy2zvIoOJp2b1Lyt1b2O1sdpYvQUrLqmH5KUryTaPGl7kIkoTE9lkx7YLdt+EjbEPHEBkbWf6BVi24qQ8lI5pGb0IvmGhU9mYH2HrjH4ENJU3yP71RPc0dVJpfrikRQ4rHaeEyOSYWXiSsuun6nixCaa8a4t9TYU61EO6891ss3I+DiIwbmO1sdpYvRUr83cPhwp5+HnN5iNZxWjzPf6AlYtGxnnBi1pyiy7KOF3m1rANpFRn09KlnfuMNsJaTnPAwK/Uw9RIDfM6gj3S6SLr2KnyHl7UeQgfhZTJzZXFJygGYmlF5BuBHbZ69hV2JZmq9CFwKtNqQ71M3lhtrDZWb8SKYxtvREb7EXhoKQEnAqQrxcwN43k5L6TFinjkRpk6grBAHH1OWhsIOmf0aKXKTECDkWvJlmgvNDtSx3Xavl8/hBWK6bQ/XScmC212WNrMNbLtACEXr1u5W9k8F4HSDQJcvc4jBjJ4LcM2m57aqo3Vxmpj9W6sJEChWS3Kk6Bm5vWYGo+KmLDXq56H++D4CQ2rHl6eDrIEYKS9IaURjj8N3CnRAl0dQdgjIuTx9fnZ/3UdF8n6DqOBGp6wX2Tg2Wel2e79OpD+fhjIUVF5mvn0YYwSpYeboh/0yV8Z/91Ybaw2Vu/DiudAaQx3nJN3JuamoD8CwEW1wq+xfnk7t1tNNqukQY88dZxEkaBdBkFNPT/DNh3VQmU1puQ+r+NpUEtov8claVND+ZjmB3zV8yYf5tU6knRdE6HT25912AlFORr/lS+0343Vxmpj9SaseNmDG9zWp4GFeCGmd58Oj6OvNvsX6mmx5g+fteKI1piNVx4NinDIXz0y6KG5hO6J4Y8ocl3f+g9fr1fmo2md87RmtNkgx5GEvSyPn3onVZkee5lYNttA4BPEUJnCg9FtXOEMSxZSVOLrMpbQbN8Jfu7GamO1sXofVs5+TTflQY+P6Fh3QcWy0WVKhxnT4DswM4Q74tgWi703dja9tmUJ6pDp9KZQzTgN26BTA0VvLM3FVEr9mlxYqt93LX6OpLGsLakERW+05k5eeUrZR+8jPRLxmmpD69cDjxcM5GJXPxhFbVj3pN6KOEr1uCT9Ibex2lhtrN6LFc8dPtGvOqVoDWCpSZBnX/5rIOAyDHFGyIcb14sNiY2Sn3WdpCN+HJ4fLF3KDb+OPnzsz+Ostv1W4U4BPzMFrbbP05wr/WGPP3OtKYge6+UZ7YayOFaggdpL4fP68O9Xp9uZ6ECXvT2Z63xaqtOysdpYbazeixW771eUkzPvOk0n3AyMy1UvCu4Etu76UEBmw0JXxsqb59Q70rOH4olkXoowDCP/L1qbON8TE/s5XsUmGoB1IYSaY+aepmK6BDEGNcQOTbIaMI7lvTaTkl7XxZGwpi5oQJP49kyk8Hrkcf6egGTsOy1lY7Wx2li9GavwQlVaUn0WZ8CGvsFxflh4tFDIlHAY1KVmjlMmEWNdcxYvREGhjW+qJVnPr+1XzEvivs/jo9eHbp048rUt+bFihg9LHX7u6tFY4tdFL2Wes4Vn4AeZsPPuP4EZmLtCG5dWrRLuczy8N9rk3dGjg6O5fVg2VhurjdV7sUJIR6w2yalr09AQGm7LtrZTaNHUxH6aGv/U5ngP/sl3lAyOlVku8pjm5dEp0OaZQv23D8+21qUmjMoQ9NvqB/QfsVeeNDck5yYiGwRtCLvHlC82kPMkKBhaZEOapMB7LmgSe8SQaMorh+/sGMvGamO1sXozVgepuoDa1ZHeebCpTvrEVyuZs2ozpoZpl3ziNN/VgmAfNs7tbeOq0T/lqc6UxcA5aWBktR/IusYFAyeuz74ULdXghohtQzY/S0jE223bgam9IgrdJBBsc7XM7jAt8S74c/TKGYG0vbK9badQm0T31yKzcVxoqXAWd8gy7QEhbnqP64qHgW0PbKw2Vhurt2E1Xf+i0nTvQQ/y6TOuDayEw870lIiMNKNUwLgHaR9NvFkQjccnG3bUt253wVb+2cYewMrpfJj4SGwGhuDbIMVozSCxeLtUvzoYjimfwo8jzcmI6lrK6pQ9xdNMbVKvJsq0gZiOdOnjclnttzdWG6uN1XuwYhlceyd0ic/d2G7LqoycXkHIAXIsVjE2/hznVbFtdrvCcVj7ZHmpHDN9tgAMxgu6zZrkEQ4haG4fplkOeecVBonHR0fu1sapM5Log8oz8EisLnUdA9rAymM5THUsqvtL6lgpR02LZKQ+zWP/Udm9peOWUu+DbKw2VhurN2JlLC63GTQtYnHv+z5h53TIkYrB2XtVkwVRmdJtzPQVRjbuzhP41ti3E06uPXs5aiaKfbYufKQFkK1acXJEQ5FkTwk7MzKPWHOAvc5+7lAniKy2QGzX0q8N2+ute8Jw4bEhcnELfX9sDDKb8rpaBi4CqQAaxk5ni/YtmTxqY7Wx2li9GascM1nWmGVM92GYsxdHKxRYtGyFYgq05qMkmv5k6FPg5eZbZhYxqW8hMhLLrbZfadjhI9S69xBjppp7uruqDDoaea0MF7F+GftjRyVsN7w5GqtzX5mTRXI3N0i0xkob/V2JazbMEomWBMrRsj2cG2KT/Lx4w1djY7Wx2li9CSvsdPmGXDNCB3gYGX0x+5cexxgmze4JPXa/RtQifKF7NRemXuVhiGOvBmekIeIR/3OnCw2vLvfeb9ZLEPgZGgSZ6jjX4bc0hnn+aU+hRpN4QpR9kH4I+MT2iR1IuUd1Dse6Ke5eOOKx+cl/84cVMnLNksifGGpWahurjdXG6r1YsfvS2xQoRz3tkC239Xx2TjOa5MuKOeOvXI9QQtpU7rkdt9wmI2IZlvkdqdcNWzD0aGMvzmM0KA7UlgtjUkqxIlNiZ5HGlevvwYcgcvtONx8vaK0KBf+tejRIBF57yblcXv+HiKs3Q+XkoIj3VotiIFQQxJsPsY3Vxmpj9V6sGBP26xZkjV0uAZdlXo83YiSvptV8aq8lis2Fkl+8sdHnVetltsnHx8T+6r95nYfeVk06GFHulpX60YLL6y4b/s6iM5tNmwV+oBka71PiyXP32b/1BxSFvlxTx+SeYmqZRckZEcrcJBBcZOmpjCfbAVtYPEgkiLkbq43VxuqdWPnOlpz1oLS8ecQOeUuilTVnsXhzUefzoQyrabO/MM95ZFj3N2d3IHt9EtFZq8rDg8KeEmKVITKwJWlvJdu9S2CRqM/FIrF9iK25Wu4I98Al70jB5YzvB/lNI28ETVYKIwsHTtyIdmmz8mjQukd1x+tMPhttrDZWG6v3YoUewWFI5cZYOi7P2o2XilLTGV5LXVWaNCb+TIJ1QZCYohJbZfU4mzgmeZQll00Wkx330s/Oq/JoiMS6dygYvOtpLvlqR0GUG93SvleQZphHdFnYnxysgTzR8PfIvBDvSljjxmSpYkrxjdXGamP1Vqywo1811QAyzZo1e5Qae2Fj2tUFIIkVb5aUWOvaJN2MrUr35yfMdKzhGs4+1seNjEYZFmZe7ronYZExiUdlKDO2jUPbKdZCoKP2n71eP9k+4rFaW6Tvq8bfzPwY6+igvcwnGnmEUdCNvU9ixhf9mQFm7sZqY7WxeitWUCHeaC5Q+f7P9HpOgNaQV1lnzJizw8gigxq9oVC4toZNRI7XjDZoniLH5J2W+C3fExyNaf2VSAW+9ovt1VfKffF/mKa86Ui11lJUfzAiHa7W457IB5LI6n6fS27wjO9Xs3DHjdXGamP1TqyMjNpexkjV0UBc6jgty5o2a0+KuZ+WWAuJSdSYYChL232bVf43PhjNhNZmFNB8jGi0JCS9gQYlIzgdI4NjNnczCRcRH+1+wR3o+ps57bzSamMJAacyXe0HJXd1zY8ox/ymzLW3DaQv/nsdrcd1bKw2Vhur92LF2NBSMpaXe4jR0zXQnbP4uaZ+Fn3j/yhWp+7lCpnSeRVYW7B5zjczyohUtRhPhJtlxThcLyL1LB4CMt0LF1ez1i/HTZVPbC6iH+zs2GUxrsuFb3F6OpNDZl3tLyN63BP2Hvf9WYDUSWCVbKw2Vhurd2KF6es8PlBqtebN069YaPK19PvS7lHXZQYQerQd/f62tjL3fX4L+XBbwe+24jinWJnSy6FJ0iWnTEcBaQY+r77270+PYQ90XR99phePpSSa12+5oNi/G0ar8f32NfUjl/r369Vu6UhhZQ5l08ZqY7WxeitWnod9HKdYXSpRZC6xHU8XneSjrt+K13Ps8N8q7bwutCsk3AitA3pyPUBWa245PURIrmqkdIZeuh4RMbt6J6o1PWFdCCmmGa1mDJFJQME0qy5bH7t+nHP1LHW/DGQQ4qhklJHz35ol6x6xo7mx2lhtrN6KFYijahJDE+9Yuk+6XCwLTJY1zme0TEfGR9RvMKzoBeH5cblpzjgj309jl0HKa+FcJGRMjy06Cvrvcg4yDA+BFNHHx9/ITXOig1LMjxFPkv4+aL5U+uKJz776Xtxe5VlVR5OXzVasyXGe/a9GjAdtrDZWG6v3YsWpwwbB4bgOo8PehZ7LY4o4sGhE/qCZYTtxDSEbfJwWSDvmZNK54QbOV19Qo8ibzJHc9qOvi3MZaWTJxAXZ15zN+vXw39IhYhrcXzhU9MeI3p+3PBPbCi2X3HIkw0N6mDX692Mg/WTPW1r4+RiFb2O1sdpYvRGr4IdpLEGRItTBwhJ0JFZTEPjFCWuxEyepZJxZjdo+GZqAwzScmn5gUXq2sPtRaDthIPhy067pLKFrb0HL2AV0iZKP426K7beOFN2hHlCa3BOKwFgoyqtpM++1eA6RkoqkYEB0KBvmXqDeLxtIbbYUZz8P0o3Vxmpj9V6s6H/93/9hb9escapsBhf3/VNfnAa9lmLL36n/MkVLy4Yd4QSwoK2XZmO0zlzsuTEo4r5eyGhUtDBOrw9Zv+fFfvcAMW7IgQUtuULysAJzjaLNKXoM5BNuiu7BP4hsUY4ugZKaenYCYxcKhvPyNq/mA4qGpHxjtbHaWL0JK5w4zVPET2G3Wk+cmQsVPXfHpEuSwiZL4pgBZcjA4OM6v7mFq1kU0krDsA29MGb17xy9niSMB55lzsJPhwnJ+Vgot+LI2PrIXvzwfcQyDzGDRmhs4vlAzl6WXiZKsLLTXBtx/n36D2G5Oab5SekYCJ0fH+lFS1lOx3tvrDZWG6s3YhWRQSo2EpMOqblnYVKMb4+WqqupDbKYLcNivh/tPA81xwsxp2eZCnItSw6aj8Qzaev1gQSzNjITl44m0eT9Iv+nV6EmAYfQ+56m1laL8jI/J/HfBiK48AcufEDKM2HXo7bl+YDqVShdvvFpA2kZkCslOs0bq43VxuqNWGFJqLaHx5GuQ5M4214WoJhbZDbBJwPWzUuRZY0qtBdvIs++q6djx7wdoWkyPce8wi2IO8PgLftseRhMRq8veNVcU6vM3FrMtupstMX366Fg8l1G2JqZfRBlf5j4K+kO7eS+0qbr/Mh9xvU8AW01c8SN1cZqY/VGrHg4K9t0SovvBFLEYKJqWRXugs8Z/iM1NT22w7dYI64k3eD16+SLzGzY4lMmDBKPWBub88Scta3ohXGitERKM20tQFqZKOMotDhaRFpstdQgWxBjlb8WrcYrbth99DWz70pGsshIdOMymMEbq43VxuptWHEKf0infYSOL8DgR9ah8fklkoPYJnYgZRO7ICttYeInnT8VmNMbTDmK3kUhVSykCBxWE2lz6sODSturUOrr4JjXbWU+31NcDyXzrVykFOtvb4i47Rn8EXspax1YGXpRf5d29zGe12F1cvjFcnQ9/KERKq2N1cZqY/VerNAacFvCCI9lyu4ibAfxjbOa9aCFGqb98/0JpK6Pj/KFFjbUjW7kzMn6F5k8jrHiTV9naJ3ANHNPeytHK0iufUGLDOvKHh4ZBq5clisa/8yJH/8lGamzhmw/k2ZDJapkbJdpvENy46lyffzNjHnWjc/YHlSziLXTko3Vxmpj9WassgGpLHMbLefXKO7Y47Cb7/zR3RqRiYZ8tv9iSShJdBsq8JjpxY4yvejD+8YHhoqx3uDG9lLXPAh7FVpt39FnY9WY160HW9aB2QpfBovDzHSEyxB2jliO/oZGaREn6/WBKOl5fsvdReXxjBCP4U1dqdnDbqw2Vhur92IVtPwo6nwLjzx9mmKrrlmWWXULfOSR9RnPNsb6dNh4io/SWGdWm/a1pw15J1MGj1VX2oajgHIRThLmJ93uXulC9yQtWhu0yCXNMpG9ySlJ9edA3+14OJqyGEULMoo1L6ClQmF796dHDKQ221OkIWdK7i0P4ojHu22sNlYbq7dixS7bCXqDjGALXWlp7tza53i0M+Wu14ctJXGKd5SX46UPEzIUu+58KurHH8z9sDr06jdwVE/Nvt18+jqltGWdS1M3KaWsCUgxu3s/liR//JQwWTgSri62GDEi6K1OG3mjmTiUOoLcexTO2T28ajdWG6uN1duw4tm6DMiIlRcWLc8v+xuYmif20rIFu0znSc4It/l4zQgjSj2lEVYhQtDMiSwZnoGy0/sCzdmz463KeM8IpF3WurG3F13h/ClHpqz3bmmWwX161yDCSRkZSLwam7Hn07Jl1YYvWtlYbaw2Vu/FitP7XcfcKZWmcCjM7E2f3V7HcdbzEpcgWXl6OEMsz5vLAtNqoMNl7PAFobWGvSFlIwMnZm7559++QfR0v6rXqn3drsproSvT+XAuwj1WW+KnZPt7+UQhjnFgIHf7Cdm119UPgZrUyCODq9JfUe0pwVx47A5UiKM2VhurjdV7sQrzCPY46DHIsXnmh4NVV6sV2dYVy9raD5OuzzQ6puw+Y7OoM+ykDLZ/DFjMHj+knGrqA1BKXjcMEo8TJeJ1feA77WXmOyTuKyYy3TBEJ8vXdQohIvCjYIpungykdl3JLkakHh3Ux1IOPk4z0fdcb9V8EMVzys2k7XFh2gnZWG2sNlbvxYp9lMI51Y5+Y8qKBGIjZI0dxzefXNHmRBNBYo6PGCKSaJRaZefepsvULpwqgVF5+he2+oV1obTrutwgsZ9cPwoKzBuaAz8rHkt069Yyx4r6sNMWO4TywJFsL4DSy6J6THc/2nGG5dh5XIyYRvF8DqtCkSdk6CPukbLV0kbQ0sZqY7Wxeh9WTGXYOmSxt65OWZvN68fxYRS3CN45DtiDye1tWOIhmoyHgY5O58O6UNKJdV4VI6e1u6N+fbu8gereQKC99kMUlKhc0h6fh5o8AoI4vhPZHiIjAUl4tRTqsN9ACgaJMQqc0HlAnWku1LZtAPdWU8TbE6PFk4qXynljtbHaWL0NK/OUWMIUl1Wu7erfoHscSDQLs5vhXM8whCc7jG2bifDDZTroarVUluxHeO06IzFcZo41c5/XqZzNuWUdslL9sQMPRjM0e+Kb7VsOT6Aqk1brjdFoMdgFQ7LjjUbK6QPBAyKYuOaofZRaO5SgqBk/j8a1SZbL9ELcWG2sNlZvxArz42ij+r/HqdwoMI/zb+rOp71ExEpyzpmQF9FR0Kc0D4yxch4NWs4yjh9BIL6utu03vPV5Xr34TFsM14mbcAgbknyeH2ZLOGZrWgwWy7Kz6LayoZPq1WcNQ0OYxvafXIgPKa4PpWjHxLU1ZTzmeHLy/3pJcmeRN1Ybq43Vu7Hip6VyUkvR0oRPIBioNq+T7/knJcM28wEf4n1MCmTTIJXVDcdkBG3GOtIQKHm4qxExlG01bmL1fp6VInEtjuhthfP4sGdAy4htjUZpLK3pYUONFXoNgi2TceBQP1Pu5xG7GZhZp+FrHBrxcBi0bQr4DqKRj6XEcn2whTdWG6uN1buw4mTNW4/TCjyb1xFbWE3DrUbnp1ymGnDqJC4Pn8ZCur/o82WRh7HMXT0uSsQEuTbIzbvIqkdBxwNcOE1teAT9BFKxp2gYnbbKbZL2Y2DE9RHgr/cRYJ1hzVqkDBVrw6JaFm19kdwP2lChhiDe9gLArNVI47b28HkWFOAvTi9XCcgoRKMbq43VxuqtWKERuTjO+34dvCwQlGa01Nzt18HmCPNnmeGHWJf2b9w/AQ2ujyiPCLrmpcAzn9M+4/IJhZQsz42xWRebeBl4JIpWLn9g8FAMeLPWO7iDy0+LRZj1Guw0+0AIN0VLYw612LZCc+9w+PjQUS/8EJYdGAiHwYXjVTdWG6uN1XuxMrcGDkGQKR7RW+xQ2ZhDJB0mFxnbahzVZEkImScFneeJ4vN+0RQx9YPVx/6cFZxuiwEV5HHZLNuGRFvTYnWJKNP03OjL7MP8+VN0zuEXqzbH+wNB0GKQ6o+tBoNEtiECHQsRKZyiJklvfQl/MjNEgzdrP512t7x+LusiNyvbWG2sNlZvxKr+1//nv8S8zs6j0HqdNCQ7xsGFlpFslrUtfFKicP8KRaIY0JTpiZWcvTsERf030pRZ6X41M8Y5CRpPNX4reXi2Jok2X28/8f8q/oCyUei+777Qrva2FnMLLYGNyWiyBOPEfiIHzM9YU5WuQ6jUD8vqk7saf8XsW01Y2UEnvLfFlqgV2O50DdMi343cWG2sNlbvwsrs38EQq0b8v+txeKAiJb9eZ81WcqHrO/wUTDXj0Vtvkk/vgLpbffG2AmfXo0/sHalXvya9tkzLHzUNuOpg3WKtnp7SMd97dgaZJFwqYtWqvJoTTtzZB1fKGqI+l7/u++gHswdU6jz9uaGh4BSnkLj3PfGg6FmLt7/VxZcRdVuopCTS0zZWG6uN1VuxIreNAPG/j5WcPjtgikxXm+Ndi1j0zhQ0Gm439oW3XZG4jczXu+S8OLqsrxe6HvC9x9s29UpPSr5/C+MeSXMwI3IAynSyFttrPHBJ+b7FebHTPdrK6fuF/EXYuZrlWG5MFpe2J++uGHdWZGrKPRLSlteRZXRZqPftXWGJ2I6N1cZqY/U2rFBttb5avJcDWOklI3mxjGYEJtoaofc+JB0cNofO59fzhLO9rg7TSW87L2SNNbbDWCGZAZHuharWaLWlrJ1xohYZtjXN8fs1sW3Im8ID284Wl/yTT5v+PbDR3jkbDsqLS1AORBa0FhMMyMzRMEagZct+8MZqY7WxeitWGFWv3hCyylVvKUsuUJmWFFG8+QK6+n6+lZM5Uw7H6PSJOBD6mrT6XoXCtOeqF4W8M9hljTP+dT4ipqe1t2zz+eCjsoeA/bTXpf0ovYS2ctS8gdDW7UgdS5S3DuNqjmXw2FwEsW05+fC99wawRh44pKaw0+7XlzdWG6uN1ZuxglXzYQeAfzPr4rWqsrpEWz2m7mzqlP8QKE5/aBnpPMbOhR7A0Edp2pFC1lieQRg2Ez8n1jhvHrEcHnmmgxuSUzV7l5ciQhI9DtsFdKTacgmfsR45rsU6OhKEJO2ol/MJylx/7oEwh78bq43VxuqdWNF//H//7WD4CuZLJ+l+pHQgWoezk7HEuqZ/hQ79pg0iOgGEJI/WZ1+YT3v3dK66Y12ty7FSXTkiq6c9GJkGkh+x1rPS7Rfjvl9HPftf3zVcvIHcHj8Rdi1V2vJbzsjIzLZQR3RqKDO+R0uDbBOz2TNwY7Wx2li9DysIDUsb2qLccvOmgTHUIrVaFltVHYD6C2SWr80Zq7adBnzU3CR0MT91nq6PP20ovCxUSndFXr01Jo1kuJHFU8VSYVWaIwxmmh8FyiwXZ/lAnArnUkzVMcac7M3UItTtOlLZVIaGHpRdD2rbWG2sNlZvxIr+5//+f/v/gdpfRjVJwRQLoiylTojm1t4goRXbmKNhl5O2FcUc5u9mttBoch5nTaW4uHe9lLSv5ly4ckrJgwJLg6HPAyMO6aa4ievLuwkf9/0TvujrdhkJHbTqJ9lpa/R4NJWw/UcYkTxCKGlkt90dt/s+j6PZs2djtbHaWL0LK4ZyUvug7nThoYf7vdFo5x7ZUq4GCzbrUw7NkfuQgVmv96tehzlgYGftft1u3uxCJJnpQ77Jl8tzGT45UVeOaTiLRh5lcB9D/+Z5nmTdBKyiW0ubL3qGtZVHoG7J5Fp9mvbzyFOzqCLLMmmvT7RvjnNjtbHaWL0Xq37m9TwvLyQ5HFTXBsXkq81v+jzY8iuXmM99Nbrb69Wnw3rW4xI7F7OVqPKSKvo1jHv2N/I7tDhL2BOD4/3dY0Msrlru108d3fMj9VZcz+vK7DZyqfpyzst0L0/Q0PTIgbRohPhMj6ij9gn9wvlha+2N1cZqY/VWrIz8XsE0A6lj8NHKd5v6HHhROEfPiEMKcXjap0ovPvs79nMvwX/Dr10nLCxekCE9D+G5GpUeR5SyGjHKYlsRTq93LxL1vL5hwy9V5kbzdXbsjQV0++FAxkTvzq0zqC0QHklI0g+Cef36+KYm5NpYbaw2Vu/FyiOsb5AoTlMhqUx31jU9qJRnLRpq7dGVHCd0f3528D/ObzYFxzDcjqs/R/rU3bAFSDOOjdLEZwym0gwjGlJwjWIYa+wX+Ljnt7+Zl4Y3dEO1gI4DxJmt3Es60vcDia7EMhBdQ5LIB9Lfq8/r6hHigeDGamO1sXobVi6QZJOJH7Wet8u2v6w9nasRmvE89pqpnTVex70jdWI6FJVhhUFWUOKfWOuWYst1ASgjfjrIJbxYXGj42fsrApBe66IpcV4fFVTaNNjn4R+GJMh+Cuiz9umdnpWnGxamzzWX7/6MKrhf0V6FfnyYglyXy7ax2lhtrN6GlZWCHAYRffbtB2rthQqt0kLd8nSdJ3N1iVDksHDuJ0d9Na6mGXBxpntKDDfo/s3jhKmzrXIzBIPzvaqFl/XXu5OZhMWrG93bVI4m7XFdfd5tRmBxtSSt1v19IMdhtvY3BhL3xNgF4O+hmQNxb7PWzOnxChqIXwkHd2O1sdpYvRErc3t3I2eoh86zUkXIj+3nDVx8UpyENYkYC7ddxdwPDQDZlpttlFkD05LM+pHgj6PhJGF4nRbyA895cbPFpXu6WDjLyFYznTfItALrQng/i6e46bI1STQkV3hY1YMvvZuMgayFc/1acrtu3FbmvVoul51hyYFEM2VjtbHaWL0VK06Pruij9hM86gUXsfs17B4MGv5Km0iT6D639zMiqmhDBEEWQT1WTepcdIs7B7rZGOMhIMY3ww6bzdyecVbTLT98N/x43IzoiohHPorZX3j/c3iV0Wjxht6q8HXCV/++B9lNSAo/2cJjIHairSNV6MAl9/QOz4Z8dpE3VhurjdWbsOKycFqT1ap9IW2CQ/GupBtLCC1M15Hx07/xuomsaZoON5LycZ1RsSCwVpvp3UkDeF2ntWbF8mDJfCpy+mXO8hF9hxtyKyDVf2ls/S1klTWMe47F/KqPWtmtKlARS/nhn/DRFzjvwHmjmJ2r5dD6JZ8ethurjdXG6n1YmdeWROMyiflmAYjQ1yKvTKbWhJQeS2gcoC81a18zN3FDQPv1ZvZjJGPLzpwr8B3JArLP0H2OP1JOlSWjBz2a8atzcBG40RqfMAPrR0ljs9iXjPhs0XTYUF6+wLm7ZUdrbumYTwKKVkiE5pID6qFpxjMJOUITOxynle3GamO1sXojVhJsUy86oQwasmkEKDpdPuowXpI48MvoXJK539ubLmpJ4cCTwm/Vs63DKzr6HN4L4dMCP4xpJkNubiaJNsj+o1ftUzSfFsxoybdpwm9dW/e6XtKx0446gh3NZhGN2EjzLplVmzV4X+bDeaOcoWUP0ZOL0Hmqy8vGamO1sXovVjNII3ThC8EWp3HYWrhhIsQ/RQd3o1nkoYmzTcYdCYpjly7YtDRmc8z9JZVO5OJMNQ7GUQ2vRQvulhfmGOta9sMDsHNBnyQO26f0p0dcABuIPqps00bVA/t5TTJgUv0eYRsIgpLOo4Pass3B09nDoZCHBcfGamO1sXoHVhwT14gOKmkBFlGriogNsyTksMiBd3OfDgkCoo/EWccAeKoeR2VY0jp62Vsb0iSnlxx4jNi+n7nnm9Fqe2Fe74t5KY3KNFpNN9Ux3aa8299ryYytvv71J48/V5r7GdqQK923s+k++j/cNDrPULMrE6LNPM7GamO1sXobVuxL0WW0eVBOFzAsQWu42htUtxExOlJkIbHPZocOSsfoZK5RHKPrmWcQe3WIPENOhnjboY8ITw8iI+aaD7QZienST1j4cyUMGMv04XEHxebOFZxePIftYjpl1q4Hal2LLiJZaSEZ0TG3N53XsrHaWG2s3olVUupFH+IiHv/FJFf7WA72bbm7YNatR0yHTiLJEJ4wY16IYFQWO4x1bg5lo72/M97Qx0Vehtns362vX8/r9BTJajxgnaviqWuSZPtSLo7HlYgRyRyTDQQX3uOU7vs+zo9qjJJIIpmXYfjqayR50MZqY7WxejNWB/xs2I0lNEN9dA2JxfvwjfDFg0Aza1L7WvOoGg75PlqfYssYD3+ZKp/OOM/OZo4QgiKskyF31IKIRysjKQiwcfq5L0g1i8bFhTX8EtnPX7LrO0tWs4U+jC/XFOM44qzXgTi/jp9cXLJuzsZqY7WxeidWbU7Ew2aeHiPxBbFVqOgO9LqvWh4GqthZT4a94YRjuEh4oSir92u1taiYl/7gb5hDmO20tbtU57E5/axXp+FWodOT/+EMpHH08cDSVRO1FK5Wr1pj1dbffMv09h+Qt3z+SGS+2aMvIsM3VhurjdXbsKL/+D//PdwFRUfXc9ECzNLO+PKukZTzPFvWeIObnxP7mCAlpQSSXtEl9dZkq2JkZlBu13V02t365N6nXLjZw3CDPUMEsgA2hdNiei0xu9PiK1aeR5lreJldC1iOuTpcWjvcZCeYIWNlTm74mI8pe8j05b3nIW2sNlYbqzdhFVwIlki4X8SIYb3DTgm5b9A1+or2PPuk+Lpf1h71rFeSXHwSR/dRp8Op5sbe8JowE+ixjZb8kiYvCM37ApdPhqVOu6VVf1IwrWIkKVNHnk+SabQxJvUWHBANpYJb7xjdo/Zh9EPU2ktfZ3c4ZzcHEuv80bWBikplY7Wx2li9F6ugo8nsUPCIYJ3l2QsRsh+np26QKQAAn2fA+qlYs5KSsE/pGSg8hzdSqmM+HhMzG8m1fbY+gPM4+29BlVDPgtU6NgIHXyxU41Yljo3GmkVjiU3EtRCd8z0sNV6v/sXlBolFL9DtWF4vEb9+wSJpThsZS3fnqiQ8G6uN1cbqXVhFkRfJQKszvJWePh1CpgRfwTLixqAIB5ntJZkmNFTkHOtPys5DBChKrpw1X2akfkNW7v6//uQ4TFQZMk1GQdrPqqWKXJZdQ06d1KJT8OWu1rCp9tX43Ato5pndkUo762I6gH5Q9gvPS5c3lusSDtZiXd6N1cZqY/VmrIoHIbZhLD9ZtuYmAfPDy7WI0ijkRjjFXpriXXAGUSvWxfqU89gV9vcjydpYsMHu9YkZ6UNobcKK/yO7I+zoA65a+5yMAEW37hqL7eduXw1oYnXtnvlj8W/nie+dQIrMJ2hoqeDHAT4IBhItmS8DGY3VjdXGamP1Xqzgee95PqY00mUVyqCQqYTPA1TUbj9BY7etr0Kts9By8TpiHYssps3zm2klTaFmIk80O/DnSghdYEnRbmD8TJqbSrOUh0WhxMahjAC1YtHbRvcgL1OtQMUzpj+RqFhvxbnCw3IMwUSQdYa/D0+xlnAa74uy/ntgJRurf/i+KhurPxor9mggrpbYk7lm1YJm+wHgZRNOFGYDZjt0Jn1UE1OSSb1hau9G9BIJjq7RJBNXi2bUNcdcS5pbi+7U5TKlkn5gno6dJtL9al4ndubuZLhByd1y5vbnQJtcOPNItA1ClZCp4yjH4ZYavvWnufI3rF0jDmFns4Zrc0sNKcs1AOJ/AazIKvaJFf1mrMrfwUr/ZbD68+8r2lj90VgdDTMeweWLaZBfS9hNHNjjMjTJgJRcsmpwPMS9I+T1MgYrN8kA26xOfQeuBs1+taG31ia4cKcEQBRL4hhGKbEPh7rUKsZ+lIPTf5+yn+KFtDNKONgmrmww0m6DIw9E53ZulkgZPhjmuOMXT83+9fBsuMo1c0VAF8GJcaRV/k5Y+SH+EazCMXJi1ezZm30fk9fDze1+1ePQH2NFP8IK4zP+8V8Nq/9E91Xu6Wys/jCs2AcWUUBm1WXP74alq3kMlq/NBVp1k83eur+4vV7qenGOfoEGBFzmLlrA14EtN7iwHej0u6AyN/BCQWmoGzUDFtHWTehzvIfT2mepBTV4NhcmjcPtqIEUzs8q4cEKie4GlJ65GkctaluMrS/XjYwbXtexX+AL+LhDJlZulY9rzokvlZkJTr7w/orV/QOs9MdY9W85VhBh2ZItCiH7S76fag9e/CXj4NWK7dgXOi9uM+RYFc3m0ROr/JxgrwSznb2n83RS1m/LFY574Ddg9W92X5V/5r7aWP0qrMQ8/dyky/5pqRtA6tCFIZb6IFczijcgo2MqUisM5/EJCUq+T+r+KUomBSfC/dPVvAL8RlGa6urtPNkj8N2fiY7Rym0um1RJWp0fwlUC/hAyJx+NgRwxEJ5stLTyYQkDjYBbcdmPs1lArr3J6Flkb5XdA8SUULgYtz14zhacFFq2Sw0rPKCs1M5IE2BVT8MqnkujQ+wDsTX8xMpsz/oK/2/2ghaeQOyzj7rnSPqHRIpu/+l1ep5lq2YQNzLtFKcvT6ycGiOwLKpelEneQzqexb5uwYh/C1b/me+r8qP7in7+vipZjXpchN9X4R6TWLWN1T+JFS8hZ/b1bUofrrromOxGj1oxBzKwjg9/PU9k/uD2jZVtDTVmG0CLNSz6Ifqn+OirGzZ6GCqFyfF3U367FAiqNqqZeX1J65XkeXwYO/bOz/m0ls2iBk+Y/qPbvMIQ9JZpk/DKMMN9mbb+Xm54uLezP8Silg58DmV0Q3zrZ6qvakR9N1uBHWXpjBhWbFj5RaUlOSCfh/UEv/nzHryVGjuXLeWpAyvAU4AVUaz504mWh62HDloeqvTE6ri+9cO+eg2fzMMfYdV/ZJug1JcFVYLHTIlVJP1mo2e4NiVWxw+x0hWrP+W+Kn/AfSWrjvdxX8Gmsw6vpoHVeFbxI4TLP+0PrMo7sfqdPoP3n4TVl/uKl1u5F3vN/B+ciCGzp2h4DQaX13IPYpitUCroFNUYbqNhoTy9B1HutV5PNmy/mbWPBbBx7L/4Fp0loKlHy1JEpcW1aZYigl4GfGMbrTGSWdD6Ze/LYIZ74WEbfMKragHWPK7LwraiLbl5OmzYPdEneCyh221BJnF6vEyRVCruil67nA+sSmI1TMsINw2vlRfbpgCkq5V/iNXYMoBIog+kvxJY3fpk4/m2K+6nwf8T3wFlx8oupdVZ/d5i+mpVObC6cV8dP8bK6NeJFc8pL7GS77EKU8k//74qv+K+SokK/Yr7ihasvBLu99UL91W/6KKPpC27r+grVryyE1asJAJs/i5WSQtgx/U3YaW/12dQf4gV8c9h5XPvwEr+Cawk76uJFY3qoH0iCAwuqJQz3lQkcmT+2MBkrKGGzKe4U2qv/shSetKmftSa5FTa/hnEh9x3Dz1XQwa5rdn+kOpyATz4yNbTflY4hYMvC/toxGuMZHyK7tdn/2mfD5JGHJTZcBeSMZ+ryiCVRM/E2xZo05gjrFg+kSbneGD12X4CVvUrVsNjjBasdNJJVu/EX4HVffenkz3ZxCT9IKFQ+Ge3stonicZ1Fc/OJN8R6Ec8+QJVGVjRV6y4Y/UyrLj8ElbkWOnQ0/4SVuULVr/ffcX//H3ll/IfuK8o7quC+0rWKX1ilfeStfB+dF+pJzIkVuXvYzVs29fcrV/5Gbx/r89g+SFW5lD6c5/BPpCBFf/jWFX+Dis2toXxZbHyOOymbEstas9DM4ho8bkl4REyq2Whe/gq9KxXf/FLWuElR8223PolxyewsFeGkps+wxGRwhZI0ypsMuiSmxvx2Qcf/fZtuIN57BAXCzsqVi9oiphkGHTYkySjkrCFJ+w9/siKjO3sHIgZtvYHRfOYSgn3aWuUAKv6C1jpgpXEQX4ZK/qK1ecnrPuxXvuC1YiFku+w0pSJTayQmllPw+r1xAoVnA3koN+Alf4WrMjuK/6d7qvj5++rV7+vyh96X/lF/8X7qoWz8M/eV/Zv+VOwuiA2/EM/g5jffxYr+X2w6vfV+QUr73NhUXBeHzS2e9aoHvbD6qKc9KQwfbrqjLSfPpLKKkk7jGCP9vl5mNhxpBA5PST/jq8tvdbZHwmTfxp1KkKbxahF2oe7GvZPpmAN1eDbbxbXi6/F/JiHTCEarmZcPef7dSxYw9tASvDc/M74dVjJb8DKutZyP7F69SfYxb+MVfkOK/oeq/tXYVV+NVb6W7BqhtXx17uv5DffV6J/976ygtF4A//IffWXxernPoPyp2ClX7BiXCSVE5yu2Oq3WU7j7uRI8shyzk2mDdO2nIdxVFfseulr1eXtrX/5/ETPoxway+O4Ti06dEOuaTnWQRWJj18qAGSs6nlsGEd2ELai2guT/eGOsd6UkyTHScaerU4XopEQGfy5MZDFZNtdXA0vfBFYnRTyhd8FKzKs5IkVQgF+P6zkfVgdo/v5n/y+OjZWvx6r8odhRf/zf/83bP+WMa9TWQzkF+NmA65p7t/p9BVbrbnYG17OKLHdloPcxAeKpLD4ys3ZRzQQ8+xJ8dLCCw2kxNrZVzOUXDhbAIuzf8U2U6jJ02Tx6x+0XVmGa4dMj57hwmGe1stA3CcD/29YUTJmNlZ/F6t9X22sfk+s0AcnW9AuDvZjJ0QnBdKDfWg0Exyp1Scw9v+MP+kRYtjke/30icV/PVFwi8ds2Baj25XJ0/pnMPG9AJYIPVvkoCHAFN8axAyNovTz9RP4BXyoLJb1ZbT4dLKvIr9oeFFP751oKrOdpIzMNfRSEF3bWmIlG6tfjdW+rzZWvytW8LOPFtL382B5HO/LHxm7/oOT5uEfnhaLb8L9y9hBd3sVjjoznF0n+YSCzybJkRszgnm0cpllcBmUf3FSm9nrGKOkQ3fLq8wK80fnvD631h3qMipkHVy+PAqeAC9zI9pYbaw2Vu/FykIy5NbYzM+dtedhpMhXL3ifLGladi0bdoplbSk3BChyXh+9SgT35L6Xk9bH80RmpFrUnDwWuiVCvNcXR9OEe3nc7ld//36UfgqgFImM331sRA5AyuqbmD+Y5NuyVOO+RNcOVT9fvurGamO1sXovVnyalLEfxqZknl4Uw+M0iBpri2CZIXV+4Vav4uk9nzeBuvnhK+pqsy+UluZdMaNBnBkTX+iw7CmD4zNtrXVNLTM2dn+/F9U+gBPdBGdttJYUszLL6RU1XKbHW+WjYKy4/VdiO/D1iX42Ljmo4BurjdXG6p1Y9ekLXHuMqDXjA2kQKkeHFEVfqK8XsVF5rGpLpmnYdmD7/Km/h6c8em3ZV7Z8nlaIiosB5oOin5YzeIlkKDo1jy3jUUNJ/A2FXfv87I8RsxwLEvCFIVnPQlNpN1O1ZfRSItWR5s7jsOURKuvt8vq8VdtxYCBmObax2lhtrN6JFbs9DbiFkAp9zmyLaQRmQdNFphJgUFdplqLZVyBzmO9IXVbJiab8soIacsBpokXyR8lZOKZ8SE1yfDS97OMSqcbZVNt3u5GgfSDeOpRxcCyQUo3Ci+rX6HgyesGFB1WYl4EIPYgsPJ5dfc3/MqT6JT9qcII3VhurjdVbsWI7BsKpwfUiBamUmem5zU/J/1hYYCty/lPQehoo/PXjAzxXCEqozC046evP/ucGEbYPawl5pdU2Y3lPvz5UfOR2DGPoogplOEOzuwIRLfPzYfRxkNlMCLzIDe1UiFchQeiYVB8bBGx2riLHeUEgao0MjuuxsdpYbazehlU/mhsDYmBofKqim/CcxJNki7pUUlaUhAyRROo2/Uefcr3NmcLLANiLRtMH1df9AqWtGqnENxRbrp1zu1HcEMDVeNl7BVLtxqnCmsdPO+ltKRYz7f5JfSCv12zXLjuXYfairoEf25mSlj7mZHe/kEhrlmOW5wGF1MZqY7Wxei9WzCEGjxTWipCM5t2EwEhlZPSE2Zb1Gc2cy6rQJrGgbY3AGquufqJhX+Be+k4sK2onwXJ/urhWymxWTKKZph6SIjgk2g7mt89whoZ5hVv5aFDdxpYdiN1IKOpgQEBnVhmaagSxcjSJIJJGLeGw6BZ4rxsXldgbN9UvE8nGamO1sXozVkJPOTXsoK7UBzkDgyOIwEtKTiXT0PZDEtAH187z5F7TstRUPC2UC00PDRM69Vea8aaTXXm1PKHQX4L+tpjHwI4VCgCC6U8oGMJhrkxe3cL674+YD7RFGshmNerbpJvw2LxMeZPbUsF1qKkZ8p8yQ7dLqNk3VhurjdVbseI0BJmySZihHZfeUsIbImygfSJM39RxksHkIhAkDja5rIuO2uKPoY9QIHQiDk/7aHcgNTgaFNtx7MHY+UtY2BN+i8sQqjtJlteHQmbfYpXMcH+9vOxkDoN/u8zmC0QRDjl+z7Y8716C1utwcq2bCrW17bqx2lhtrN6HVVR5MudgO9GD+ySqquE74NMhhQdEmF16viFKzBuzYT3cn3A8KHhx5ArbnedmXr0uKIqwxbjs82l2OyevLG2CzzOlU24l7G8r0/erfKF2wKIcrlWL5Y7bkc0T0RA2wSS0vcxRumry1lqYDk+ENlYbq43VG7EKbod3TbO+dBtg6vOcoSU+XZrtqe95eYrPGsFQ0/iGlxalTkO4GLSOjTVvwR7wFyYzZiuLQavHcecvmeScz8Pdl+RH4oXypV2yBmSTCcplhN2W6VRKZeg8Wy9+uU/rpyMlPPPXorom2lhtrDZW78XKrC2cMTZ122lyiD0v7JUF72s4bEkUde3+tNnwbA91kJZpc6EP12qmxdDHUGMYyLlZj/uGpfLcJvjKSNAWqahCrcLMeLUsd6cSueU50jQAyrOuhlemZ88qlMTti8HWBXnvHAaOPu33n9taPcSZG6uN1cbqvVixRbT6sSmV03PiBFpGwOdlV9D/r7WGlJXzlK96obS+Hb7g+TttVqpucpnEODxGwoxw0UnhakAL3i+HJxI7EPJF+jmfFcts75J0ygtsGQ52Mfx6l8U7tplc/rRrNp034kFDKrrYs26sNlYbq7diNTyWOV1K8zvqNq1cedR5uXqGTXAvV8/rm3zVX89x8GhrzEMkiEvN6taFcOpRGciitQnyRYNKqXo0m4naXaQQU3paYci0i2UveiP8yAelbO6J7IlBGs3g6K201mG8rm+OCz+uN8voIH8dyMZqY7WxegNW7AwuXkfbnmOfRqjBxWhi0+H1kWNe3SEkV7hO+hilqeb3VQZQbscTO3PVHBMlvcFUW3+knC4CCNHAdAuixzqafeMxGyJcHrpQHakTdPAZRv7orUZSxAltQY0idnQ+RNeVv1oK3MZqY7Wxei9WPJRIkoYSQq5apOBlNNNMIxEIv37fjVQhATcN1HAjXFfIZfWV0PH9sJgOTNeuhOEJXNgmUEv2qBZOFvCFleJjTy+seQCS52IF+povEeduELVQNqj5AlVxE1rzsIbDNSyum+e/r72L3AT1xvFYlW+sNlYbq7dhZdO6xVGEelK8qfnwg3B5Nx9H6wvadh/nhb0vI8mGA/QXgEZ7gq2Sk4h1y1o3V6SRboBFvGkNfI6v9+uznxzcMIYufPUU42HtmmvaaJZEYzX96ifzJK8WNUts7gMBJ/i+4fkPjBtFgnSON9I7nKU3NxM2VhurjdV7sWIdXoVpO8++71b9FTSSq8GMJw8L0jD0CgwWqwuvFf3dJGLTbcJeErdR3xqHg0c6qeZS25upzg5rQ7JgC2NOTXqcqsR+njvs2zUTXdM+XXkU0koZzV2yUD97bsmSjoVH2OKNb9cjLDDAIfYBb6w2Vhurd2JldtKS+3CWJCw13eyXN0KJiBTiq57fkLJrkWfsxjoR/p4KgukznX5iY6ksw1KHoLqcOaBRWyJlW+XCypxdNgkom8e/L9xeiSVuvJVMf1jb7QtbaK00eXPhGF1NVHkfx3mcH5jjka9V1POAYUQkjDaqCQJ8vyDdF4U3VhurjdWbsTqiBuOybKHJLCxJLYaoH+Ku51E97OhSGO7wwewc+4UhFvpNjx6jKCKjdKRYg3vWnU+fnh3P1ehvNyEF+7AEeOq43a9e+h5MNCbdMhQKRgmRWIon25+dYOZQQig5HIMq0nUrmrS9nDa1OoRObGpyLZCbQm86tw9tTS79RUlvoRr6gI3Vxmpj9TasfP28pjbOujS9b6S97opI2tNE3Qq9EtxqbhFdftHrviF5Ilv3LumJPFgbuXsnwzrD/GFVz/OqmEMFecXQcMITh718FZ1kkhCPk4eChDbSituW7dtmmisz0LFr47G39wsOZqf3VsQGguaLitN8ka0W52Te+55kGyWxG19srDZWG6v3YcV1cjRo6IiWGrL04pN6GQqkvNmK+Ru0V6pyOxNtpld7oNjAyFkX6QhhW3rrVSmeWw3c+5fXYUih2YBuZ/+do0IKcJtinNNGLB8+a8tTw0DWO7hKMlWZNHqiYjIldIJl+P1Al3DwcaMu9UYM1OKZQUQjyLvYruDGamO1sXovViZQmiEWY9MumqMoESuf5xl8Ux7Mil43Xhjn3Qb7g+d6uyz29TytEjWrylKSVMsQBKj0GTcmWnyzGncfAJ1GZnvBz4wz/3ZUzZq58B0eygeIr9mVJdoursLqVSgUDNeHRgA3BugM2lpPrqeFxTvPxBf9wdwdnmbkfOCN1cZqY/U+rDhorokWi9mXeqzrq/V/nOdHMFB90VlGrAc8a/A9W/faMrvED3NNbk1XyhHMoXKw7M0FtZXTDBLDDjH03+Q9jP4XDxb1ujQNdeLXZytEy6KQAqHWwx5z0X7D2uKop/NWXEZKsUVJyr3Arr4XiP1C5sa62LjGatwotxurjdXG6p1Y/f8CDAALD53LFmMO+gAAAABJRU5ErkJggg==); background-repeat:repeat; background-attachment:fixed; overflow-x: hidden; overflow-y: auto; } i.icon,i.fa { margin-right: 6px } .col, .col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12, .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12, .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12, .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 { padding: 0px 5px; } header { position: fixed; top: 0; left: 0; width: 100%; z-index: 100; height: 50px; background: #FFF; } header .logo { font-size: 20px; height: 50px; margin: 0; font-weight: 400; position: relative; z-index: 99; border-bottom: 1px solid #e8e8e8; background: #FFF; text-align:center; } header .main { position: relative; } header .nav { width: 100%; margin-left: 25px; background: #FFF; margin: 0; overflow: hidden; transition: all 0.4s ease; -moz-transition: all 0.4s ease; /* Firefox 4 */ -webkit-transition: all 0.4s ease; /* Safari Chrome */ -o-transition: all 0.4s ease; /* Opera */ position: absolute; top: -300px; left: 0; } header .showNav { top: 50px; box-shadow: 0 5px 5px rgba(204,204,204,.15); -moz-box-shadow: 0 5px 5px rgba(204,204,204,.15); } header .nav li { font-size: 16px; } header .nav a { display: block; line-height: 40px; font-size: 16px; color: #959595; padding: 0 25px; border-bottom: 1px solid #f5f5f5; } header .nav a:hover { border-color: #459df5; color: #459df5; } header .head-btn { float: right; line-height: 60px; } header .head-btn a { margin-left: 5px; display: inline-block; width: 30px; height: 30px; line-height: 30px; text-align: center; background: #f5f5f5; color: #03b8cf; border: 1px solid #e5e5e5; transition: all .2s; -moz-transition: all .2s; /* Firefox 4 */ -webkit-transition: all .2s; /* Safari Chrome */ -o-transition: all .2s; /* Opera */ } header .head-btn a:hover { background: #03b8cf; color: #FFF; border: 1px solid #03b8cf; } header .head-btn a>i { margin-right: 0px; font-size: 15px; } header .nav-btn { position: fixed; border: none; background: transparent; top: 0; left: 10px; outline: 0; margin-top: 10px; z-index: 100 } header .nav-btn { left: inherit; right: 10px; } header .nav-btn .icon-line { display: block; margin: 6px 0; width: 25px; height: 2px; background: #999; cursor: pointer; transition: all .4s ease; -moz-transition: all .4s ease; /* Firefox 4 */ -webkit-transition: all .4s ease; /* Safari Chrome */ -o-transition: all .4s ease; /* Opera */ } header .nav-btn .middle { margin: 0 auto; } header .animated2 .top { transform: translateY(8px) rotateZ(45deg); -ms-transform: translateY(8px) rotateZ(45deg); /* IE 9 */ -moz-transform: translateY(8px) rotateZ(45deg); /* Firefox */ -webkit-transform: translateY(8px) rotateZ(45deg); /* Safari 鍜� Chrome */ -o-transform: translateY(8px) rotateZ(45deg); /* Opera */ } header .animated2 .middle { width: 0; } header .animated2 .bottom { transform: translateY(-8px) rotateZ(-45deg); -ms-transform: translateY(-8px) rotateZ(-45deg); /* IE 9 */ -moz-transform: translateY(-8px) rotateZ(-45deg); /* Firefox */ -webkit-transform: translateY(-8px) rotateZ(-45deg); /* Safari Chrome */ -o-transform: translateY(-8px) rotateZ(-45deg); /* Opera */ } .left-bar { position: fixed; top: 50px; left: -240px; width: 200px; max-width: 100%; height: 100%; background: #353535; z-index: 12; transition: all 0.4s ease; -moz-transition: all 0.4s ease; /* Firefox 4 */ -webkit-transition: all 0.4s ease; /* Safari 鍜� Chrome */ -o-transition: all 0.4s ease; /* Opera */ transform: translateZ(0); -ms-transform: translateZ(0); /* IE 9 */ -moz-transform: translateZ(0); /* Firefox */ -webkit-transform: translateZ(0); /* Safari 鍜� Chrome */ -o-transform: translateZ(0); /* Opera */ } .left-bar .header { padding: 0px 15px; border-bottom: 1px solid #464646; } .left-bar .header h2 { font-size: 17px; line-height: 40px; max-width: 100%; overflow: hidden; margin: 0; font-weight: 400; display: block; color: #ccc; } .left-bar .menu { height: 450px; margin-bottom: 15px; border-bottom: 1px solid #424242 } .left-bar .menu ul li a { display: block; height: 35px; line-height: 35px; font-size: 14px; color: #777; padding-left: 38px; } .scrollcontent { width: 100%; top: 0; left: 0; padding-right: 4px; padding-top: 5px } .left-bar .menu ul li a:hover { background: #f5f5f5 } .left-bar .menu ul li i.fa { width: 15px; text-align: center; margin-right: 20px } .left-bar .tree li.open > ul::-webkit-scrollbar { width: 3px; margin-right: 2px } .menu-about p { font-size: 12px; color: #ccc; text-align: center; } #content { position: absolute; left: 0; right: 0; top: 0; bottom: 0; } #content > .Off-left-menu { display: none; } #content > div.center-main { margin: 0 auto; } .sousuo { padding: 35px 0; } .search { position: relative; width: 100%; margin: 0 auto; } .search-box { height: 50px; /*box-shadow: 0px 0px 2px 0px #ccc;*/ border-radius: 10px; overflow: hidden; display: -webkit-flex; /* Safari */ display: flex; flex-wrap: wrap; border: 1px solid #e6e6e6 } .search-engine-name { width: 69px; height: 50px; background: #2C3E50; border: none; color: #fff; font-weight: bold; outline: none; } .search-input { box-sizing: border-box; flex: 1; height: 50px; line-height: 50px; font-size: 16px; color: #999; border: none; outline: none; padding-left: 6px; } input::-webkit-input-placeholder { font-size: 12px; letter-spacing: 1px; color: #ccc; } .search-btn { width: 80px; height: 50px; background: #2C3E50; border: none; color: #fff; font-weight: bold; outline: none; } .search-engine { position: absolute; top: 60px; left: 0; width: 100%; background: #FFF; padding: 15px 0 0 15px; border-radius: 5px; box-shadow: 0px 5px 20px 0px #d8d7d7; transition: all 0.3s; display: none; z-index: 999 } .search-engine-head { overflow: hidden; margin-bottom: 10px; padding-right: 15px; } .search-engine-tit { float: left; margin: 0; font-size: 14px; color: #999; } .search-engine ul::before { content: ''; width: 0px; height: 0px; position: absolute; top: -15px; border-top: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 8px solid #fff; border-left: 8px solid transparent; } .search-engine-list::after { content: ''; width: 70px; height: 18px; position: absolute; top: -17px; left: 1px; } .search-engine-list li { float: left; width: 30%; line-height: 30px; font-size: 14px; padding: 5px 10px 5px 10px; margin: 0 10px 10px 0; background: #f9f9f9; color: #999; cursor: pointer } .search-engine-list li img { width: 25px; height: 25px; border-radius: 15px; float: left; margin-right: 5px; margin-top: 2.5px; } #content .content-box { padding-top: 51px } .content-box { max-width: 1200px; margin: 0 auto; padding: 0 10px; } .item { width: 100%; } .item > .container-fluid { padding-top: 0; margin-top: 0; } .item > .container-fluid .row { padding: 10px 5px; } .item-tit > strong { color: #999; font-size: 18px; font-weight: 400; display: block; margin-bottom: 10px; padding-left: 5px; } .item-tit > strong > i { margin-right: 5px; font-size: 18px; } .card-link { display: block; padding: 10px 10px; border-radius: 5px; overflow: hidden; margin-bottom: 10px; background: #fff; transition: all 0.2s ease-out; -moz-transition: all 0.2s ease-out; /* Firefox 4 */ -webkit-transition: all 0.2s ease-out; /* Safari Chrome */ -o-transition: all 0.2s ease-out; /* Opera */ } .card-link:hover { transform: translateY(-5px); -ms-transform: translateY(-5px); /* IE 9 */ -moz-transform: translateY(-5px); /* Firefox */ -webkit-transform: translateY(-5px); /* Safari Chrome */ -o-transform: translateY(-5px); /* Opera */ box-shadow: 4px 4px 10px rgba(204, 204, 204, 0.5); -moz-box-shadow: 4px 4px 10px rgba(204, 204, 204, 0.5); /* Firefox */ } .card-tit { height: 20px; font-size: 14px; font-weight: 700; overflow: hidden; text-overflow: ellipsis; white-space: normal; } .card-tit img { width: 40px; height: 40px; border-radius: 50%; margin-right: 5px; } .card-desc { color: gray; font-size: 12px; padding-top: 10px; height: 45px; overflow: hidden; text-overflow: ellipsis; white-space: normal; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; } .content-box .list-box { background: #FFF; padding: 20px 10px 0px 10px; margin: 0; } #get-top { width: 40px; height: 40px; background: #2C3E50; color: #FFF; position: fixed; right: 15px; bottom: 55px; line-height: 30px; text-align: center; font-size: 30px; cursor: pointer; display: none; z-index: 100; } #get-top i { margin: 0; font-size: 20px; } .footer { padding: 15px 20px 10px 20px; border-top: 1px solid #d0d0d0; background-color: #e8e8e8; text-align: center; font-size: 14px; color: #5d5d5d; } @media (min-width: 768px) { .col, .col-xs-1, .col-xs-2, .col-xs-3, .col-xs-4, .col-xs-5, .col-xs-6, .col-xs-7, .col-xs-8, .col-xs-9, .col-xs-10, .col-xs-11, .col-xs-12, .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12, .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12, .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 { padding: 0 10px } #content .main { padding-top: 51px; } .sousuo { padding: 10px 0 50px 0; margin-top: 0; } .sousuo-form { width: 100%; margin: 0 auto; } #input { outline: none; padding: 0 10px; height: 46px; line-height: 46px; border: 1px solid #ccc; border-left: none; display: block; padding-left: 90px; } .link-box { width: 12.5%; float: left } .item-tit > strong { padding: 5px 0 0 10px; margin-bottom: 10px; } .get-home { margin: 0; margin-top: 20px; } .footer { margin-top: 20px; } } @media (min-width: 992px) { header { height: 60px; border-bottom: 1px solid #e8e8e8; } header .main { padding: 0 22px; } header .logo { float: left; font-size: 22px; margin: 0; font-weight: 400; border: none; } header .logo a { display: block; line-height: 50px; color: #484848; font-weight: 400; } header .logo img { width: 30px; vertical-align: -10px; } header .nav { float: left; margin-left: 25px; padding-top: 0px; height: 100%; display: block; overflow: hidden; position: static; width: auto; box-shadow: none; } header .nav li { float: left; font-size: 16px; } header .nav a { display: block; line-height: 59px; color: #959595; padding: 0 18px; border-bottom: 1px solid #e8e8e8; } header .nav a:hover { border-color: #459df5; color: #459df5; } .left-bar { height: 100%; background: #FFF; top: 60px; left: 0; z-index: 1; } .left-bar .header { padding: 11px 0px; border-bottom: none; margin: 0 25px; padding-top: 15px; } .left-bar .header h2 { color: #28b779; font-size: 16px; font-weight: bold; line-height: inherit; border-left: 3px solid #28b779; padding-left: 10px; } .left-bar .menu { height: 600px; border-top: 1px solid #f2f2f2; border-bottom: 1px solid #f2f2f2 } .left-bar .tree-menu { border-bottom: 1px solid #e8e8e8; } .left-bar .tree li.open > ul { height: 281px; background: #f5f5f5; } .tree-menu li li a { color: #797979; font-size: 14px; } .search { width: 650px; } .search-engine { width: 650px; } .search-engine-list li { width: 112px; margin: 0 15px 15px 0; } #content .main { margin-left: 200px; padding-top: 70px } .content-box { padding: 0 10px; padding-top: 61px } .nav-item .container-fluid { padding: 20px 20px 10px 20px; } .item > .container-fluid .row { padding: 0; } .card-box .col-md-3 { padding: 0 7.5px; } .card-link { margin-bottom: 15px; } .main .list-box .menu-list { margin: 0px 10px 20px 10px; } .nav-tabs > li > a { padding: 4px 15px; } .footer { margin-top: 30px; } } @media (min-width: 1200px) { header .nav a { padding: 0 25px; } .content-box { padding: 0 20px; } .sousuo-form { width: 60% } .item > .container-fluid { padding: 0; padding-top: 91px; margin-top: -65px; } } @media (min-width: 1700px) { .content-box { max-width: 1400px; } .col-md-3 { width: 20%; } } Web Nav blog github cnblog 目录 Myself Android Graphics 语言手册 Web建站 图片资源 视频教程 在线学习 百度 搜索 选择您的默认搜索引擎： Myself MyWeb My website Github My cnblog Vulkan Study Android AndroidXRef Android源码 Opersys 专门用于查看AOSP的网站 Android源码 Android & Kernel 系统源代码 mobdevgroup 专注于移动平台资源整理和分享，并分类整理浏览器里那些杂乱的书签 Android Developer Google官方Android开发指南 GAPID GAPID supports tracing all OpenGL ES and Vulkan calls made by either a pure Java, native or hybrid application. Git文档 版本控制工具 Jenkins 基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能 {OpenGrok OpenGrok is a fast and usable source code search and cross reference engine. Graphics EasyX Graphics API And C++ Study LearnOpenGL CN 这个网站都将能够教会你现代(Core-profile) OpenGL从基础，中级，到高级的知识。 Vulkan极客教程 Vulkan Study GLFW GLFW 语言手册 C++语言手册 一份核心 C++ 语言构造的参考手册 Markdown Markdown 是一个 Web 上使用的文本到HTML的转换工具，可以通过简单、易读易写的文本格式生成结构化的HTML文档。 正则手册 正则表达式语法手册 Web建站 Hexo Doc 快速、简洁且高效的博客框架 Hugo Doc Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。 NexT Theme NexT坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性。 Suka Theme Modern, powerful and simple theme for Hexo。 Fexo Theme 简约，好看，不臃肿 大道至简 Theme Maupassant最初是由Cho大神为Typecho平台设计开发的一套响应式模板，体积只有20KB，在各种尺寸的设备上表现出色。 图片资源 极简壁纸 ISO 不错的图片资源 elimage 一个友好的共享的图片云服务器 Unsplash 非常好看的图片资源站 WallpaperCraft 壁纸 Font Awesome 中文网 矢量图标库 easyicon 网站小图标库，包含各种尺寸，提供免费下载 视频教程 慕课网 程序员的梦工厂，慕课网是垂直的互联网IT技能免费学习网站 极客学院 一家很不错的IT职业在线教育平台，入门教程视频通俗易懂，很适合新手学习 宅客学院 IT职业教育线上品牌，课程涵盖大数据、前端开发、后端开发等，免费课程挺多的 饥人谷 一家收费的前端开发线上培训机构，虽然课程收费，但是官网还是有挺多免费教程视频的 网易云课程 - 编程开发 网易旗下实用技能学习平台，内容非常丰富，免费教程也挺多的 腾讯课程 - IT&middot;互联网 腾讯推出的专业在线教育平台，采用直播教学方式，适合有充裕时间学习的同学 在线学习 w3school 领先的免费 Web 技术教程，在 w3school，你可以找到你所需要的所有的网站建设教程 菜鸟教程 学的不仅是技术，更是梦想！该站提供了很全的编程技术基础教程，适合入门学习 汇智网 汇智网是一个学习最前沿编程技术的平台，提供了node.js、js、jq等相关的课程 W3Cways Web前端学习之路，网站提供很丰富的相关技术中文文档 WEB前端开发 一个前端开发技术和前端开发资讯的专业博客，专注前端开发，关注用户体验 Mozilla 开发者网络 一个完整的学习平台，你可以在这里深入学习网络技术以及能够驱动网络的软件 本站内容源自互联网，如有内容侵犯了你的权益，请联系删除相关内容 Copyright © 2019 wizzie.top window.onscroll = function(){ //回到顶部 var sllTop = document.documentElement.scrollTop||document.body.scrollTop; if(sllTop>240){ $('#get-top').css('display','block') }else{ $('#get-top').css('display','none') } } $('#get-top').click(function(){ $('body,html').animate({ scrollTop: 0 }, 800);//点击回到顶部按钮，数字越小越快 }) //判断用户使用的设备 var deviceVal = browserRedirect(); function browserRedirect() { var sUserAgent = navigator.userAgent.toLowerCase(); var bIsIpad = sUserAgent.match(/ipad/i) == \"ipad\"; var bIsIphoneOs = sUserAgent.match(/iphone os/i) == \"iphone os\"; var bIsMidp = sUserAgent.match(/midp/i) == \"midp\"; var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == \"rv:1.2.3.4\"; var bIsUc = sUserAgent.match(/ucweb/i) == \"ucweb\"; var bIsAndroid = sUserAgent.match(/android/i) == \"android\"; var bIsCE = sUserAgent.match(/windows ce/i) == \"windows ce\"; var bIsWM = sUserAgent.match(/windows mobile/i) == \"windows mobile\"; if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) { return 'phone'; } else { return 'pc'; } } $('.nav-btn').on('click', function () { $('.nav').toggleClass('showNav'); $(this).toggleClass('animated2'); }); // 默认搜索引擎的内容，如果界面修改了需要同步修改 var thisSearch = 'https://www.baidu.com/s?wd='; $('#txt').keydown(function(ev){ // 回车键的处理 if(ev.keyCode==13){ window.open(thisSearch + $('#txt').val()) // $('#txt').val(''); $('#box ul').html('') } }) $(function(){ // 搜索引擎列表，样式一行五个内容，自动换行 var search = { data: [{ name: '百度', url: 'https://www.baidu.com/s?wd=' }, { name: '萌搜', url: 'http://www.caup.cn/search?q=' }, { name: '谷歌', url: 'https://www.google.com/search?q=' }, { name: '必应', url: 'https://cn.bing.com/search?q=' }, { name: '好搜', url: 'https://www.so.com/s?q=' }, { name: '搜狗', url: 'https://www.sogou.com/web?query=' }, { name: '淘宝', url: 'https://s.taobao.com/search?q=' }, { name: '京东', url: 'http://search.jd.com/Search?keyword=' }, { name: '天猫', url: 'https://list.tmall.com/search_product.htm?q=' }, { name: '1688', url: 'https://s.1688.com/selloffer/offer_search.htm?keywords=' }, { name: '知乎', url: 'https://www.zhihu.com/search?type=content&q=' }, { name: '微博', url: 'https://s.weibo.com/weibo/' }, { name: 'Bilibili', url: 'http://search.bilibili.com/all?keyword=' }, { name: '豆瓣', url: 'https://www.douban.com/search?source=suggest&q=' }, { name: '优酷', url: 'https://so.youku.com/search_video/q_' }, { name: 'GitHub', url: 'https://github.com/search?q=' }] } for(var i = 0; i < search.data.length; i++){ var addList = '' + search.data[i].name + '' $('.search-engine-list').append(addList); } $('.search-engine-name, .search-engine').hover(function() { $('.search-engine').css('display', 'block') }, function() { $('.search-engine').css('display', 'none') }); $('.search-engine-list li').click(function() { var _index = $(this).index(); var searchNameBtn = document.getElementById(\"search-engine-name\"); searchNameBtn.innerHTML = search.data[_index].name; thisSearch = search.data[_index].url; $('.search-engine').css('display', 'none') }) }) $(\"#search-btn\").click(function(){ var textValue = $('#txt').val(); if(textValue != ''){ window.open(thisSearch + textValue) } });"}],"posts":[{"title":"Android Display/Graphics调试技巧（六月份更新）","slug":"2021/210607_android_debug3","date":"2021-06-07T13:52:00.000Z","updated":"2021-06-08T14:50:41.463Z","comments":true,"path":"2021/06/07/2021/210607_android_debug3/","link":"","permalink":"https://alonealive.github.io/Blog/2021/06/07/2021/210607_android_debug3/","excerpt":"android display/graphics相关的调试方法和优化工作效率技巧整理","text":"android display/graphics相关的调试方法和优化工作效率技巧整理 RenderThread渲染绘制（结合systrace） 参考：Android Systrace 基础知识(7) - Vsync 解读参考：BufferQueue 学习总结（内附动态图）参考：android 判断list里有这条数据_Android图形渲染原理（中） 12345678910111213141516171819202122232425262728293031----frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;renderthread -- DrawFrameTask::drawFrame() -----&gt;DrawFrameTask::postAndWait() ----&gt;DrawFrameTask::run() -----&gt;(1) DrawFrameTask::syncFrameState 同步Frame的State ----&gt;CanvasContext::prepareTree(2) context-&gt;draw() 绘制 ------&gt;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;renderthread -- CanvasContext::draw() ----&gt;----(1) frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;pipeline&#x2F;skia -- SkiaOpenGLPipeline::getFrame() ----&gt;frameworks&#x2F;base&#x2F;libs&#x2F;hwui&#x2F;renderthread&#x2F;EglManager.cpp - EglManager::beginFrame ----&gt;(1.1)EglManager::makeCurrent -----&gt;frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;eglApi.cpp -- eglMakeCurrent ---&gt;frameworks&#x2F;native&#x2F;libs&#x2F;nativewindow&#x2F;ANativeWindow.cpp -- ANativeWindow_dequeueBuffer ----&gt;frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;Surface.cpp -- Surface::dequeueBuffer (&#96;systrace: HWC release&#96;)(1.2)EglManager::queryBufferAge----(2) SkiaOpenGLPipeline::draw() ----&gt;(2.1) EglManager::damageFrame(2.2) SkiaPipeline::renderFrame (&#96;systrace:flush commands&#96; 后调用，systrace显示在后)[---&gt;SkiaPipeline::renderOverdraw] ---&gt;SkiaPipeline::renderFrameImpl (先调用，systrace显示在前) ---&gt;RenderNodeDrawable::onDraw ----&gt;RenderNodeDrawable::forceDraw [------&gt;RenderNodeDrawable::drawBackwardsProjectedNodes] ----&gt; RenderNodeDrawable::drawContent ----&gt;RenderNodeDrawable::setViewProperties (&#96;systrace:alpha caused saveLayer&#96;)----(3) SkiaOpenGLPipeline::swapBuffers -----&gt;frameworks&#x2F;native&#x2F;opengl&#x2F;libs&#x2F;EGL&#x2F;eglApi.cpp -- eglSwapBuffersWithDamageKHR ----&gt;frameworks&#x2F;native&#x2F;libs&#x2F;nativewindow&#x2F;ANativeWindow.cpp -- ANativeWindow_queueBuffer ---&gt;frameworks&#x2F;native&#x2F;libs&#x2F;gui&#x2F;Surface.cpp -- Surface::queueBuffer (&#96;systrace: gpu completion&#96;绘制完成) 合成送显流程 Android Q，非最新AOSP流程，有变动 SurfaceFlinger模块12345678910SurfaceFlinger::handleMessageRefresh(); preComposition(); rebuildLayerStacks(); calculateWorkingSet(); doComposition(); doDisplayComposition(); postFramebuffer(); HWComposer::presentAndGetReleaseFences(); HWC2::Display::present(); Composer::presentDisplay(); HWC模块1234567891011HWCSession::PresentDisplay(); HWCDisplayBuiltIn::Present(); HWCDisplayBuiltIn::CommitLayerStack(); HWCDisplay::CommitLayerStack(); DisplayBuiltIn::Commit(); DisplayBase::Commit(); HWPeripheralDRM::Commit(); HWDeviceDRM::Commit(); HWDeviceDRM::AtomicCommit(); DRMAtomicReq::Commit(); drmModeAtomicCommit(); DRM模块12345678910111213141516171819202122232425262728293031323334353637383940msm_atomic_commit(); msm_atomic_commit_dispatch(); kthread_queue_work(commit-&gt;commit_work); _msm_drm_commit_work_cb(); complete_commit(); drm_atomic_helper_commit_planes(); sde_crtc_atomic_begin(); _sde_crtc_setup_mixers(); _sde_crtc_blend_setup(); _sde_crtc_blend_setup_mixer(); _sde_crtc_setup_blend_cfg(); &#x2F;&#x2F; blend_op _sde_crtc_dest_scaler_setup(); sde_plane_atomic_update(); sde_plane_sspp_atomic_update(); sde_crtc_atomic_flush(); sde_plane_flush(); msm_atomic_helper_commit_modeset_enables(); sde_crtc_enable(); sde_encoder_virt_enable(); sde_encoder_resource_control(SDE_ENC_RC_EVENT_KICKOFF); _sde_encoder_virt_enable_helper(); hw_mdptop-&gt;ops.reset_ubwc(); hw_ctl-&gt;ops.setup_intf_cfg_v1(); _sde_encoder_update_vsync_source(); sde_encoder_phys_cmd_setup_vsync_source(); sde_hw_intf_vsync_sel(); sde_encoder_control_te(); sde_encoder_phys_cmd_connect_te(); sde_hw_intf_connect_external_te(); sde_kms_commit(); sde_crtc_commit_kickoff(); sde_encoder_prepare_for_kickoff(); drm_bridge_enable(); dsi_bridge_enable(); msm_atomic_wait_for_commit_done(); sde_kms_wait_for_commit_done(); sde_encoder_wait_for_event(MSM_ENC_COMMIT_DONE); sde_crtc_complete_flip(); drm_crtc_send_vblank_event(); Fence同步机制DummySwSyncTimeline CreateDummyFence()创建软件模拟fence 核心只有两件事情： sw_sync_fence_create 创建一个软件模拟的fence sw_sync_timeline_inc sync_timeline 时间轴向后推一个时间同步点 BufferSlot对应的BufferItem中的mFence对象就是Fence类，最后会在setUpHwcComposer中prepareFrame设置到Hal中 在Android Framework中有一个用于操作fence同步栅的类（libsync中sync_wait类） Google平台帧率切换 参考：Android UI架构四、五参考：Android UI架构十、十一 关键函数： setFrameRate getRefreshRate app: 用于接收vsync信号并且上报给App进程，App开始画图 属性名：VSYNC_EVENT_PHASE_OFFSET_NS sf: 用于SurfaceFlinger接收vsync信号用于渲染 属性名：SF_VSYNC_EVENT_PHASE_OFFSET_NS 磁盘空间占满100% 使用命令 sudo du -sh * 查看各个目录的占内存情况，使用du -h -x --max-depth=1查看哪个深度1的目录占用过高 如果发现/usr/local/tomcat的目录占用的磁盘空间特别大,则进入该目录，发现logs的目录特别大,Tomcat的日志太大,可以将其删除。比如本地电脑发现~/.cache/vmware目录下的drag_and_drop文件很大，这是因为虚拟机和主系统之间每次拖拉文件，都会生成一个复制文件，造成该文件越来越大，可以删除。 再使用df -h发现磁盘空间 Android设备分辨率、密度以及dp的理解 参考：Android设备分辨率、密度以及dp的理解参考：UI设计师不可不知的安卓屏幕知识 dpi计算方法： 分辨率的平方和开方（勾股定理） adb shell wm size 然后除以屏幕的物理英寸，即是dpi adb shell wm density可以查看当前的dpi（一般有的手机会在计算的结果上调整） dp计算方法（开发者选项最小宽度dp） 1.在安卓中，系统密度为160dpi的中密度手机屏幕为基准屏幕，即320×480的手机屏幕。在这个屏幕中，1dp=1px2.分辨率的宽高分别除以dpi，获取到sw320dp,h533dp值 可通过adb shell dumpsys window查看到 低内存分析方向和技巧 参考：Android ANR基本Log分析 参考：Android 系统内存耗用：VSS/RSS/PSS/USS 的介绍 dumpsys meminfo: 123456789Total RAM: 2,697,524K (status normal) Free RAM: 1,063,563K ( 252,355K cached pss + 717,200K cached kernel + 0K cached ion + 94,008K free) ION: 189,688K ( 7,624K mapped + 182,064K unmapped + 0K pools) totalSwapPss: 775,324K kernelCached: 272,476K Used RAM: 2,677,904K (2,090,100K used pss + 587,804K kernel) Lost RAM: -23,995K ZRAM: 200,100K physical used for 669,848K in swap (1,572,860K total swap) Tuning: 128 (large 512), oom 322,560K, restore limit 107,520K (high-end-gfx)--------- 14.816s was the duration of dumpsys meminfo, ending at: 2021-01-05 16:09:23 查看进程占用内存情况adb shell procrank 1234 PID Vss Rss Pss Uss Swap PSwap USwap ZSwap cmdline 1195 9776476K 509716K 228733K 166648K 3748K 405K 352K 78K system_server 5466 7005964K 351036K 139327K 123836K 3404K 53K 0K 10K com.android.systemui..... VSS： 一个进程总共可访问的地址空间。其大小还包括了可能不在RAM中的内存（比如虽然malloc分配了空间，但尚未写入）。 VSS 很少被用于判断一个进程的真实内存使用量 RSS： 一个进程在RAM中真实存储的总内存。仅仅表示该进程所使用的所有共享库的大小，而不管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况 PSS： 按比例表示使用的共享库。系统中所有进程的PSS都相加的话，就刚好反映了系统中的总共占用的内存。而当一个进程被销毁之后， 其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程 USS： 进程所占用的私有内存（内存泄漏的最佳观察数据）。不包含so库占用内存的 ubuntu查看公网ip三种方法： curl www.icanhazip.com curl ifconfig.me curl -4sSkL https://myip.ipip.net 查看视频解码的分辨率及对应的帧率支持日志关键词MediaCodec 配置文件：/vendor/etc/media_codecs.xml linux和windows书签同步about:config网址搜索sync： identity.sync.tokenserver.uri： 修改： linux：https://sync.firefox.com.cn/token/1.0/sync/1.5 windows：https://token.services.mozilla.com/1.0/sync/1.5 getService配置权限首先getService获取服务，紧接着就是getTransport的接口调用。如果在配置文件里面没找到我们所要求的服务，就会报错并结束服务的获取 首先会去system/etc/vintf/manifest.xml文件去找我们调用者的服务名，如果找到就返回。 如果没找到就会去vendor/etc/vintf/manifest.xml文件去找，如果找到就返回。如果没找到则返回NULLPRT。同时打印Cannot find entry xxx in either framework or device manifest. 所以，如果碰到这样的log，首先要去检测这两个文件里面有没有配置我们调用的服务，没有就要自己配置。 一般是没有配置引起的，当然也有可能是xml增加的语法有问题，比如格式对齐等。 HIDL编写/升级流程 参考：VINTF参考：VINTF简介参考：供应商接口对象 总体流程: 创建HIDL接口文件XXX.hal：HIDL为每个HAL模块设计了不同接口定义hal文件，以.hal结尾，在hidl-gen工具的帮助下即可自动编译生成对应接口C++实现或者Java实现 hidl-gen生成interface hash, 添加至current.txt hidl-gen生成接口,更新接口, XXX.bp, XXX.mk等 更新vendor manifest文件：对于TA开发来说, 底层TA是服务提供者(需求提供者), 因此提供的是manifest(vendor), 将vintf/manifests.xmlpush到设备端:adb push manifest.xml /vendor/etc/vintf；system(framwork是发起需求者,需要设什么样的需求), 这部分内容在新平台上也在vintf/manifests.xml，push到设备端:adb push compatibity.device.xml /system/etc/vintf 更新fcm(matrix)，即compatibility matrix XML编写：manifest文件描述了提供给对方的feature, Matrix描述了需要对方提供什么样的feature. Manifest和Matrix在OTA升级之前会进行匹配检查, 确保framework和device是兼容的, 总的来说,manifest是feature提供端, matrix是feature需求端 关于compatibility Matrices： framework compatibility matrix：描述了framwork对device的需求, 这个matrix文件是和system.img关联的, 这些需求需要被device manifest支持 device compatibility matrix：描述了device对framework的需求 123456789101112//xml manifest语法&lt;manifest version=\"1.0\" type=\"device\"&gt; //version: 必选, manifest的主版本号；type: 必选, manifest的类型,属于vendor,值为device; 属于system,值为framework &lt;hal format=\"hidl\"&gt; //hal:可选,可以存在多个,代表HAL(HIDL或者native); format:可选, 值为hidl(默认),或者native,分别代表HIDL和native HALS &lt;name&gt;vendor.android.hardware.test&lt;/name&gt; // name 必选, 代表HAL的合规包名 &lt;transport&gt;hwbinder&lt;/transport&gt; // 和format有关,format的值是hidl时，就是必选的，否则不必存在.申明了当这个包的接口被service manager查询时将使用何种transport方式 // 可以是hwbinder,代表绑定式hidl, 也可以是passthrough: 代表直通式hide &lt;version&gt;1.1&lt;/version&gt; //必选, 代表当前hidl的版本号 &lt;interface&gt; // 必选的,可以多个但是不能重复,声明了一个含有实例的接口 &lt;name&gt;ITestService&lt;/name&gt; //必选 接口实例的名字 &lt;instance&gt;default&lt;/instance&gt; //必选,不可重复 &lt;/interface&gt; ..... 结构层级: 12345678910manifest:version type &#x2F;&#x2F;这一层级申明当前manifest|--hal format 第二层级 |--name |--transtport |--version |-- interface |-- name |-- instance|--sepolicy |--version 启动服务:首先需要将生成的库文件和服务守护进程分别push到设备端, 其次, 使用lshal查看对应的服务是否启动,如果为启动,需要查看对应的rc文件是否存在, 若不存在,则push(vendor/etc/xxx.rc), 手动启服务 概念：hidl接口哈希,是一种旨在防止意外更改接口,并确保接口更改经过全面审查的机制.因为HIDL接口带有版本号, 因此,接口一旦发布就bade在更改 布局：每个软件包根目录,都必须包含一个列出所有已经发布的HIDL接口的current.txt文件 使用hidl-gen添加哈希：hidl-gen生成的每个接口定义库都包含哈希，通过调用IBase::getHashChain可检索这些哈希。hidl-gen 编译接口时，会检查HAL软件包根目录中的current.txt 文件，以查看HAL是否已被更改 如果没有找到HAL的哈希，则接口会被视为未发布（处于开发阶段），并且编译会继续进行 如果找到了相应哈希，则会对照当前接口对其进行检查 如果接口与哈希匹配，则编译会继续进行 如果接口与哈希不匹配，则编译会暂停，因为这意味着之前发布的接口会被更改 如要进行保留ABI的更改（ABI稳定性），必须先修改current.txt文件，然后编译才能继续进行 所有其他更改都应在接口的minor或major版本升级中进行 Tips： 查看HIDL编写的hal服务是否启动：adb shell lshal 重启 ssk-key生成current.txt hash值1234$ hidl-gen -L hash -r vendor.....Testservice（service名称）:&#x2F;vendor&#x2F;...&#x2F;interfaces&#x2F;Testservice（路径） -r android.hidl:system&#x2F;libhidl&#x2F;transport vendor...Testservice@1.0e147fb59c6ffd19c8ea7345423e6b99d8d450e6078ff40367122a9c4ee005da5 vendor...Testservice@1.0::types8f202376e0d66fa4c9448d71415993994de99150b7326e32ac5a04b4b94aec09 vendor....Testservice@1.0::ITestQservice 修改git remote -v的orign源 git remote -v查看远程提交信息 git remote rm origin删除 添加：git remote add origin (正确的信息)ssh://..../platform/frameworks/native git remote -v查看，如果push未修改成功没有关系 提交代码，记得加上-u选项：git push -u orign master git报错无法push（不建议使用）报错信息： 12fatal: Unpack error, check server logerror: remote unpack failed: error Missing tree 7d3329b06421654faca962eab6cb6f9da6b47b9f 使用：git push --no-thin origin dev git commit修改作者名称git commit --amend --author=&quot;wizzie &lt;wizzie@test.com&gt;&quot; gerrit拉取Andorid指定模块代码 repo init gerrit提交代码的界面projects里面搜索要拉取的指定模块 复制git clone然后本地执行 git branch -a查看所有分支，然后git checkout 分支名（不包含orign/master） git pull ubuntu命令查看dnsnm-tool 12345678910111213141516171819202122- Device: eth0 [Auto Ethernet] ------------------------------------------------ Type: Wired Driver: e1000e State: connected Default: yes HW Address: ...:5D Capabilities: Carrier Detect: yes Speed: 1000 Mb&#x2F;s Wired Properties Carrier: on IPv4 Settings: Address: ....241 Prefix: 24 (255.255.255.0) Gateway: ....1 DNS: ....74 DNS: ....75 DNS: ....73 markdown数学公式语法 参考：Markdown数学公式语法 行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$ 上标符号，符号：^，如：$x^4$ 下标符号，符号：_，如：$x_1$ 组合符号，符号：{}，如：${16}{8}O{2+}{2}$ 安装adb和fastbootsudo apt-get install android-tools-adb sudo apt-get install android-tools-fastboot 或者使用Android SDK/platform-tools 针对image编译 编译所有image 123source build&#x2F;envsetup.shlunch XX-userdebug.&#x2F;build.sh dist -j4 编译system.img，生成在qssi目录下 123source build&#x2F;envsetup.shlunch xx-userdebug.&#x2F;build.sh dist qssi_only -j4 编译super.img 123source build&#x2F;envsetup.shlunch xx-userdebug.&#x2F;build.sh dist merge_only -j4 编译其它img，例如vendorimage（如果不指定会编译其它所有img） 123source build&#x2F;envsetup.shlunch xx-userdebug.&#x2F;build.sh vendorimage dist target_only -j4 安装APK报错如果安装APK报错，控制台输出如下： 123$ adb install test.apk5451 KB&#x2F;s (635477 bytes in 0.113s)Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package com.debug.test signatures do not match previously installed version; ignoring!] 需要先删除原先的APK，并且清楚缓存，重启： 123456789101112adb shell dumpsys activity top|grep ACTIVITYadb shell pm path com.debug.test&#x2F;&#x2F;删除卸载原APKadb shell rm -rf ***&#x2F;&#x2F;清楚缓存adb shell pm clear com.debug.testadb reboot&#x2F;&#x2F;再次安装新的APKadb install test.apk 查看当前前台app包名（实时）adb shell dumpsys window | grep mCurrentFocus 监控设备实时获取当前的包名adb shell am monitor APP增加多国语言 参考：让App支持不同的语言参考：语言代码参考：Android多语言支持以及各国语言Values文件夹命名规则 目录在：res/values-*** 将各个语言区域的字符串值添加到相应文件中。在运行时，Android 系统会根据当前为用户设备设置的语言区域使用相应的字符串资源集的 如需添加对更多语言的支持，在res/目录下创建名称末尾不同的values，其中目录末尾ISO语言代码则对应着相应语言，譬如：values-fr则代表着手机系统语言为法语时读取的目录 例如： 英语（默认语言区域），/values/strings.xml 中文，/values-zh/strings.xml 法语，values-fr/strings.xml native crash分析使用addr2line命令定位堆栈地址： 12&#x2F;out&#x2F;target&#x2F;product&#x2F;product&#x2F;symbols&#x2F;system&#x2F;lib64$ addr2line -f -e libgui.so 00000000000c39a0_ZNK7android12SortedVectorINS_12DisplayStateEE16do_move_backwardEPvPKvm 解释：-e后加上.so的文件名；-f可同时输出函数名称 分析工具： addr2line：addr2line –e obj/local/armeabi/libhello-jni.so 00004de8, 用来分析单个pc地址对应的源码行数 objdump：objdump –S obj/local/armeabi/libhello-jni.so &gt; hello.asm,或者symbols/out/target/product/merlin/symbols$ objdump -tT system/lib64/libdisplayfeature.so 用来把相应的so变成汇编语言的asm文件，然后根据地址信息（比如00000000000c39a0）就可以找到更加详细的相关函数信息； ndk-stack：用来把log信息全部翻译成更加详细的带源码行数信息的log，相当于是在整个crash堆栈信息都执行addr2line命令。 addr2line -Cef .so address 或者： 可以使用readelf -a [.so/.bin]解析库地址 根据解析结果查询函数，C++在linux系统编译后会变成类似_ZNK...的修饰名。使用c++filt获取函数的原始名称： c++filt [_ZNK...函数修饰名] YUV数据查看 从ffmpeg官网：http://ffmpeg.org/download.html下载最新的ffmpeg安装包，然后通过如下命令解压：tar jxf ffmpeg-2.5.3.tar.bz2 查看YUV：ffplay -f rawvideo -video_size 1280x800 raw_1280x800_1878.yuv 或者使用YUVPlayer工具，执行： wine yuvplayer.exe YUV Player工具获取： https://github.com/Yonsm/RawPlayer RawPlayer https://github.com/latelee/YUVPlayer YUVPlayer https://github.com/figgis/yuv-viewer yuv-viewer https://github.com/Luomingbear/YuvPlayer android yuv播放器 SDL 关闭硬件加速三种不同针对对象的方法： 在AndroidManifest.xml中设置android:hardwareAccelerated=&quot;false&quot;，注意关闭整个app的硬件加速，慎用 View有个方法支持单独的View关闭硬件加速，可以设置mView.setLaterType(View.LAYER_TYPE_SOFTWARE); 关闭某一个控件的硬件加速功能：findViewById(R.id.btn).setLayerType(View.LAYER_TYPE_SOFTWARE,null); linux绘图UML/序列图工具dia 安装：sudo apt-get install dia 使用，终端执行：dia 屏幕旋转/转向切换命令1234567adb root#turn off the automatic rotationadb shell settings put system accelerometer_rotation 0# rotate landscapeadb shell settings put system user_rotation 1# rotate portraitadb shell settings put system user_rotation 0 Surface两种合成方式（dump sf） Client合成：Client合成方式是相对于硬件合成来说的，其合成方式是，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件。这个暂存缓冲区，我们称为FBTarget，每个Display设备有各自的FBTarget。Client合成，之前称为GLES合成，我们也可以称之为GPU合成。Client合成，采用RenderEngine进行合成 Device合成：就是用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Devicehec的抽象。 getprop查看当前版本是user/userdebugadb shell getprop ro.system.build.type getprop查看设备信息adb shell getprop ro.build.product 滑动到边缘Pixel值调试AOSP源码位置：/frameworks/base/core/java/com/android/internal/widget/PointerLocationView.java的onDraw函数中有ps.mCoords.x和ps.mCoords.y（float类型），可以将其打印出来，如果有问题可以修改此处转换逻辑 Input调试（PointerLocation）systrace查看systrace可以查看到touch点击的事件 点击input事件(up/down)adb shell getevent -lrt 查看帮助：adb shell getevent -h 123456789101112[ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TRACKING_ID 0000003b [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_POSITION_X 0000017e &#x2F;&#x2F;十六进制转成十进制 1*16*16+7*16+14*1&#x3D;382 横坐标X[ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_POSITION_Y 0000032d &#x2F;&#x2F;3*16*16+2*16+13*1&#x3D;813 纵坐标Y[ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TOUCH_MAJOR 0000000a [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_PRESSURE 000003e8 [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY BTN_TOUCH DOWN [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN SYN_REPORT 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TOUCH_MAJOR 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_PRESSURE 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TRACKING_ID ffffffff [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY BTN_TOUCH UP [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN SYN_REPORT 00000000 rate 0 input和wms的debug log开关打开1234567891011adb root&#x2F;&#x2F;wns debugadb shell dumpsys window -d enable DEBUG_FOCUSadb shell dumpsys window -d enable DEBUG_INPUT&#x2F;&#x2F;或者adb shell dumpsys window -d enable a&#x2F;&#x2F;input debugadb shell setprop sys.inputlog.enabled trueadb shell setprop sys.input.TouchFilterEnable trueadb shell setprop sys.input.TouchFilterLogEnable trueadb shell dumpsys input FPS帧率测试查看设备的帧率：while true;do adb shell dumpsys SurfaceFlinger | grep &quot;refresh-rate&quot;;done 获取实时帧率（主要用于获取游戏/视频应用的fps数据） 参考前面的文章：Android 两种实时获取FPS的方法 查询当前的layer（直接dump sf）：adb shell dumpsys SurfaceFlinger --list adb shell dumpsys SurfaceFlinger --latency SurfaceView dump gfxinfo信息 adb shell dumpsys gfxinfo &lt;package_name&gt; 查看每一帧的信息：adb shell dumpsys gfxinfo &lt;package_name&gt; framestats 结果： Graphics info for pid 31148 [com.android.settings]: 表明当前dump的为设置界面的帧信息，pid为31148 Total frames rendered: 105 本次dump搜集了105帧的信息 Janky frames: 2 (1.90%) 105帧中有2帧的耗时超过了16ms，卡顿概率为1.9% Number Missed Vsync: 0 垂直同步失败的帧 Number High input latency: 0 处理input时间超时的帧数 Number Slow UI thread: 2 因UI线程上的工作导致超时的帧数 Number Slow bitmap uploads: 0 因bitmap的加载耗时的帧数 Number Slow issue draw commands: 1 因绘制导致耗时的帧数 HISTOGRAM: 5ms=78 6ms=16 7ms=4 … 直方图数据 例如：while true;do adb shell dumpsys gfxinfo com.android.home framestat;sleep 1;done|tee swipeHome_dumpgfx.log 然后通过一秒抓一次，递减总帧数，确认每秒绘制的帧数: 重置：adb shell dumpsys gfxinfo com.android.home reset 抓取：adb shell dumpsys gfxinfo com.android.home framestats 查看帧率以及如何在systrace分析帧率12345adb rootadb shell setprop debug.gr.calcfps 1adb shell setprop debug.gr.calcfps.period 5adb shell stopadb shell start 之后可以在logcat中通过fps关键字查看帧率 Tips: 该帧率为实时帧率，一个动画的首帧和尾帧存在误差，可以忽略 debug.gr.calcfps.period n:后面的数字n控制统计的帧数 重启手机后将不再统计帧率 systrace中的Frame在每个app进程，都有一个Frames行，正常情况以绿色的圆点表示。当圆点颜色为黄色或者红色时，意味着这一帧超过16.6ms（即发现丢帧），点击黄色或红色的Frames圆点便会有相关的提示信息； 另外，在systrace的最右侧，有一个Alerts tab可以展开，这里记录着所有的的警告提示信息； 也可以通过放大那一帧进一步分析问题。 对于Android 5.0(API level 21)或者更高的设备，该问题主要聚焦在UI Thread和Render Thread这两个线程当中 屏幕录制视频（限定时间长） adb shell screenrecord --time-limit 10 --verbose /sdcard/record.mp4 录屏带--bugreport调试参数： adb shell screenrecord --bugreport /sdcard/test.mp4 截图命令adb shell screencap /sdcard/screencap.png dump sf查看buffer/layer列表adb shell dumpsys SurfaceFlinger --list dump windows/inpu/sf1234adb rootadb shell dumpsys inputadb shell dumpsys window -aadb shell dumpsys SurfaceFlinger 源码打开input debug日志开关 frameworks/native/services/inputflinger/InputDispatcher.cpp：bool gInputLogEnabled = false;改为true frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java：static final boolean DEBUG_INPUT = false; adb打印kernel log，即内核调试信息dmsg和kmsg Android的log信息分为内核空间和用户空间中LOG，查看用户空间（也就是app等上层的log）的log直接用adb logcat就可以 如果想过滤一些信息就用adb logcat | grep -E &quot;log_xxx|log_aaa”命令，这样log只会显示含有log_aaa和log_xxx的log信息了。上层的log信息另行查看。 执行dmesg命令，可以查看全部消息。如果想把log信息保存到文件，可以用adb shell dmesg &gt; E:/Kernel.log (输出内核信息) adb shell cat /proc/kmsg：程序里面用printk函数打印的信息会显示出来。 用cat /proc/kmsg命令打印出来的信息跟与dmesg不同。第一次执行/proc/kmsg打印到当前时间的所有内核信息，再次执行cat /proc/kmsg，不会再打印已经打印的信息，只打印上一次执行之后打印出来的新的信息。 Tips:查看kernel log时间，前面是秒，然后隔一段时间会打印android time标记日志 合并kmsg log adb shell logcat -v time -f /dev/kmsg | adb shell cat /proc/kmsg | tee kernel_logcat.txt “-f”选项 : 该选向后面跟着输入日志的文件, 使用adb logcat -f /sdcard/log.txt命令, 注意这个log文件是输出到手机上，需要指定合适的路径 例如触屏inpu事件log抓取： adb shell logcat -v threadtime -f /dev/kmsg | adb shell cat /proc/kmsg | grep -Ei &quot;InputDispatcher|DOWN\\!|Up\\!|ViewRootImpl|onTouchEvent&quot; 查看设备的白名单 adb shell cat vendor/etc/power_whitelist_cfg.xml 代码添加示例： 12345678//vendor/PLATFORM/proprietary/hardware/power/config/平台型号/power_whitelist_cfg.xml &lt;Package name=\"com.android.gallery\"&gt; &lt;Activity name=\"Common\"&gt; &lt;PERF_RES_SCHED_BOOST_VALUE_TA Param1=\"10\"/&gt; &lt;PERF_RES_THERMAL_POLICY Param1=\"8\"/&gt; &lt;PERF_RES_DRAM_CM_MGR Param1=\"1\"/&gt; &lt;/Activity&gt; &lt;/Package&gt; Android.mk和Android.bp转换语法相互转换的定义在： /build/soong/androidmk/cmd/androidmk/android.go12345678910111213141516171819202122232425&#x2F;&#x2F;该代码Android Q AOSP，在R之后该文件有变化func init() &#123; addStandardProperties(bpparser.StringType, map[string]string&#123; &quot;LOCAL_MODULE&quot;: &quot;name&quot;, &quot;LOCAL_CXX_STL&quot;: &quot;stl&quot;, &quot;LOCAL_STRIP_MODULE&quot;: &quot;strip&quot;, &quot;LOCAL_MULTILIB&quot;: &quot;compile_multilib&quot;, &quot;LOCAL_ARM_MODE_HACK&quot;: &quot;instruction_set&quot;, &quot;LOCAL_SDK_VERSION&quot;: &quot;sdk_version&quot;, &quot;LOCAL_NDK_STL_VARIANT&quot;: &quot;stl&quot;, &quot;LOCAL_JAR_MANIFEST&quot;: &quot;manifest&quot;, &quot;LOCAL_JARJAR_RULES&quot;: &quot;jarjar_rules&quot;, &quot;LOCAL_CERTIFICATE&quot;: &quot;certificate&quot;, &quot;LOCAL_PACKAGE_NAME&quot;: &quot;name&quot;, &quot;LOCAL_MODULE_RELATIVE_PATH&quot;: &quot;relative_install_path&quot;, &quot;LOCAL_PROTOC_OPTIMIZE_TYPE&quot;: &quot;proto.type&quot;, &quot;LOCAL_MODULE_OWNER&quot;: &quot;owner&quot;, &quot;LOCAL_RENDERSCRIPT_TARGET_API&quot;: &quot;renderscript.target_api&quot;, &quot;LOCAL_NOTICE_FILE&quot;: &quot;notice&quot;, &quot;LOCAL_JAVA_LANGUAGE_VERSION&quot;: &quot;java_version&quot;, &quot;LOCAL_INSTRUMENTATION_FOR&quot;: &quot;instrumentation_for&quot;, &quot;LOCAL_MANIFEST_FILE&quot;: &quot;manifest&quot;, &quot;LOCAL_DEX_PREOPT_PROFILE_CLASS_LISTING&quot;: &quot;dex_preopt.profile&quot;, 将HIDL接口服务从设备system移到vendor 修改Android.bp中添加vendor:true（或者vendor_avaiable：ture）；如果是Android.mk，则添加如下： 12LOCAL_MODULE_PATH_64 &#x3D; $(TARGET_OUT_VENDOR)&#x2F;lib64LOCAL_MODULE_PATH_32 &#x3D; $(TARGET_OUT_VENDOR)&#x2F;lib32 如果有.rc文件，则需要修改其中的目录；其中class hal是不会自动启动的，所以需要将其修改成class main ；并且onrestart restart后面添加的是service名称。 可以在adb shell；cd /vendor/bin/里面手动执行bin文件，然后查看进程是否启动。 在seploicy添加权限：device/PLATFORM/sepolicy/basic/non_plat/file_contexts Android.bp（可参考） VNDK 构建系统支持 系统将通过以下规则确定cc_library或cc_library_shared的默认安装路径： 将核心变体安装到/system/lib[64]中 供应商变体安装路径可能会有所不同： 如果vndk.enabled为false，则将供应商变体将安装到/vendor/lib[64]中 如果vndk.enabled为true，则vndk.support_system_process可以是true或false。如果： 为false，则供应商变体将安装到/system/lib[64]/vndk-${VER}中 为true，则供应商变体将安装到/system/lib[64]/vndk-sp-${VER}中 C函数memset(…) 函数解释：将s中当前位置后面的n个字节（typedef unsigned int size_t ）用ch替换并返回s memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 memset()函数原型：是extern void *memset(void *buffer, int c, int count)，buffer为指针或是数组，c是赋给buffer的值，count是buffer的长度 domain.te错误类型 错误日志：The following types on /vendor/ must be associated with the &quot;vendor_file_type&quot; attribute: ×××_exec 如果是system/则type ***_exec, exec_type, system_file_type, file_type; 如果是svendor/则type ***_exec, exec_type, vendor_file_type, file_type; 查看手机硬件设备（包含屏幕信息） adb shell cat proc/cmdline ubuntu的ll命令不能使用将ll作为一个别名： .bash_profile12...+ alias ll&#x3D;&#39;ls -alF&#39;&#39; 然后执行source .bash_profile生效 ubuntu挂载硬盘 查看硬盘：sudo fdisk -l 比如打印：Disk /dev/sdb: 3000.6 GB, 3000592982016 bytes 编辑添加到文件：sudo vim /etc/fstab 比如打印：/dev/sdb /sunwg/ ext4 defaults 0 0 (后面的目录是挂载的目录) 重启电脑，然后df -h查看系统分区 find命令find ./ -iname &quot;*gpuinfo*&quot; ## 查看CPU/GPU硬件频率 查看CPU: adb shell &quot;cat /proc/cpufreq/*/cpufreq_freq&quot; 查看DDR: adb shell &quot;cat /sys/devices/platform/10012000.dvfsrc/helio-dvfsrc/dvfsrc_dump | grep -e uv -e khz -e CONTROL -e VCORE_OPP -e DDR_OPP -e LEVEL -e RSV_9&quot; 查看GPU频率： adb shell cat /proc/gpufreq/gpufreq_var_dump或者adb shell cat /proc/gpufreq/gpufreq_opp_dump 设置GPU频率12adb root;adb shell &quot;echo 1000000 &gt; &#x2F;proc&#x2F;gpufreq&#x2F;gpufreq_opp_freq&quot; ☆CPU/GPU信息文件路径CPU信息是在：/sys/devices/system/cpuGPU的信息在如下目录查看：/sys/class/kgsl/kgsl-3d0 加大dequeuebuffer数目有时候从systrace中看到dequeuebuffer耗时长，如果可能和gpu/cpu相关，则可以参照上面的方式对gpu/cpu进行提频； 也可以尝试修改文件：/frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp mProducer-&gt;setMaxDequeuedBufferCount(1); //增加这里值 比如修改为3，看是否有改善 windows cmd过滤logadb logcat |find &quot;***&quot; vscode插件gitlens：可以查看提交 抓取perfetto-trace（替代systrace） 打开开发者选项-&gt;系统跟踪-&gt;显示‘快捷设置’图块或者命令方式打开：adb shell am start com.android.traceur/com.android.traceur.MainActivity 然后点击“录制跟踪记录”开始抓取 点击停止后分享生成文件，或者命令导出：adb pull data/local/traces 使用chrome登录perfetto-trace网站：https://ui.perfetto.dev/#!/ 或者转换成html格式： 123456&#x2F;&#x2F; 仅支持python 2.7 且需要GLIBC_2.28版本curl https:&#x2F;&#x2F;get.perfetto.dev&#x2F;traceconv -o traceconvchmod +x traceconv.&#x2F;traceconv [text|json|systrace|profile] [input proto file] [output file] systrace打开空白或者打不开在chrome地址栏中输入”chrome:tracing”，然后点击load按钮load你的trace.html文件 atrace转换到html./systrace.py --from-file 2-1.atrace 结果文件生成2-1.html systrace的类别和选项（直接添加） systrace脚本来源：Android\\Sdk\\platform-tools\\systrace 示例命令：./systrace.py -b 8000 -t 5 –list-categories=&quot;Screen turning on&quot; hal app sched gfx view wm power binder_driver -o systrace.html options 描述 -o &lt; FILE &gt; 输出的目标文件 -t N, –time=N 执行时间，默认5s -b N, –buf-size=N buffer大小（单位kB),用于限制trace总大小，默认无上限 -k &lt; KFUNCS &gt;，–ktrace=&lt; KFUNCS &gt; 追踪kernel函数，用逗号分隔 -a &lt; APP_NAME &gt;,–app=&lt; APP_NAME &gt; 追踪应用包名，用逗号分隔 –from-file=&lt; FROM_FILE &gt; 从文件中创建互动的systrace -e &lt; DEVICE_SERIAL &gt;,–serial=&lt; DEVICE_SERIAL &gt; 指定设备 -l, –list-categories 列举可用的tags category 描述 gfx Graphics input Input view View System webview WebView wm Window Manager am Activity Manager sm Sync Manager audio Audio video Video camera Camera hal Hardware Modules app Application res Resource Loading dalvik Dalvik VM rs RenderScript bionic Bionic C Library power Power Management sched CPU Scheduling irq IRQ Events freq CPU Frequency idle CPU Idle disk Disk I/O mmc eMMC commands load CPU Load sync Synchronization workq Kernel Workqueueszuidi 几个比较常用的模块： sched：CPU调度的信息，非常重要；你能看到CPU在每个时间段在运行什么线程；线程调度情况，比如锁信息 gfx：Graphic系统的相关信息，包括SurfaceFlinger，VSYNC消息，Texture，RenderThread等；分析卡顿非常依赖这个 view：View绘制系统的相关信息，比如onMeasure，onLayout等；对分析卡顿比较有帮助 am：ActivityManager调用的相关信息；用来分析Activity的启动过程比较有效 dalvik： 虚拟机相关信息，比如GC停顿等 binder_driver：Binder驱动的相关信息，如果你怀疑是Binder IPC的问题，不妨打开这个 core_services：SystemServer中系统核心Service的相关信息，分析特定问题用 SElinux权限相关 参考网站程序员大本营selinux scontext表示进程的SContext，u:r:bluetooth:s0，属于bluetooth域； tcontext表示目标的SContext，u:r:system_data_file:s0，属于system_data_file类型; tclass表示进程要操作的ObjectClass，dir表示目录； 自动生成selinux权限代码 过滤avc关键词代码，导入到新文件log.txt 需要安装：policycoreutils 执行命令或区域权限的代码：cat log.txt | grep avc | audit2al 命令执行后生成权限相关代码，然后进行修改，例如下面： 12345#&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; mcd &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;allow mcd sysfs_battery_supply:dir search;allow mcd sysfs_battery_supply:file &#123; read open &#125;;allow mcd sysfs_batteryinfo:dir search;... 开启/关闭Selinux权限12adb shell setenforce 0 &#x2F;&#x2F;设置成permissive模式，临时关闭selinuxadb shell setenforce 1 &#x2F;&#x2F;设置成enforce模式 重启后失效 使用adb shell getenforce查看当前权限状态。 可能返回结果有三种： Disabled代表SELinux被禁用 Permissive代表仅记录安全警告但不阻止可疑行 Enforcing代表记录警告且阻止可疑行为 进入fastbootadb reboot fastboot 或者 adb reboot bootloader LCD屏幕低温残影现象LCD屏幕里的像素发光是由液晶偏转来控制的，而液晶这种材料对温度十分敏感，温度越低，液晶翻转的速度也就越慢，屏幕的响应速度也就会越慢。当画面已经刷新到了下一帧时，液晶还未翻转完成，新生成的画面与未消失的画面错位存在，看上去就像重影一样。 而OLED屏幕的像素点是由一个个单独控制的发光二级管所组成的，低温对其响应速度影响不大，所以单独发光的OLED的响应速度要远高于LCD屏幕。所以OLED屏幕的手机在低温下几乎不会出现拖影的问题。 此外，录屏是录取不到拖影的现象，需要拍视频才能看的到。 makefilemakefile中-D*表示：#define * 如：-DPOSGP730 等价于 #define POSGP730 亮度单位nitnit(尼特),1nit=1坎德拉/平方米[cd/m2] 亮度(L)指物体明暗的程度,定义是单位面积的发光强度,是表示眼睛从某一方向所看到物体反射光的强度。 光学单位lux0.1Lux是指摄像机的照度 Lux是一个光学单位，指的是每平方米的光照亮，可以理解成对光线强度的反应，在同等光线条件下，LUX越小的摄像机感光度越好。 场所/环境 光照度 晴天 30000～300000 lux 晴天室内 100～1000 lux 阴天 3000～10000 lux 阴暗夜晚 0.003～0.0007 lux 夜间路灯 0.1 lux 启动activity/关闭activity1234567891011121314151617&#x2F;&#x2F;使用Action方式打开系统设置-输入法设置adb shell am start -a android.settings.INPUT_METHOD_SETTINGS &#x2F;&#x2F;使用组件名方式启动照相机功能adb shell am start -n com.android.camera&#x2F;.Camera &#x2F;&#x2F;打开拨号界面，并传递一个DATA_URI数据给拨号界面am start -a android.intent.action.CALL -d tel:10086&#x2F;&#x2F;使用ComponentName方式启动一个Serviceadb shell am startservice com.some.package.name&#x2F;.YourServiceSubClassName&#x2F;&#x2F;关闭指定包名的应用程序 adb shell am force-stop com.some.package&#x2F;&#x2F;杀死进程adb shell am kill com.some.package Git命令查看代码提交历史（具体到某一行）git blame SurfaceFlinger.cpp（文件名） 提交代码git push origin HEAD:refs/for/×××Branch 提交草稿代码git push origin HEAD:refs/drafts/×××Branch 提交代码、sync代码报错Agent admitted failure to sign using the key执行：ssh-add ~/.ssh/id_rsa apt-get报错不能进行正常更新 提示错误信息The package lists or status file could not be parsed or opened 解决方法： 12sudo rm -vf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*sudo apt-get update ubuntu自带截图快捷键123456789Alt + Print Screen #截取选中的窗口Shift + Print Screen #自由选区Ctrl + Print Screen #整个桌面Ctrl + Alt + Print Screen #选中的窗口Shift + Ctrl + Print Screen #自由选区 gedit乱码执行：gconftool-2 --set --type=list --list-type=string /apps/gedit-2/preferences/encodings/auto_detected &quot;[UTF-8,CURRENT,GB18030,BIG5-HKSCS,UTF-16]&quot; 跳过开机向导12adb shell settings put secure user_setup_complete 1adb shell settings put global device_provisioned 1 ubuntu快速下载命令axel -n 20 下载链接 谷歌GMS服务 GMS（Google Mobile Service），即谷歌移动服务，是Google提供的移动设备上的一系列应用服务，比如包含Play Sotre，Gmail，YouTube，Chrome，Google Maps等。如果需要预置GMS应用，需要通过Google认证，比如CTS、GTS等跑测。 GMS测试注意事项 如果升级应用到最新版本不再复现，则是应用本身的问题，Google在升级过程中已进行修补 如果仍旧复现，则使用对比机器进行对比验证 常见问题开机向导设置密码后关机再开机黑屏修改方式： 找到frameworks/base/packages/SystemUI/src/com/android/systemui/Keyguard/KeyguardViewMediator.java 找到函数private void doKeyguardLocked(Bundle options) 修改if (!lockedOrMissing &amp;&amp; !provisioned &amp;&amp; !antiTheftLocked) —&gt; if(!lockedOrMissing &amp;&amp; shouldWaitForProvisioning() &amp;&amp; !antiTheftLocked) Play Store无法正常连接 无法登陆Google账户，提示与Google服务器通信时出现问题 如果可以登录Google账户（设置添加Google账户），而不能进入Google Play，可以抓取一份log，搜索关键字CheckinTask，如果出现如下log： E CheckinTask: Checkin failed: https://android.clients.google.com/checkin (request #0): java.io.IOException: Bad Content-Type: text/html; charset=UTF-8 就先检查系统以下属性值的设定是否存在“非法”字符： 1234ro.product.modelro.product.namero.product.devicero.product.board Play Store下载应用失败 从服务器检索信息时出错 (Error retrieving information from server) 可以参考：Google Play商店的各种报错解释以及修复方法 GMS应用首次登陆闪退，第二次正常 闪退问题先Check log中是否收到PACKAGE_CHANGED的广播 查看system log，Google Maps如果有发生package changed，这是厂商的Maps版本比较旧，开机后联网情况下会自动从server升级造成process kill，属于正常的行为。关键log如下： 123V ActivityManager: Broadcast: Intent &#123; act&#x3D;android.intent.action.PACKAGE_CHANGED dat&#x3D;package:com.google.android.apps.maps flg&#x3D;0x4000010 (has extras) &#125; ordered&#x3D;false userid&#x3D;0 callerApp&#x3D;nullI ActivityManager: Force stopping com.google.android.apps.maps appid&#x3D;10060 user&#x3D;0: pkg changedI ActivityManager: Killing 6004:com.google.android.apps.maps&#x2F;u0a60 (adj 0): stop com.google.android.apps.maps GMS应用缺少部分菜单如果系统分区太小，会拿掉一些feature，你可以尝试更大的RAM size，比如1GB或更大。 GMS部分应用联网后消失GMS中部分应用有地域使用限制，Play Books, Play Magazine, Play Movies等应用目前不支持在中国大陆这边使用，所以联网后应用会自己屏蔽掉，此为正常现象。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"数据结构之二叉树","slug":"2021/210528_cpp_DataStructure4","date":"2021-05-28T14:05:00.000Z","updated":"2021-05-28T12:16:51.908Z","comments":true,"path":"2021/05/28/2021/210528_cpp_DataStructure4/","link":"","permalink":"https://alonealive.github.io/Blog/2021/05/28/2021/210528_cpp_DataStructure4/","excerpt":"包含树、二叉树、哈希表、二分查找的定义和实现","text":"包含树、二叉树、哈希表、二分查找的定义和实现 树定义树（Tree）是 n（n≥0）个结点的有限集 T，当 T 为空时称为空树，否则它满足以下两个条件： 有且仅有一个特定的数据元素称为根（root）的结点，根结点没有前驱结点 其余的结点可分为m（m＞0）个互不相交的子集Tl, T2,…, Tm，其中每个集合Ti（1≤i≤m）本身又是一棵树，并称其为根的子树（subtree） 树的递归定义刻画了树的固有特性：一棵非空树是由若干棵子树构成的，而子树又可由若干棵更小的子树构成。因此，树结构的很多算法都使用了递归方法 基本术语 结点的度（degree）：结点拥有的子树数 叶子（终端结点）：度为0的结点 非终端结点：度不为0的结点 结点的层次：树中根结点的层次为1，其子树的根为第2层，其余类推 树的度：树中所有结点的最大度数 树的深度：树中所有结点层次的最大值 有序树、无序树：如果树中每棵子树从左向右的排列拥有一定的顺序，不得互换，则称为有序树；否则称为无序树 森林：m（m≥0）棵互不相交的树的集合 在树结构中，结点之间的关系又可用家族关系描述，定义如下： 孩子、双亲：结点子树的根称为这个结点的孩子，而这个结点又被称为孩子的双亲（父结点、子结点） 子孙：以某结点为根的子树中的所有结点都被称为是该结点的子孙 祖先：从根结点到该结点路径上的所有结点 兄弟：同一个双亲的孩子之间互为兄弟 堂兄弟：双亲在同一层的结点互为堂兄弟 树的遍历 之所以叫前序、中序、后序遍历，是因为根节点在前、中、后 前序：根左右；中序：左根右；后序：左右根； 中序常用来在二叉搜索数中得到递增的有序序列； 后序可用于数学中的后缀表示法，结合栈处理表达式，每遇到一个操作符，就可以从栈中弹出栈顶的两个元素，计算并将结果返回到栈中； 先序遍历首先访问根节点，然后遍历左子树，最后遍历右子树 中序遍历先遍历左子树，然后访问根节点，然后遍历右子树。 后序遍历先遍历左子树，然后遍历右子树，最后访问树的根节点 森林遍历根据森林和树相互递归的定义，可推出森林的两种遍历方法： 先序遍历森林： 访问森林中第一棵树的根结点； 先序遍历第一棵树中根结点的子树森林； 先序遍历除去第一棵树之后剩余的树构成的森林 后序遍历森林： 后序遍历森林中第一棵树的根结点的子树森林； 访问第一棵树的根结点； 后序遍历除去第一棵树之后剩余的树构成的森林。 上面的森林进行先序遍历和后序遍历，分别得到森林的先序序列为1 23 4 5 6 7 8 9 10 11 12，后序序列为5 2 3 4 1 8 9 7 6 12 11 10 二叉树定义一棵二叉树（binary tree）是结点的一个有限集合，该集合或者为空，或者由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。 五种基本形态： 性质 在二叉树的第i层上至多有$2^{i-1}$个结点（i≥1） 深度为k的二叉树至多有$2^{k-1}$个结点（k≥1） 对任意一棵非空二叉树T，若其叶结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$（根节点加上其他度为2的结点树） 具有n个结点的完全二叉树的深度为$[log_2n]+1$ 证明：设完全二叉树的深度为k，由它的定义和性质可知2k-1-1＜n≤2k-1 或2k-l≤n＜2k，取对数后有k-1≤log2n＜k，因为k是整数，所以k = log2n || +1（或者） 如果将一棵有 n个结点的完全二叉树（其深度为log n||2+）自顶向下、同一1层自左向右编号为1, 2, 3,…, n，则对任意一个结点i（1≤i≤n）有：① 如果i = 1，则此结点为二叉树的根，无双亲；如果 i＞1，则其双亲结点是floor(i/2)。② 如果2i＞n，则结点 i无左孩子（结点 i 为叶子结点）；否则其左孩子是结点2i。③ 如果2i+1＞n，则结点 i 无右孩子；否则其右孩子是结点2i+1 满二叉树和完全二叉树 满二叉树（full binarytree）是指深度为k，且有2k-1个结点的二叉树。特点是，每一层上结点数都是最大结点数，即不存在度为1的结点 完全二叉树（completed binary tree）是指深度为k，有n个结点的二叉树，除最后一层外，其余层均是满的，且最下面一层的结点都集中在最左边的位置上 层序遍历层序遍历就是逐层遍历树结构。 广度优先搜索是一种广泛运用在树或图这类数据结构中，遍历或搜索的算法。 该算法从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。 当我们在树中进行广度优先搜索时，我们访问的节点的顺序是按照层序遍历顺序的。 二叉树的层序遍历实现12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; //创建返回数组 vector&lt;vector&lt;int&gt;&gt; ans; //创建队列 queue&lt;TreeNode*&gt; que; //若空 if(root == nullptr) return ans; //根节点压入队列 que.push(root); //若队列不为空，循环 while(!que.empty())&#123; //当前队列长度 int queLen = que.size(); ans.push_back(vector&lt;int&gt;()); //循环遍历当前层所有节点 for(int i = 0; i &lt; queLen; ++i)&#123; //选择节点 auto node = que.front(); //选择的当前节点弹出队列 que.pop(); //将选择的当前节点的值压入数组 ans.back().push_back(node-&gt;val); //寻找当前节点的下一层节点压入队列 if(node-&gt;left) que.push(node-&gt;left); if(node-&gt;right) que.push(node-&gt;right); &#125; &#125; return ans; &#125;&#125;; 二叉搜索树二叉搜索树（BST）是二叉树的一种特殊表示形式，它满足如下特性： 每个节点中的值必须大于（或等于）存储在其左侧子树中的任何值 每个节点中的值必须小于（或等于）存储在其右子树中的任何值 哈希表哈希表是一种数据结构，它使用哈希函数组织数据，以支持快速插入和搜索 哈希函数：将结点的关键字与它的存储位置之间建立一种对应关系的函数称为哈希函数。 哈希表：根据设定的哈希函数h(key)和处理冲突的方法将一组关键字映射到一个有限的连续地址区间上，这样的表称为哈希表，这一映射过程称为哈希造表或散列，所得的存储位置称为哈希地址或散列地址 冲突（collision）：不同的关键字映射到同一哈希地址的现象称为冲突 同义词（synonym）：在一个哈希函数中，具有相同函数值的关键字，互称为同义词。 有两种不同类型的哈希表：哈希集合和哈希映射。 哈希集合是集合数据结构的实现之一，用于存储非重复值。 哈希映射是映射 数据结构的实现之一，用于存储(key, value)键值对。 在标准模板库的帮助下，哈希表是易于使用的 原理哈希表的关键思想是使用哈希函数将键映射到存储桶。更确切地说， 当我们插入一个新的键时，哈希函数将决定该键应该分配到哪个桶中，并将该键存储在相应的桶中； 当我们想要搜索一个键时，哈希表将使用相同的哈希函数来查找对应的桶，并只在特定的桶中进行搜索。 例如我们使用$y = x ％ 5$作为哈希函数，然后完成插入和搜索策略： 插入：我们通过哈希函数解析键，将它们映射到相应的桶中。例如，1987分配给桶2，而24分配给桶4 搜索：我们通过相同的哈希函数解析键，并仅在特定存储桶中搜索。如果我们搜索 1987，我们将使用相同的哈希函数将1987 映射到 2。因此我们在桶 2 中搜索，我们在那个桶中成功找到了 1987。例如，如果我们搜索23，将映射23到3，并在桶3中搜索。我们发现23不在桶3中，这意味着23不在哈希表中。 哈希集用法1234567891011121314151617181920212223242526272829#include &lt;unordered_set&gt; // 0. include the libraryint main() &#123; // 1. initialize a hash set unordered_set&lt;int&gt; hashset; // 2. insert a new key hashset.insert(3); hashset.insert(2); hashset.insert(1); // 3. delete a key hashset.erase(2); // 4. check if the key is in the hash set if (hashset.count(2) &lt;= 0) &#123; cout &lt;&lt; \"Key 2 is not in the hash set.\" &lt;&lt; endl; &#125; // 5. get the size of the hash set cout &lt;&lt; \"The size of hash set is: \" &lt;&lt; hashset.size() &lt;&lt; endl; // 6. iterate the hash set for (auto it = hashset.begin(); it != hashset.end(); ++it) &#123; cout &lt;&lt; (*it) &lt;&lt; \" \"; &#125; cout &lt;&lt; \"are in the hash set.\" &lt;&lt; endl; // 7. clear the hash set hashset.clear(); // 8. check if the hash set is empty if (hashset.empty()) &#123; cout &lt;&lt; \"hash set is empty now!\" &lt;&lt; endl; &#125;&#125; 使用哈希集查重1234567891011121314/* * Template for using hash set to find duplicates. */bool findDuplicates(vector&lt;Type&gt;&amp; keys) &#123; // Replace Type with actual type of your key unordered_set&lt;Type&gt; hashset; for (Type key : keys) &#123; if (hashset.count(key) &gt; 0) &#123; return true; &#125; hashset.insert(key); &#125; return false;&#125; 哈希映射用法 哈希集合只能存储值。另一方面，哈希映射是映射的一种实现，它能够存储 (key,value) 键值对 由于能够存储更多信息，哈希映射可以帮助我们解决更复杂的问题。 例如，我们可以使用哈希映射按键聚合所有信息，并在平均为常量的时间内查找与特定键相关的信息。 123456789101112131415161718192021222324252627282930313233#include &lt;unordered_map&gt; // 0. include the libraryint main() &#123; // 1. initialize a hash map unordered_map&lt;int, int&gt; hashmap; // 2. insert a new (key, value) pair hashmap.insert(make_pair(0, 0)); //make_pair无需标明类型即可生成一个pair对象 hashmap.insert(make_pair(2, 3)); // 3. insert a new (key, value) pair or update the value of existed key hashmap[1] = 1; hashmap[1] = 2; // 4. get the value of a specific key cout &lt;&lt; \"The value of key 1 is: \" &lt;&lt; hashmap[1] &lt;&lt; endl; // 5. delete a key hashmap.erase(2); // 6. check if a key is in the hash map if (hashmap.count(2) &lt;= 0) &#123; cout &lt;&lt; \"Key 2 is not in the hash map.\" &lt;&lt; endl; &#125; // 7. get the size of the hash map cout &lt;&lt; \"the size of hash map is: \" &lt;&lt; hashmap.size() &lt;&lt; endl; // 8. iterate the hash map for (auto it = hashmap.begin(); it != hashmap.end(); ++it) &#123; cout &lt;&lt; \"(\" &lt;&lt; it-&gt;first &lt;&lt; \",\" &lt;&lt; it-&gt;second &lt;&lt; \") \"; &#125; cout &lt;&lt; \"are in the hash map.\" &lt;&lt; endl; // 9. clear the hash map hashmap.clear(); // 10. check if the hash map is empty if (hashmap.empty()) &#123; cout &lt;&lt; \"hash map is empty now!\" &lt;&lt; endl; &#125;&#125; 二分查找它描述了在有序集合中搜索特定值的过程。 二分查找中使用的术语： 目标 Target —— 你要查找的值 索引 Index —— 你要查找的当前位置 左、右指示符 Left，Right —— 我们用来维持查找空间的指标 中间指示符 Mid —— 我们用来应用条件来确定我们应该向左查找还是向右查找的索引 三步骤二分查找一般由三个主要部分组成： 预处理 —— 如果集合未排序，则进行排序 二分查找 —— 使用循环或递归在每次比较后将查找空间划分为两半 后处理 —— 在剩余空间中确定可行的候选者 二分查找代码模板查找单个索引 二分查找的最基础和最基本的形式 用于查找可以通过访问数组中的单个索引来确定的元素或条件 二分查找的最基础和最基本的形式。 查找条件可以在不与元素的两侧进行比较的情况下确定（或使用它周围的特定元素）。 不需要后处理，因为每一步中，你都在检查是否找到了元素。如果到达末尾，则知道未找到该元素。 12345678910111213141516int binarySearch(vector&lt;int&gt;&amp; nums, int target)&#123; if(nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while(left &lt;= right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid - 1; &#125; &#125; // End Condition: left &gt; right return -1;&#125; 查找索引及其右邻居索引 用于查找需要访问数组中当前索引及其直接右邻居索引的元素或条件 一种实现二分查找的高级方法。 查找条件需要访问元素的直接右邻居。 使用元素的右邻居来确定是否满足条件，并决定是向左还是向右。 保证查找空间在每一步中至少有2个元素。 需要进行后处理。当你剩下1个元素时，循环/递归结束。需要评估剩余元素是否符合条件。 123456789101112131415161718int binarySearch(vector&lt;int&gt;&amp; nums, int target)&#123; if(nums.size() == 0) return -1; int left = 0, right = nums.size(); while(left &lt; right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if(nums[mid] == target)&#123; return mid; &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; //右邻居 &#125; // Post-processing: // End Condition: left == right if(left != nums.size() &amp;&amp; nums[left] == target) return left; return -1;&#125; 查找索引及其左右邻居索引 用于搜索需要访问当前索引及其在数组中的直接左右邻居索引的元素或条件。 实现二分查找的另一种方法。 搜索条件需要访问元素的直接左右邻居。 使用元素的邻居来确定它是向右还是向左。 保证查找空间在每个步骤中至少有 3 个元素。 需要进行后处理。当剩下2个元素时，循环/递归结束。需要评估其余元素是否符合条件。 1234567891011121314151617181920212223int binarySearch(vector&lt;int&gt;&amp; nums, int target)&#123; if (nums.size() == 0) return -1; int left = 0, right = nums.size() - 1; while (left + 1 &lt; right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1;&#125; 例子给定一个n个元素有序的（升序）整型数组nums和一个目标值target，写一个函数搜索nums中的target，如果目标值存在返回下标，否则返回-1 12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.empty()) return -1; int left=0; int right=nums.size()-1; while(left&lt;=right)&#123; int mid = left + (right-left)/2; //中间值 if(nums[mid]&gt;target)&#123; right=mid-1; //右边界重新赋值 &#125; else if(nums[mid]&lt;target)&#123; left=mid+1; &#125; else&#123; return mid; &#125; &#125; return -1; &#125;&#125;; 参考 leetcode-二叉树 数据结构：图（Graph） leetcode-哈希表 leetcode-二分查找 leetcode-二叉搜索树 《数据结构（C++语言版）》","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"},{"name":"datastructure","slug":"datastructure","permalink":"https://alonealive.github.io/Blog/tags/datastructure/"}]},{"title":"数据结构之栈和队列","slug":"2021/210519_cpp_DataStructure3","date":"2021-05-19T11:49:00.000Z","updated":"2021-05-27T14:33:06.866Z","comments":true,"path":"2021/05/19/2021/210519_cpp_DataStructure3/","link":"","permalink":"https://alonealive.github.io/Blog/2021/05/19/2021/210519_cpp_DataStructure3/","excerpt":"栈和队列以及相关代码实现（阅读《数据结构（C++语言版）》及leetcode课题）","text":"栈和队列以及相关代码实现（阅读《数据结构（C++语言版）》及leetcode课题） FIFO（先入先出数据结构） FIFO数据结构中，将首先处理添加到队列中的第一个元素。 队列是典型的FIFO数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。删除（delete）操作也被称为出队（dequeue)。你只能移除第一个元素。 队列实现为了实现队列，可以使用动态数组和指向队列头部的索引。 队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点 以下是简单的代码实现，但是某些场景效率会很低。随着起始指针的移动，会造成更多的空间浪费。 cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;class MyQueue &#123; private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() &#123;p_start = 0;&#125; /** Insert an element into the queue. Return true if the operation is successful. */ //入队增加元素 bool enQueue(int x) &#123; data.push_back(x); return true; &#125; /** Delete an element from the queue. Return true if the operation is successful. */ //出队删除一个元素 bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; p_start++; //队列头部索引后移 return true; &#125;; /** Get the front item from the queue. */ //队列第一个元素 int Front() &#123; return data[p_start]; &#125;; /** Checks whether the queue is empty or not. */ //判断是否为空 bool isEmpty() &#123; return p_start &gt;= data.size(); &#125;&#125;;int main() &#123; MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125; q.deQueue(); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125; q.deQueue(); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125;&#125; java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// \"static void main\" must be defined in a public class.class MyQueue &#123; // store elements private List&lt;Integer&gt; data; // a pointer to indicate the start position private int p_start; public MyQueue() &#123; data = new ArrayList&lt;Integer&gt;(); p_start = 0; &#125; /** Insert an element into the queue. Return true if the operation is successful. */ public boolean enQueue(int x) &#123; data.add(x); return true; &#125;; /** Delete an element from the queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty() == true) &#123; return false; &#125; p_start++; return true; &#125; /** Get the front item from the queue. */ public int Front() &#123; return data.get(p_start); &#125; /** Checks whether the queue is empty or not. */ public boolean isEmpty() &#123; return p_start &gt;= data.size(); &#125; &#125;;public class Main &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); q.enQueue(5); q.enQueue(3); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; q.deQueue(); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; q.deQueue(); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; &#125;&#125; 循环队列上面的方式简单但是低效。 更有效的方法是使用循环队列。具体来说，就是使用固定大小的数组和两个指针来指示起始位置和结束位置 目的是重用我们之前提到的被浪费的存储。 定义和接口 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k Front: 从队首获取元素。如果队列为空，返回 -1 Rear: 获取队尾元素。如果队列为空，返回 -1 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真 isEmpty(): 检查循环队列是否为空 isFull(): 检查循环队列是否已满 cpp实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class MyCircularQueue &#123;private: int queue[1000] = &#123;0&#125;; //假设值范围在0-1000内 int k = 0; //队列长度 int head = 0; //头指针 int end = -1; //尾指针 int count = 0; public: MyCircularQueue(int k) &#123; this-&gt;k = k; &#125; //入队 bool enQueue(int value) &#123; if (count &lt; k) &#123; count++; //当前入队元素数量，判断队列是否已满 end = (end + 1) % k; //取余，注意end初始化是-1 queue[end] = value; return true; &#125; return false; &#125; //出队 bool deQueue() &#123; if (count == 0) &#123; return false; &#125; count--; //队列元素减一 head = (head + 1) % k; //队列元素后移，即第一次更新是1（移除了下标为0的元素） return true; &#125; int Front() &#123; if (count == 0) &#123; return -1; &#125; return queue[head]; //队首元素 &#125; int Rear() &#123; if (count == 0) &#123; return -1; &#125; return queue[end]; //获取队尾元素 &#125; bool isEmpty() &#123; if (count == 0) &#123; //队列元素是0，即空队列 return true; &#125; return false; &#125; bool isFull() &#123; if (count == k) &#123; //队列已满 return true; &#125; return false; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&gt;enQueue(value); * bool param_2 = obj-&gt;deQueue(); * int param_3 = obj-&gt;Front(); * int param_4 = obj-&gt;Rear(); * bool param_5 = obj-&gt;isEmpty(); * bool param_6 = obj-&gt;isFull(); */int main() &#123; MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 return 0;&#125; Leetcode实现方式-C++ 在循环队列中，我们使用一个数组和两个指针（head 和 tail）。 head 表示队列的起始位置，tail 表示队列的结束位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyCircularQueue &#123;private: vector&lt;int&gt; data; int head; int tail; int size;public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; data.resize(k); //重置size head = -1; tail = -1; size = k; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) &#123; if (isFull()) &#123; return false; &#125; if (isEmpty()) &#123; head = 0; &#125; tail = (tail + 1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head + 1) % size; return true; &#125; /** Get the front item from the queue. */ int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ int Rear() &#123; if (isEmpty()) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ bool isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ bool isFull() &#123; return ((tail + 1) % size) == head; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * bool param_1 = obj.enQueue(value); * bool param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * bool param_5 = obj.isEmpty(); * bool param_6 = obj.isFull(); */ Leetcode实现方式-Java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyCircularQueue &#123; private int[] data; private int head; private int tail; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) &#123; data = new int[k]; head = -1; tail = -1; size = k; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) &#123; if (isFull() == true) &#123; return false; &#125; if (isEmpty() == true) &#123; head = 0; &#125; tail = (tail + 1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty() == true) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head + 1) % size; return true; &#125; /** Get the front item from the queue. */ public int Front() &#123; if (isEmpty() == true) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ public int Rear() &#123; if (isEmpty() == true) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ public boolean isFull() &#123; return ((tail + 1) % size) == head; &#125;&#125;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * boolean param_1 = obj.enQueue(value); * boolean param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * boolean param_5 = obj.isEmpty(); * boolean param_6 = obj.isFull(); */ ☆内置队列库大多数流行语言都提供内置的队列库，因此您无需重新发明轮子。 队列有两个重要的操作，入队 enqueue 和出队 dequeue。 此外，我们应该能够获得队列中的第一个元素，因为应该首先处理它。 cpp123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; // 1. Initialize a queue. queue&lt;int&gt; q; // 2. Push new element. q.push(5); q.push(13); q.push(8); q.push(6); // 3. Check if queue is empty. if (q.empty()) &#123; cout &lt;&lt; \"Queue is empty!\" &lt;&lt; endl; return 0; &#125; // 4. Pop an element.移除一个元素 q.pop(); // 5. Get the first element.获取第一个元素 cout &lt;&lt; \"The first element is: \" &lt;&lt; q.front() &lt;&lt; endl; // 6. Get the last element.获取最后一个元素 cout &lt;&lt; \"The last element is: \" &lt;&lt; q.back() &lt;&lt; endl; // 7. Get the size of the queue.长度 cout &lt;&lt; \"The size is: \" &lt;&lt; q.size() &lt;&lt; endl;&#125; java1234567891011121314151617181920// \"static void main\" must be defined in a public class.public class Main &#123; public static void main(String[] args) &#123; // 1. Initialize a queue. Queue&lt;Integer&gt; q = new LinkedList(); // 2. Get the first element - return null if queue is empty. System.out.println(\"The first element is: \" + q.peek()); // 3. Push new element. q.offer(5); q.offer(13); q.offer(8); q.offer(6); // 4. Pop an element. q.poll(); // 5. Get the first element. System.out.println(\"The first element is: \" + q.peek()); // 7. Get the size of the queue. System.out.println(\"The size is: \" + q.size()); &#125;&#125; LIFO（后入先出数据结构） 参考：leetcode-后入先出的数据结构 在LIFO数据结构中，将首先处理添加到队列中的最新元素。 与队列不同，栈是一个LIFO数据结构。通常，插入操作在栈中被称作入栈push。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈pop，将始终删除队列中相对于它的最后一个元素 栈定义和实现 栈是限制在表的一端进行插入和删除的线性表。表中允许插入、删除的这一端称为栈顶，栈顶的当前位置是动态变化的；不允许插入和删除的另一端称为栈底，栈底是固定不变的。当表中没有元素时称为空栈。栈的插入运算称为进栈、压栈或入栈，栈的删除运算称为退栈或出栈。 cpp12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack &#123; private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) &#123; data.push_back(x); &#125; /** Checks whether the queue is empty or not. */ bool isEmpty() &#123; return data.empty(); &#125; /** Get the top item from the queue. */ int top() &#123; return data.back(); &#125; /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() &#123; if (isEmpty()) &#123; return false; &#125; data.pop_back(); return true; &#125;&#125;;int main() &#123; MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) &#123; if (!s.isEmpty()) &#123; cout &lt;&lt; s.top() &lt;&lt; endl; &#125; cout &lt;&lt; (s.pop() ? \"true\" : \"false\") &lt;&lt; endl; &#125;&#125; java123456789101112131415161718192021222324252627282930313233343536373839404142// \"static void main\" must be defined in a public class.class MyStack &#123; private List&lt;Integer&gt; data; // store elements public MyStack() &#123; data = new ArrayList&lt;&gt;(); &#125; /** Insert an element into the stack. */ public void push(int x) &#123; data.add(x); &#125; /** Checks whether the queue is empty or not. */ public boolean isEmpty() &#123; return data.isEmpty(); &#125; /** Get the top item from the queue. */ public int top() &#123; return data.get(data.size() - 1); &#125; /** Delete an element from the queue. Return true if the operation is successful. */ public boolean pop() &#123; if (isEmpty()) &#123; return false; &#125; data.remove(data.size() - 1); return true; &#125;&#125;;public class Main &#123; public static void main(String[] args) &#123; MyStack s = new MyStack(); s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) &#123; if (!s.isEmpty()) &#123; System.out.println(s.top()); &#125; System.out.println(s.pop()); &#125; &#125;&#125; ☆内置栈库cpp12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 1. Initialize a stack. stack&lt;int&gt; s; // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty()) &#123; cout &lt;&lt; \"Stack is empty!\" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. cout &lt;&lt; \"The top element is: \" &lt;&lt; s.top() &lt;&lt; endl; // 6. Get the size of the stack. cout &lt;&lt; \"The size is: \" &lt;&lt; s.size() &lt;&lt; endl;&#125; java1234567891011121314151617181920212223// \"static void main\" must be defined in a public class.public class Main &#123; public static void main(String[] args) &#123; // 1. Initialize a stack. Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty() == true) &#123; System.out.println(\"Stack is empty!\"); return; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. System.out.println(\"The top element is: \" + s.peek()); // 6. Get the size of the stack. System.out.println(\"The size is: \" + s.size()); &#125;&#125; 栈的存储与一般的线性表的存储类似，主要有两种存储方式：顺序存储和链式存储。 顺序栈 利用顺序存储方式实现的栈称为顺序栈。类似于顺序表的定义，要分配一块连续的存储空间存放栈中的元素，栈底位置可以固定地设置在数组的任何一端（一般在下标为0的一端），而栈顶是随着插入和删除而变化的，再用一个变量指明当前栈顶的位置（实际上是栈顶元素的下一个位置） 类描述： 1234567891011121314151617181920212223242526typedef int DataType;class SeqStack &#123;private: DataType *base; //栈底指针 DataType *top; //栈顶指针，始终指向栈顶元素的后一个位置 int size; //栈大小public: //构造一个空栈 SeqStack(int stacksize=100) &#123; base = new DataType[stacksize]; top=base; //只想栈顶元素的后一个位置 size=stacksize; &#125; //销毁一个已存在的栈 ~SeqStack() &#123; delete[] base; top=NULL; base=NULL; &#125; int Empty_Stack(); //判断栈是否为空 int Push_Stack(DataType e); //将元素e插入栈顶 int Pop_Stack(DataType &amp;e); //从栈顶删除一个元素到e中返回 int GetTop_Stack(DataType &amp;e); //从栈顶取出一个元素到e中返回&#125;; 基本运算判断栈是否为空算法思想：判断top是否小于等于base，小于等于则为空栈，返回1，否则返回0 123int SeqStack::Empty_Stack() &#123; return((top &lt;= base));&#125; 入栈入栈操作是在栈的顶部进行插入操作，相当于在顺序表的表尾进行插入，因而无须移动元素。 算法思想：首先判断栈是否已满，若满则失败，返回0；否则，由于栈的top 指向栈顶元素的后一个位置，将入栈元素赋到top的位置，再将top+1指向新的位置，成功返回1 123456789int SeqStack::Push_Stack(DataType e) &#123; if ((top-base) &lt; size) &#123; //是否栈满 *top = e; top++; return 1; &#125; else &#123; return 0; &#125;&#125; 出栈出栈操作是在栈的顶部进行删除操作，相当于在顺序表的表尾进行删除，因而也无须移动元素。 算法思想：首先判断栈是否为空，若空则失败，返回0；否则，由于栈的top 指向栈顶元素的后一位置，要先修改top为top-1，再将其所指向的元素以引用参数e返回，成功返回1。 123456789int SeqStack::Pop_Stack(DataType &amp;e) &#123; if (top &gt; base) &#123; //是否栈为空 top--; e = *top; return 1; &#125; else &#123; return 0; &#125;&#125; 取栈顶元素操作取栈顶元素是获取出栈顶元素的值，而不改变栈。 算法思想：首先判断栈是否为空，若空则失败，返回0；否则，由于栈的top 指向栈顶元素的后一位置，返回top-1所指单元的值，栈不发生变化。 12345678int SeqStack::Get_Stack(DataType &amp;e) &#123; if (top &gt; base) &#123; //是否栈为空 e = *(top-1); return 1; &#125; else &#123; return 0; &#125;&#125; 链栈 用链式存储结构的栈，节点结构和单链表相同 因为栈中的主要运算是在栈顶进行插入和删除操作，显然在单链表的表头插入和删除都比较方便 因此以其作为栈顶，而且没有必要像单链表那样为了运算方便而附加一个头结点 12345678910111213141516171819202122232425262728293031typedf int DataType;class StackNode &#123; public: DataType data; StackNode *next; StackNode() &#123; next = NULL; &#125;;&#125;class LinkStack &#123; private: StackNode *top; public: LinkStack() &#123; top = NULL; &#125; ~LinkStack() &#123; while(top) &#123; p = top; top = top-&gt;next; delete p; &#125; top = NULL; &#125; int Empty_Stack(); //判空 int Push_Stack(DataType e); //将元素e插入栈顶 int Pop_Satck(DataType &amp;e); //从栈顶删除一个元素到e中返回 int GetTop_Stack(DataType &amp;e); //从栈顶去除元素到e中返回&#125;； 参考 Leetcode-队列&amp;栈","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"},{"name":"datastructure","slug":"datastructure","permalink":"https://alonealive.github.io/Blog/tags/datastructure/"}]},{"title":"数据结构之链表","slug":"2021/210516_cpp_DataStructure2","date":"2021-05-16T10:05:00.000Z","updated":"2021-05-27T14:33:03.130Z","comments":true,"path":"2021/05/16/2021/210516_cpp_DataStructure2/","link":"","permalink":"https://alonealive.github.io/Blog/2021/05/16/2021/210516_cpp_DataStructure2/","excerpt":"链表基本运算实现以及快慢指针应用","text":"链表基本运算实现以及快慢指针应用 单链表 单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。 单链表中的节点应该具有两个属性：val和next。 val是当前节点的值 next 是指向下一个节点的指针/引用 如果要使用双向链表，则还需要一个属性prev以指示链表中的上一个节点。 定义： 123456// Definition for singly-linked list.struct SinglyListNode &#123; int val; SinglyListNode *next; SinglyListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 函数功能 get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 C++函数实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class MyLinkedList &#123;public: /** Initialize your data structure here. */ MyLinkedList() &#123; size = 0; head = nullptr; &#125; /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ int get(int index) &#123; if(index &gt;= size || index &lt; 0 || head == nullptr) &#123; return -1; &#125; SinglyListNode *temp = head; //从第一个节点开始 for (int i = 0;i &lt; index; ++i) &#123; temp = temp-&gt;next; //遍历查找 &#125; return temp-&gt;val; //返回该index的val值 &#125; /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ void addAtHead(int val) &#123; SinglyListNode *temp = new SinglyListNode(val); //new一个val值的结点 temp-&gt;next = head; //加在链表第一个元素之前 temp = nullptr; size++; &#125; /** Append a node of value val to the last element of the linked list. */ void addAtTail(int val) &#123; if (size == 0) &#123; head = new SinglyListNode(val); //新建第一个结点 ++size; &#125; SinglyListNode *find = head; while (find-&gt;next != nullptr) &#123; find = find-&gt;next; //遍历到最后一个结点 &#125; SinglyListNode *temp = new SinglyListNode(val); find-&gt;next = temp; //最后一个节点的指针指向需要添加的这个元素 size++; &#125; /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ void addAtIndex(int index, int val) &#123; if (index &gt; size) return; if (index &lt;= 0) &#123; addAtHead(val); //添加为第一个元素之前 return; &#125; SinglyListNode *pr = head; for (int i = 0;i &lt; index-1; ++i) &#123; pr = pr-&gt;next; &#125; SinglyListNode *cur = new SinglyListNode(val); cur-&gt;next = pr-&gt;next; //插入到查找到的index前面 pr-&gt;next = cur; size++; &#125; /** Delete the index-th node in the linked list, if the index is valid. */ void deleteAtIndex(int index) &#123; if (index &gt; size) return; if (index &lt; 0) return; if (index == 0) &#123; head = head-&gt;next; size--; return; &#125; SinglyListNode *del = head; for (int i = 0;i &lt; index-1; ++i) &#123; del = del-&gt;next; &#125; del-&gt;next = del-&gt;next-&gt;next; size--; &#125; /* 打印链表 */ void print() &#123; if (size == 0) &#123; cout &lt;&lt; \"empty\" &lt;&lt;endl; &#125; SinglyListNode *pr = head; for(int i=0; i&lt;size; ++i) &#123; cout &lt;&lt; \"Node \" &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; pr-&gt;val &lt;&lt;endl; pr = pr-&gt;next; &#125; &#125; ~MyLinkedList() &#123; size = 0; head = nullptr; &#125;private: struct SinglyListNode &#123; int val; SinglyListNode *next; SinglyListNode(int x) : val(x), next(nullptr) &#123;&#125; &#125;; int size; SinglyListNode* head;&#125;;/** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj-&gt;get(index); * obj-&gt;addAtHead(val); * obj-&gt;addAtTail(val); * obj-&gt;addAtIndex(index,val); * obj-&gt;deleteAtIndex(index); */ //new对象，调用方法MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 C++的i++和++ii++ ：先引用后增加，先在i所在的表达式中使用i的当前值，后让i加1 ++i ：先增加后引用，让i先加1，然后在i所在的表达式中使用i的新值 即： ++i是将i的值先+1，然后返回i的值 i++是先将i的值存到寄存器里，然后执行i+1，然后返回寄存器里的值。 链表双指针模板（快慢指针java&amp;cpp）快慢指针可用于环形链表、相交链表的查询等运算 注意以下点： 在调用 next 字段之前，始终检查节点是否为空。获取空节点的下一个节点将导致空指针错误。例如，在我们运行fast = fast.next.next之前，需要检查fast和fast.next不为空 仔细定义循环的结束条件 C++语言版 123456789101112131415// Initialize slow &amp; fast pointersListNode* slow = head;ListNode* fast = head;/** * Change this condition to fit specific problem. * Attention: remember to avoid null-pointer error **/while (slow &amp;&amp; fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; // move slow pointer one step each time fast = fast-&gt;next-&gt;next; // move fast pointer two steps each time if (slow == fast) &#123; // change this condition to fit specific problem return true; &#125;&#125;return false; // change return value to fit specific problem Java语言： 123456789101112131415// Initialize slow &amp; fast pointersListNode slow = head;ListNode fast = head;/** * Change this condition to fit specific problem. * Attention: remember to avoid null-pointer error **/while (slow != null &amp;&amp; fast != null &amp;&amp; fast.next != null) &#123; slow = slow.next; // move slow pointer one step each time fast = fast.next.next; // move fast pointer two steps each time if (slow == fast) &#123; // change this condition to fit specific problem return true; &#125;&#125;return false; // change return value to fit specific problem 在环形链表的查找循环中，假设我们每次移动较快的指针 2 步，每次移动较慢的指针 1 步： 如果没有循环，快指针需要 N/2 次才能到达链表的末尾，其中 N 是链表的长度。 如果存在循环，则快指针需要 M 次才能赶上慢指针，其中 M 是列表中循环的长度 显然，M &lt;= N。所以我们将循环运行N次。该算法的时间复杂度总共为O(N) 参考 leetcode-链表 链表设计实现详解 C++的i++和++i详解","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"},{"name":"datastructure","slug":"datastructure","permalink":"https://alonealive.github.io/Blog/tags/datastructure/"}]},{"title":"数据结构之时间复杂度和线性表","slug":"2021/210514_cpp_DataStructure1","date":"2021-05-14T12:49:00.000Z","updated":"2021-05-22T11:29:40.821Z","comments":true,"path":"2021/05/14/2021/210514_cpp_DataStructure1/","link":"","permalink":"https://alonealive.github.io/Blog/2021/05/14/2021/210514_cpp_DataStructure1/","excerpt":"《数据结构（C++语言版）》书，关于数据结构再读记录。主要包含数据结构的基本概念、算法概念、时间复杂度、线性表（顺序表&amp;链表）","text":"《数据结构（C++语言版）》书，关于数据结构再读记录。主要包含数据结构的基本概念、算法概念、时间复杂度、线性表（顺序表&amp;链表） 基本概念术语 数据（Data）：对客观事物的符号表示，它能被计算机识别、存储和加工处理。含义广泛，声音、图像、视频都属于数据的范畴。 数据元素（Data Element）：数据的基本单位，有时也称为元素、结点、顶点、记录。 数据项：一个数据元素可能由若干数据项（Data Item）组成。数据项是最小标识单位，有时也称为字段、域或属性。数据元素也可以仅有一个数据项。 数据结构（Data Structure）：指数据元素之间的相互关系，即数据的组织形式。一般包含三方面内容： 数据元素之间的逻辑关系，也称为数据的逻辑结构（Logical Structure） 数据元素及逻辑关系在计算机存储器内的表示方式，称为数据的存储结构（Storage Structure） 数据运算，即对数据施加的操作。运算的定义直接依赖于逻辑结构，但运算的实现必须依赖于存储结构 数据的逻辑结构数据中元素通常有下列四种形式的逻辑关系： 集合：每个元素都是独立的，相互之间没有逻辑关系 线性结构：结构中的元素之间存在一对一的关系，即所谓的线性关系 树形结构：结构中的数据元素之间存在一对多的关系 图状结构：结构中的元素之间存在多对多的关系 通常将集合、树形结构、图状结构归纳为非线性结构。因此，数据的逻辑结构可分为两大类，即线性结构和非线性结构。 数据的存储结构（物理实现方面）四种： 顺序存储：将数据元素依次存储于一组地址连续的存储单元中，元素间的逻辑关系由存储单元的位置直接体现，由此得到的存储表示称为顺序存储结构（Sequential Storage Structure）。高级语言中，常用一维数组来实现顺序存储结构。该方法主要用于线性结构。非线性结构也可通过某种线性化的处理，实现顺序存储。 链接存储：将数据元素存储在一组任意的存储单元中，用附加的指针域表示元素之间的逻辑关系，由此得到的存储表示称为链接存储（Linked StorageStructure）。使用这种存储结构时，往往把一个数据元素及附加的指针一起称作一个结点。高级语言中，常用指针变量实现链接存储。 索引存储：该方法的特点是在存储数据元素的同时，还可以建立附加的索引表（通俗讲，相当于目录）。索引表中每一项称为索引项。索引项的一般形式是：（关键字，地址）。关键字是指能唯一标识数据元素的数据项。若每个数据元素在索引表中均有一个索引项，则该索引表称为稠密索引（Dense Index）。若一个索引项对应一组数据元素，则该索引表称为稀疏索引（Sparse Index）。 散列存储：该方法是依据数据元素的关键字，用一个事先设计好的函数计算出该数据元素的存储地址，然后把它存入该地址中。这种函数称为散列函数（即Hash），由散列函数计算出的地址称为散列地址。 数据运算最常用的基本运算有检索（查找）、插入、删除、更新、排序等。 综上，数据结构包含逻辑结构、存储结构和运算三方面的内容。同一逻辑结构采用不同存储结构，得到的是不同的数据结构，常用不同的数据结构名来标识它们（1）；而同一逻辑结构定义不同的运算也会导致不同的数据结构（2） 举几个例子： 线性结构采用顺序存储时称为顺序表，采用链接存储时则称为链表 若限制线性结构的插入、删除在一端进行，则该结构称为栈（先进后出）；若限制插入在一端进行，而删除在另一端进行，则称为队列（先进先出） 若栈采用顺序存储结构，则称为顺序栈；若栈采用链式存储结构，则称为链栈。顺序栈与链栈也是两种不同的数据结构 数据类型（Data Type） 数据类型是一个值的集合和在这个集合上定义的一组操作的总称。例如，C++中的整型变量，其值集为某个区间上的整数（区间大小依赖于不同的机器），定义在其上的操作为加、减、乘、除和取模等运算 按“值”可否分解，可把数据类型分为两类: 原子类型：其值不可分解，如C++的基本类型（整型、字符型、实型、枚举型）、指针类型和空类型 结构类型：其值可分解成若干成分（或称分量），如C++的数组类型、结构类型等。结构类型的成分可以是原子类型，也可以是某种结构类型。可以把数据类型看作程序设计语言已实现的数据结构 抽象数据类型抽象数据类型（Abstract Data Type, ADT）是指一个数学模型，以及定义在该模型上的一组操作。抽象数据类型的定义取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 抽象数据类型的定义可以由一种数据结构和定义在其上的一组操作组成，而数据结构又包括数据元素间的关系，因此抽象数据类型一般可以由元素、关系及操作三种要素来定义。 算法 沃斯（N.Wirth）的公式数据结构+算法=程序 数据运算是通过算法来描述的。算法（Algorithm）是对特定问题求解步骤的描述，是指令的有限序列，其中每条指令表示一个或多个操作 算法的五个特性算法必须具备五个特性： 有穷性：一个算法对于任何合法的输入必须在执行有穷步骤之后结束，且每步都可在有限时间内完成 确定性：算法的每条指令必须有确切含义，不能有二义性。在任何条件下，算法只有唯一的一条执行路径，即对相同的输入只能得出相同的结果 可行性：算法是可行的，即算法中描述的操作均可通过已经实现的基本运算的有限次执行来实现 输入：一个算法有零个或多个输入，这些输入取自算法加工对象的集合 输出：一个算法有一个或多个输出，这些输出应是算法对输入加工后合乎逻辑的结果 Tips：程序和算法十分相似，但是程序不一定要满足有穷性，例如操作系统启动后，如果没有作业处理也仍会循环等待。 算法的三种描述方法 自然语言：不够严谨 程序流程图、N-S图等算法描述工具：简洁明了 伪码语言描述：伪码语言介于高级程序设计语言和自然语言之间，它忽略高级程序设计语言中一些严格的语法规则与描述细节，因此它比程序设计语言更容易描述和被人理解，而比自然语言更接近程序设计语言 算法的四个衡量指标 正确性（硬性指标）：算法的正确性主要有4个层次的要求，第一层次是指算法没有语法错误，第二层次是指算法对于几组输入数据能够得出满足规格说明要求的结果，第三层次是指算法对于精心选择的苛刻并带有刁难性的几组输入数据能够得出满足规格说明要求的结果，第四层次是指算法对于一切合法的输入数据都能得出满足规格说明要求的结果 可读性：提高可读性的方法包含：注释、变量命名、程序缩排（代码规范）、段落（不同目的的代码块之间插入一个空白行） 健壮性：算法中应对输入数据和参数进行合法性检查，例如三角形三条边的长度 时空效率：算法的执行时间尽可能短，占用的存储空间尽可能少。但这两者往往相互矛盾，节省了时间可能牺牲空间，反之亦然。设计者应在时间与空间两方面有所平衡 算法性能分析和度量 可以用算法的时间复杂度与空间复杂度来评价算法的优劣 时间复杂度（Time Complexity）（T(n)）一个算法的时间复杂度是指算法运行从开始到结束所需要的时间。 这个时间就是该算法中每条语句的执行时间之和，而每条语句的执行时间 = 该语句执行次数（也称为频度） * 执行该语句所需时间 但是，当算法转换为程序之后，一条语句执行一次所需的时间与机器的性能及编译程序生成目标代码的质量有关，是很难确定的。 为此，假设执行每条语句所需的时间均为单位时间。在这一假设下，一个算法所花费的时间就等于算法中所有语句的频度之和。这样就可以脱离机器的硬、软件环境而独立地分析算法所消耗的时间。 例如： 1234567891011#define N 100 //问题规模void matrixMultiply(int A[N][N], int B[N][N], int C[N][N])&#123; for( i=0; i&lt;N; i=i+1) //本身执行n+1次，但是内部的循环体是执行n次 for( j=0; j&lt;N; j=j+1) //执行n(n+1)次，因为本身执行n+1次 &#123; C[i][j] = 0; //执行n^2次 for(k=0; k&lt;N; k=k+1) //执行(n^2)*(n+1)次 C[i][j] += A[i][k] * B[k][j]; //执行n^3次 &#125;&#125; 总计执行$n+1+n(n+1)+n^2+(n^2)*(n+1)+n^3，即T(n)=2n^3+3n^2+2n+1$ 一般而言，一个算法的执行时间是求解问题的规模n（如矩阵的阶数、线性表的长度）的函数，这是因为问题的规模往往决定了算法工作量的大小。 但是，我们不关心它是个怎样的函数，只关心它的数量级量度，即它与什么简单函数f(n)是同一数量级的，即T(n)=O(f(n))。其中“O”是数学符号，其数学定义如下: 如果存在正的常数C和n0，使得当n≥n0时都满足0≤T(n)≤Cf(n)，则称T(n)与f(n)是同一数量级的，并记作T(n)=O(f(n))，即最高幂次方。*算法的执行时间T(n)=O(f(n))为该算法的时间复杂度。** 它表示随着问题规模n的增大，该算法执行时间的增长率和f(n)的增长率相同。 1.对于上面的例子，当n→∞时， $$T(n)/n^3= (2n^3+3n^2+2n+1)/ n^3→2$$ 根据“O”的定义可知T(n)=O(n^3)，所以上面例子的算法的时间复杂度是O(n^3) 2.例如，用两个算法A1和A2求解同一问题，它们的时间耗费分别是$T_1(n)=100n^2+5000n+3,T_2(n)=2n^3$。如果问题规模n不太大，则二者的时间花费也相差不大；若问题规模n很大，如n=10000，则二者的时间花费相差很大。二者的差别从时间复杂度上一目了然，因为$T_1(n)=O(n^2), T_2(n)=O(n^3)$，所以算法A1的时间性能优于算法A2 如果一个算法的所有语句的频度之和是问题规模n的多项式， 即 $$T(n)=C_kn^k+C_{k-1}n^{k-1}+…+C_1n+C_0C_k≠0$$ 则按“O”的定义可知，该算法为k次方阶算法： $$T(n)=O(n^k)$$ 特殊情况，如果T(n)=C，其中C为常数，即算法耗费的时间与问题规模n无关，则记T(n)=O(1)，称该算法为常数阶算法。 常见的时间复杂度按数量级递增排序有： 常数阶$O(1)$ 对数阶$O(log_2n)$ 线性阶$O(n)$ 平方阶$O(n^2)$ 立方阶$O(n^3)$ 指数阶$O(2^n)$ 指数阶算法的执行时间随n的增大而迅速放大，所以其时间性能极差，当n稍大时我们就无法忍受，如汉诺塔问题。 常见的时间复杂度有： $O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)$ 简化时间复杂度计算由于算法的时间复杂度仅刻画了算法执行时间的数量级，为了简化对算法时间性能的分析，通常的做法是，从算法中选取一种对于所研究的问题来说是最基本的操作，并以该基本操作执行的次数作为算法的时间度量 被选用的基本操作应是其重复执行次数与算法的执行时间成正比例的 例如上面的代码例子，只需获取最大阶乘的时间复杂度，即$n^3$即可，$O(n)=n^3$。 平均时间复杂度和输入数据有关的时间复杂度有些情况下，算法的时间复杂度不仅与问题的规模有关，还与输入数据有关。例如，在数组A[n]中查找给定值k的算法如下： 123i = n-1;while(i&gt;=0 &amp;&amp; A[i] != k) =i-1;return i; 这个操作的执行次数取决于数组A中有没有值为k的元素。若有，这个值为k的元素又在数组中哪个位置。 若数组中无值为k的元素，则操作“A[i]! =k”的执行次数为n； 若A[n-1]等于k，则该操作的执行次数为1。 所以，该算法在最坏情况下的时间复杂度为O(n)，最好情况下的时间复杂度是O(1)。 因此，有时我们会对算法的平均（或称期望）时间复杂度感兴趣。所谓平均时间复杂度，是指所有可能的输入数据在等概率出现的情况下算法的平均执行时间。 当算法的平均时间复杂度难以确定时，就以算法的最坏时间复杂度作为算法的时间复杂度。因为它是算法执行时间的一个上界，保证了算法的执行时间不会比它更长。 递归算法的时间复杂度12345fact(int n)&#123; if(n&lt;=1) return 1; //(1) else return (n*fact(n-1)); //(2)&#125; 设fact(n)的运行时间复杂度函数是T(n)，该函数中语句（1）的运行时间是$O(1)$，语句（2）的运行时间是T(n-1)+O(1)，其中O(1)为基本运行时间， 因此：如果n≤1，则$T(n) = O(1)$ 如果n&gt;1，则$T(n) = T(n-1)+O(1)$ 则$T(n) = T(n-1)+O(1)= T(n-2)+2O(1)= T(n-3)+3O(1)=…= T(1)+(n-1)O(1)=nO(1)=O(n)$ 即fact(n)的时间复杂度为$O(n)$ 空间复杂度（Space Complexity）（S(n)）空间复杂度作为算法所需存储空间的量度，记作$S(n)=O(f(n))$（n为问题的规模） 度量和时间复杂度一样。 在大多数算法设计中，时间效率和空间效率很难兼得，设计者往往要根据具体问题进行取舍。 线性表 线性表是最简单、最基本也是最常用的一种线性结构。它有两种存储方式：顺序存储方式和链式存储方式。它的主要操作是插入、删除和检索等 逻辑结构表示为： $LinearList = {D, R}$ 其中， $D={a_i | 1&lt;=i&lt;=n, n&gt;=0, a_i∈DataType} (DataType为数据元素类型)$ $R={r}$ $r={&lt;a_i, a_{i+1}&gt; | 1&lt;=i&lt;=n-1}$ 线性表的基本运算方法如下： 作用 函数 初始条件 操作结果 线性表初始化 void Initiate() 线性表不存在 构造一个空的线性表 求线性表的长度 int Length() 线性表已存在 返回线性表所含数据元素的个数 取表元 DataType Get(int i) 表存在且1≤i≤Length() 返回线性表的第i个数据元素的值 按值查找 int Locate(DataType x) 线性表已存在，x是给定的一个数据元素 查找值为x的数据元素，返回首次出现的值为x的那个数据元素的序号，称为查找成功；如果未找到值为x的数据元素，返回0表示查找失败 插入操作 int Insert(DataType x, int i) 线性表已存在 在线性表的第i个位置上插入一个值为x的新元素，使原序号为i,i+1, …,n的数据元素的序号变为i+1,i+2, …,n+1，插入后表长=原表长+1，返回1表示插入成功；若线性表L中数据元素个数少于i-1个，则返回0表示插入失败 删除操作 int Deleted(int i) 线性表已存在 在线性表L中删除序号为i的数据元素，删除后使序号为i+1, i+2, …, n的元素变为序号i, i+1, …, n-1，新表长=原表长-1，返回1；若线性表中数据元素个数少于i，则返回0表示删除失败 顺序存储结构-顺序表内存中的地址空间是线性的，顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙 设数据元素a1的存储地址为Loc(a1)，每个数据元素占用d个存储地址，则第i个数据元素的地址为： $Loc(a_i)=Loc(a_1)+(i-1)*d (其中1≤i≤n)$ 特点：只要知道顺序表的首地址和每个数据元素所占用地址单元的个数，就可以求出第i个数据元素的地址。这也是顺序表具有按数据元素的序号随机存取的特点。 因为线性表的运算经常会导致长度发生变化，所以数组容量需要设计的足够大 假设用$data[MAXSIZE]$来表示，其中MAXSIZE是一个根据实际问题定义的足够大的整数，线性表中的数据元素从data[0]开始依次存放，但当前线性表中的实际元素个数可能未达到MAXSIZE，因此需要用一个变量len记录当前线性表中数据元素个数，使得len起到一个数字指针的作用，始终指向线性表中最后一个元素的下一个位置，其值为最后一个数据元素的位置值，若该表为空表，则len=0。 顺序表运算 初始化 123456789101112//初始化void SequenList::Initiate()&#123; len=0;&#125;void main()&#123; SequenList L; L.Initiate(); ...&#125; 插入 123456789101112//在线性表的第i个元素之前插入一个新的数据元素xint SequenList::Insert(DataType x, int i)&#123; //做插入i位置的判断，是否溢出(MAXSIZE)或者不合法(len) ... for(int j=len; j&gt;=i; j--) data[j]=data[j-1]; //元素后移 data[i-1]=x; //插入元素 len++; //表长度+1 return 1;&#125; 插入算法的时间性能分析：顺序表上的插入运算，时间主要消耗在数据元素的移动上。在第i个位置上插入x，从第i个到第n个元素都要向后移动一个位置，共需要移动n-(i-1)，即n-i+1个数据元素。而i的取值范围为1≤i≤n+1，即有n+1个位置可以插入 在顺序表上做插入操作需移动表中一半数据元素。时间复杂度为O(n) 删除 在顺序表上完成删除运算的步骤如下： （1）将数据元素ai+1～an依次向前移动一个位置 （2）修改len值，使之仍指向最后一个数据元素的下一个位置 1234567891011//删除第i个元素int SequenList::Delete(int i)&#123; //做插入i位置的判断，是否溢出(MAXSIZE)或者不合法(len) ... for(int j=i; j&lt;len; j++) data[j-1]=data[j]; //元素前移 len--; //表长度-1 return 1;&#125; 删除算法的时间性能分析：与插入运算相同，其时间主要消耗在移动表中元素上。删除第i个元素时，其后面的元素$a_{i+1}-a_n$都要向前移动一个位置，共移动n-i个元素 在顺序表上做删除运算时大约需要移动表中一半元素。该算法的时间复杂度为O(n) 按值查找 12345678910int SequenList::Locate(DataType x)&#123; //返回值为x的元素的位序值 ... int j=0; while((j&lt;len)&amp;&amp;(data[j] != x)) j++; if(j&lt;len) return j+1; else return 0; //没有查找到&#125; 比较的次数与x在表中的位置有关，也与表长有关。当a1=x时，比较一次成功；当an=x时，比较n次成功。 在查找成功的情况下，平均比较次数为（n+1）/2，时间复杂度为O(n) 读取第i个数据元素的值 1234567891011int SequenList::Get(int i)&#123; ... if((i&lt;1) || (i&gt;len)) &#123; cout &lt;&lt;\"not correct input\"&lt;&lt;endl; return NULL; &#125; else return data[i-1];&#125; 取得元素个数 直接return len值 顺序表存储空间的分配线性表顺序存储结构，是预先给定大小为MAXSIZE的存储空间，程序在编译阶段就已经知道该类型变量的大小，在程序开始运行前会为它分配好存储空间，因此是一种存储空间的静态分配 而动态分配是在定义线性表的存储类型时，不是定义好一个存储空间，而是只定义一个指针，待程序运行后再申请一个用于存放线性表数据元素的存储空间，并把该存储空间的起始地址赋给这个指针。访问动态存储分配的线性表中的元素和访问静态存储分配的线性表中的元素的情况完全相同，既可以采用指针方式，也可以采用数组下标方式。 关于数据内存存储的方式可参考C++内存分配方式-管理数据内存的四种方式 链式存储结构顺序表的存储特点是用物理位置上的相邻实现了逻辑关系上的相邻，它要求用连续的存储单元顺序存储线性表中的各元素，因此，对顺序表插入、删除操作时需要通过移动数据元素来实现，严重影响了运行效率 而链式存储结构不需要用地址连续的存储单元来实现，因为它不要求逻辑关系上相邻的两个数据元素物理位置上也相邻。它通过“链”建立起数据元素之间的逻辑关系。因此对线性表的插入、删除不需要移动数据元素 1.单链表结构 链表是通过一组任意的存储单元来存储线性表中的数据元素 为建立起数据元素之间的线性关系，对每个数据元素ai，除了存放数据元素自身的数据信息ai之外，还需要存放其后继ai+1所在的存储单元的地址，这两部分信息组成一个“结点”。 存放数据元素信息的域称为数据域，存放其后继数据元素地址的域称为指针域 n个数据元素的线性表通过每个结点的指针域形成了一个“链”，称为链表。 由于每个结点中只有一个指向后继的指针，所以称其为单链表 结点结构： 头指针：一个指向第一个节点地址的指针变量，头指针具有标识单链表的作用，所以经常用头指针代表单链表的名字 头结点：在单链表的第一个结点之前附设一个结点，它没有直接前驱，称之为头结点可不存信息，也可以作为监视哨，或用于存放线性表的长度等附加信息指针域中存放首元结点的地址 首元结点：存储第一个元素的节点 定义及基本运算函数： 12345678910111213141516171819202122232425262728293031typedef int DataType;clasee Item&#123; public: DataType data; Item *next; Item() &#123;next=NULL&#125;;&#125;;class Link&#123; public: Item *head; //链表头指针 Link() &#123;head=NULL;&#125; //构造函数 ~Link() &#123;DeleteAll(); &#125; //析构函数 void Initiate(); //初始化 void DeleteAll(); //删除所有结点 void HeadCreate(int n); //从头建链表 void TailCreate(int n); //从尾建链表 void HeadCreateWithHead(int n); //建立带表头的链表（从头） void TailreateWithHead(int n); //建立带表头的链表（从尾） int Length(); //链表长度 Item *Locatex(DataType x); //查找值为x的数据元素 Item *Locatei(int i); //查找第i个元素 DataType Get(int i); //获取第i个元素的值 bool Insert(DataType x, int i); //在链表第i个结点之前插入x bool Deleted(int i); //删除链表中第i个结点 void Print(); //打印链表&#125; 单链表运算-初始化12345void Initiate()&#123; DeleteAll(); head=NULL;&#125; 单链表运算-建立单链表链表与顺序表不同，它是一种动态管理的存储结构，链表中的每个结点占用的存储空间不是预先分配的，而是在运行时系统根据需求动态生成的，因此建立单链表应该从空表开始。 (1)从表尾到表头建立单链表（不带有空白头结点） 可以在每读入一个数据元素后申请一个结点，然后插在链表的头部（从表尾到表头建立单链表） 因为是在链表的头部插入，读入数据的顺序和线性表中的逻辑顺序是相反的。 123456789101112131415void Link::HeadCreate(int n)&#123; DeleteAll(); Item *s, *p; int i; p=NULL; for(i=1;i&lt;=n; i++) &#123; s=new Item(); cin&gt;&gt; s-&gt;data; //输入 s-&gt;next = p; p = s; &#125; head = p;&#125; (2)从表头到表尾建立单链表（不带有空白头结点） 从表尾到表头插入结点建立单链表比较简单，但读入的数据元素的顺序与生成的单链表中元素的顺序是相反的。 若希望次序一致，则用从表头到表尾建立单链表的方法。 因为每次是将新结点插入链表的尾部，所以需加入一个指针r用来始终指向链表中的尾结点，以便能够将新结点插入链表的尾部 1234567891011121314151617181920212223void Link::TailCreate(int n)&#123; DeleteAll(); Item *s, *r, *p; int i; p=NULL; for(i=1;i&lt;=n; i++) &#123; s=new Item(); cin&gt;&gt; s-&gt;data; //输入 s-&gt;next = NULL; //不带有空白头结点 //第一个结点加入前链表为空，它没有直接前驱结点 //它的地址就是整个链表的指针，需要放在链表的头指针变量p中 if(p==NULL) p=r=s; else &#123; r-&gt;next=s; //此处的顺序和上面那种方式相反 r=s; &#125; &#125; head = p;&#125; (3)从表尾到表头建立单链表（带有空白头结点） 123456789101112131415161718void Link::TailCreate(int n)&#123; DeleteAll(); Item *s, *p; int i; p=new Item(); p-&gt;next=NULL; for(i=1;i&lt;=n; i++) &#123; s=new Item(); cin&gt;&gt; s-&gt;data; //输入 s-&gt;next = p-&gt;next; //带有空白头结点 p-&gt;next = s; &#125; &#125; head = p;&#125; (4)从表头到表尾建立单链表（带有空白头结点） 12345678910111213141516171819void Link::TailCreate(int n)&#123; DeleteAll(); Item *s, *r, *p; int i; p=new Item(); p-&gt;next=NULL; r=p; //带有空白头结点 for(i=1;i&lt;=n; i++) &#123; s=new Item(); cin&gt;&gt; s-&gt;data; //输入 r-&gt;next=s; r=s; &#125; r-&gt;next=NULL; head = p;&#125; 从上面4个算法可以看出，对于不带空白头结点的单链表，空表情况下需要单独处理，而带上空白头结点之后则不用了，算法的时间复杂度均为O(n) 单链表运算-求表长设有一个移动指针p和计数器j，初始化后，p所指结点后面若还有结点，p向后移动，计数器加1。算法如下： 123456789101112int Link::Length()&#123; int j=1; Item *p; p=head-&gt;next; while(p!=NULL) &#123; j++; p=p-&gt;next; &#125; return --j;&#125; 此算法的时间复杂度为O(n) 单链表运算-查找操作(1)按序号查找 从单链表的第一个元素结点起，判断当前结点是否是第i个，若是，则返回该结点的指针；否则继续下一个结点的查找，直到表结束为止。 若没有第i个结点，则返回空；如果i=0，则返回头指针。算法如下： 123456789101112131415161718192021Item *Locatei(int i)&#123; int j=1; Item *p; if(i=1) return head; p=head-&gt;next; while((p!=NULL) &amp;&amp; (j&lt;i)) &#123; j++; p=p-&gt;next; &#125; if(j==i) return p; else &#123; cout&lt;&lt;\"not correct input!\" &lt;&lt;endl; return NULL; &#125;&#125; 时间复杂度均为O(n) (2)按值查找即定位 从链表的第一个元素结点起，判断当前结点值是否等于x，若是，返回该结点的指针，否则继续下一个结点的查找，直到表结束为止。若找不到，则返回空。算法如下： 12345678910111213Item *Locatex(DataType x)&#123; Item *p; p=head-&gt;next; while((p!=NULL) &amp;&amp; (p-&gt;data != x)) p=p-&gt;next; if(p) return p; //即p不为空 else &#123; cout&lt;&lt; x &lt;&lt; \" is not exist\" &lt;&lt;endl; return NULL; &#125;&#125; 时间复杂度均为O(n) (3) 读取第i个位置上的元素值 123456789101112131415161718192021DataType Link::Get(int i)&#123; int j; Item *p; j=1; p=head-&gt;next; while((j&lt;i) &amp;&amp; (p != NULL)) &#123; j++; p=p-&gt;next; &#125; if((p==NULL) || (j&gt;i)) &#123; cout &lt;&lt;\"not correct\" &lt;&lt;endl; &#125; else &#123; return p-&gt;data; &#125;&#125; 时间复杂度均为O(n) 单链表运算-插入(1)后插结点 设p指向单链表中某结点，s指向待插入的值为x的新结点，将*s插入 *p的后面 操作如下：（两个指针的操作顺序不能交换） ① s-&gt;next=p-&gt;next; ② p-&gt;next=s; 时间复杂度为O(1) (2)前插结点 设p指向链表中某结点，s指向待插入的值为x的新结点，将*s插入 *p的前面 与后插不同的是，首先要找到＊p的前驱＊q，再完成在q之后插入s。设单链表头指针为L，操作如下： 123456q=L;while(q-&gt;next != p) q=q-&gt;next; //找到*p的直接前驱s-&gt;next = q-&gt;next;q-&gt;next = s; 时间复杂度为O(n) 如果将*s直接插入 *p的后面，然后将p-&gt;data与s-&gt;data交换。这样既满足了逻辑关系，也能使得时间复杂度为O(1)。 (3)插入算法 步骤： ① 找到第i-1个结点；若存在，继续步骤②，否则结束 ② 申请新结点，将数据填入新结点的数据域 ③ 将新结点插入 123456789101112131415bool Link::Insert(DataType x, int x) &#123; Item *p, *s; p = Locatei(i-1); //查找i-1的结点 if(p == NULL) &#123; cout &lt;&lt; \"not correct\" &lt;&lt;endl; return false; &#125; s = new Item(); s-&gt;data = x; s-&gt;next = p-&gt;next; p-&gt;next = s; return true;&#125; 单链表运算-删除(1)删除结点 设p指向单链表中某结点，删除*p 要实现对结点*p的删除， 首先要找到*p的前驱结点 *q，然后完成指针的删除操作即可 指针的操作，由下列语句实现： 12q-&gt;next = p-&gt;next;delete p; PS:找前驱结点*q的时间复杂度是$O(n)$ 删除： 123s = p-&gt;next;p-&gt;next = s-&gt;next;delete s; PS:该操作时间复杂度$O(1)$ (2)删除运算 ① 找到第i-1个结点，若存在，继续步骤②，否则结束 ② 若存在第i个结点，则继续步骤③，否则结束 ③ 删除第i个结点，结束 单链表运算-删除所有结点123456789void Link::DeleteAll() &#123; Item *p = head, *q; while(p != NULL) &#123; q = p-&gt;next; delete p; p = q; &#125; head = NULL;&#125; 通过上面的基本操作可知： 在单链表上插入、删除一个结点，必须知道其前驱结点的指针； 单链表不具有按序号随机访问的特点，只能从头指针开始一个个顺次进行。 2.循环链表结构对于单链表而言，最后一个结点的指针域是空指针。 如果将该链表头指针置入该指针域，则使得链表头尾结点相连，就构成了循环单链表 对于单链表，只能从头结点开始遍历整个链表；而对于循环单链表，则可以从表中任意结点开始遍历整个链表。不仅如此，有时对链表常做的操作是在表尾、表头之间进行。 此时可以改变链表的标识方法，不用头指针而用一个指向尾结点的指针R来标识，可以使操作效率得以提高 3.双向链表结构单链表的结点中只有一个指向其后继结点的指针域next，因此若已知某结点的指针为p，其后继结点的指针则为p-&gt;next，而找其前驱则只能从该链表的头指针开始，顺着各结点的next域进行。 也就是说，找后继的时间复杂度是O(1)，找前驱的时间复杂度是O(n)。 如果也希望找前驱的时间复杂度达到O(1)，则只能付出空间的代价：每个结点再加一个指向前驱的指针域，用这种结点组成的链表称为双向链表 顺序表和链式表对比顺序存储有以下3个优点： 方法简单，各种高级语言中都有数组，容易实现 不用为表示结点间的逻辑关系而增加额外的存储开销 可以按元素序号随机访问表中结点 缺点： 在顺序表中做插入、删除操作时，平均约需移动表中一半元素。因此对数据元素较多的顺序表来说，运算效率比较低 需要预先分配足够大的存储空间，估计得过大，可能会导致顺序表空间大量闲置；预先分配过小，容易会造成溢出 链式表优点： 基于存储的考虑，顺序表的存储空间是静态分配的，在程序执行之前必须明确规定它的存储规模。对线性表的长度或存储规模难以估计时，不宜采用顺序表。链式表不用事先估计存储规模，但链式表的存储密度较低 基于运算的考虑，在顺序表中按序号访问ai的时间复杂度是O(1)，而在链式表中按序号访问ai的时间复杂度是O(n)，所以如果经常做的操作是按序号访问数据元素，显然顺序表优于链式表。在顺序表中做插入、删除时，平均约需移动表中一半元素，当数据元素的信息量较大且表较长时；在链式表中做插入、删除时，虽然也要找插入位置，但主要是比较操作。从这个角度考虑，显然后者优于前者 基于难易的考虑，顺序表容易实现，任何高级语言中都有数组类型；链式表的操作是基于指针的 PS：存储密度，是指一个结点中数据元素所占的存储单元和整个结点所占的存储单元之比。显然，链式存储结构的存储密度小于1。 参考 C语言-链表的创建头插法和尾插法（有无头节点） 如何使用C++实现单链表 C语言之单链表操作","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"},{"name":"datastructure","slug":"datastructure","permalink":"https://alonealive.github.io/Blog/tags/datastructure/"}]},{"title":"Android R背光调节流程梳理","slug":"2021/210507_android_brightness","date":"2021-05-07T14:32:00.000Z","updated":"2021-05-07T09:08:29.000Z","comments":true,"path":"2021/05/07/2021/210507_android_brightness/","link":"","permalink":"https://alonealive.github.io/Blog/2021/05/07/2021/210507_android_brightness/","excerpt":"参考Android R源码，对背光手动调节、自动调节的流程作简单梳理。","text":"参考Android R源码，对背光手动调节、自动调节的流程作简单梳理。 SystemUI-settings手动背光调节函数调用流程1234567frameworks&#x2F;base&#x2F;packages&#x2F;SystemUI&#x2F;src&#x2F;com&#x2F;android&#x2F;systemui&#x2F;settings&#x2F;BrightnessController.java - onChanged ----&gt;setBrightness ----&gt;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;display&#x2F;DisplayManager.java - setTemporaryBrightness ----&gt;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;display&#x2F;DisplayManagerGlobal.java - setTemporaryBrightness [调用IDisplayManager.aidl的setTemporaryBrightness]---&gt;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;display&#x2F;DisplayManagerService.java - setTemporaryBrightness [binder call跨进程 APP进程到DMS进程]frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;display&#x2F;DisplayPowerController.java - setTemporaryBrightness [消息处理] ----&gt;updatePowerState* [主要设置、实现背光函数] 部分代码梳理 BrightnessController.java设置背光： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//frameworks/base/packages/SystemUI/src/com/android/systemui/settings/BrightnessController.java @Override public void onChanged(ToggleSlider toggleSlider, boolean tracking, boolean automatic, int value, boolean stopTracking) &#123; .... final float minBacklight; final float maxBacklight; final int metric; final String settingToChange; //获取背光值 //value入参，Gamma转换成线性 //valFloat:根据亮度条的拖动，计算出新的亮度值 final float valFloat = MathUtils.min(convertGammaToLinearFloat(value, minBacklight, maxBacklight), 1.0f); .... //设置背光值 setBrightness(valFloat); if (!tracking) &#123; //在异步任务中将新的亮度值保存在SettingsProvider中 AsyncTask.execute(new Runnable() &#123; public void run() &#123; Settings.System.putFloatForUser(mContext.getContentResolver(), settingToChange, valFloat, UserHandle.USER_CURRENT); &#125; &#125;); &#125; for (BrightnessStateChangeCallback cb : mChangeCallbacks) &#123; cb.onBrightnessLevelChanged(); &#125; &#125; //设置背光值 private void setBrightness(float brightness) &#123; //DisplayManagerService对象 mDisplayManager.setTemporaryBrightness(brightness); &#125;//frameworks/base/packages/SettingsLib/src/com/android/settingslib/display/BrightnessUtils.java // Hybrid Log Gamma constant values private static final float R = 0.5f; private static final float A = 0.17883277f; private static final float B = 0.28466892f; private static final float C = 0.55991073f; public static final float convertGammaToLinearFloat(int val, float min, float max) &#123; // 计算 (val-GAMMA_SPACE_MIN) / (GAMMA_SPACE_MAX-GAMMA_SPACE_MAX) //最大值减去最小值评价一组数据的离散度，即极差 final float normalizedVal = MathUtils.norm(GAMMA_SPACE_MIN, GAMMA_SPACE_MAX, val); //min 0, max 65535 final float ret; //对调用者自身的rgb值平方或开放 if (normalizedVal &lt;= R) &#123; ret = MathUtils.sq(normalizedVal / R); //开方根 &#125; else &#123; ret = MathUtils.exp((normalizedVal - C) / A) + B; //以自然常数e为底的指数函数 &#125; // HLG is normalized to the range [0, 12], ensure that value is within that range, // it shouldn't be out of bounds. final float normalizedRet = MathUtils.constrain(ret, 0, 12); // Re-normalize to the range [0, 1] // in order to derive the correct setting value. return MathUtils.lerp(min, max, normalizedRet / 12); &#125; AIDL跨进程（bind call）到DMS.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191//frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java @VisibleForTesting final class BinderService extends IDisplayManager.Stub &#123; ..... @Override // Binder call public void setTemporaryBrightness(float brightness) &#123; mContext.enforceCallingOrSelfPermission( Manifest.permission.CONTROL_DISPLAY_BRIGHTNESS, \"Permission required to set the display's brightness\"); final long token = Binder.clearCallingIdentity(); try &#123; //同步执行代码块 //保证在同一时刻最多只有一个线程执行该段代码 synchronized (mSyncRoot) &#123; mDisplayPowerController.setTemporaryBrightness(brightness); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(token); &#125; &#125;//frameworks/base/services/core/java/com/android/server/display/DisplayPowerController.java public void setTemporaryBrightness(float brightness) &#123; //mHandler是DisplayControllerHandler类型 //创建message（省去了创建对象申请内存的开销，相比new message） Message msg = mHandler.obtainMessage(MSG_SET_TEMPORARY_BRIGHTNESS, Float.floatToIntBits(brightness), 0 /*unused*/); //内部调用sendMessage，即发送消息 msg.sendToTarget(); &#125; private final class DisplayControllerHandler extends Handler &#123; public DisplayControllerHandler(Looper looper) &#123; super(looper, null, true /*async*/); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ... //消息处理 case MSG_SET_TEMPORARY_BRIGHTNESS: //入参int，返回float类型，赋值给mTemporaryScreenBrightness mTemporaryScreenBrightness = Float.intBitsToFloat(msg.arg1); updatePowerState(); break; ... &#125; &#125; //主要实现函数 private void updatePowerState() &#123; // Update the power state request. final boolean mustNotify; final int previousPolicy; boolean mustInitialize = false; int brightnessAdjustmentFlags = 0; mBrightnessReasonTemp.set(null); ... // 如果power状态变化，则第一时间初始化更新 if (mustInitialize) &#123; initialize(); &#125; ... //获取p-sensor距离感应器（Apply the proximity sensor） if (mProximitySensor != null) &#123; ... &#125; //1. 手动设置亮度是否改变 final boolean userSetBrightnessChanged = updateUserSetScreenBrightness(); //如果没有覆盖，则使用手动设置的临时背光 if (isValidBrightnessValue(mTemporaryScreenBrightness)) &#123; //2. 将手动设置的背光值 赋值给 brightnessState brightnessState = mTemporaryScreenBrightness; mAppliedTemporaryBrightness = true; mBrightnessReasonTemp.setReason(BrightnessReason.REASON_TEMPORARY); &#125; else &#123; mAppliedTemporaryBrightness = false; &#125; final boolean autoBrightnessAdjustmentChanged = updateAutoBrightnessAdjustment(); if (autoBrightnessAdjustmentChanged) &#123; mTemporaryAutoBrightnessAdjustment = Float.NaN; &#125; //如果设置了，则使用自动背光覆盖 final float autoBrightnessAdjustment; if (!Float.isNaN(mTemporaryAutoBrightnessAdjustment)) &#123; autoBrightnessAdjustment = mTemporaryAutoBrightnessAdjustment; brightnessAdjustmentFlags = BrightnessReason.ADJUSTMENT_AUTO_TEMP; mAppliedTemporaryAutoBrightnessAdjustment = true; &#125; else &#123; autoBrightnessAdjustment = mAutoBrightnessAdjustment; brightnessAdjustmentFlags = BrightnessReason.ADJUSTMENT_AUTO; mAppliedTemporaryAutoBrightnessAdjustment = false; &#125; .... // Apply auto-brightness. boolean slowChange = false; if (Float.isNaN(brightnessState)) &#123; float newAutoBrightnessAdjustment = autoBrightnessAdjustment; if (autoBrightnessEnabled) &#123; //获取自动背光值 brightnessState = mAutomaticBrightnessController.getAutomaticScreenBrightness(); //获取新的adjustment值 newAutoBrightnessAdjustment = mAutomaticBrightnessController.getAutomaticScreenBrightnessAdjustment(); &#125; if (isValidBrightnessValue(brightnessState) || brightnessState == PowerManager.BRIGHTNESS_OFF_FLOAT) &#123; // Use current auto-brightness value and slowly adjust to changes. //3. 使用当前的自动背光值，缓慢的变化 brightnessState = clampScreenBrightness(brightnessState); ..... &#125; if (autoBrightnessAdjustment != newAutoBrightnessAdjustment) &#123; //将adjustment值保存到SettingsProvider中 //以确保Settings等其他进程对它的使用 putAutoBrightnessAdjustmentSetting(newAutoBrightnessAdjustment); &#125; else &#123; // Adjustment values resulted in no change brightnessAdjustmentFlags = 0; &#125; &#125; ..... float animateValue = brightnessState == PowerManager.BRIGHTNESS_OFF_FLOAT ? PowerManager.BRIGHTNESS_MIN : brightnessState; if (isValidBrightnessValue(animateValue)) &#123; if (initialRampSkip || hasBrightnessBuckets || wasOrWillBeInVr || !isDisplayContentVisible || brightnessIsTemporary) &#123; //4. 设置背光到底层LED驱动，调节背光值，不设置背光动画（并且防止非法值时，保证不黑屏，设置最小背光） animateScreenBrightness(animateValue, SCREEN_ANIMATION_RATE_MINIMUM); &#125; else &#123; //设置亮度值到底层驱动，调节背光值，根据slowChange设置快动画还是慢动画 animateScreenBrightness(animateValue, slowChange ? mBrightnessRampRateSlow : mBrightnessRampRateFast); &#125; &#125; &#125;//-------------------------------- //1.手动设置的亮度 private boolean updateUserSetScreenBrightness() &#123; //mPendingScreenBrightnessSetting是通过SettingsObserver监测Settings数据库中的值 //在handleSettingsChange方法中通过getScreenBrightnessSetting()获取 if ((Float.isNaN(mPendingScreenBrightnessSetting) || mPendingScreenBrightnessSetting &lt; 0.0f)) &#123; return false; &#125; if (mCurrentScreenBrightnessSetting == mPendingScreenBrightnessSetting) &#123; mPendingScreenBrightnessSetting = PowerManager.BRIGHTNESS_INVALID_FLOAT; //手动设置的背光 mTemporaryScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT; return false; &#125; mCurrentScreenBrightnessSetting = mPendingScreenBrightnessSetting; mLastUserSetScreenBrightness = mPendingScreenBrightnessSetting; mPendingScreenBrightnessSetting = PowerManager.BRIGHTNESS_INVALID_FLOAT; mTemporaryScreenBrightness = PowerManager.BRIGHTNESS_INVALID_FLOAT; //not a number， 0.0f / 0.0f return true; &#125; private float clampScreenBrightness(float value) &#123; //非法值则返回最小背光值 if (Float.isNaN(value)) &#123; return mScreenBrightnessRangeMinimum; &#125; //当前背光值在最小背光和最大背光之间进行百分比缩放 return MathUtils.constrain( value, mScreenBrightnessRangeMinimum, mScreenBrightnessRangeMaximum); &#125; private void animateScreenBrightness(float target, float rate) &#123; if (DEBUG) &#123; Slog.d(TAG, \"Animating brightness: target=\" + target +\", rate=\" + rate); &#125; if (mScreenBrightnessRampAnimator.animateTo(target, rate)) &#123; Trace.traceCounter(Trace.TRACE_TAG_POWER, \"TargetScreenBrightness\", (int) target); // TODO(b/153319140) remove when we can get this from the above trace invocation SystemProperties.set(\"debug.tracing.screen_brightness\", String.valueOf(target)); try &#123; // TODO(brightnessfloat): change BatteryStats to use float mBatteryStats.noteScreenBrightness( BrightnessSynchronizer.brightnessFloatToInt( mContext, target)); &#125; catch (RemoteException ex) &#123; // same process &#125; &#125;&#125; 异步任务机制AsyncTask在Android中实现异步任务机制有两种方式：Handler和AsyncTask 相比于Handle模式需为每个文物创建新县城，发送消息接受消息过程精细，工具类android.os.AsyncTask使创建异步任务变得更加简单 注意点： 实例必须在UI线程中创建 execute必须在UI线程中调用 不要手动调用onPreExecute，doInBackground，onProgressUpdate，onPostExecute方法 不能在doInBackground(Params… params)中更改UI组件的信 一个任务实例只能执行一次，如果执行第二次将会抛出异常 异步任务主要方法AsyncTask是一个泛型类，它的三个类型参数的含义如下： Params：doInBackground方法的参数类型； Progress：AsyncTask所执行的后台任务的进度类型； Result：后台任务的返回结果类型。 方法： execute(Params… params)，执行一个异步任务，需要在代码中调用此方法，触发异步任务的执行 onPreExecute()，在execute(Params… params)被调用后立即执行，一般用来在执行后台任务前对UI做一些标记 doInBackground(Params… params)，在onPreExecute()完成后立即执行，用于执行较为费时的操作，此方法将接收输入参数和返回计算结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息 onProgressUpdate(Progress… values)，在调用publishProgress(Progress… values)时，此方法被执行，直接将进度信息更新到UI组件上 onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，直接将结果显示到UI组件 自动背光调节主要变量代码主要在frameworks/base/services/core/java/com/android/server/display目录下的DisplayPowerController.java和AutomaticBrightnessController.java 在AutomaticBrightnessController.java中定义了一些自动背光的变量： mScreenAutoBrightness：屏幕亮度级别是由自动亮度算法决定的，实际的亮度应向这个值靠拢。我们保留这个值，即使我们停止使用光传感器，以便我们可以快速恢复到之前的自动亮度级别 mResetAmbientLuxAfterWarmUpConfig：如果设置为true，屏幕点亮后，控制器根据当前传感器读到的值调整亮度；如果是false，控制器将收集更多的数据，然后决定是否改变亮度 mAmbientLux：当前接收的环境光级别 mAmbientLightRingBuffer：用来保存最近环境光传感器读值的环形传感器 AMBIENT_LIGHT_PREDICTION_TIME_MILLIS=100：假定当前传感器读数超出当前时间的有效期，并且确保最后样本的权重非0，这反过来确保了总权重非0 mLightSensorWarmUpTimeConfig：亮屏后在等待光传感器准备时自动亮度调整时间，以毫秒为单位。该值在创建AutomaticBrightnessController对象时被入参赋值 BrightnessMappingStrategy类负责创建背光曲线（从BrightnessConfigure类中读取两个数组源:config_autoBrightnessLevels和config_autoBrightnessDisplayValuesNits），计算自动背光值 背光相关名词 光照度（照度）：从光源照射到单位面积上的光通量,以E表示,照度的单位为勒克斯(Lux) DisplayPowerController初始化背光属性变量 首先通过initPowerManagement方法new一个DisplayPowerController对象 1234567891011121314151617181920 private final class LocalService extends DisplayManagerInternal &#123; @Override public void initPowerManagement(final DisplayPowerCallbacks callbacks, Handler handler, SensorManager sensorManager) &#123; synchronized (mSyncRoot) &#123; DisplayBlanker blanker = new DisplayBlanker() &#123; @Override public void requestDisplayState(int state, float brightness) &#123; ....... &#125;; //创建DisplayPowerController对象 mDisplayPowerController = new DisplayPowerController( mContext, callbacks, handler, sensorManager, blanker, mDisplayDevices.get(Display.DEFAULT_DISPLAY)); mSensorManager = sensorManager; &#125; mHandler.sendEmptyMessage(MSG_LOAD_BRIGHTNESS_CONFIGURATION);&#125; DisplayPowerController构造函数中初始化了很多和亮度相关的属性变量。 mBatteryStats：获取电池信息service状态用于更新电池电量 mSensorManager：获取SensorManager用于调节吧诶广 mWindowManagerPolicy： 亮屏时调用到window绘制屏幕 mBlanker：亮屏以及设置背光时调用到DisplayPowerState的中介类对象 mScreenBrightnessDozeConfig：Doze状态配置亮度 mScreenBrightnessDimConfig：暗屏状态配置亮度 mScreenBrightnessRangeMaximum：屏幕最大亮度 mScreenBrightnessRangeMinimum：屏幕最小亮度 mUseSoftwareAutoBrightnessConfig：是否支持自动亮度 lightSensorWarmUpTimeConfig：Light sensor启动时间 lightSensorRate：sensor采集数据频率，配置在frameworks/base/core/res/res/values/config.xml，默认250 brighteningLightDebounce：变亮防抖时间，同上，默认4000 darkeningLightDebounce：变暗防抖时间，同上，默认8000 autoBrightnessResetAmbientLuxAfterWarmUp：当sensor启动时重置环境光照值，同上，默认true 创建背光曲线（映射）创建曲线示意图整体来看，共创建了三条样条曲线，对Lux-Nit-Backlight进行映射。和8.1不同的是，并非直接由Lux和Baclight映射，而是将Nit作为Lux和Backlight的中间介质。 mNitsToBacklightSpline mBacklightToNitsSpline mBrightnessSpline 流程： 构造函数开始创建在上面DisplayPowerController构造函数中会调用以下函数：mBrightnessMapper = BrightnessMappingStrategy.create(resources); 而BrightnessMappingStrategy.java的create函数中获取配置文件config.xml中的配置值（厂商会覆盖重新配置，一般路径会有overlay），然后根据这个配置值决定映射方式： config_autoBrightnessLevels：环境光lux值，等级和背光对应 config_autoBrightnessLcdBacklightValues：背光等级 1234567891011121314151617&lt;!-- Lux值数组--&gt;&lt;integer-array name=\"config_autoBrightnessLevels\"&gt;&lt;/integer-array&gt;&lt;!-- Lux值对应的背光值数组 --&gt;&lt;integer-array name=\"config_autoBrightnessLcdBacklightValues\"&gt;&lt;/integer-array&gt;&lt;!-- ##### 以下三组是Android Q之后添加 --&gt;&lt;!-- Lux值对应的Nits值数组 --&gt; &lt;array name=\"config_autoBrightnessDisplayValuesNits\"&gt;&lt;/array&gt;&lt;!-- 描述屏幕发光强度的Nits值数组 --&gt;&lt;array name=\"config_screenBrightnessNits\"&gt;&lt;/array&gt;&lt;!-- 和发光强度Nits值对应的背光值数组 --&gt;&lt;integer-array name=\"config_screenBrightnessBacklight\"&gt;&lt;/integer-array&gt; 创建函数： frameworks/base/services/core/java/com/android/server/display/BrightnessMappingStrategy.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Nullablepublic static BrightnessMappingStrategy create(Resources resources) &#123; //lux环境光数组 float[] luxLevels = getLuxLevels(resources.getIntArray( com.android.internal.R.array.config_autoBrightnessLevels)); //Lux值对应的背光值 int[] brightnessLevelsBacklight = resources.getIntArray( com.android.internal.R.array.config_autoBrightnessLcdBacklightValues); //和Lux值对应的屏幕亮度的Nits值数组，长度比Lux值数组大1。如果配置了该值，则： //1.config_screenBrightnessNits必须配置 //2.config_screenBrightnessBacklight必须配置 float[] brightnessLevelsNits = getFloatArray(resources.obtainTypedArray( com.android.internal.R.array.config_autoBrightnessDisplayValuesNits)); //用户可调整的gamma最大值 float autoBrightnessAdjustmentMaxGamma = resources.getFraction( com.android.internal.R.fraction.config_autoBrightnessAdjustmentMaxGamma, 1, 1); //描述屏幕亮度的nits值数组 float[] nitsRange = getFloatArray(resources.obtainTypedArray( com.android.internal.R.array.config_screenBrightnessNits)); //与nitsRange数组中的亮度值(单位为Nits)相对应的屏幕背光值 int[] backlightRange = resources.getIntArray( com.android.internal.R.array.config_screenBrightnessBacklight); long shortTermModelTimeout = resources.getInteger( com.android.internal.R.integer.config_autoBrightnessShortTermModelTimeout); //判断是否是有效映射: //1.非空 //2.长度相同 //3.元素&gt;=0;4.nitsRange/luxLevels必须递增,backlightRange/brightnessLevelsNits必须非递减 if (isValidMapping(nitsRange, backlightRange) &amp;&amp; isValidMapping(luxLevels, brightnessLevelsNits)) &#123; //最小背光值1 int minimumBacklight = resources.getInteger( com.android.internal.R.integer.config_screenBrightnessSettingMinimum); //最大背光值255 int maximumBacklight = resources.getInteger( com.android.internal.R.integer.config_screenBrightnessSettingMaximum); //创建BrightnessConfiguration.Builder实例对象 //将luxLevels和nits值保存进去 BrightnessConfiguration.Builder builder = new BrightnessConfiguration.Builder( luxLevels, brightnessLevelsNits); builder.setShortTermModelTimeoutMillis(shortTermModelTimeout); builder.setShortTermModelLowerLuxMultiplier(SHORT_TERM_MODEL_THRESHOLD_RATIO); builder.setShortTermModelUpperLuxMultiplier(SHORT_TERM_MODEL_THRESHOLD_RATIO); //（1） 映射Lux值和Nits值，而非Lux值和直接显示的背光值，物理映射 //一般执行该流程创建曲线 return new PhysicalMappingStrategy(builder.build(), nitsRange, backlightRange, autoBrightnessAdjustmentMaxGamma); &#125; else if (isValidMapping(luxLevels, brightnessLevelsBacklight)) &#123; //（2） 直接映射Lux值和背光值，简单映射 return new SimpleMappingStrategy(luxLevels, brightnessLevelsBacklight, autoBrightnessAdjustmentMaxGamma, shortTermModelTimeout); &#125; else &#123; return null; &#125;&#125; （1） PhysicalMappingStrategy构造函数一般执行此处流程： BrightnessMappingStrategy.java123456789101112131415161718192021222324252627282930313233343536//=================== //（1） PhysicalMappingStrategy构造函数，创建两条映射曲线 @VisibleForTesting static class PhysicalMappingStrategy extends BrightnessMappingStrategy &#123; .... public PhysicalMappingStrategy(BrightnessConfiguration config, float[] nits, int[] backlight, float maxGamma) &#123; ..... mMaxGamma = maxGamma; //自动亮度调节 mAutoBrightnessAdjustment = 0; //自动亮度开启的情况下，用户手动调节亮度时的当前lux值 mUserLux = -1; //自动亮度开启的情况下，用户手动调节亮度设置的亮度值 mUserBrightness = -1; // Setup the backlight spline final int N = nits.length; float[] normalizedBacklight = new float[N]; for (int i = 0; i &lt; N; i++) &#123; normalizedBacklight[i] = normalizeAbsoluteBrightness(backlight[i]); &#125; //创建Nits-Backlight样条曲线 mNitsToBacklightSpline = Spline.createSpline(nits, normalizedBacklight); //创建Backlight-Nits样条曲线 mBacklightToNitsSpline = Spline.createSpline(normalizedBacklight, nits); mDefaultConfig = config; if (mLoggingEnabled) &#123; PLOG.start(\"physical mapping strategy\"); &#125; mConfig = config; //根据不同的场景创建Lux-nits样条曲线 computeSpline(); &#125; &#125; （1.1） PhysicalMappingStrategy中的computeSpline1234567891011121314151617181920212223242526272829303132 private void computeSpline() &#123; //获取BrightnessConfiguration中的Lux数组和Lux值对应的Nits数组，并放入Pair对象中 Pair&lt;float[], float[]&gt; defaultCurve = mConfig.getCurve(); float[] defaultLux = defaultCurve.first; //lux数组 float[] defaultNits = defaultCurve.second; //和lux对应的nits数组 //创建一个和defaultNits等长的数组，用于存放对应的背光值（从曲线中获取） float[] defaultBacklight = new float[defaultNits.length]; for (int i = 0; i &lt; defaultBacklight.length; i++) &#123; //从mNitsToBacklightSpline中获取背光值，即根据config_autoBrightnessDisplayValuesNits值 //从config_screenBrightnessNits与config_screenBrightnessBacklight的曲线中获取默认的背光值 defaultBacklight[i] = mNitsToBacklightSpline.interpolate(defaultNits[i]); &#125; //对上面获取的背光值进一步加工，如果用户设置过亮度，需将该亮度也加入曲线， //最终得到调整后的lux数组和brightness数组 Pair&lt;float[], float[]&gt; curve = getAdjustedCurve(defaultLux, defaultBacklight, mUserLux, mUserBrightness, mAutoBrightnessAdjustment, mMaxGamma); //最终的lux数组和backlight数组 float[] lux = curve.first; float[] backlight = curve.second; float[] nits = new float[backlight.length]; //根据背光值，从config_screenBrightnessNits和onfig_screenBrightnessBacklight构建的mBacklightToNitsSpline曲线中获取Nit值 for (int i = 0; i &lt; nits.length; i++) &#123; nits[i] = mBacklightToNitsSpline.interpolate(backlight[i]); &#125; //完成创建Lux-nits样条曲线 //最终的背光值从此曲线和mNitsToBacklightSpline曲线中获取 mBrightnessSpline = Spline.createSpline(lux, nits); &#125;public Pair&lt;float[], float[]&gt; getCurve() &#123; return Pair.create(Arrays.copyOf(mLux, mLux.length), Arrays.copyOf(mNits, mNits.length));&#125; Pair容器类Pair对两个对象组成的元素组进行传递。这个对象提供了一个合理的equals()方法，如果两个对象的first和second值相等则返回true 特征： Pair(F first, S second)，一个Pair容器里面有2个元素，他们成组存在。 Pair里面两个元素都是final的 Pair的equals是值比较，不是地址比较 示例： 12345String PAIR = \"PAIR\";Pair p1 = new Pair(18, \"张三\"); // 通过 构造函数 实例化对象Pair p2 = Pair.create(20, \"李四\");//通过 create方法 实例化对象boolean e1 = p1.equals(p2);Log.d(PAIR, \"RESULT: \" + e1); // false （2） SimpleMappingStrategy构造函数BrightnessMappingStrategy.java1234567891011121314151617181920//=================== //（2） 调用SimpleMappingStrategy构造函数 private SimpleMappingStrategy(float[] lux, int[] brightness, float maxGamma, long timeout) &#123; final int N = brightness.length; mLux = new float[N]; mBrightness = new float[N]; for (int i = 0; i &lt; N; i++) &#123; mLux[i] = lux[i]; mBrightness[i] = normalizeAbsoluteBrightness(brightness[i]); &#125; mMaxGamma = maxGamma; mAutoBrightnessAdjustment = 0; mUserLux = -1; mUserBrightness = -1; //映射lux和brightness曲线 computeSpline(); mShortTermModelTimeout = timeout; &#125; （2.1） SimpleMappingStrategy中的computeSplineBrightnessMappingStrategy.java1234567private void computeSpline() &#123; //计算调整，得到调整后的Lux值数组和backlight值数组 Pair&lt;float[], float[]&gt; curve = getAdjustedCurve(mLux, mBrightness, mUserLux, mUserBrightness, mAutoBrightnessAdjustment, mMaxGamma); //Lux-Nits曲线,最终的背光值从此曲线+mNitsToBacklightSpline曲线获取 mSpline = Spline.createSpline(curve.first, curve.second);&#125; AutomaticBrightnessController初始化在DisplayPowerController构造函数中创建了AutomaticBrightnessController对象 frameworks/base/services/core/java/com/android/server/display/DisplayPowerController.java12345678910111213141516....mBrightnessMapper = BrightnessMappingStrategy.create(resources);//背光曲线不为空if (mBrightnessMapper != null) &#123; //实例化 mAutomaticBrightnessController = new AutomaticBrightnessController(this, handler.getLooper(), sensorManager, lightSensor, mBrightnessMapper, lightSensorWarmUpTimeConfig, mScreenBrightnessRangeMinimum, mScreenBrightnessRangeMaximum, dozeScaleFactor, lightSensorRate, initialLightSensorRate, brighteningLightDebounce, darkeningLightDebounce, autoBrightnessResetAmbientLuxAfterWarmUp, ambientBrightnessThresholds, screenBrightnessThresholds, context, displayDeviceConfig);&#125; else &#123; mUseSoftwareAutoBrightnessConfig = false;&#125;.... *configure方法配置AutomaticBrightnessController 在updatePowerState()中也会对mAutomaticBrightnessController对象进行配置： DisplayPowerController.java1234567891011121314151617181920212223242526 private void updatePowerState() &#123; ....... // If the brightness is already set then it's been overridden by something other than the // user, or is a temporary adjustment. boolean userInitiatedChange = (Float.isNaN(brightnessState)) &amp;&amp; (autoBrightnessAdjustmentChanged || userSetBrightnessChanged); boolean hadUserBrightnessPoint = false; // Configure auto-brightness. if (mAutomaticBrightnessController != null) &#123; //曲线中是否有用户设置的短期点 hadUserBrightnessPoint = mAutomaticBrightnessController.hasUserDataPoints(); mAutomaticBrightnessController.configure(autoBrightnessEnabled, mBrightnessConfiguration, mLastUserSetScreenBrightness, userSetBrightnessChanged, autoBrightnessAdjustment, autoBrightnessAdjustmentChanged, mPowerRequest.policy); &#125; .... &#125;//表示是否在自动背光打开的情况下拖动亮度条调节过亮度//判断依据是BrightnessMappingStrategy中的mUserLux成员，它表示用户在开启自动背光后手动设置亮度时的Lux值@Overridepublic boolean hasUserDataPoints() &#123; return mUserLux != -1;&#125; 配置的参数： autoBrightnessEnabled：表示自动背光是否可用 1234567final boolean autoBrightnessEnabledInDoze = mAllowAutoBrightnessWhileDozingConfig &amp;&amp; Display.isDozeState(state);//打开了自动亮度调节&amp;&amp;(亮屏或Doze)&amp;&amp;局部变量brightness为0&amp;&amp;BrightnessMappingStrategy不为空final boolean autoBrightnessEnabled = mPowerRequest.useAutoBrightness &amp;&amp; (state == Display.STATE_ON || autoBrightnessEnabledInDoze) &amp;&amp; Float.isNaN(brightnessState) &amp;&amp; mAutomaticBrightnessController != null; mBrightnessConfiguration：BrightnessConfiguration对象，携带有用于创建曲线的Lux值数组和对应的Nit值数组。每一个用户可对应一个BrightnessConfiguration，由DisplayManagerService设置 userSetBrightnessChanged：用户是否手动通过拖动亮度条设置过亮度 autoBrightnessAdjustmentChanged：自动背光调整至adjustment是否发生变化（对应的即下面configure中的userChangedAutoBrightnessAdjustment） displayPolicy：当前请求的屏幕状态 configure()函数方法 1234567891011121314151617181920212223242526272829303132public void configure(boolean enable, @Nullable BrightnessConfiguration configuration, float brightness, boolean userChangedBrightness, float adjustment, boolean userChangedAutoBrightnessAdjustment, int displayPolicy) &#123; //是否要进入Doze状态 boolean dozing = (displayPolicy == DisplayPowerRequest.POLICY_DOZE); //step 1: 设置BrightnessConfiguration对象，若发生变化返回true boolean changed = setBrightnessConfiguration(configuration); //step 2: 设置Display状态，若发生变化返回true changed |= setDisplayPolicy(displayPolicy); //step 3: 如果用户改变自动背光调节值，设置自动背光调节值 if (userChangedAutoBrightnessAdjustment) &#123; changed |= setAutoBrightnessAdjustment(adjustment); &#125; //step 4: 如果在自动亮度开启的情况下调节了亮度，需要将当前的Lux值和用户设置的亮度添加到曲线中 if (userChangedBrightness &amp;&amp; enable) &#123; // Update the brightness curve with the new user control point. It's critical this // happens after we update the autobrightness adjustment since it may reset it. changed |= setScreenBrightnessByUser(brightness); &#125; final boolean userInitiatedChange = userChangedBrightness || userChangedAutoBrightnessAdjustment; if (userInitiatedChange &amp;&amp; enable &amp;&amp; !dozing) &#123; //step 5 prepareBrightnessAdjustmentSample(); &#125; //step 6: 注册LightSensor changed |= setLightSensorEnabled(enable &amp;&amp; !dozing); //step 7: 如果changed为true，更新自动背光亮度值，但不会主动调用DPC更新背光 if (changed) &#123; updateAutoBrightness(false /*sendUpdate*/, userInitiatedChange); &#125;&#125; 1. setBrightnessConfiguration 针对每个用户，都会有一个BrightnessConfiguration和它映射，所以当切换用户后，设备的背光将可能发生改变 当BrightnessConfiguration发生改变且在BrighnessMappingStragety中设置完成后，将会通过resetShortTermModel()清除原有用户的配置 清除用户设置的亮度和对应Lux的三种情况： 切换用户：handleSettingsChange BrightnessConfigure对象发生变化：setBrightnessConfiguration 屏幕进入不可交互状态超过30s，且再次进入交互状态后环境光发生变化：setDisplayPolicy 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//display/AutomaticBrightnessController.java public boolean setBrightnessConfiguration(BrightnessConfiguration configuration) &#123; //Step 1 if (mBrightnessMapper.setBrightnessConfiguration(configuration)) &#123; //Step 2 resetShortTermModel(); return true; &#125; return false; &#125; public void resetShortTermModel() &#123; //清楚用户添加的曲线Points mBrightnessMapper.clearUserDataPoints(); //表示短期模型仍有效 mShortTermModelValid = true; mShortTermModelAnchor = -1; &#125;//display/BrightnessMappingStrategy.java @Override public boolean setBrightnessConfiguration(@Nullable BrightnessConfiguration config) &#123; if (config == null) &#123; config = mDefaultConfig; &#125; if (config.equals(mConfig)) &#123; return false; &#125; if (mLoggingEnabled) &#123; PLOG.start(\"brightness configuration\"); &#125; //如果config对象发生改变，则替换后，会调用computeSpline重新创建Lux-Nits曲线 mConfig = config; computeSpline(); return true; &#125; @Override public void clearUserDataPoints() &#123; if (mUserLux != -1) &#123; //重置变量 mAutoBrightnessAdjustment = 0; mUserLux = -1; mUserBrightness = -1; //重新创建曲线 computeSpline(); &#125; &#125; 2. setDisplayPolicy该方法主要根据屏幕状态来设置mShortTermModelValid的值 当屏幕状态进入Doze或者Asleep后，会发送一个定义Handler，并在到达时间后将mShortTermModelValid值置为false 123456789101112131415161718//display/AutomaticBrightnessController.java private boolean setDisplayPolicy(int policy) &#123; if (mDisplayPolicy == policy) &#123; return false; &#125; final int oldPolicy = mDisplayPolicy; mDisplayPolicy = policy; //如果Display状态值由交互变为不可交互状态 if (!isInteractivePolicy(policy) &amp;&amp; isInteractivePolicy(oldPolicy)) &#123; //发送一个30s的延迟消息，30s后将mShortTermModelValid置为false mHandler.sendEmptyMessageDelayed(MSG_INVALIDATE_SHORT_TERM_MODEL, mBrightnessMapper.getShortTermModelTimeout()); //如果Display状态值由不可交互变为交互状态，移除延时消息的发送 &#125; else if (isInteractivePolicy(policy) &amp;&amp; !isInteractivePolicy(oldPolicy)) &#123; mHandler.removeMessages(MSG_INVALIDATE_SHORT_TERM_MODEL); &#125; return true; &#125; 3. setAutoBrightnessAdjustment用于设置自动背光调整值，前提是自动背光调整值已经发生变化 123456789101112131415161718192021222324//display/AutomaticBrightnessController.java private boolean setAutoBrightnessAdjustment(float adjustment) &#123; return mBrightnessMapper.setAutoBrightnessAdjustment(adjustment); &#125;//display/BrightnessMappingStrategy.java @Override public boolean setAutoBrightnessAdjustment(float adjustment) &#123; //限制，取值范围为[-1,1] adjustment = MathUtils.constrain(adjustment, -1, 1); //adjustment未发生变化 if (adjustment == mAutoBrightnessAdjustment) &#123; return false; &#125; if (mLoggingEnabled) &#123; Slog.d(TAG, \"setAutoBrightnessAdjustment: \" + mAutoBrightnessAdjustment + \" =&gt; \" + adjustment); PLOG.start(\"auto-brightness adjustment\"); &#125; //adjustment发生变化，则重新创建曲线 mAutoBrightnessAdjustment = adjustment; computeSpline(); return true; &#125; 4. setScreenBrightnessByUser用于将用户拖动亮度条设置的亮度和当时的Lux值添加到用于创建曲线的数组中，并重新创建曲线 123456789101112131415//AutomaticBrightnessController.java//添加用户设置亮度 private boolean setScreenBrightnessByUser(float brightness) &#123; if (!mAmbientLuxValid) &#123; // If we don't have a valid ambient lux then we don't have a valid brightness anyway, // and we can't use this data to add a new control point to the short-term model. return false; &#125; //将当前的Lux值和用户设置的背光值添加到曲线中 mBrightnessMapper.addUserDataPoint(mAmbientLux, brightness); //更新设置当前lux值 mShortTermModelValid = true; mShortTermModelAnchor = mAmbientLux; return true; &#125; 5. prepareBrightnessAdjustmentSample调用configure更新时，做一些标记记录 6. setLightSensorEnabled用于LightSensor的注册和解除注册，当设备处于亮屏状态且打开自动背光功能时，将注册一个LightSensor，以监听环境光的强度变化 1234567891011121314151617181920//AutomaticBrightnessController.java private boolean setLightSensorEnabled(boolean enable) &#123; if (enable) &#123; if (!mLightSensorEnabled) &#123; .... registerForegroundAppUpdater(); //注册 mSensorManager.registerListener(mLightSensorListener, mLightSensor, mCurrentLightSensorRate * 1000, mHandler); return true; &#125; &#125; else if (mLightSensorEnabled) &#123; ..... mHandler.removeMessages(MSG_UPDATE_AMBIENT_LUX); unregisterForegroundAppUpdater(); //解除 mSensorManager.unregisterListener(mLightSensorListener); &#125; return false; &#125; 7. *updateAutoBrightness自动背光获取更新自动背光亮度值 从这处流程可以看出自动背光获取的方式： 首先会根据当前的Lux值，从mBrightnessSpline曲线中寻找对应的Nit值 然后根据Nit值，从曲线mNitsToBacklightSpline中获取到最终的背光值 其中mBrightnessSpline曲线是由Lux值数组和它对应的Nit值数组创建，mNitsToBacklightSpline是由配置文件中的config_screenBrightnessNits和config_screenBrightnessBacklight创建 具体的创建在computeSline()方法中 1234567891011121314151617181920212223242526272829303132333435//AutomaticBrightnessController.java private void updateAutoBrightness(boolean sendUpdate, boolean isManuallySet) &#123; if (!mAmbientLuxValid) &#123; return; &#125; //根据lux值从曲线中获取背光值（区间是[0, 1.0]的浮点数） float value = mBrightnessMapper.getBrightness(mAmbientLux, mForegroundAppPackageName, mForegroundAppCategory); //得到最终的自动背光值 float newScreenAutoBrightness = clampScreenBrightness(value); if (!BrightnessSynchronizer.floatEquals(mScreenAutoBrightness, newScreenAutoBrightness)) &#123; mScreenAutoBrightness = newScreenAutoBrightness; mScreenBrighteningThreshold = clampScreenBrightness( mScreenBrightnessThresholds.getBrighteningThreshold(newScreenAutoBrightness)); mScreenDarkeningThreshold = clampScreenBrightness( mScreenBrightnessThresholds.getDarkeningThreshold(newScreenAutoBrightness)); //背光更新 if (sendUpdate) &#123; mCallbacks.updateBrightness(); &#125; &#125; &#125;//BrightnessMappingStrategy.java @Override public float getBrightness(float lux, String packageName, @ApplicationInfo.Category int category) &#123; //根据lux从曲线中获取nits，然后获取背光 float nits = mBrightnessSpline.interpolate(lux); float backlight = mNitsToBacklightSpline.interpolate(nits); ... return backlight; &#125; adjustment变量计算例如dump我的一加六（Android 10）设备，adb shell dumpsys display信息： 12345678910111213&#x2F;&#x2F;开启自动亮度调节后dumpPhysicalMappingStrategy mConfig&#x3D;BrightnessConfiguration&#123;[(0.0, 2.0487), (1.0, 4.848), (4.0, 17.2347), (12.0, 39.0867), (20.0, 50.671), (40.0, 92.3019), (65.0, 94.2512), (95.0, 98.372), (140.0, 100.297), (200.0, 105.297), (350.0, 120.385), (650.0, 142.064), (1300.0, 236.5179), (2000.0, 350.0267), (3300.0, 427.6287)], &#123;&#125;, &#39;&#39;&#125; &#x2F;&#x2F;背光曲线 mBrightnessSpline&#x3D;MonotoneCubicSpline&#123;[(0.0, 2.0487: 2.7699974), (1.0, 4.8186975: 3.4543567), (4.0, 17.234846: 3.435018), (12.0, 39.085403: 2.089745), (20.0, 50.67077: 1.7645122), (40.0, 92.28784: 0.23451348), (65.0, 94.25191: 0.023499148), (95.0, 98.38648: 0.09019067), (140.0, 100.30178: 0.0627253), (200.0, 105.275085: 0.0918182), (350.0, 120.38728: 0.08650002), (650.0, 142.0629: 0.108782366), (1300.0, 236.51614: 0.15355834), (2000.0, 349.77896: 0.11084422), (3300.0, 427.6287: 0.05988441)]&#125; &#x2F;&#x2F;nits对应背光的曲线 mNitsToBacklightSpline&#x3D;MonotoneCubicSpline&#123;[(2.0482, 0.0019550342: 0.00395116), (2.543, 0.0039100684: 0.004002362), (3.0253, 0.0058651026: 0.0040531447), (3.5077, 0.007820137: 0.0037272798), (4.0824, 0.009775171: 0.00419204), (4.4748, 0.011730205: 0.005721517), (5.08, 0.015640274: 0.004685791), (6.4233, 0.019550342: 0.002632065), (8.0848, 0.02346041: 0.0017233933), (11.6607, 0.027370479: 0.001788805), (13.2347, 0.031280547: 0.0023087142), (15.0676, 0.035190616: 0.0021758107), (16.8302, 0.039100684: 0.0023342122), (18.4261, 0.043010753: 0.002262629), (20.3103, 0.04692082: 0.0022641667), (21.9042, 0.05083089: 0.00241765), (23.5456, 0.054740958: 0.00236309), (25.2137, 0.058651026: 0.0021678535), (27.1769, 0.062561095: 0.0020940518), (28.9571, 0.06647117: 0.0023456002), (30.5244, 0.07038123: 0.0023162398), (32.3535, 0.074291304: 0.0021968414), (34.0867, 0.07820137: 0.0023086662), (42.366, 0.097751714: 0.0022959393), (51.1309, 0.11730205: 0.0022804863), (59.52, 0.1368524: 0.0023538377), (67.744, 0.15640274: 0.002376392), (75.9738, 0.17595308: 0.002316629), (84.6332, 0.19550343: 0.002155731), (94.1525, 0.21505377: 0.002238446), (102.2207, 0.2346041: 0.0023939852), (110.4878, 0.25415444: 0.0026741978), (117.0405, 0.2737048: 0.0028248527), (124.3733, 0.29325512: 0.0028097979), (130.9928, 0.31280547: 0.00251312), (140.4247, 0.33235583: 0.0021358524), (149.3156, 0.35190615: 0.0023393487), (157.1995, 0.3714565: 0.0024370078), (165.3651, 0.39100686: 0.0024333047), (173.2726, 0.41055718: 0.0024349196), (181.4272, 0.43010753: 0.0024660935), (189.1402, 0.44965786: 0.0024320162), (197.5334, 0.4692082: 0.0023719585), (205.6301, 0.48875856: 0.002383901), (213.9381, 0.5083089: 0.002348846), (222.2769, 0.5278592: 0.002423523), (230.0891, 0.5474096: 0.002398687), (238.6084, 0.5669599: 0.002379861), (246.5399, 0.58651024: 0.0023049354), (255.6544, 0.6060606: 0.0022993367), (263.6221, 0.62561095: 0.002403119), (271.9324, 0.6451613: 0.002531584), (279.1449, 0.66471165: 0.0023920578), (288.5736, 0.684262: 0.002112214), (297.6628, 0.7038123: 0.0022218374), (306.1899, 0.7233627: 0.0023296294), (314.4511, 0.742913: 0.0024545297), (322.1404, 0.76246333: 0.002378489), (330.969, 0.7820137: 0.002454385), (338.2251, 0.80156404: 0.0025690594), (346.2251, 0.82111436: 0.0023937116), (354.567, 0.8406647: 0.0017740328), (370.799, 0.86021507: 2.6955837E-4), (413.1738, 0.8797654: 0.0013575983), (415.6397, 0.8993157: 0.009982219), (417.264, 0.9188661: 0.010905683), (419.264, 0.9384164: 0.009775162), (421.264, 0.95796674: 0.007777949), (424.646, 0.9775171: 0.0066592516), (427.6287, 1.0: 0.0075377673)]&#125; mMaxGamma&#x3D;3.0 mAutoBrightnessAdjustment&#x3D;0.0 mUserLux&#x3D;-1.0 mUserBrightness&#x3D;-1.0 mDefaultConfig&#x3D;BrightnessConfiguration&#123;[(0.0, 2.0487), (1.0, 4.848), (4.0, 17.2347), (12.0, 39.0867), (20.0, 50.671), (40.0, 92.3019), (65.0, 94.2512), (95.0, 98.372), (140.0, 100.297), (200.0, 105.297), (350.0, 120.385), (650.0, 142.064), (1300.0, 236.5179), (2000.0, 350.0267), (3300.0, 427.6287)], &#123;&#125;, &#39;&#39;&#125; 用户手动调节亮度条入参adjustment，范围是[-1.0, 1.0] DisplayManager的setTemporaryAutoBrightnessAdjustment接口供上层应用调用，作为入口 1234567891011frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;display&#x2F;DisplayManager.java - setTemporaryAutoBrightnessAdjustment ----&gt;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;hardware&#x2F;display&#x2F;DisplayManagerGlobal.java - setTemporaryAutoBrightnessAdjustment [入参adjustment] ----&gt;IDisplayManager.aidl - setTemporaryAutoBrightnessAdjustment [AIDL跨进程] ----&gt;DisplayManagerService.java - setTemporaryAutoBrightnessAdjustment [Binder call] ---&gt;DisplayPowerController.java - setTemporaryAutoBrightnessAdjustment [消息处理] -----&gt;updatePowerState ----&gt;（1） updateUserSetScreenBrightness [mLastUserSetScreenBrightness更新值，并返回true赋值给userSetBrightnessChanged] 详细代码参考上面小节（2） AutomaticBrightnessController.configure [会入参上面两个变量：mLastUserSetScreenBrightness和userSetBrightnessChanged] ----&gt;setScreenBrightnessByUser ----&gt;BrightnessMappingStrategy.java - addUserDataPoint ----&gt;getUnadjustedBrightness 大致流程： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160//DisplayPowerController.java - updatePowerState ... if (mAutomaticBrightnessController != null) &#123; hadUserBrightnessPoint = mAutomaticBrightnessController.hasUserDataPoints(); mAutomaticBrightnessController.configure(autoBrightnessEnabled, mBrightnessConfiguration, mLastUserSetScreenBrightness, userSetBrightnessChanged, autoBrightnessAdjustment, autoBrightnessAdjustmentChanged, mPowerRequest.policy); &#125;//============================//AutomaticBrightnessController.java//mLastUserSetScreenBrightness对应brightness//userSetBrightnessChanged对应userChangedBrightness//autoBrightnessAdjustment对应adjustment public void configure(boolean enable, @Nullable BrightnessConfiguration configuration, float brightness, boolean userChangedBrightness, float adjustment, boolean userChangedAutoBrightnessAdjustment, int displayPolicy) &#123; .... if (userChangedBrightness &amp;&amp; enable) &#123; // Update the brightness curve with the new user control point. It's critical this // happens after we update the autobrightness adjustment since it may reset it. changed |= setScreenBrightnessByUser(brightness); &#125; ....//============================//BrightnessMappingStrategy.java//brightness即上面传参的用户手动设置的背光mLastUserSetScreenBrightness @Override public void addUserDataPoint(float lux, float brightness) &#123; //step 1： 获取默认配置值创建的曲线中Lux值对应的背光值 float unadjustedBrightness = getUnadjustedBrightness(lux); //step 2： 通过传入的三个值计算调整 自动背光值 float adjustment = inferAutoBrightnessAdjustment(mMaxGamma, brightness /* desiredBrightness */, unadjustedBrightness /* currentBrightness */); //更新自动背光调整值（浮点） mAutoBrightnessAdjustment = adjustment; //表示用户在开启自动背光情况下拖动亮度条调节亮度时的当时Lux值 mUserLux = lux; //表示用户在开启自动背光情况下拖动亮度条调节亮度值 mUserBrightness = brightness; //step 3： 更新曲线图 computeSpline(); &#125; //step 1 获取曲线中的对应背光值 private float getUnadjustedBrightness(float lux) &#123; //获取BrightnessConfiguration中的Lux-Nits映射 Pair&lt;float[], float[]&gt; curve = mConfig.getCurve(); //创建一个lux-nits样条曲线 Spline spline = Spline.createSpline(curve.first, curve.second); //根据lux得到nits值，再根据nit值从mNitsToBacklightSpline中的到对应的背光 0-1的float浮点数 return mNitsToBacklightSpline.interpolate(spline.interpolate(lux)); &#125; //step 2 推断adjustment值 protected float inferAutoBrightnessAdjustment(float maxGamma, float desiredBrightness, float currentBrightness) &#123; float adjustment = 0; float gamma = Float.NaN; // 当前Lux值对应的默认配置亮度值 &lt;=25.5 || &gt;= 229.5 (0-255默认背光) if (currentBrightness &lt;= 0.1f || currentBrightness &gt;= 0.9f) &#123; adjustment = (desiredBrightness - currentBrightness); //最暗的可能情况 &#125; else if (desiredBrightness == 0) &#123; adjustment = -1; //最大亮度255 &#125; else if (desiredBrightness == 1) &#123; adjustment = +1; &#125; else &#123; // current^gamma = desired =&gt; gamma = log[current](desired) //根据换底公式，得到currentBrightness为底desiredBrightness的对数 gamma = MathUtils.log(desiredBrightness) / MathUtils.log(currentBrightness); // max^-adjustment = gamma =&gt; adjustment = -log[max](gamma) //maxGamma为底gamma的对数 adjustment = -MathUtils.log(gamma) / MathUtils.log(maxGamma); &#125; adjustment = MathUtils.constrain(adjustment, -1, +1); //返回计算后的adjustment return adjustment; &#125; //step 3 在computeSpline方法重新创建样条曲线的时候，会调用getAdjustedCurve函数 protected Pair&lt;float[], float[]&gt; getAdjustedCurve(float[] lux, float[] brightness, float userLux, float userBrightness, float adjustment, float maxGamma) &#123; float[] newLux = lux; float[] newBrightness = Arrays.copyOf(brightness, brightness.length); //限定取值范围 adjustment = MathUtils.constrain(adjustment, -1, 1); //maxGamma 的 -adjustment次方得到gamma值 float gamma = MathUtils.pow(maxGamma, -adjustment); //gamma != 1说明adjustment不为0 if (gamma != 1) &#123; for (int i = 0; i &lt; newBrightness.length; i++) &#123; //重新设置亮度值，新的亮度值为就亮度值的gamma次方 newBrightness[i] = MathUtils.pow(newBrightness[i], gamma); &#125; &#125; //用户在BrightnessController拖动条上手动调节了亮度 if (userLux != -1) &#123; //插入一对新的lux和对应背光值 Pair&lt;float[], float[]&gt; curve = insertControlPoint(newLux, newBrightness, userLux, userBrightness); newLux = curve.first; newBrightness = curve.second; if (mLoggingEnabled) &#123; // This is done for comparison. curve = insertControlPoint(lux, brightness, userLux, userBrightness); &#125; &#125; //返回该Pair对象给到computeSpline()中 return Pair.create(newLux, newBrightness); &#125; private Pair&lt;float[], float[]&gt; insertControlPoint( float[] luxLevels, float[] brightnessLevels, float lux, float brightness) &#123; //找到插入点索引，以保持值的递增 final int idx = findInsertionPoint(luxLevels, lux); final float[] newLuxLevels; final float[] newBrightnessLevels; //1. 插入索引等于数组长度 if (idx == luxLevels.length) &#123; //需要插入到末尾位置，且新Lux数组长度比原来大1 newLuxLevels = Arrays.copyOf(luxLevels, luxLevels.length + 1); newBrightnessLevels = Arrays.copyOf(brightnessLevels, brightnessLevels.length + 1); newLuxLevels[idx] = lux; newBrightnessLevels[idx] = brightness; //2. 用户lux值已处在lux值数组中 &#125; else if (luxLevels[idx] == lux) &#123; newLuxLevels = Arrays.copyOf(luxLevels, luxLevels.length); newBrightnessLevels = Arrays.copyOf(brightnessLevels, brightnessLevels.length); newBrightnessLevels[idx] = brightness; &#125; else &#123; //初始化新的lux数组，长度比原数组大1 newLuxLevels = Arrays.copyOf(luxLevels, luxLevels.length + 1); //将原数组从idx位置起的元素，向后移动1位，将新的Lux值插入到idx位置 System.arraycopy(newLuxLevels, idx, newLuxLevels, idx+1, luxLevels.length - idx); newLuxLevels[idx] = lux; //初始化新亮度值数组，长度比原数组大1 newBrightnessLevels = Arrays.copyOf(brightnessLevels, brightnessLevels.length + 1); //原数组从idx位置起的元素，向后移动1位，将新的亮度值值插入到idx位置 System.arraycopy(newBrightnessLevels, idx, newBrightnessLevels, idx+1, brightnessLevels.length - idx); newBrightnessLevels[idx] = brightness; &#125; //平滑曲线 //newLuxLevels之后的Lux对应的亮度值将全部为newBrightnessLevels smoothCurve(newLuxLevels, newBrightnessLevels, idx); //返回一个携带有Lux和背光值的Pair对象给getAdjustedCurve() return Pair.create(newLuxLevels, newBrightnessLevels); &#125; //返回arr数组（递增）中开始大于等于val值的 数组下标 private int findInsertionPoint(float[] arr, float val) &#123; for (int i = 0; i &lt; arr.length; i++) &#123; if (val &lt;= arr[i]) &#123; return i; &#125; &#125; return arr.length; &#125; debug调试 dump power：执行命令adb shell dumpsys power|grep &quot;Brightness&quot;查看背光相关 抓取log查看上层背光变化，背光节点，以及kernel中背光变化 在DisplayPowerController.java中将Debug log开关打开 使用dump查看自动亮度调节的变量值: adb shell dumpsys display 参考 Android R AOSP源码Opensys 详解Android中AsyncTask的使用 深入理解AsyncTask的工作原理 Android Message和obtainMessage的区别 Handler的sendMessage和obtainMessage和sendToTarget比较 Android7.1 亮度自动调节 *Android 9.0 自动背光机制分析","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android R Vsync相关梳理","slug":"2021/210414_android_VsyncStudy","date":"2021-04-14T12:55:00.000Z","updated":"2021-05-27T14:44:23.568Z","comments":true,"path":"2021/04/14/2021/210414_android_VsyncStudy/","link":"","permalink":"https://alonealive.github.io/Blog/2021/04/14/2021/210414_android_VsyncStudy/","excerpt":"为了理解systrace中HW Vsync， sf vsync， app vsync的含义和作用。这里主要参照Android R AOSP源码对这几种VSYNC的关系和调用流程进行大致的梳理。","text":"为了理解systrace中HW Vsync， sf vsync， app vsync的含义和作用。这里主要参照Android R AOSP源码对这几种VSYNC的关系和调用流程进行大致的梳理。 vsync相关线程 EventControlThread: 控制硬件vsync的开关 DispSyncThread: 软件产生vsync的线程，接收HWComposer HAL的VSYNC信号，并分发给EventThread SF EventThread: 该线程用于SurfaceFlinger接收vsync信号用于渲染 App EventThread: 该线程用于接收vsync信号并且上报给App进程，App开始绘制 四种vsync从这4个线程，可以将vsync分为4种不同的类型： HW vsync, 真实由硬件产生的vsync信号 SW vsync, 由DispSync产生的vsync信号 SF vsync, SF接收到的vsync信号 App vsync, App接收到的vsync信号 硬件vsyncHWComposer HAL通过callback函数，把VSYNC信号传给DispSyncThread，DispSyncThread传给EventThread 函数调用总流程图 部分流程： 123456789101112131415161718192021SurfaceFlinger::init() ----&gt;SurfaceFlinger::processDisplayHotplugEventsLocked() ----&gt;SurfaceFlinger::initScheduler 创建sf thread和app thread ----&gt;(1)Scheduler::createConnection ----&gt;Scheduler::createConnectionInternal ----&gt;EventThread::createEventConnection [new EventThreadConnection创建对象](2)MessageQueue::setEventConnection ----&gt;(2.1) mEventTube.getFd()(2.2) stealReceiveChannel(2.3) MessageQueue::cb_eventReceiver ----&gt;MessageQueue::eventReceiver [接收Vsync信号] ----&gt;MessageQueue::Handler::dispatchInvalidate [Handler消息处理]----&gt;MessageQueue::Handler::handleMessage ----&gt;SurfaceFlinger::onMessageReceived ----&gt;SurfaceFlinger::onMessageInvalidate -----&gt;&#x2F;&#x2F;合成刷新是通过frameAvailableListener-&gt;onFrameAvailable(item)触发SurfaceFlinger::signalLayerUpdate() 请求合成 ----&gt;MessageQueue::invalidate() -----&gt;EventThreadConnection::requestNextVsync() SF创建EventThread(app&amp;sf)12345678910111213//函数SurfaceFlinger::initScheduler // start the EventThread，调用setVsyncEnabled函数控制硬件Vysnc mScheduler = getFactory().createScheduler([this](bool enabled) &#123; setVsyncEnabled(enabled); &#125;, *mRefreshRateConfigs, *this); mAppConnectionHandle = mScheduler-&gt;createConnection(\"app\", mPhaseConfiguration-&gt;getCurrentOffsets().late.app, impl::EventThread::InterceptVSyncsCallback()); mSfConnectionHandle = mScheduler-&gt;createConnection(\"sf\", mPhaseConfiguration-&gt;getCurrentOffsets().late.sf, [this](nsecs_t timestamp) &#123; mInterceptor-&gt;saveVSyncEvent(timestamp); &#125;); SF注册Connection12345678910111213141516171819202122232425262728293031//frameworks/native/services/surfaceflinger/Scheduler/EventThread.cppEventThreadConnection::EventThreadConnection(EventThread* eventThread, ResyncCallback resyncCallback, ISurfaceComposer::ConfigChanged configChanged) : resyncCallback(std::move(resyncCallback)), mConfigChanged(configChanged), mEventThread(eventThread), mChannel(gui::BitTube(8 * 1024 /* default size is 4KB, double it */)) &#123;&#125;void EventThreadConnection::onFirstRef() &#123; // NOTE: mEventThread doesn't hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125;status_t EventThread::registerDisplayEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); // this should never happen auto it = std::find(mDisplayEventConnections.cbegin(), mDisplayEventConnections.cend(), connection); if (it != mDisplayEventConnections.cend()) &#123; ALOGW(\"DisplayEventConnection %p already exists\", connection.get()); mCondition.notify_all(); return ALREADY_EXISTS; &#125; //添加到mDisplayEventConnections集合中 mDisplayEventConnections.push_back(connection); //唤醒threadMain函数（唤醒所有等待队列中阻塞的线程，存在锁争用，只有一个线程能够获得锁） mCondition.notify_all(); return NO_ERROR;&#125; Note： 有关notify_all和unique_lock&lt;std::mutex&gt;锁可参考：C++11条件变量：notify_one()与notify_all()的区别 sf请求vsync两条请求vsync的流程： 参考signalLayerUpdate通知Layer更新信息开始，SF触发合成开始请求VSYNC 当显示屏准备完毕，SF EventThread connection开始监听Vsync信号，相关流程： 12345678SurfaceFlinger::init() ----&gt;SurfaceFlinger::initializeDisplays() 设置初始条件 -----&gt;SurfaceFlinger::onInitializeDisplays() -----&gt;SurfaceFlinger::setTransactionState ----&gt;SurfaceFlinger::setTransactionFlags ----&gt;SurfaceFlinger::signalTransaction() ----&gt;MessageQueue::invalidate() [在请求刷新合成时也会调用] -----&gt;EventThread::requestNextVsync EventThread线程唤醒函数threadmain部分代码： 12345678910111213//frameworks/native/services/surfaceflinger/Scheduler/EventThread.cppvoid EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; if (connection-&gt;resyncCallback) &#123; connection-&gt;resyncCallback(); &#125; std::lock_guard&lt;std::mutex&gt; lock(mMutex); if (connection-&gt;vsyncRequest == VSyncRequest::None) &#123; //None=-1 connection-&gt;vsyncRequest = VSyncRequest::Single; //Single=0，只接收一次信号 mCondition.notify_all(); //唤醒threadmain函数 &#125;&#125; 在threadmain函数其中创建了DisplayEventReceiver对象，该类用于传输VSYNC信号。 12345678DisplayEventReceiver::DisplayEventReceiver (MessageQueue::setEventConnection) ----&gt;EventThreadConnection::stealReceiveChannel -----&gt;//函数MessageQueue::setEventConnection也会调用到此处status_t EventThreadConnection::stealReceiveChannel(gui::BitTube* outChannel) &#123; outChannel-&gt;setReceiveFd(mChannel.moveReceiveFd()); return NO_ERROR;&#125; 调用DispSyncSource.setVSyncEnabled开启硬件Vsync BitTube参考：setEventThread变更 BitTube，其实现是socketpairt套接字，用于传递消息。Buffer大小是4K DisplayEventReceiver查看该类的头文件，关于vsync的主要函数作用： 123456789101112131415161718192021222324252627282930313233//frameworks/native/libs/gui/include/gui/DisplayEventReceiver.hpublic: //DisplayEventReceiver创建并注册了SF的一个事件连接，默认禁止VSync //通过调用setVSyncRate、requestNextVsync开始接受。其他事件则即刻分发 explicit DisplayEventReceiver( ISurfaceComposer::VsyncSource vsyncSource = ISurfaceComposer::eVsyncSourceApp, ISurfaceComposer::ConfigChanged configChanged = ISurfaceComposer::eConfigChangedSuppress); //获取用于接收事件的文件描述符，该描述符由本类持有，不得关闭 int getFd() const; //从队列中读取事件并返回事件个数如果返回NOT_ENOUGH_DATA //如果返回的数据不够多，则对象将永远无效，应该销毁，并且不应该再次调用getEvents ssize_t getEvents(Event* events, size_t count); static ssize_t getEvents(gui::BitTube* dataChannel, Event* events, size_t count); //向队列中写入事件并返回写入的数量 static ssize_t sendEvents(gui::BitTube* dataChannel, Event const* events, size_t count); //设置VSync分发频率，每次VSync事件返回1，其他事件返回2，没有事件返回0 status_t setVsyncRate(uint32_t count); //请求下一次Vsync status_t requestNextVsync(); //强制请求当前primary display的config属性 status_t requestLatestConfig();private: sp&lt;IDisplayEventConnection&gt; mEventConnection; std::unique_ptr&lt;gui::BitTube&gt; mDataChannel;&#125;; DispSyncSource.setVSyncEnabled开启硬件Vsync流程： 1234EventThread::threadMain -----&gt;DispSyncSource::setVSyncEnabled ----&gt;surfaceflinger&#x2F;Scheduler&#x2F;DispSync.cpp -- DispSync::addEventListener ----&gt;class DispSyncThread : public Thread -- addEventListener 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//surfaceflinger/Scheduler/EventThread.cppvoid EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock) &#123; ..... State nextState; if (mVSyncState &amp;&amp; vsyncRequested) &#123; nextState = mVSyncState-&gt;synthetic ? State::SyntheticVSync : State::VSync; &#125; else &#123; ALOGW_IF(!mVSyncState, \"Ignoring VSYNC request while display is disconnected\"); nextState = State::Idle; &#125; if (mState != nextState) &#123; if (mState == State::VSync) &#123; mVSyncSource-&gt;setVSyncEnabled(false); &#125; else if (nextState == State::VSync) &#123; mVSyncSource-&gt;setVSyncEnabled(true); &#125; mState = nextState; &#125; ....&#125;//surfaceflinger/Scheduler/DispSyncSource.cppvoid DispSyncSource::setVSyncEnabled(bool enable) &#123; std::lock_guard lock(mVsyncMutex); if (enable) &#123; //开启硬件Vsync信号就是添加EventListener status_t err = mDispSync-&gt;addEventListener(mName, mPhaseOffset, static_cast&lt;DispSync::Callback*&gt;(this), mLastCallbackTime); &#125; else &#123; status_t err = mDispSync-&gt;removeEventListener(static_cast&lt;DispSync::Callback*&gt;(this), &amp;mLastCallbackTime); if (mDolphinCheck) &#123; if (mDolphinCheck(mName)) &#123; status_t err = mDispSync-&gt;addEventListener(mName, mPhaseOffset, static_cast&lt;DispSync::Callback*&gt;(this), mLastCallbackTime); if (err != NO_ERROR) &#123; ALOGE(\"error registering vsync callback: %s (%d)\", strerror(-err), err); &#125; &#125; &#125; &#125; mEnabled = enable;&#125; 硬件VSYNC从HWComposer HAL发到EventThreadSF请求合成时关于Vsync的部分流程： 12345678SurfaceFlinger::onMessageInvalidate ----&gt;SurfaceFlinger::updateFrameScheduler() -----&gt;(1) SurfaceFlinger::getVsyncPeriod() ----&gt;surfaceflinger&#x2F;DisplayHardware&#x2F;HWC2.cpp -- Display::getDisplayVsyncPeriod(2) Scheduler::resyncToHardwareVsync(3) DispSync::addResyncSample -----&gt;DispSync::updateModelLocked [开始计算更新SW vsync 模型] mPeriod Vsync周期时长值变更流程流程： 123456789101112SurfaceFlinger::init() ----&gt;SurfaceFlinger::initializeDisplays() 设置初始条件 -----&gt;SurfaceFlinger::onInitializeDisplays() -----&gt;SurfaceFlinger::setPowerModeInternal 设置Display的power mode -----&gt;(1) Scheduler::onScreenAcquired(2) Scheduler::resyncToHardwareVsync 通过硬件Vsync重新设置软件vysnc -----&gt;Scheduler::setVsyncPeriod 设置vsync周期时长 -----&gt;(1) DispSync::setPeriod(2) DispSync::beginResync()(3) EventControlThread::setVsyncEnabled 唤醒threadmain线程[如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC] 流程图及部分代码 resyncToHardwareVsync打开硬件VYSNCSurfaceFlinger在初始化HWComposer时会默认关闭硬件Vsync信号，这里直接调用eventControl 而resyncToHardwareVsync则是和硬件VSYNC进行同步，通过调用到setVsyncEnabled开启硬件VSYNC surfaceflinger/Scheduler/Scheduler.cpp123456789101112131415161718192021222324252627282930void Scheduler::resyncToHardwareVsync(bool makeAvailable, nsecs_t period, bool force_resync) &#123; &#123; std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock); //表示硬件VSYNC被enable if (makeAvailable) &#123; mHWVsyncAvailable = makeAvailable; &#125; else if (!mHWVsyncAvailable) &#123; // Hardware vsync is not currently available, so abort the resync // attempt for now return; &#125; &#125; if (period &lt;= 0) &#123; return; &#125; setVsyncPeriod(period, force_resync);&#125;void Scheduler::setVsyncPeriod(nsecs_t period, bool force_resync) &#123; std::lock_guard&lt;std::mutex&gt; lock(mHWVsyncLock); //设置DispSync模型里period为显示设备的频率 mPrimaryDispSync-&gt;setPeriod(period); if (!mPrimaryHWVsyncEnabled || force_resync) &#123; mPrimaryDispSync-&gt;beginResync(); //如果硬件vsync没有enable,那么就通知EventControlThread去通知硬件enable VSYNC，这个和DispSync的setVsyncEnabled是不一样的 mEventControlThread-&gt;setVsyncEnabled(true); mPrimaryHWVsyncEnabled = true; &#125;&#125; setVsyncEnabled会释放mCond信号，这样在EventControlThread的threadLoop里的mCond会被唤醒去操作硬件Vsync开关 *addResyncSample更新mPeriod重要变量的含义： 硬件vsync样本个数：MIN_RESYNC_SAMPLES_FOR_UPDATE（要6个硬件vsync样本以上才计算，当然样本越多，模型越精确） mPeriod：即是显示屏的刷新率，这里mPeriod是根据样本个数去掉一个最大一个最小，算平均 mPhase：偏移时间，这个相称和具体的SF/APP Thread里固定的相称是不一样的，这个相移是针对 mPeroid的一个偏移 mModelUpdated：表示是否模型已经更新 mReferenceTime：第一个硬件Vsync的时间，每次SW vsync计算下一个vsync时间时，都是以该时间作为基准，这样可以减少误差 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119//surfaceflinger/Scheduler/DispSync.cppvoid DispSync::beginResync() &#123; Mutex::Autolock lock(mMutex); ALOGV(\"[%s] beginResync\", mName); resetLocked();&#125;bool DispSync::addResyncSample(nsecs_t timestamp, std::optional&lt;nsecs_t&gt; /*hwcVsyncPeriod*/, bool* periodFlushed) &#123; Mutex::Autolock lock(mMutex); ALOGV(\"[%s] addResyncSample(%\" PRId64 \")\", mName, ns2us(timestamp)); *periodFlushed = false; //MAX_RESYNC_SAMPLES=32,即最大只保存32次硬件vysnc时间戳，用于计算SW Vsync模型 //mNumResyncSamples表示已有硬件Vysnc样本个数 //mFirstResyncSample用于记录第几个硬件vysnc const size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES; //mResyncSamples用于记录每个硬件vsync样本的时间戳 mResyncSamples[idx] = timestamp; if (mNumResyncSamples == 0) &#123; mPhase = 0; ALOGV(\"[%s] First resync sample: mPeriod = %\" PRId64 \", mPhase = 0, \" \"mReferenceTime = %\" PRId64, mName, ns2us(mPeriod), ns2us(timestamp)); &#125; else if (mPendingPeriod &gt; 0) &#123; .... if (mTraceDetailedInfo) &#123; ATRACE_INT(\"DispSync:PendingPeriod\", mPendingPeriod); ATRACE_INT(\"DispSync:IntendedPeriod\", mIntendedPeriod); &#125; *periodFlushed = true; &#125; &#125; ..... // Always update the reference time with the most recent timestamp. mReferenceTime = timestamp; mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime); if (mNumResyncSamples &lt; MAX_RESYNC_SAMPLES) &#123; mNumResyncSamples++; &#125; else &#123; mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES; &#125; //开始计算更新SW Vsync模型 updateModelLocked(); ...... ALOGV(\"[%s] addResyncSample returning %s\", mName, modelLocked ? \"locked\" : \"unlocked\"); if (modelLocked) &#123; *periodFlushed = true; mThread-&gt;lockModel(); &#125; return !modelLocked;&#125;//计算更新SW Vsync模型，更新完后就会关闭硬件VSYNC信号void DispSync::updateModelLocked() &#123; //MIN_RESYNC_SAMPLES_FOR_UPDATE=6 // 如果已经保存了6个以上的 硬件 vsync样本后，就要开始计算 sw vsync模型了 if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123; nsecs_t durationSum = 0; nsecs_t minDuration = INT64_MAX; nsecs_t maxDuration = 0; static constexpr size_t numSamplesSkipped = 2; //跳过两个，因为可能存在不准确、延迟 //还记得上面 如果 mNumResyncSamples=0,即第一个硬件vsync时，直接更新SW vsync模型了，所以这里把第一个给去除掉 for (size_t i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES; // mResyncSamples[idx] - mResyncSamples[prev] 这个差值就是计算出两个硬件vsync样本之间的时间间隔 nsecs_t duration = mResyncSamples[idx] - mResyncSamples[prev]; // durationSum 表示保存的所有样本(除去前两个vsync)时间间隔之后，用于后面计算 平均 mPeriod durationSum += duration; minDuration = min(minDuration, duration); maxDuration = max(maxDuration, duration); &#125; // 去掉一个最小，一个最大值再来计算平均值，这个平均值就是硬件vsync产生的时间间隔 durationSum -= minDuration + maxDuration; // 减去4 mPeriod = durationSum / (mNumResyncSamples - numSamplesSkipped - 2); //下面计算出模型需要的偏移, 因为现在 mPeriod 算出来的是平均值，所以并不是真的硬件vsync时间间隔就是 mPeriod, 存在着偏移与噪音(这个和样本个数有很大的关系) // 即有些样本信号的时间间隔大于平均值，而有些样本时间间隔小于平均值，而这些与 mPriod的差值就是偏移 // 下面就是要算出这些平均的偏移值 double sampleAvgX = 0; double sampleAvgY = 0; //将硬件vsync的时间间隔换算成对应的度数,即刻度，这里的刻度表示每ns代表多少度 // M_PI是圆周率 3.14159265359f，其中2π就是值360度 double scale = 2.0 * M_PI / double(mPeriod); for (size_t i = numSamplesSkipped; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; nsecs_t sample = mResyncSamples[idx] - mReferenceTime; // 这里对mPeriod取余就是相对于mPeriod倍数的偏移值，然后将其转换成对应的度数 double samplePhase = double(sample % mPeriod) * scale; sampleAvgX += cos(samplePhase); //依次累加成 sampleAvgX sampleAvgY += sin(samplePhase); //依次累加成 sampleAvgY &#125; //获得在x轴与y轴的偏移的平均值 sampleAvgX /= double(mNumResyncSamples - numSamplesSkipped); sampleAvgY /= double(mNumResyncSamples - numSamplesSkipped); //最后再通过atan2获得最终的相移值 mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale); //如果相移偏过了mPeriod的一半，那么重新调整一下 if (mPhase &lt; -(mPeriod / 2)) &#123; mPhase += mPeriod; ALOGV(\"[%s] Adjusting mPhase -&gt; %\" PRId64, mName, ns2us(mPhase)); &#125; // 将最新的 偏移 mPhase和 vsync时间间隔mPeriod和mReferenceTime更新到SW vsync模型当中 mThread-&gt;updateModel(mPeriod, mPhase, mReferenceTime); // 模型更新了 mModelUpdated = true; &#125;&#125; 计算的相移图 setVsyncEnabled硬件VSYNC开关控制12345SurfaceFlinger::init() ----&gt;SurfaceFlinger::processDisplayHotplugEventsLocked() ----&gt;SurfaceFlinger::initScheduler 创建sf thread和app thread ----&gt;SurfaceFlinger::setVsyncEnabled(bool enabled) [传入true，开启硬件vsync] -----&gt;SurfaceFlinger::setVsyncEnabledInternal(bool enabled) 硬件vsync相关函数： 1234567891011121314151617181920212223void SurfaceFlinger::setVsyncEnabledInternal(bool enabled) &#123; ATRACE_CALL(); Mutex::Autolock lockVsync(mVsyncLock); //复制 mHWCVsyncPendingState = enabled ? hal::Vsync::ENABLE : hal::Vsync::DISABLE; auto displayId = getInternalDisplayIdLocked(); if (mNextVsyncSource) &#123; // Disable current vsync source before enabling the next source if (mActiveVsyncSource) &#123; displayId = mActiveVsyncSource-&gt;getId(); getHwComposer().setVsyncEnabled(*displayId, hal::Vsync::DISABLE); &#125; displayId = mNextVsyncSource-&gt;getId(); &#125; else if (mActiveVsyncSource) &#123; displayId = mActiveVsyncSource-&gt;getId(); &#125; getHwComposer().setVsyncEnabled(*displayId, mHWCVsyncPendingState); if (mNextVsyncSource) &#123; mActiveVsyncSource = mNextVsyncSource; mNextVsyncSource = NULL; &#125;&#125; DispSync DispSyncThread是软件产生vsync的线程，也控制硬件VSync信号同步。DispSync是定义在SurfaceFlinger类里的成员变量，因此在初始化 SurfaceFlinger时，就会初始化DispSync。 DispSync初始化流程： 123456SurfaceFlinger::init() ----&gt;SurfaceFlinger::processDisplayHotplugEventsLocked() ---&gt;SurfaceFlinger::initScheduler -----&gt;surfaceflinger&#x2F;SurfaceFlingerDefaultFactory.cpp -- DefaultFactory::createScheduler ---&gt;Scheduler::Scheduler [构造函数] ----&gt;std::unique_ptr&lt;DispSync&gt; createDispSync [创建DispSync] 代码： Scheduler构造函数： frameworks/native/services/surfaceflinger/Scheduler/Scheduler.cpp12345678910111213141516171819Scheduler::Scheduler(impl::EventControlThread::SetVSyncEnabledFunction function, const scheduler::RefreshRateConfigs&amp; refreshRateConfig, ISchedulerCallback&amp; schedulerCallback, bool useContentDetectionV2, bool useContentDetection) : mSupportKernelTimer(sysprop::support_kernel_idle_timer(false)), mPrimaryDispSync(createDispSync(mSupportKernelTimer)), //调用createDispSync函数 mEventControlThread(new impl::EventControlThread(std::move(function))), mSchedulerCallback(schedulerCallback), mRefreshRateConfigs(refreshRateConfig), mUseContentDetection(useContentDetection), mUseContentDetectionV2(useContentDetectionV2) &#123; ....std::unique_ptr&lt;DispSync&gt; createDispSync(bool supportKernelTimer) &#123; ... &#125; else &#123; return std::make_unique&lt;impl::DispSync&gt;(\"SchedulerDispSync\", sysprop::running_without_sync_framework(true)); &#125;&#125; surfaceflinger/Scheduler/DispSync.cpp123456789101112131415161718192021222324252627282930313233343536373839//构造函数DispSync::DispSync(const char* name, bool hasSyncFramework) : mName(name), mIgnorePresentFences(!hasSyncFramework) &#123; mThread = new DispSyncThread(name, mTraceDetailedInfo); //创建DispSyncThread对象 mThread-&gt;run(\"DispSync\", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE); //线程执行 ... &#125;class DispSyncThread : public Thread &#123;public: DispSyncThread(const char* name, bool showTraceDetailedInfo) : mName(name), mStop(false), mModelLocked(\"DispSync:ModelLocked\", false), mPeriod(0), //初始化为0 mPhase(0), mReferenceTime(0), mWakeupLatency(0), mFrameNumber(0), mTraceDetailedInfo(showTraceDetailedInfo) &#123;&#125; ...... virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); ... //当threadLoop第一次进来后，由于mPeriod初始化为0，所以一直死等在这里 if (mPeriod == 0) &#123; err = mCond.wait(mMutex); if (err != NO_ERROR) &#123; ALOGE(\"error waiting for new events: %s (%d)\", strerror(-err), err); return false; &#125; continue; &#125; //计算下一次vsync事件的时间 targetTime = computeNextEventTimeLocked(now); ..... &#125; addEventListener唤醒线程DispSyncThread接着上面threadmain函数流程调用到addEventListener，此处将唤醒上面threadloop的mCond.wait(mMutex) 123456789status_t addEventListener(const char* name, nsecs_t phase, DispSync::Callback* callback, nsecs_t lastCallbackTime) &#123; ... mEventListeners.push_back(listener); //唤醒线程，threadLoop可以跳出循环继续执行 mCond.signal(); return NO_ERROR; &#125; 而mPeriod == 0)则仍旧是0，所以此时会continue继续往下执行。计算下一个Vsync信号的时间戳，并且上报给EventListener，如此DispSyncThread模型就会运作起来。 HWComposer回调onVysncReceived1234surfaceflinger&#x2F;DisplayHardware&#x2F;HWComposer.cpp -- class ComposerCallbackBridge - android::hardware::Return&lt;void&gt; onVsync ----&gt;SurfaceFlinger::onVsyncReceived ----&gt;(1) addResyncSample 更新vysnc计算模型(2) VSyncModulator::onRefreshRateChangeCompleted 此处会调用到addResyncSample函数，该函数会加入硬件vsync的样本，目的是为了计算、更新SW VSYNC的参数。具体解释将对应小节。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556void SurfaceFlinger::onVsyncReceived(int32_t sequenceId, hal::HWDisplayId hwcDisplayId, int64_t timestamp, std::optional&lt;hal::VsyncPeriodNanos&gt; vsyncPeriod) &#123; ATRACE_NAME(\"SF onVsync\"); //systrace Mutex::Autolock lock(mStateLock); // Ignore any vsyncs from a previous hardware composer. if (sequenceId != getBE().mComposerSequenceId) &#123; return; &#125; if (!getHwComposer().onVsync(hwcDisplayId, timestamp)) &#123; return; &#125; bool periodFlushed = false; mScheduler-&gt;addResyncSample(timestamp, vsyncPeriod, &amp;periodFlushed); if (periodFlushed) &#123; mVSyncModulator-&gt;onRefreshRateChangeCompleted(); &#125;&#125;//surfaceflinger/Scheduler/VSyncModulator.cppvoid VSyncModulator::onRefreshRateChangeCompleted() &#123; if (!mRefreshRateChangePending) &#123; return; &#125; mRefreshRateChangePending = false; updateOffsets();&#125;void VSyncModulator::updateOffsets() &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); updateOffsetsLocked();&#125;void VSyncModulator::updateOffsetsLocked() &#123; const Offsets&amp; offsets = getNextOffsets(); mPhaseOffsetControl.setPhaseOffset(mSfConnectionHandle, offsets.sf); mPhaseOffsetControl.setPhaseOffset(mAppConnectionHandle, offsets.app); mOffsets = offsets; if (!mTraceDetailedInfo) &#123; return; &#125; const bool isEarly = &amp;offsets == &amp;mOffsetsConfig.early; const bool isEarlyGl = &amp;offsets == &amp;mOffsetsConfig.earlyGl; const bool isLate = &amp;offsets == &amp;mOffsetsConfig.late; ATRACE_INT(\"Vsync-EarlyOffsetsOn\", isEarly); ATRACE_INT(\"Vsync-EarlyGLOffsetsOn\", isEarlyGl); ATRACE_INT(\"Vsync-LateOffsetsOn\", isLate);&#125; 计算SW vsync并向APP/SF发送vsync信号在计算完后，继续执行DispSyncThread的threadloop函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//surfaceflinger/Scheduler/DispSync.cpp virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); ... //计算下一次vsync事件的时间 targetTime = computeNextEventTimeLocked(now); bool isWakeup = false; //等待计算出来的下一次vsync时间到来 //如果到了就发送SW VSYNC信号 if (now &lt; targetTime) &#123; if (mTraceDetailedInfo) ATRACE_NAME(\"DispSync waiting\"); if (targetTime == INT64_MAX) &#123; ALOGV(\"[%s] Waiting forever\", mName); err = mCond.wait(mMutex); &#125; else &#123; ALOGV(\"[%s] Waiting until %\" PRId64, mName, ns2us(targetTime)); //等到SW VSYNC时间到了，就唤醒，发送vsync信号 err = mCond.waitRelative(mMutex, targetTime - now); &#125; if (err == TIMED_OUT) &#123; isWakeup = true; &#125; else if (err != NO_ERROR) &#123; ALOGE(\"error waiting for next event: %s (%d)\", strerror(-err), err); return false; &#125; &#125; now = systemTime(SYSTEM_TIME_MONOTONIC); //计算wake up时间, 但是不能超过1.5 ms static const nsecs_t kMaxWakeupLatency = us2ns(1500); if (isWakeup) &#123; //累加mWakeupLatency醒来的时间 //用于在后面计算SW VSYNC时间 //所有的wake up时间最大不能超过1.5 ms mWakeupLatency = ((mWakeupLatency * 63) + (now - targetTime)) / 64; mWakeupLatency = min(mWakeupLatency, kMaxWakeupLatency); if (mTraceDetailedInfo) &#123; ATRACE_INT64(\"DispSync:WakeupLat\", now - targetTime); ATRACE_INT64(\"DispSync:AvgWakeupLat\", mWakeupLatency); &#125; &#125; //收回回调的EventListener（在前面addEventListener中） // callbackInvocations = gatherCallbackInvocationsLocked(now, computeNextRefreshLocked(0, now)); &#125; if (callbackInvocations.size() &gt; 0) &#123; //向SF/APP EventThread发送vsync信号 fireCallbackInvocations(callbackInvocations); &#125; &#125; return false; &#125; 计算SW Vsync下一个vsync时间这里其实就最多只有两种EventListener, 一个是SF EventThread,一个是App EventThread。 它们都需要接收Vsync信号来分别做不同的事情。 但是实际上两个线程都有一个vsync phase offset偏移值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//surfaceflinger/Scheduler/DispSync.cppprivate: nsecs_t computeNextEventTimeLocked(nsecs_t now) &#123; if (mTraceDetailedInfo) ATRACE_CALL(); ALOGV(\"[%s] computeNextEventTimeLocked\", mName); nsecs_t nextEventTime = INT64_MAX; for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; //对所有的EventListener进行分别计算，里面的mLastEventTime值不同 nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], now); if (t &lt; nextEventTime) &#123; nextEventTime = t; &#125; &#125; return nextEventTime; &#125; nsecs_t computeListenerNextEventTimeLocked(const EventListener&amp; listener, nsecs_t baseTime) &#123; if (mTraceDetailedInfo) ATRACE_CALL(); //计算的是上一次vsync事件的时间，等于上一次vsync事件 + wake up唤醒时间 nsecs_t lastEventTime = listener.mLastEventTime + mWakeupLatency; //一般情况是fasle; //如果是true，比如第一次，threadLoop的now生成的时间比较早，而addEventListener发生的比较晚, //listener的lastEventTime设为了当前的系统时间，此时baseTime就会小于lastEventTime if (baseTime &lt; lastEventTime) &#123; //重新修正baseTime baseTime = lastEventTime; ALOGV(\"[%s] Clamping baseTime to lastEventTime -&gt; %\" PRId64, mName, ns2us(baseTime)); &#125; //减去参考时间（第一个硬件vsync样本的时间） baseTime -= mReferenceTime; //mPhase是通过硬件vsync样本计算出来的 //listener.mPhase是固定的具体在编译时设置的（在PhaseOffsets.cpp中） nsecs_t phase = mPhase + listener.mPhase; //减去偏移 baseTime -= phase; if (baseTime &lt; 0) &#123; ALOGV(\"[%s] Correcting negative baseTime\", mName); baseTime = -mPeriod; &#125; //求出下一时刻发送sw vsync的时间，这个时间是以第一个硬件vsync作为参考来这样计算 //如果以一个sw vsync时间作为参考，因为sw vsync的时间本身就是一种根据模型模拟出来的，所以本身存在误差， //所以如果每个sw vsync以上一个作为base的话,那么它的误差会慢慢积累; //而每次以第一个硬件vsync时间作为基准，那么每个sw vsync的误差，并不会累加，这样就相对来说更加精确些 nsecs_t numPeriods = baseTime / mPeriod; //计算距离第一个硬件Vsync时间的偏移，即得到下一个sw vsync的时间，numPeriods + 1,注意是下一个vsync的时间 nsecs_t t = (numPeriods + 1) * mPeriod + phase; //t是相对于每一个硬件vsync的时间 t += mReferenceTime; //如果这个vsync距离上一个vsync时间小于3/5个mPeriod的话，为了避免连续的两个sw vsync, //那么这次sw vsync就放弃了，直接放到下一个周期里 if (isCloseToPeriod(t - listener.mLastEventTime)) &#123; t += mPeriod; ALOGV(\"[%s] Modifying t -&gt; %\" PRId64, mName, ns2us(t)); &#125; //当然算出来的时间要减去wake up的时间了，这样才能精确的模拟硬件vsync的时间， //注意mWakeupLatency是所有wake up的时间累加，但是最大只能到1.5ms t -= mWakeupLatency; ALOGV(\"[%s] Corrected for wakeup latency -&gt; %\" PRId64, mName, ns2us(t)); return t; &#125; bool isCloseToPeriod(nsecs_t duration) &#123; // Ratio of 3/5 is arbitrary, but it must be greater than 1/2. return duration &lt; (3 * mPeriod) / 5; &#125; 向SF/APP EventThread发送vsync信号1234567891011121314151617181920212223242526272829303132333435363738//surfaceflinger/Scheduler/DispSync.cpp std::vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now, nsecs_t expectedVSyncTime) &#123; if (mTraceDetailedInfo) ATRACE_CALL(); std::vector&lt;CallbackInvocation&gt; callbackInvocations; //因为computeListenerNextEventTimeLocked计算的是下一个vsync时间， //那么这一次的vsync就以上now - mPeriod作为基准时间 nsecs_t onePeriodAgo = now - mPeriod; for (auto&amp; eventListener : mEventListeners) &#123; nsecs_t t = computeListenerNextEventTimeLocked(eventListener, onePeriodAgo); if (t &lt; now) &#123; if (isCloseToPeriod(now - eventListener.mLastCallbackTime)) &#123; eventListener.mLastEventTime = t; ALOGV(\"[%s] [%s] Skipping event due to model error\", mName, eventListener.mName); continue; &#125; CallbackInvocation ci; ci.mCallback = eventListener.mCallback; ci.mEventTime = t; ci.mExpectedVSyncTime = expectedVSyncTime; if (eventListener.mPhase &lt; 0) &#123; ci.mExpectedVSyncTime += mPeriod; &#125; ALOGV(\"[%s] [%s] Preparing to fire, latency: %\" PRId64, mName, eventListener.mName, t - eventListener.mLastEventTime); //回调 callbackInvocations.push_back(ci); eventListener.mLastEventTime = t; eventListener.mLastCallbackTime = now; &#125; &#125; return callbackInvocations; &#125; postComposition更新SW Vsync的误差值123456789101112131415161718192021222324252627282930313233343536373839//surfaceflinger/SurfaceFlinger.cppvoid SurfaceFlinger::postComposition()&#123; ATRACE_CALL(); ALOGV(\"postComposition\"); ... getBE().mDisplayTimeline.updateSignalTimes(); mPreviousPresentFences[1] = mPreviousPresentFences[0]; sp&lt;DisplayDevice&gt; vSyncSource = mNextVsyncSource; if (mNextVsyncSource == NULL) &#123; vSyncSource = mActiveVsyncSource; &#125; mPreviousPresentFences[0] = vSyncSource ? getHwComposer().getPresentFence(*vSyncSource-&gt;getId()) : Fence::NO_FENCE; auto presentFenceTime = std::make_shared&lt;FenceTime&gt;(mPreviousPresentFences[0]); getBE().mDisplayTimeline.push(presentFenceTime); ... //获取fence mTransactionCompletedThread.addPresentFence(mPreviousPresentFences[0]); mTransactionCompletedThread.sendCallbacks(); if (display &amp;&amp; display-&gt;isPrimary() &amp;&amp; display-&gt;getPowerMode() == hal::PowerMode::ON &amp;&amp; presentFenceTime-&gt;isValid()) &#123; mScheduler-&gt;addPresentFence(presentFenceTime); &#125; ...&#125;//surfaceflinger/Scheduler/Scheduler.cppvoid Scheduler::addPresentFence(const std::shared_ptr&lt;FenceTime&gt;&amp; fenceTime) &#123; if (mPrimaryDispSync-&gt;addPresentFence(fenceTime)) &#123; //如果addPresentFence返回true，则说明SW vsync和硬件Vsync的误差太大 //此时就需要重新打开硬件vsync，来重新调节计算SW vsync模型 enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125;&#125; addPresentFence12345678910111213141516171819//surfaceflinger/Scheduler/DispSync.cppbool DispSync::addPresentFence(const std::shared_ptr&lt;FenceTime&gt;&amp; fenceTime) &#123; Mutex::Autolock lock(mMutex); if (mIgnorePresentFences) &#123; return true; &#125; //将当前硬件vsync的fence保存到mPresentFences中， //目的是为了计算偏移 mPresentFences[mPresentSampleOffset] = fenceTime; mPresentSampleOffset = (mPresentSampleOffset + 1) % NUM_PRESENT_SAMPLES; //置为0 mNumResyncSamplesSincePresent = 0; //更新错误信息 updateErrorLocked(); //一般情况下mModelUpdated已经被更新，然后硬件vsync被disable //所以这里只需要看SW VSYNC的真实的硬件vsync的误差是否在可允许的范围内即可 return !mModelUpdated || mError &gt; kErrorThreshold;&#125; 上面的mError是方差，当方差大于kErrorThreshold就返回true。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//surfaceflinger/Scheduler/DispSync.cppvoid DispSync::updateErrorLocked() &#123; if (!mModelUpdated) &#123; return; &#125; int numErrSamples = 0; nsecs_t sqErrSum = 0; //NUM_PRESENT_SAMPLES=8 for (size_t i = 0; i &lt; NUM_PRESENT_SAMPLES; i++) &#123; nsecs_t time = mPresentFences[i]-&gt;getCachedSignalTime(); if (time == Fence::SIGNAL_TIME_PENDING || time == Fence::SIGNAL_TIME_INVALID) &#123; continue; &#125; //mReferenceTime是第一个硬件vsync的时间戳（addResyncSample中） nsecs_t sample = time - mReferenceTime; //此处sample一般情况下是大于偏移量mPhase的 if (sample &lt;= mPhase) &#123; continue; &#125;5 nsecs_t sampleErr = (sample - mPhase) % mPeriod; if (sampleErr &gt; mPeriod / 2) &#123; sampleErr -= mPeriod; &#125; //记录偏移差的平方和 sqErrSum += sampleErr * sampleErr; numErrSamples++; &#125; //mError即求出的方差 if (numErrSamples &gt; 0) &#123; mError = sqErrSum / numErrSamples; mZeroErrSamplesCount = 0; &#125; else &#123; mError = 0; // Use mod ACCEPTABLE_ZERO_ERR_SAMPLES_COUNT to avoid log spam. mZeroErrSamplesCount++; ALOGE_IF((mZeroErrSamplesCount % ACCEPTABLE_ZERO_ERR_SAMPLES_COUNT) == 0, \"No present times for model error.\"); &#125; if (mTraceDetailedInfo) &#123; ATRACE_INT64(\"DispSync:Error\", mError); &#125;&#125; 参考文献 参考google文章： 在 Android 上进行高刷新率渲染 Google官网Multiple Refresh Rate 参考： CCSDN博客 刷新率和Vsync 参考： Android SurfaceFlinger SW Vsync模型","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android Systrace的部分Tag含义","slug":"2021/210309_android_systraceTAG","date":"2021-03-09T13:52:00.000Z","updated":"2021-03-09T13:02:57.632Z","comments":true,"path":"2021/03/09/2021/210309_android_systraceTAG/","link":"","permalink":"https://alonealive.github.io/Blog/2021/03/09/2021/210309_android_systraceTAG/","excerpt":"systrace的一些tag标签的含义和作用。","text":"systrace的一些tag标签的含义和作用。 CPU*（0-7）Kernel内核模块，可以查看各个CPU执行了什么进程任务。 cpu信息的目录是/sys/devices/system/cpu，例如我的一加六老设备： 123456OnePlus6:&#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu $ lscore_ctl_isolated cpu4 cpuidle isolated possible cpu0 cpu5 gladiator_hang_detect kernel_max power cpu1 cpu6 hang_detect_gold modalias present cpu2 cpu7 hang_detect_silver offline uevent cpu3 cpufreq hotplug online HW_VSYNC_ON_XXX 值：1表示HW VSYNC信号被打开，0关闭 出现时间：HW VSYNC硬件信号被打开/关闭的时候 含义： HW_VSYNC_ON_XXX后面的XXX表示display id（可通过dump SurfaceFlinger查看），用于区分不同屏幕的HW VSYNC硬件信号 HW VSYNC硬件信号之所以会有时候被打开/关闭，是因为目前Android Graphics/Display依赖的信号不是硬件信号，而是软件信号 —— DispSync。硬件信号的主要作用是用于校准，打开的时机是当软件VSYNC的误差超过一定值后，DispSync会打开HW VSYNC硬件信号进行校准。 作用：用作分析硬件模块导致的BUG的时间点 fence同步机制简单释义 BufferQueue中的Buffer在整个绘制、合成、显示的过程中，一直在 CPU，GPU 和 HWC 之前传递，某一方要使用 Buffer 之前，需要检查之前的使用者是否已经移交了 Buffer 的“使用权”。而这里的“使用权”，就是fence。当fence释放（即signal）的时候，说明 Buffer 的上一个使用者已经交出了使用权，对于 Buffer 进行操作是安全的。 在 Android 里面，总共有三类fence：acquire fence，release fence 和 present fence。其中acquire fence和release fence隶属于Layer，present fence隶属于帧（即 Layers）： acquire fence：App将Buffer通过queueBuffer()还给BufferQueue的时候，此时该Buffer的GPU侧其实是还没有完成的，此时会带上一个fence，这个fence就是acquire fence。当SurfaceFlinger/HWC要读取Buffer以进行合成操作的时候，需要等acquire fence释放之后才行 release fence：当App通过dequeueBuffer()从BufferQueue申请Buffer，要对Buffer进行绘制的时候，需要保证HWC已经不再需要这个Buffer了，即需要等release fence signal才能对 Buffer进行写操作。 present fence：在HWC1的时候称为retire fence，在HWC2中改名为present fence。当前帧成功显示到屏幕的时候，present fence就会signal。 HW_VSYNC_XXX 值：值发生变化（0-&gt;1 / 1-&gt;0）是表示当前时刻发出了HW VSYNC硬件信号 出现时间：上面HW_VSYNC_ON_XXX打开的时候 含义： HW_VSYNC_XXX记录的是当前时刻收到了HW VYSNC硬件信号 123456789101112//frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp//Step 1: 当收到硬件信号后，回调该函数bool HWComposer::onVsync(hal::HWDisplayId hwcDisplayId, int64_t timestamp) &#123; const auto displayId = toPhysicalDisplayId(hwcDisplayId); ...... const auto tag = \"HW_VSYNC_\" + to_string(*displayId); ATRACE_INT(tag.c_str(), displayData.vsyncTraceToggle); //Step 2: 取反赋值给HW_VSYNC_XXX，即systrace中该值0和1之间的变化 displayData.vsyncTraceToggle = !displayData.vsyncTraceToggle; return true;&#125; hasClientComposition 值：布尔值，1表示本次SurfaceFlinger合成存在GPU合成的layer，0表示本次合成的所有layer都不是GPU合成 出现时间：SurfaceFlinger的doComposition合成开始 含义： Client合成（GPU合成）是通过CompositionEngine调用一系列的OpenGLES接口完成合成 Device合成（硬件合成）是使用Hardware Composer进行合成。 优势：省电 劣势：某些场景无法进行Device合成，比如Layer是圆角的，Layer的总数超过硬件上限 作用：如果发现本应该是Device合成的场景出现hasClientComposition值为1的情况，则可结合dump SurfaceFlinger信息分析合成策略是否有问题 FrameMissed/GpuFrameMissed/HwcFrameMissed 值：1表示上一次合成有FrameMissed/GpuFrameMissed/HwcFrameMissed，0则没有 出现时间：SurfaceFlinger的INVALIDATE阶段开始 含义：FrameMissed/GpuFrameMissed/HwcFrameMissed表示的是上一次合成的结果，当SurfaceFlinger合成后显示到屏幕上显示一帧，present fence就会signal。因此可以将present fence signal作为一次合成完结的标志。SurfaceFlinger每次开始被Vysnc-sf唤醒时，会先检查上一次合成情况，方式就是检查上一次合成的present fence有没有signal。如果没有，则认为是FrameMissed，并结合上一次合成方式是否有GPU或者HWC参与，同步GpuFrameMissed/HwcFrameMissed信息。 present fence没有及时signal主要有两种原因： Display问题 APP/游戏的GPU负载过高：上层GPU负载过高会导致底层大部分时间都在等GPU渲染工作完成，延迟了present fence的signal，导致FrameMissed FrameMissed作用： 统计丢帧 Android有一个debug开关，可以在检测到上一帧有FrameMissed出现的时候，跳过本次的合成，留给底层更多的时间去显示。这个初衷是好的，不让底层过于繁忙，通过主动跳过合成来减缓底层的工作量。但是由于跳过合成就相当于主动丢帧，在某些场景下会导致到持续性的掉帧。因此这个开关一般是不会打开的。 VSYNC-sf/VSYNC-app 值：表示SurfaceFlinger和APP发出Vsync信号（刷新率60是16.67ms，刷新率90是11.11ms） 出现时间：DispSync分发的时候 作用：分别针对SurfaceFlinger合成和APP应用渲染的起点。如果一处没有Vsync-sf，则说明此处有丢帧情况，原因可能是上面的FrameMissed，或者是APP没有及时完成渲染导致丢帧 VSYNC-app基本不变化的原因现在绝大部分手游都使用游戏引擎，例如Unity、Unreal，这些引擎会自己去控制刷新率。 例如和平精英、王者荣耀可以有多个帧率档位选择，所以就不会通过Vsync-app的速率进行绘制刷新。 queueBufferSystrace中抓取的都是CPU侧的，例如每个CPU核的频率、C-State、运行了什么线程、线程间的调用关系、运行时长等。 而生产者通过dequeuebuffer获取buffer后，会最终交给GPU渲染绘制，然后通过queuebuffer将buffer还给BufferQueue。 如果GPU渲染的时间长，则可以初步判断性能问题是出自于GPU侧 FenceMonitorAndroid Q在libgui库引入新的内部类FenceMonitor，作用是跟踪Fence的生命周期，在Systrace中展示一个Fence从产生到signal需要的时间。 在Systrace中GPU Completion的每个waiting for GPU completion ×××的长度，大致可以作为GPU渲染所花费的时间（即acquire fence释放的总时间），但是并不严谨（解释如下）。 通过这个时间，可以判断是否有GPU bound的现象。 相对应的，waiting for HWC release ×××的长度大致可以作为release fence的释放总时间参考。在release fence signal之前，GPU是无法对dequeuebuffer拿到的Buffer进行读写的（因为此时Buffer还是归HWC所有）。 通过这点，可以判断Display是否有问题。 注：systrace上的fence信息只能准确反映出signal的时间点，但无法反应出gpu/display开始干活的时间点。 再说原因：systrace上等待GPU fence的起始时间是从queueBuffer开始算的，而不是gpu真正开始干活时才算的。queueBuffer执行完成并不意味着gpu就能马上开始干活，有可能这个时候是因为display还没有释放（即signal）该buffer导致gpu不得不等在那里。所以我们不能说等待gpu的fence耗时就是gpu渲染的时间。同样的，HWC release fence也是一样的道理。 但有时候我们可以变相的计算出gpu的耗时：GPU complete signal的时间点，减去上一帧HWC release fence signal的时间点，这样计算出来的结果也只能是个近似值，因为从display buffer释放到gpu真正开始干活，这中间还有额外的准备时间。当然，有的时候systrace上反应不出HWC release fence signal的时间点，因为在dequeueBuffer的时候该release fence就已经释放了，所以上面的公式就排不上用场了。 FenceMonitor相关代码： 123456789101112131415161718192021222324252627282930313233343536//frameworks/native/libs/gui/Surface.cpp//内部类class FenceMonitor &#123;public: explicit FenceMonitor(const char* name) : mName(name), mFencesQueued(0), mFencesSignaled(0) &#123; std::thread thread(&amp;FenceMonitor::loop, this); pthread_setname_np(thread.native_handle(), mName); thread.detach(); &#125; ......&#125;int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123; ATRACE_CALL(); ALOGV(\"Surface::dequeueBuffer\"); ..... if (CC_UNLIKELY(atrace_is_tag_enabled(ATRACE_TAG_GRAPHICS))) &#123; //申请到Buffer static FenceMonitor hwcReleaseThread(\"HWC release\"); hwcReleaseThread.queueFence(fence); &#125; .....&#125;int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123; ATRACE_CALL(); ALOGV(\"Surface::queueBuffer\"); ..... if (CC_UNLIKELY(atrace_is_tag_enabled(ATRACE_TAG_GRAPHICS))) &#123; //GPU绘制完成 static FenceMonitor gpuCompletionThread(\"GPU completion\"); gpuCompletionThread.queueFence(fence); &#125; return err;&#125; 参考 Android Systrace如何抓取分析问题 Systrace 中的这些 tag 究竟是什么意思（一） 如何通过 Systrace 查看 GPU 渲染花费的时间","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android Q SurfaceFlinger合成（二）","slug":"2020/201031_android_SurfaceFlinger2","date":"2020-10-31T10:42:00.000Z","updated":"2020-11-04T13:45:14.666Z","comments":true,"path":"2020/10/31/2020/201031_android_SurfaceFlinger2/","link":"","permalink":"https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/","excerpt":"继上篇《Android Ｑ SurfaceFlinger合成（一）》中SF对INVALIDATE信息处理，针对Layer属性变化、显示设备变化等情况处理，将mCurrentState提交到mDrawingState。然后遍历mDrawingState的Layer，将新的Buffer内容更新绑定到Layer纹理对象。经过这些流程，决定是否需要SF进行合成刷新，如果需要则调用handleMessageRefresh开始合成处理。","text":"继上篇《Android Ｑ SurfaceFlinger合成（一）》中SF对INVALIDATE信息处理，针对Layer属性变化、显示设备变化等情况处理，将mCurrentState提交到mDrawingState。然后遍历mDrawingState的Layer，将新的Buffer内容更新绑定到Layer纹理对象。经过这些流程，决定是否需要SF进行合成刷新，如果需要则调用handleMessageRefresh开始合成处理。 signalRefresh在onMessageReceivedINVALIDATE信息处理完成后，如果需要刷新，则会触发刷新： SF.cpp12345678910111213141516171819202122232425void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS &#123; ATRACE_CALL(); switch (what) &#123; case MessageQueue::INVALIDATE: &#123; ...... refreshNeeded |= mRepaintEverything; //在BootStage:：BOOTLOADER中时不要调用signalRefresh，不想用一个空白屏幕代替bootloader引导加载程序启动。 //这样可以节省HWC不必要的工作 if (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123; //如果事务修改了窗口状态，新的Buffer被获取到，或者HWC已经请求一个新的repaint，则发出刷新信号 signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125; &#125;&#125;void SurfaceFlinger::signalRefresh() &#123; mRefreshPending = true; mEventQueue.refresh();&#125; 需要刷新的情况： 有新的Transaction处理 PageFlip时，有Buffer更新 有重新合成请求时mRepaintEverything，这是响应HWC的请求时触发的。 MessageQueue分发refreshframeworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp1234567891011121314151617181920212223void MessageQueue::refresh() &#123; mHandler-&gt;dispatchRefresh();&#125;void MessageQueue::Handler::dispatchRefresh() &#123; if ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::REFRESH)); &#125;&#125;//最终回调handleMessage，处理REFRESH的message//这过程中不用去等Vsync的，INVALIDATE时，是需要等Vsync的//即INVALIDATE和REFRESH是在同一个Vsync周期内完成的void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; handleMessageRefresh刷新总流程handleMessageRefresh函数包含了刷新（合成）一帧显示数据的所有流程。 SF.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS &#123; ATRACE_CALL();d switch (what) &#123; case MessageQueue::INVALIDATE: &#123; ...... case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125; &#125;&#125;void SurfaceFlinger::handleMessageRefresh() &#123; ATRACE_CALL(); mRefreshPending = false; const bool repaintEverything = mRepaintEverything.exchange(false); //合成前预处理工作 preComposition(); //计算和存储每个Layer的脏区域 rebuildLayerStacks(); // calculateWorkingSet();//和P不同 //遍历Display for (const auto&amp; [token, display] : mDisplays) &#123; beginFrame(display);//和P不同 prepareFrame(display); //和P不同 doDebugFlashRegions(display, repaintEverything); //先进行GL合成，将合成后的的图像放在HWC任务列表的最后为止 //然后由HWC进行合成并输出到屏幕 doComposition(display, repaintEverything); &#125; logLayerStats(); postFrame(); //合成善后工作 postComposition(); mHadClientComposition = false; mHadDeviceComposition = false; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto displayId = display-&gt;getId(); mHadClientComposition = mHadClientComposition || getHwComposer().hasClientComposition(displayId); mHadDeviceComposition = mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId); &#125; mVsyncModulator.onRefreshed(mHadClientComposition); mLayersWithQueuedFrames.clear();&#125; preComposition合成前预处理SF.cpp1234567891011121314151617181920void SurfaceFlinger::preComposition()&#123; ATRACE_CALL(); ALOGV(\"preComposition\"); mRefreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC); bool needExtraInvalidate = false; //遍历所有需要进行合成的Layer（mDrawingState） mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; //调用onPreComposition，但绘制 if (layer-&gt;onPreComposition(mRefreshStartTime)) &#123; needExtraInvalidate = true; &#125; &#125;); //通过上述函数的返回值来判断是否需要再次触发SurfaceFlinger接受Vsync合成 if (needExtraInvalidate) &#123; signalLayerUpdate(); &#125;&#125; 其中onPreComposition函数的返回值针对不同Layer： ColorLayer和ContainLayer固定返回false BufferLayer如下： frameworks/native/services/surfaceflinger/BufferLayer.cpp123456789101112131415161718192021222324252627282930bool BufferLayer::onPreComposition(nsecs_t refreshStartTime) &#123; if (mBufferLatched) &#123; Mutex::Autolock lock(mFrameEventHistoryMutex); //mFrameEventHistory记录PreComposition事件 mFrameEventHistory.addPreComposition(mCurrentFrameNumber, refreshStartTime); &#125; mRefreshPending = false; return hasReadyFrame();&#125;bool BufferLayer::hasReadyFrame() const &#123; return hasFrameUpdate() || getSidebandStreamChanged() || getAutoRefresh();&#125;//****** BufferQueueLayer.cpp **********bool BufferQueueLayer::hasFrameUpdate() const &#123; //之前在acquireBuffer的时候已经做了-1操作，而此处是现在BufferQueue中还有Buffer //（即仍有待处理的Buffer，就需要下次Vsync到来的时候再次执行合成） return mQueuedFrames &gt; 0;&#125;bool BufferQueueLayer::getSidebandStreamChanged() const &#123; //SidebandStream改变 return mSidebandStreamChanged;&#125;bool BufferQueueLayer::getAutoRefresh() const &#123; //自动刷新模式 return mAutoRefresh;&#125; rebuildLayerStacks重构Layer栈执行该函数，将完成创建Layer栈。 此时需要进行合成显示的数据已经被更新到每个Display各自的layersSortedByZ中。 SF.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192void SurfaceFlinger::invalidateHwcGeometry()&#123; mGeometryInvalid = true;&#125;void SurfaceFlinger::rebuildLayerStacks() &#123; ATRACE_CALL(); ALOGV(\"rebuildLayerStacks\"); // rebuild the visible layer list per screen // 前提是存在脏区域，即mVisibleRegionsDirty为true if (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_NAME(\"rebuildLayerStacks VR Dirty\"); mVisibleRegionsDirty = false; //重置mGeometryInvalid标记 invalidateHwcGeometry(); //遍历每个屏幕，因为每个Display是分开合成的 //根据显示屏的特性，分别进行合成，合成后的数据也送给各自的显示屏 //mDisplays是当前系统中的显示屏 for (const auto&amp; pair : mDisplays) &#123; ...... if (displayState.isEnabled) &#123; //计算屏幕的脏区域、每个Layer的可见区域、被覆盖的区域、可见非透明区域（见下面一小节） computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion); //正序遍历mDrawingState合成列表的layer //和当前的显示设备进行比较，Layer的脏区域是否在显示设备的显示区域内 //如果在显示区域内的话说明该layer是需要更新的，则更新到显示设备的`VisibleLayersSortedByZ`列表中，等待被合成 mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; // auto compositionLayer = layer-&gt;getCompositionLayer(); if (compositionLayer == nullptr) &#123; return; &#125; const auto displayId = displayDevice-&gt;getId(); sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;getLayerFE(); LOG_ALWAYS_FATAL_IF(layerFE.get() == nullptr); bool needsOutputLayer = false; //计算Layer需要绘制的区域drawRegion if (display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123; Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); //将Layer的可见区域和Display大小做交集 drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; needsOutputLayer = true; &#125; &#125; //drawRegion不为空，将该Layer加到当前Display的Layer列表中 if (needsOutputLayer) &#123; layersSortedByZ.emplace_back( display-&gt;getOrCreateOutputLayer(displayId, compositionLayer, layerFE)); deprecated_layersSortedByZ.add(layer); auto&amp; outputLayerState = layersSortedByZ.back()-&gt;editState(); outputLayerState.visibleRegion = tr.transform(layer-&gt;visibleRegion.intersect(displayState.viewport)); //之前Layer可见，现在不可见，将销毁掉HWC Layer &#125; else if (displayId) &#123; //对于正在从HWC Display中移除的和已经排队的帧的那些Layer，将他们添加到一个发布的Layer列表中，以便可以设置一个fence bool hasExistingOutputLayer = display-&gt;getOutputLayerForLayer(compositionLayer.get()) != nullptr; bool hasQueuedFrames = std::find(mLayersWithQueuedFrames.cbegin(), mLayersWithQueuedFrames.cend(), layer) != mLayersWithQueuedFrames.cend(); if (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123; //销毁掉的Layer放置到layersNeedingFences中 //虽然不需要releaseFence，但是还是需要fence去释放旧的Buffer layersNeedingFences.add(layer); &#125; &#125; &#125;); //遍历Layer结束 &#125; //最后将数据更新到DisplayDevice中 display-&gt;setOutputLayersOrderedByZ(std::move(layersSortedByZ)); displayDevice-&gt;setVisibleLayersSortedByZ(deprecated_layersSortedByZ); displayDevice-&gt;setLayersNeedingFences(layersNeedingFences); Region undefinedRegion&#123;bounds&#125;; undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); display-&gt;editState().undefinedRegion = undefinedRegion; display-&gt;editState().dirtyRegion.orSelf(dirtyRegion); &#125;//遍历Display结束 &#125;&#125; computeVisibleRegions计算可见区域代码包含注解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//outOpaqueRegion是屏幕的非透明区域void SurfaceFlinger::computeVisibleRegions(const sp&lt;const DisplayDevice&gt;&amp; displayDevice, Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion) &#123; ATRACE_CALL(); ALOGV(\"computeVisibleRegions\"); //获取当前合成显示屏的display auto display = displayDevice-&gt;getCompositionDisplay(); //针对当前整个Display！ //当前Layer上层所有Layer不透明区域的累加 Region aboveOpaqueLayers; //当前Layer上层所有Layer可见区域的累加 Region aboveCoveredLayers; //脏区域 Region dirty; //清空屏幕脏区域（每个Layer脏区域的和），将计算好的区域值设置到Layer中 outDirtyRegion.clear(); //反序号遍历，即从最上面layer层开始遍历 mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123; // start with the whole surface at its current location const Layer::State&amp; s(layer-&gt;getDrawingState()); // layerStackId必须匹配 if (!display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123; return; &#125; //针对每个Layer！ //完全不透明区域 Region opaqueRegion; //可见区域（屏幕上可见的Surface区域，而且是不完全透明） //包含半透明区域：半透明Surface覆盖的区域被视为可见 Region visibleRegion; //覆盖区域：被全部覆盖的Surface区域（包括被透明区域覆盖的区域） Region coveredRegion; //完全透明区域：Surface完全透明的部分，如果没有可见的非透明区域，这个Layer就可以从Layer列表中删除 //并且不会影响该Layer本身或其下方layer的可见区域大小 //这个区域可能不太准，因为有的APP不遵守SurfaceView的限制 Region transparentRegion; // 通过将可见区域设置为空来处理隐藏的Surface if (CC_LIKELY(layer-&gt;isVisible())) &#123; //isOpaque表示Lyaer是非透明的Layer（上层应用层设置） const bool translucent = !layer-&gt;isOpaque(s); //获取Layer在屏幕上的大小 //注：activeWidth和activeHeight是Layer本身的大小,用win表示 //crop是Layer的源剪截区域，由上层设置，表示该Layer只截取crop的区域进行合成显示。可能比win大也可能小，需要取交集，截取重复的部分 Rect bounds(layer-&gt;getScreenBounds()); //即上面返回Layer大小设置为可见区域，但是后续还会被裁剪 visibleRegion.set(bounds); //Layer的变换矩阵，例如旋转，适配显示屏幕 ui::Transform tr = layer-&gt;getTransform(); //可见区域不为空（一般情况下，如果layer是非透明的，非透明区域就是可见区域） if (!visibleRegion.isEmpty()) &#123; // 从可见区域移除完全透明区域 if (translucent) &#123; if (tr.preserveRects()) &#123; // transform the transparent region transparentRegion = tr.transform(layer-&gt;getActiveTransparentRegion(s)); &#125; else &#123; //转型太复杂，不能做到透明区域优化 transparentRegion.clear(); &#125; &#125; //计算不透明区域 const int32_t layerOrientation = tr.getOrientation(); if (layer-&gt;getAlpha() == 1.0f &amp;&amp; !translucent &amp;&amp; layer-&gt;getRoundedCornerState().radius == 0.0f &amp;&amp; ((layerOrientation &amp; ui::Transform::ROT_INVALID) == false)) &#123; // the opaque region is the layer's footprint opaqueRegion = visibleRegion; &#125; &#125; &#125; ...... // 将覆盖区域剪辑到可见区域 //遍历时，第一层时，aboveCoveredLayers为空，coveredRegion也是为空，最上面一层是没有被覆盖的，当然为空 coveredRegion = aboveCoveredLayers.intersect(visibleRegion); //为下一个（底）layer更新aboveCoveredLayers //更新aboveCoveredLayers，该层之下的Layer都被该层Layer覆盖，所以这里和可见区域做一个或操纵，最下面的区域被覆盖的越大 aboveCoveredLayers.orSelf(visibleRegion); //减去在我aboveOpaqueLayers覆盖的不透明区域 //可见区域要减掉该层之上的非透明区域 visibleRegion.subtractSelf(aboveOpaqueLayers); // 计算Layer的脏区域 // contentDirty表示包含脏区域内容，即Layer的可见区域被修改了 if (layer-&gt;contentDirty) &#123; //需要使整个地区无效 dirty = visibleRegion; //以及旧的可见区域 dirty.orSelf(layer-&gt;visibleRegion); layer-&gt;contentDirty = false; &#125; else &#123; //计算暴露出来的区域 exposedRegion //包含两部分：1.之前被覆盖的区域，现在可见了；2.现在暴露的比之前的少 //注：1是从整体的可见区域开始，但是只保留以前被覆盖的区域（现在暴露了）；2是处理那种因为重新调整了大小从而暴露出来的区域 const Region newExposed = visibleRegion - coveredRegion; const Region oldVisibleRegion = layer-&gt;visibleRegion; const Region oldCoveredRegion = layer-&gt;coveredRegion; const Region oldExposed = oldVisibleRegion - oldCoveredRegion; dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed); &#125; dirty.subtractSelf(aboveOpaqueLayers); //累计到屏幕脏区域 outDirtyRegion.orSelf(dirty); //更新opaqueRegion到aboveOpaqueLayers，为下面（底）的Layer做准备 aboveOpaqueLayers.orSelf(opaqueRegion); //在屏幕空间保存可见区域 //设置可见区域 layer-&gt;setVisibleRegion(visibleRegion); //设置被覆盖的区域 layer-&gt;setCoveredRegion(coveredRegion); //设置可见的非透明区域（=可见区域-透明区域） layer-&gt;setVisibleNonTransparentRegion( visibleRegion.subtract(transparentRegion)); &#125;); //遍历结束 //屏幕的非透明区域 outOpaqueRegion = aboveOpaqueLayers;&#125; calculateWorkingSet在Android P中是用的setUpHWComposer函数，Q升级后将其分成几个单独的函数。以下是第一个： SF.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106void SurfaceFlinger::calculateWorkingSet() &#123; ATRACE_CALL(); ALOGV(__FUNCTION__); //创建H/W工作列表（判断变量在rebuildLayerStacks中变动） if (CC_UNLIKELY(mGeometryInvalid)) &#123; //重置 mGeometryInvalid = false; //遍历Display for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); uint32_t zOrder = 0; //遍历Layer for (auto&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123; //**调用CompositionEngine/src/OutputLayer.cpp返回mState auto&amp; compositionState = layer-&gt;editState(); //forceClientComposition指强制GPU合成（Client） //mDebugDisableHWC指开发者选项的“停用HWC叠加层”，mDebugRegion指调试Region compositionState.forceClientComposition = false; if (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123; compositionState.forceClientComposition = true; &#125; //输出的z顺序值是一个简单的计数器设置 compositionState.z = zOrder++; //更新Display自己的合成状态 layer-&gt;getLayerFE().latchCompositionState(layer-&gt;getLayer().editState().frontEnd, true); //重新计算输出output layer的合成状态 layer-&gt;updateCompositionState(true); //写入到HWC，该函数会设置Layer的几何尺寸（见下一小节该函数释义） layer-&gt;writeStateToHWC(true); &#125; &#125; &#125; //设置每层Layer的frame帧数据 //遍历Display for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto displayId = display-&gt;getId(); if (!displayId) &#123; continue; &#125; auto* profile = display-&gt;getDisplayColorProfile(); //设置颜色矩阵 if (mDrawingState.colorMatrixChanged) &#123; display-&gt;setColorTransform(mDrawingState.colorMatrix); &#125; Dataspace targetDataspace = Dataspace::UNKNOWN; if (useColorManagement) &#123; ColorMode colorMode; RenderIntent renderIntent; pickColorMode(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent); //设置色彩模式 display-&gt;setColorMode(colorMode, targetDataspace, renderIntent); &#125; //遍历可见layer for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; //根据layer的数据空间dataSpace（通过dump SurfaceFlinger可以查看到）来设置layer的合成方式 if (layer-&gt;isHdrY410()) &#123; layer-&gt;forceClientComposition(displayDevice); &#125; else if ((layer-&gt;getDataSpace() == Dataspace::BT2020_PQ || layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_PQ) &amp;&amp; !profile-&gt;hasHDR10Support()) &#123; layer-&gt;forceClientComposition(displayDevice); &#125; else if ((layer-&gt;getDataSpace() == Dataspace::BT2020_HLG || layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_HLG) &amp;&amp; !profile-&gt;hasHLGSupport()) &#123; layer-&gt;forceClientComposition(displayDevice); &#125; if (layer-&gt;getRoundedCornerState().radius &gt; 0.0f) &#123; layer-&gt;forceClientComposition(displayDevice); &#125; if (layer-&gt;getForceClientComposition(displayDevice)) &#123; ALOGV(\"[%s] Requesting Client composition\", layer-&gt;getName().string()); //设置合成方式GPU合成 layer-&gt;setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CLIENT); continue; &#125; //设置每一层Layer的显示数据 const auto&amp; displayState = display-&gt;getState(); layer-&gt;setPerFrameData(displayDevice, displayState.transform, displayState.viewport, displayDevice-&gt;getSupportedPerFrameMetadata(), isHdrColorMode(displayState.colorMode) ? Dataspace::UNKNOWN : targetDataspace); &#125; &#125; mDrawingState.colorMatrixChanged = false; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; auto&amp; layerState = layer-&gt;getCompositionLayer()-&gt;editState().frontEnd; layerState.compositionType = static_cast&lt;Hwc2::IComposerClient::Composition&gt;( layer-&gt;getCompositionType(displayDevice)); &#125; &#125;&#125; 颜色矩阵如下，可以在开发这选项中设置，有模拟颜色空间选项。其支持的transform主要有： system/core/libsystem/include/system/graphics-base-v1.0.h123456789typedef enum &#123; HAL_COLOR_TRANSFORM_IDENTITY = 0, HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX = 1, HAL_COLOR_TRANSFORM_VALUE_INVERSE = 2, HAL_COLOR_TRANSFORM_GRAYSCALE = 3, HAL_COLOR_TRANSFORM_CORRECT_PROTANOPIA = 4, HAL_COLOR_TRANSFORM_CORRECT_DEUTERANOPIA = 5, HAL_COLOR_TRANSFORM_CORRECT_TRITANOPIA = 6,&#125; android_color_transform_t; writeStateToHWC设置Layer几何尺寸OutputLayer.cpp是Android新分离出来的文件，writeStateToHWC函数也是分离成一个单独的函数，以供SurfaceFlinger的calculateWorkingSet函数调用。 frameworks/native/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void OutputLayer::writeStateToHWC(bool includeGeometry) const &#123; // Skip doing this if there is no HWC interface //此处的State数据是来源于DrawingState if (!mState.hwc) &#123; return; &#125; auto&amp; hwcLayer = (*mState.hwc).hwcLayer; if (!hwcLayer) &#123; ALOGE(\"[%s] failed to write composition state to HWC -- no hwcLayer for output %s\", mLayerFE-&gt;getDebugName(), mOutput.getName().c_str()); return; &#125; if (includeGeometry) &#123; //输出依赖状态 Output dependent state //计算DisplayFrame if (auto error = hwcLayer-&gt;setDisplayFrame(mState.displayFrame); error != HWC2::Error::None) &#123;... //log打印 &#125; //计算SourceCrop if (auto error = hwcLayer-&gt;setSourceCrop(mState.sourceCrop); error != HWC2::Error::None) &#123; ... //log打印 &#125; //设置zOrder if (auto error = hwcLayer-&gt;setZOrder(mState.z); error != HWC2::Error::None) &#123; ... //log打印 &#125; //设置transform旋转 if (auto error = hwcLayer-&gt;setTransform(static_cast&lt;HWC2::Transform&gt;(mState.bufferTransform)); error != HWC2::Error::None) &#123; ... //log打印 &#125; //输出独立状态 Output independent state const auto&amp; outputIndependentState = mLayer-&gt;getState().frontEnd; //设置图层混合模式（见https://developer.android.google.cn/reference/android/graphics/BlendMode） if (auto error = hwcLayer-&gt;setBlendMode( static_cast&lt;HWC2::BlendMode&gt;(outputIndependentState.blendMode)); error != HWC2::Error::None) &#123; ... //log打印 &#125; //设置Alpha透明度 if (auto error = hwcLayer-&gt;setPlaneAlpha(outputIndependentState.alpha); error != HWC2::Error::None) &#123; ... //log打印 &#125; //设置Layer信息 //type和appId是Android Framework层创建SurfaceControl时设置的 //其中type包含ScreenshotSurface、Background等 //appId是应用进程号 if (auto error = hwcLayer-&gt;setInfo(outputIndependentState.type, outputIndependentState.appId); error != HWC2::Error::None) &#123; A... //log打印 &#125; &#125;&#125; 其中setBlendModes设置混合模式（两个Layer直接的混合方式），主要有以下几种： hardware/libhardware/include/hardware/hwcomposer2.h12345678910111213/* Blend modes, settable per layer */typedef enum &#123; HWC2_BLEND_MODE_INVALID = 0, /* colorOut = colorSrc */ HWC2_BLEND_MODE_NONE = 1, //不混合，源和输出不变 /* colorOut = colorSrc + colorDst * (1 - alphaSrc) */ HWC2_BLEND_MODE_PREMULTIPLIED = 2, //预乘，Dst需要做Alpha的处理 /* colorOut = colorSrc * alphaSrc + colorDst * (1 - alphaSrc) */ HWC2_BLEND_MODE_COVERAGE = 3, //覆盖方式，源和Dst都需要做Alpha透明度的处理&#125; hwc2_blend_mode_t; setPerFrameData设置每一层Layer显示数据 ColorLayer::setPerFrameData frameworks/native/services/surfaceflinger/ColorLayer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445void ColorLayer::setPerFrameData(const sp&lt;const DisplayDevice&gt;&amp; display, const ui::Transform&amp; transform, const Rect&amp; viewport, int32_t /* supportedPerFrameMetadata */, const ui::Dataspace targetDataspace) &#123; ...... //设置可见区域，之前已经计算好，但是此处需要确保可见区域在Display的窗口内 auto error = hwcLayer-&gt;setVisibleRegion(visible); ... //设置数据空间 error = hwcLayer-&gt;setDataspace(dataspace); ... auto&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd; layerCompositionState.dataspace = mCurrentDataSpace; //设置RGB颜色，Alpha默认255（全透明） half4 color = getColor(); error = hwcLayer-&gt;setColor(&#123;static_cast&lt;uint8_t&gt;(std::round(255.0f * color.r)), static_cast&lt;uint8_t&gt;(std::round(255.0f * color.g)), static_cast&lt;uint8_t&gt;(std::round(255.0f * color.b)), 255&#125;); ... layerCompositionState.color = &#123;static_cast&lt;uint8_t&gt;(std::round(255.0f * color.r)), static_cast&lt;uint8_t&gt;(std::round(255.0f * color.g)), static_cast&lt;uint8_t&gt;(std::round(255.0f * color.b)), 255&#125;; //色彩ColorLayer不需要变换矩阵，清除掉 error = hwcLayer-&gt;setTransform(HWC2::Transform::None); if (error != HWC2::Error::None) &#123; ALOGE(\"[%s] Failed to clear transform: %s (%d)\", mName.string(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); &#125; ... error = hwcLayer-&gt;setColorTransform(getColorTransform()); if (error != HWC2::Error::None) &#123; ALOGE(\"[%s] Failed to setColorTransform: %s (%d)\", mName.string(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); &#125; layerCompositionState.colorTransform = getColorTransform(); error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion); if (error != HWC2::Error::None) &#123; ALOGE(\"[%s] Failed to set surface damage: %s (%d)\", mName.string(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); surfaceDamageRegion.dump(LOG_TAG); &#125; layerCompositionState.surfaceDamage = surfaceDamageRegion;&#125; BufferLayer::setPerFrameData BufferLayer的处理比ColorLayer多，Sideband，Cursor和其他的UI图层都属于BufferLayer，每种类型Layer处理都不同。 frameworks/native/services/surfaceflinger/BufferLayer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263void BufferLayer::setPerFrameData(const sp&lt;const DisplayDevice&gt;&amp; displayDevice, const ui::Transform&amp; transform, const Rect&amp; viewport, int32_t supportedPerFrameMetadata, const ui::Dataspace targetDataspace) &#123; RETURN_IF_NO_HWC_LAYER(displayDevice); //在给HWC HAL层前，设置Display的投影的viewport给可见区域 Region visible = transform.transform(visibleRegion.intersect(viewport)); const auto outputLayer = findOutputLayerForDisplay(displayDevice); LOG_FATAL_IF(!outputLayer || !outputLayer-&gt;getState().hwc); auto&amp; hwcLayer = (*outputLayer-&gt;getState().hwc).hwcLayer; //设置可见区域 auto error = hwcLayer-&gt;setVisibleRegion(visible); outputLayer-&gt;editState().visibleRegion = visible; auto&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd; //设置Damage区域 error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion); layerCompositionState.surfaceDamage = surfaceDamageRegion; // Sideband layers处理，默认为SIDEBAND合成 if (layerCompositionState.sidebandStream.get()) &#123; setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::SIDEBAND); ALOGV(\"[%s] Requesting Sideband composition\", mName.string()); error = hwcLayer-&gt;setSidebandStream(layerCompositionState.sidebandStream-&gt;handle()); layerCompositionState.compositionType = Hwc2::IComposerClient::Composition::SIDEBAND; return; &#125; // Device or Cursor layers //如果是Cursor Layer，则合成方式为CURSOR，其他为DEVICE合成 if (mPotentialCursor) &#123; ALOGV(\"[%s] Requesting Cursor composition\", mName.string()); setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CURSOR); &#125; else &#123; ALOGV(\"[%s] Requesting Device composition\", mName.string()); setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::DEVICE); &#125; ui::Dataspace dataspace = isColorSpaceAgnostic() &amp;&amp; targetDataspace != ui::Dataspace::UNKNOWN ? targetDataspace : mCurrentDataSpace; //设置数据空间 error = hwcLayer-&gt;setDataspace(dataspace); //HDR const HdrMetadata&amp; metadata = getDrawingHdrMetadata(); error = hwcLayer-&gt;setPerFrameMetadata(supportedPerFrameMetadata, metadata); //设置色彩矩阵 error = hwcLayer-&gt;setColorTransform(getColorTransform()); if (error == HWC2::Error::Unsupported) &#123; //如果每个layer的色彩矩阵都不支持，则使用GPU合成（CLIENT） setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CLIENT); &#125; else if (error != HWC2::Error::None) &#123; ALOGE(\"[%s] Failed to setColorTransform: %s (%d)\", mName.string(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); &#125; layerCompositionState.dataspace = mCurrentDataSpace; layerCompositionState.colorTransform = getColorTransform(); layerCompositionState.hdrMetadata = metadata; setHwcLayerBuffer(displayDevice);&#125; beginFrameSF.cpp1234567891011121314151617181920212223void SurfaceFlinger::beginFrame(const sp&lt;DisplayDevice&gt;&amp; displayDevice) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); bool dirty = !display-&gt;getDirtyRegion(false).isEmpty(); bool empty = displayDevice-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !displayState.lastCompositionHadVisibleLayers; //判断是否需要重新合成： //如果没有变化（即没有脏区域），不需要重新合成； //如果有一些变化，但是当前没有任何可见的Layers，并且最近一次的合成也没有，则跳过这次合成； //第二条判断做了以下两件事： //1.当所有layers从该Display被移除，我们将发射一个黑色（无内容）的帧，然后没有其他任何东西，直到我们获取到新的layers； //2.当一个Display被创建，包含了一个单独的空layer栈，我们将不会发射任何黑色的帧，知道一个Layers被添加到这个layer栈 bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); ...... //主显、外显：fsurfaceflinger/DisplayHardware/FramebufferSurface.h的beginFrame //虚拟显示：surfaceflinger/DisplayHardware/VirtualDisplaySurface.h的beginFrame display-&gt;getRenderSurface()-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; display-&gt;editState().lastCompositionHadVisibleLayers = !empty; &#125;&#125; prepareFrame准备数据SF.cpp123456789101112void SurfaceFlinger::prepareFrame(const sp&lt;DisplayDevice&gt;&amp; displayDevice) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); if (!displayState.isEnabled) &#123; return; &#125; status_t result = display-&gt;getRenderSurface()-&gt;prepareFrame(); ALOGE_IF(result != NO_ERROR, \"prepareFrame failed for %s: %d (%s)\", displayDevice-&gt;getDebugName().c_str(), result, strerror(-result));&#125; frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp12345678910111213141516171819202122232425262728status_t RenderSurface::prepareFrame() &#123; auto&amp; hwc = mCompositionEngine.getHwComposer(); const auto id = mDisplay.getId(); if (id) &#123; //查看HWC是否支持之前SurfaceFlinger决定的合成方式 status_t error = hwc.prepare(*id, mDisplay); if (error != NO_ERROR) &#123; return error; &#125; &#125; //合成方式 DisplaySurface::CompositionType compositionType; const bool hasClient = hwc.hasClientComposition(id); const bool hasDevice = hwc.hasDeviceComposition(id); if (hasClient &amp;&amp; hasDevice) &#123; compositionType = DisplaySurface::COMPOSITION_MIXED; &#125; else if (hasClient) &#123; compositionType = DisplaySurface::COMPOSITION_GLES; &#125; else if (hasDevice) &#123; compositionType = DisplaySurface::COMPOSITION_HWC; &#125; else &#123; // Nothing to do -- when turning the screen off we get a frame like // this. Call it a HWC frame since we won't be doing any GLES work but // will do a prepare/set cycle. compositionType = DisplaySurface::COMPOSITION_HWC; &#125; return mDisplaySurface-&gt;prepareFrame(compositionType);&#125; 重要函数： frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990status_t HWComposer::prepare(DisplayId displayId, const compositionengine::Output&amp; output) &#123; ... displayData.validateWasSkipped = false; //SurfaceFlinger没有指定得有Client端合成，即false if (!displayData.hasClientComposition) &#123; sp&lt;Fence&gt; outPresentFence; uint32_t state = UINT32_MAX; //调用函数尝试直接present，如果HWC不能直接显示，再执行validate操纵 error = hwcDisplay-&gt;presentOrValidate(&amp;numTypes, &amp;numRequests, &amp;outPresentFence , &amp;state); if (error != HWC2::Error::HasChanges) &#123; RETURN_IF_HWC_ERROR_FOR(\"presentOrValidate\", error, displayId, UNKNOWN_ERROR); &#125; //如果成功，数据显示，则不再执行后续流程 if (state == 1) &#123; //Present Succeeded. std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences; error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences); displayData.releaseFences = std::move(releaseFences); displayData.lastPresentFence = outPresentFence; displayData.validateWasSkipped = true; displayData.presentError = error; return NO_ERROR; &#125; // Present failed but Validate ran. &#125; else &#123; //调用validate error = hwcDisplay-&gt;validate(&amp;numTypes, &amp;numRequests); &#125; ...... std::unordered_map&lt;HWC2::Layer*, HWC2::Composition&gt; changedTypes; changedTypes.reserve(numTypes); //通过getChangedCompositionTypes函数获取到HWC对合成方式的修改，保存在changedTypes中 error = hwcDisplay-&gt;getChangedCompositionTypes(&amp;changedTypes); RETURN_IF_HWC_ERROR_FOR(\"getChangedCompositionTypes\", error, displayId, BAD_INDEX); displayData.displayRequests = static_cast&lt;HWC2::DisplayRequest&gt;(0); std::unordered_map&lt;HWC2::Layer*, HWC2::LayerRequest&gt; layerRequests; layerRequests.reserve(numRequests); //获取LayerRequest，保存在layerRequests中 error = hwcDisplay-&gt;getRequests(&amp;displayData.displayRequests, &amp;layerRequests); RETURN_IF_HWC_ERROR_FOR(\"getRequests\", error, displayId, BAD_INDEX); ..... //合成方式初始化为false displayData.hasClientComposition = false; displayData.hasDeviceComposition = false; //遍历Layer for (auto&amp; outputLayer : output.getOutputLayersOrderedByZ()) &#123; auto&amp; state = outputLayer-&gt;editState(); LOG_FATAL_IF(!state.hwc.); auto hwcLayer = (*state.hwc).hwcLayer; if (auto it = changedTypes.find(hwcLayer.get()); it != changedTypes.end()) &#123; auto newCompositionType = it-&gt;second; validateChange(static_cast&lt;HWC2::Composition&gt;((*state.hwc).hwcCompositionType), newCompositionType); (*state.hwc).hwcCompositionType = static_cast&lt;Hwc2::IComposerClient::Composition&gt;(newCompositionType); &#125; switch ((*state.hwc).hwcCompositionType) &#123; case Hwc2::IComposerClient::Composition::CLIENT: displayData.hasClientComposition = true; break; case Hwc2::IComposerClient::Composition::DEVICE: case Hwc2::IComposerClient::Composition::SOLID_COLOR: case Hwc2::IComposerClient::Composition::CURSOR: case Hwc2::IComposerClient::Composition::SIDEBAND: displayData.hasDeviceComposition = true; break; default: break; &#125; //响应layerRequests state.clearClientTarget = false; if (auto it = layerRequests.find(hwcLayer.get()); it != layerRequests.end()) &#123; auto request = it-&gt;second; if (request == HWC2::LayerRequest::ClearClientTarget) &#123; state.clearClientTarget = true; &#125; else &#123; LOG_DISPLAY_ERROR(displayId, (\"Unknown layer request \" + to_string(request)).c_str()); &#125; &#125; &#125; //最后，通过HWC，SurfaceFlinger接受修改 error = hwcDisplay-&gt;acceptChanges(); RETURN_IF_HWC_ERROR_FOR(\"acceptChanges\", error, displayId, BAD_INDEX); return NO_ERROR;&#125; validate刷新： frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp123456789101112131415Error Display::validate(uint32_t* outNumTypes, uint32_t* outNumRequests)&#123; uint32_t numTypes = 0; uint32_t numRequests = 0; //调用Composer::validateDisplay auto intError = mComposer.validateDisplay(mId, &amp;numTypes, &amp;numRequests); auto error = static_cast&lt;Error&gt;(intError); if (error != Error::None &amp;&amp; error != Error::HasChanges) &#123; return error; &#125; *outNumTypes = numTypes; *outNumRequests = numRequests; return error;&#125; validateDisplay是通过CommandWriter写Buffer的方式调用到HWC中的，但是多了一个execute函数： frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp1234567891011121314Error Composer::validateDisplay(Display display, uint32_t* outNumTypes, uint32_t* outNumRequests)&#123; mWriter.selectDisplay(display); //Buffer命令的调用，只是将命令写到Buffer中 mWriter.validateDisplay(); //真正的将触发HWC服务端解析Buffer命令，再分别取调HWC对应的实现函数 Error error = execute(); if (error != Error::NONE) &#123; return error; &#125; mReader.hasChanges(display, outNumTypes, outNumRequests); return Error::NONE;&#125; doDebugFlashRegionsdoDebugFlashRegions只是一个debug功能，受mDebugRegion控制（开发者选项）。 12345678910111213141516171819202122232425262728void SurfaceFlinger::doDebugFlashRegions(const sp&lt;DisplayDevice&gt;&amp; displayDevice, bool repaintEverything) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); // is debugging enabled if (CC_LIKELY(!mDebugRegion)) return; if (displayState.isEnabled) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything); if (!dirtyRegion.isEmpty()) &#123; base::unique_fd readyFence; // redraw the whole screen doComposeSurfaces(displayDevice, dirtyRegion, &amp;readyFence); display-&gt;getRenderSurface()-&gt;queueBuffer(std::move(readyFence)); &#125; &#125; postFramebuffer(displayDevice); if (mDebugRegion &gt; 1) &#123; usleep(mDebugRegion * 1000); &#125; prepareFrame(displayDevice);&#125; doComposition合成处理SF.cpp1234567891011121314151617181920212223void SurfaceFlinger::doComposition(const sp&lt;DisplayDevice&gt;&amp; displayDevice, bool repaintEverything) &#123; ATRACE_CALL(); ALOGV(\"doComposition\"); auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); if (displayState.isEnabled) &#123; //获取rebuildLayerStacks时计算的当前显示设备的脏区域DirtyRegion //如果是强制重画，mRepaintEverything为true，那么脏区域就是整个屏幕的大小 //1. 获取脏区域 const Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything); // repaint the framebuffer (if needed) //2. 主要是对当前的显示设备上的所有不支持硬件合成Layer进行OpenGL合成处理 doDisplayComposition(displayDevice, dirtyRegion); display-&gt;editState().dirtyRegion.clear(); display-&gt;getRenderSurface()-&gt;flip(); &#125; //统一交由HWC，由HWC硬件合成并输出到显示屏 postFramebuffer(displayDevice);&#125; 合成方式： Client合成Client合成方式是相对与硬件合成来说的，其合成方式是，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件。这个暂存缓冲区，我们称为FBTarget，每个Display设备有各自的FBTarget。Client合成，之前称为GLES合成，我们也可以称之为GPU合成。Client合成，采用RenderEngine进行合成。 Device合成就是用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Devicehec的抽象。 getDirtyRegion获取脏区域前面在rebuildLayerStacks重构Layer的时候，Display的脏区域DirtyRegion已经计算出来。如果重画，则mRepaintEverything为true，此时脏区域就是整个屏幕的大小。 frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp1234567Region Output::getDirtyRegion(bool repaintEverything) const &#123; Region dirty(mState.viewport); if (!repaintEverything) &#123; dirty.andSelf(mState.dirtyRegion); &#125; return dirty;&#125; doDisplayComposition合成合成方式主要就两种，一种Client客户端用GPU合成；另外一种，Device端HWC硬件合成。doComposeSurfaces主要是处理Client端合成，通过RenderEngine用GPU来进行合成。 SF.cpp123456789101112131415161718192021void SurfaceFlinger::doDisplayComposition(const sp&lt;DisplayDevice&gt;&amp; displayDevice, const Region&amp; inDirtyRegion) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); // 只有在以下情况下才去真正合成这个Display的图像: // 1) 需要HWC硬件合成 // 2) 脏区域不为空 if (!displayDevice-&gt;getId() &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(\"Skipping display composition\"); return; &#125; ALOGV(\"doDisplayComposition\"); base::unique_fd readyFence; //调用doComposeSurfaces进行合成 if (!doComposeSurfaces(displayDevice, Region::INVALID_REGION, &amp;readyFence)) return; //将合成后的Buffer提交给该显示设备的BufferQueue,最终有FrameBufferSurface进行处理 //swap buffers (presentation) //代码路径：frameworks/native/libs/gui/Surface.cpp display-&gt;getRenderSurface()-&gt;queueBuffer(std::move(readyFence));&#125; *doComposeSurfacesSF.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120//doComposeSurfacesbool SurfaceFlinger::doComposeSurfaces(const sp&lt;DisplayDevice&gt;&amp; displayDevice, const Region&amp; debugRegion, base::unique_fd* readyFence) &#123; ..... //RenderEngine初始化 const Region bounds(displayState.bounds); const DisplayRenderArea renderArea(displayDevice); const bool hasClientComposition = getHwComposer().hasClientComposition(displayId); ATRACE_INT(\"hasClientComposition\", hasClientComposition); bool applyColorMatrix = false; renderengine::DisplaySettings clientCompositionDisplay; std::vector&lt;renderengine::LayerSettings&gt; clientCompositionLayers; sp&lt;GraphicBuffer&gt; buf; base::unique_fd fd; if (hasClientComposition) &#123; ALOGV(\"hasClientComposition\"); if (displayDevice-&gt;isPrimary() &amp;&amp; supportProtectedContent) &#123; bool needsProtected = false; //遍历layer for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; //如果layer受保护，则进行标记 if (layer-&gt;isProtected()) &#123; needsProtected = true; break; &#125; &#125; if (needsProtected != renderEngine.isProtected()) &#123; renderEngine.useProtectedContext(needsProtected); &#125; if (needsProtected != display-&gt;getRenderSurface()-&gt;isProtected() &amp;&amp; needsProtected == renderEngine.isProtected()) &#123; display-&gt;getRenderSurface()-&gt;setProtected(needsProtected); &#125; &#125; ... //Client合成Display的属性赋值 clientCompositionDisplay.physicalDisplay = displayState.scissor; //主屏剪切区 clientCompositionDisplay.clip = displayState.scissor; const ui::Transform&amp; displayTransform = displayState.transform; clientCompositionDisplay.globalTransform = displayTransform.asMatrix4(); clientCompositionDisplay.orientation = displayState.orientation; //屏幕转向 const auto* profile = display-&gt;getDisplayColorProfile(); Dataspace outputDataspace = Dataspace::UNKNOWN; //是否用WideColor，设置数据空间 if (profile-&gt;hasWideColorGamut()) &#123; outputDataspace = displayState.dataspace; &#125; clientCompositionDisplay.outputDataspace = outputDataspace; clientCompositionDisplay.maxLuminance = ... if (applyColorMatrix) &#123; clientCompositionDisplay.colorTransform = displayState.colorTransformMat; &#125; &#125; ...... //将Client端Layer渲染到FrameBuffer（即FBTarget） ALOGV(\"Rendering client layers\"); bool firstLayer = true; Region clearRegion = Region::INVALID_REGION; //遍历layer for (auto&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123; const Region viewportRegion(displayState.viewport); const Region clip(viewportRegion.intersect(layer-&gt;visibleRegion)); if (!clip.isEmpty()) &#123; switch (layer-&gt;getCompositionType(displayDevice)) &#123; case Hwc2::IComposerClient::Composition::CURSOR: case Hwc2::IComposerClient::Composition::DEVICE: case Hwc2::IComposerClient::Composition::SIDEBAND: case Hwc2::IComposerClient::Composition::SOLID_COLOR: &#123; LOG_ALWAYS_FATAL_IF(!displayId); const Layer::State&amp; state(layer-&gt;getDrawingState()); if (layer-&gt;getClearClientTarget(displayDevice) &amp;&amp; !firstLayer &amp;&amp; layer-&gt;isOpaque(state) &amp;&amp; (layer-&gt;getAlpha() == 1.0f) &amp;&amp; layer-&gt;getRoundedCornerState().radius == 0.0f &amp;&amp; hasClientComposition) &#123; //千万不要清除第一层，因为我们保证FB已经清除了 renderengine::LayerSettings layerSettings; Region dummyRegion; //调用该函数，此处有对受保护secure layer的处理（如果有数字保护协议，则会显示black layer） //然后会将layer的clip区域绘制到FBTarget上 bool prepared = layer-&gt;prepareClientLayer(renderArea, clip, dummyRegion, supportProtectedContent, layerSettings); if (prepared) &#123; layerSettings.source.buffer.buffer = nullptr; layerSettings.source.solidColor = half3(0.0, 0.0, 0.0); layerSettings.alpha = half(0.0); layerSettings.disableBlending = true; clientCompositionLayers.push_back(layerSettings); &#125; &#125; break; &#125; case Hwc2::IComposerClient::Composition::CLIENT: &#123; renderengine::LayerSettings layerSettings; //同上 bool prepared = layer-&gt;prepareClientLayer(renderArea, clip, clearRegion, supportProtectedContent, layerSettings); if (prepared) &#123; clientCompositionLayers.push_back(layerSettings); &#125; break; &#125; default: break; &#125; &#125; else &#123; ALOGV(\" Skipping for empty clip\"); &#125; firstLayer = false; &#125; ......&#125;&#125; postFramebufferSF.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void SurfaceFlinger::postFramebuffer(const sp&lt;DisplayDevice&gt;&amp; displayDevice) &#123; ATRACE_CALL(); ALOGV(\"postFramebuffer\"); auto display = displayDevice-&gt;getCompositionDisplay(); const auto&amp; displayState = display-&gt;getState(); const auto displayId = display-&gt;getId(); if (displayState.isEnabled) &#123; if (displayId) &#123; //调用该函数获取releaseFence getHwComposer().presentAndGetReleaseFences(*displayId); &#125; display-&gt;getRenderSurface()-&gt;onPresentDisplayCompleted(); for (auto&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123; sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE; bool usedClientComposition = true; //在这一帧的fence发出信号的时候，上一帧的layer buffer被HWC释放 //始终先从HWC处获取释放fence if (layer-&gt;getState().hwc) &#123; const auto&amp; hwcState = *layer-&gt;getState().hwc; releaseFence = getHwComposer().getLayerReleaseFence(*displayId, hwcState.hwcLayer.get()); usedClientComposition = hwcState.hwcCompositionType == Hwc2::IComposerClient::Composition::CLIENT; &#125; //如果层在上一帧中是Client客户端合成的，则需要与前一个Client客户端获取的fence合并。 //因为我们不跟踪它，所以当它可用时，总是与当前客户端Fence合并，即使这是子选项 if (usedClientComposition) &#123; releaseFence = Fence::merge(\"LayerRelease\", releaseFence, display-&gt;getRenderSurface()-&gt;getClientTargetAcquireFence()); &#125; layer-&gt;getLayerFE().onLayerDisplayed(releaseFence); &#125; //我们有一列需要fence的layer，它们与display-&gt;getVisibleLayersSortedByZ不相交。 //我们能做的最好的就是给他们提供现有的fence if (!displayDevice-&gt;getLayersNeedingFences().isEmpty()) &#123; sp&lt;Fence&gt; presentFence = displayId ? getHwComposer().getPresentFence(*displayId) : Fence::NO_FENCE; for (auto&amp; layer : displayDevice-&gt;getLayersNeedingFences()) &#123; layer-&gt;getCompositionLayer()-&gt;getLayerFE()-&gt;onLayerDisplayed(presentFence); &#125; &#125; if (displayId) &#123; //清除 getHwComposer().clearReleaseFences(*displayId); &#125; &#125;&#125; postCompositionSF.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void SurfaceFlinger::postComposition()&#123; ATRACE_CALL(); ALOGV(\"postComposition\"); //调用Layer的onPostComposition， 处理Layer中刚刚绘制的Buffer的Fence //此时才会真正释放掉一个Buffer nsecs_t dequeueReadyTime = systemTime(); for (auto&amp; layer : mLayersWithQueuedFrames) &#123; //这一帧合成完成后，将会被替代的Buffer释放掉 layer-&gt;releasePendingBuffer(dequeueReadyTime); &#125; ... //记录Buffer状态 mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; bool frameLatched = layer-&gt;onPostComposition(displayDevice-&gt;getId(), glCompositionDoneFenceTime, presentFenceTime, compositorTiming); if (frameLatched) &#123; recordBufferingStats(layer-&gt;getName().string(), layer-&gt;getOccupancyHistory(false)); &#125; &#125; //VSYNC是由mScheduler分发出来的，并不是每一次都是从底层硬件上报的 //所以mScheduler需要和底层硬件Vsync保持同步 if (presentFenceTime-&gt;isValid()) &#123; mScheduler-&gt;addPresentFence(presentFenceTime); &#125; //Vsync同步 if (!hasSyncFramework) &#123; if (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId()) &amp;&amp; displayDevice-&gt;isPoweredOn()) &#123; mScheduler-&gt;enableHardwareVsync(); &#125; &#125; //动画合成处理 if (mAnimCompositionPending) &#123; mAnimCompositionPending = false; if (presentFenceTime-&gt;isValid()) &#123; mAnimFrameTracker.setActualPresentFence( std::move(presentFenceTime)); &#125; else if (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId())) &#123; // The HWC doesn't support present fences, so use the refresh // timestamp instead. const nsecs_t presentTime = getHwComposer().getRefreshTimestamp(*displayDevice-&gt;getId()); mAnimFrameTracker.setActualPresentTime(presentTime); &#125; //advanceFrame处理FBTarget mAnimFrameTracker.advanceFrame(); &#125; ...... //处理时间的记录 &#125; 至此，REFRESH处理完成。之后等到下一个Vsync周期，开始下一次合成。 advanceFrame其中调用advanceFrame方法，虚显用的VirtualDisplaySurface，非虚显用的FramebufferSurface。advanceFrame获取FBTarget的数据： frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647status_t FramebufferSurface::advanceFrame() &#123; uint32_t slot = 0; sp&lt;GraphicBuffer&gt; buf; sp&lt;Fence&gt; acquireFence(Fence::NO_FENCE); Dataspace dataspace = Dataspace::UNKNOWN; status_t result = nextBuffer(slot, buf, acquireFence, dataspace); mDataSpace = dataspace; if (result != NO_ERROR) &#123; ALOGE(\"error latching next FramebufferSurface buffer: %s (%d)\", strerror(-result), result); &#125; return result;&#125;status_t FramebufferSurface::nextBuffer(uint32_t&amp; outSlot, sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence, Dataspace&amp; outDataspace) &#123; Mutex::Autolock lock(mMutex); BufferItem item; //1.获取一个Buffer（在上面doComposition - doDisplayComposition函数最后调用queueBuffer，会放到FrameBufferSurface的BufferQueue中） //此处的函数将从这个BufferQueue中获取一个Buffer status_t err = acquireBufferLocked(&amp;item, 0); ... //2.当前Buffer序号mCurrentBufferSlot，当前Buffer是mCurrentBuffer，对应的Fence是mCurrentFence //如果上面获取到的Buffer不一样，则将Current置为Previous上一个buffer，否则没有变化 if (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp; item.mSlot != mCurrentBufferSlot) &#123; mHasPendingRelease = true; mPreviousBufferSlot = mCurrentBufferSlot; mPreviousBuffer = mCurrentBuffer; &#125; //3.将获取到的Buffer置为当前的Current mCurrentBufferSlot = item.mSlot; mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer; mCurrentFence = item.mFence; outFence = item.mFence; mHwcBufferCache.getHwcBuffer(mCurrentBufferSlot, mCurrentBuffer, &amp;outSlot, &amp;outBuffer); outDataspace = static_cast&lt;Dataspace&gt;(item.mDataSpace); //4.将FBTarget设置给HWC （头文件HWComposer&amp; mHwc;） status_t result = mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace); if (result != NO_ERROR) &#123; ALOGE(\"error posting framebuffer: %d\", result); return result; &#125; return NO_ERROR;&#125; setClientTarget函数： frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp123456789status_t HWComposer::setClientTarget(DisplayId displayId, uint32_t slot, const sp&lt;Fence&gt;&amp; acquireFence, const sp&lt;GraphicBuffer&gt;&amp; target, ui::Dataspace dataspace) &#123; //头文件：std::unordered_map&lt;DisplayId, DisplayData&gt; mDisplayData; auto&amp; hwcDisplay = mDisplayData[displayId].hwcDisplay; //FBTarget是通过Command Buffer的方式传到HWC中的 auto error = hwcDisplay-&gt;setClientTarget(slot, target, acquireFence, dataspace); return NO_ERROR;&#125; HWComposer头文件，hwcDisplay在HWC2命名空间内。 123456789101112131415161718192021222324struct DisplayData &#123; bool isVirtual = false; bool hasClientComposition = false; bool hasDeviceComposition = false; HWC2::Display* hwcDisplay = nullptr; HWC2::DisplayRequest displayRequests; sp&lt;Fence&gt; lastPresentFence = Fence::NO_FENCE; // signals when the last set op retires std::unordered_map&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences; buffer_handle_t outbufHandle = nullptr; sp&lt;Fence&gt; outbufAcquireFence = Fence::NO_FENCE; mutable std::unordered_map&lt;int32_t, std::shared_ptr&lt;const HWC2::Display::Config&gt;&gt; configMap; bool validateWasSkipped; HWC2::Error presentError; bool vsyncTraceToggle = false; std::mutex vsyncEnabledLock; HWC2::Vsync vsyncEnabled GUARDED_BY(vsyncEnabledLock) = HWC2::Vsync::Disable; mutable std::mutex lastHwVsyncLock; nsecs_t lastHwVsync GUARDED_BY(lastHwVsyncLock) = 0;&#125;; GPU合成模块概述硬件HWC合成是由Vendor实现。而各个厂商在这部分的实现不同。 GPU合成（Client）是Android原生自带的，本质是采用GPU进程合成，SurfaceFlinger模块封装了RenderEngine进行具体的实现。 看一下这个模块的文件目录： frameworks/native/libs/renderengine123456789101112131415161718192021222324252627282930313233343536373839404142├── Android.bp├── Description.cpp├── gl│ ├── GLESRenderEngine.cpp│ ├── GLESRenderEngine.h│ ├── GLExtensions.cpp│ ├── GLExtensions.h│ ├── GLFramebuffer.cpp│ ├── GLFramebuffer.h│ ├── GLImage.cpp│ ├── GLImage.h│ ├── ProgramCache.cpp│ ├── ProgramCache.h│ ├── Program.cpp│ └── Program.h├── include│ └── renderengine│ ├── DisplaySettings.h│ ├── Framebuffer.h│ ├── Image.h│ ├── LayerSettings.h│ ├── Mesh.h│ ├── mock│ │ ├── Framebuffer.h│ │ ├── Image.h│ │ └── RenderEngine.h│ ├── private│ │ └── Description.h│ ├── RenderEngine.h│ └── Texture.h├── Mesh.cpp├── mock│ ├── Framebuffer.cpp│ ├── Image.cpp│ └── RenderEngine.cpp├── OWNERS├── RenderEngine.cpp├── TEST_MAPPING├── tests│ ├── Android.bp│ └── RenderEngineTest.cpp└── Texture.cpp 创建RenderEngine在SF.cpp初始化函数init中： 123456789void SurfaceFlinger::init() &#123; ... // TODO(b/77156734): We need to stop casting and use HAL types when possible. // Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display. mCompositionEngine-&gt;setRenderEngine( renderengine::RenderEngine::create(static_cast&lt;int32_t&gt;(defaultCompositionPixelFormat), renderEngineFeature, maxFrameBufferAcquiredBuffers)); ...&#125; create调用RenderEngine.cpp中的对应函数：（在Q版本该模块已经独立出来，该模块是对GPU渲染的封装） frameworks/native/libs/renderengine/RenderEngine.cpp1234567891011std::unique_ptr&lt;impl::RenderEngine&gt; RenderEngine::create(int hwcFormat, uint32_t featureFlags, uint32_t imageCacheSize) &#123; char prop[PROPERTY_VALUE_MAX]; property_get(PROPERTY_DEBUG_RENDERENGINE_BACKEND, prop, \"gles\"); if (strcmp(prop, \"gles\") == 0) &#123; ALOGD(\"RenderEngine GLES Backend\"); return renderengine::gl::GLESRenderEngine::create(hwcFormat, featureFlags, imageCacheSize); &#125; ALOGE(\"UNKNOWN BackendType: %s, create GLES RenderEngine.\", prop); return renderengine::gl::GLESRenderEngine::create(hwcFormat, featureFlags, imageCacheSize);&#125; frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354std::unique_ptr&lt;GLESRenderEngine&gt; GLESRenderEngine::create(int hwcFormat, uint32_t featureFlags, uint32_t imageCacheSize) &#123; //创建EGLDisplay EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY); //初始化EGLDisplay if (!eglInitialize(display, nullptr, nullptr)) &#123; LOG_ALWAYS_FATAL(\"failed to initialize EGL\"); &#125; //选择EGLConfig EGLConfig config = EGL_NO_CONFIG; if (!extensions.hasNoConfigContext()) &#123; config = chooseEglConfig(display, hwcFormat, /*logConfig*/ true); &#125; ... //创建EGLContext //在该函数中: //1.调用eglGetConfigAttrib获取renderableType、 //2.初始化Context属性contextAttributes、 //3.调用eglCreateContext创建EGLContext if ((featureFlags &amp; RenderEngine::ENABLE_PROTECTED_CONTEXT) &amp;&amp; extensions.hasProtectedContent()) &#123; protectedContext = createEglContext(display, config, nullptr, useContextPriority, Protection::PROTECTED); ALOGE_IF(protectedContext == EGL_NO_CONTEXT, \"Can't create protected context\"); &#125; EGLContext ctxt = createEglContext(display, config, protectedContext, useContextPriority, Protection::UNPROTECTED); ... EGLSurface dummy = EGL_NO_SURFACE; if (!extensions.hasSurfacelessContext()) &#123; //创建PBuffer dummy = createDummyEglPbufferSurface(display, config, hwcFormat, Protection::UNPROTECTED); &#125; ... //查看可以获取到什么版本的GL GlesVersion version = parseGlesVersion(extensions.getVersion()); //初始化当前GL的渲染器RenderEngine std::unique_ptr&lt;GLESRenderEngine&gt; engine; switch (version) &#123; case GLES_VERSION_1_0: case GLES_VERSION_1_1: LOG_ALWAYS_FATAL(\"SurfaceFlinger requires OpenGL ES 2.0 minimum to run.\"); break; case GLES_VERSION_2_0: case GLES_VERSION_3_0: engine = std::make_unique&lt;GLESRenderEngine&gt;(featureFlags, display, config, ctxt, dummy, protectedContext, protectedDummy, imageCacheSize); break; &#125; ......&#125; 创建Surface FBTargetRenderEngine创建时始化的EGLDisplaym，EGLConfig，EGLContext等，都是所有Display共用的。 而Surface每个Display的是自己的，在创建DisplayDevice时，创建对应的Surface。 从BufferQueue中dequeue Buffer进行渲染，swapBuffer时，也queue到Bufferqueu中。这里的ANativeWindow，本质就是FBTarget。 创建Texture纹理在BufferLayer创建的构造函数中创建Texture： BufferLayer.cpp123456789BufferLayer::BufferLayer(const LayerCreationArgs&amp; args) : Layer(args), //调用SurfaceFlinger的getNewTexture创建 //在创建BufferLayerConsumer时，传到了Consumer中，对应的值为mTexName mTextureName(args.flinger-&gt;getNewTexture()), mCompositionLayer&#123;mFlinger-&gt;getCompositionEngine().createLayer( compositionengine::LayerCreationArgs&#123;this&#125;)&#125; &#123; ......&#125; SF.cpp12345678uint32_t SurfaceFlinger::getNewTexture() &#123; ...... // The pool was empty, so we need to get a new texture name directly using a // blocking call to the main thread uint32_t name = 0; postMessageSync(new LambdaMessage([&amp;]() &#123; getRenderEngine().genTextures(1, &amp;name); &#125;)); return name;&#125; 调用genTextures： frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp123void GLESRenderEngine::genTextures(size_t count, uint32_t* names) &#123; glGenTextures(count, names); //生成Texture，在BufferLayer中保存在mTexture中&#125; 绑定Texture纹理在BufferLayerConsumer::updateTexImage函数中调用bindTextureImageLocked绑定新的buffer到GL Texture纹理。 而该函数是在SurfaceFlinger调用latchBuffer从BufferQueue申请获取渲染好的buffer的时候会调用到。 Layer合成在Q版本之前是调用的onDraw函数，而在Q上函数名变成prepareClientLayer。 12345678910bool BufferLayer::prepareClientLayer(const RenderArea&amp; renderArea, const Region&amp; clip, bool useIdentityTransform, Region&amp; clearRegion, const bool supportProtectedContent, renderengine::LayerSettings&amp; layer) &#123; ... //DRM处理，是否阻塞当前Layer bool blackOutLayer = (isProtected() &amp;&amp; !supportProtectedContent) || (isSecure() &amp;&amp; !renderArea.isSecure()); ...&#125; 在SurfaceFlinger::doComposeSurfaces函数中，调用完prepareClientLayer后，末尾最后调用renderEngine.drawLayers函数。 最终调用到GPU合成模块frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp的GLESRenderEngine::drawLayers函数。 123456789101112131415161718192021222324252627282930status_t GLESRenderEngine::drawLayers(const DisplaySettings&amp; display, const std::vector&lt;LayerSettings&gt;&amp; layers, ANativeWindowBuffer* const buffer, const bool useFramebufferCache, base::unique_fd&amp;&amp; bufferFence, base::unique_fd* drawFence) &#123; ... //Texture坐标顶点 renderengine::Mesh::VertexArray&lt;vec2&gt; texCoords(mesh.getTexCoordArray&lt;vec2&gt;()); texCoords[0] = vec2(0.0, 0.0); texCoords[1] = vec2(0.0, 1.0); texCoords[2] = vec2(1.0, 1.0); texCoords[3] = vec2(1.0, 0.0); ... // Buffer sources will have a black solid color ignored in the shader, // so in that scenario the solid color passed here is arbitrary. //处理Alpha的Blend setupLayerBlending(usePremultipliedAlpha, isOpaque, disableTexture, color, layer.geometry.roundedCornersRadius); &#125; ... // We only want to do a special handling for rounded corners when having rounded corners // is the only reason it needs to turn on blending, otherwise, we handle it like the // usual way since it needs to turn on blending anyway. if (layer.geometry.roundedCornersRadius &gt; 0.0 &amp;&amp; color.a &gt;= 1.0f &amp;&amp; isOpaque) &#123; handleRoundedCorners(display, layer, mesh); &#125; else &#123; //绘制（合成）内容 //该函数中使用glDrawArrays函数进行绘制（合成） drawMesh(mesh); &#125; 参考文章 Google Developers - BlendMode SurfaceFlinger合成流程(一) SurfaceFlinger合成流程(二) Android Handler消息循环处理机制 Android 图形显示框架 Android BitTube Android之BitTube 基于Android Q分析SurfaceFlinger启动过程 Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState SurfaceFlinger图像合成[1]","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android Q SurfaceFlinger合成（一）","slug":"2020/201015_android_SurfaceFlinger1","date":"2020-10-15T12:52:00.000Z","updated":"2020-10-15T12:44:00.005Z","comments":true,"path":"2020/10/15/2020/201015_android_SurfaceFlinger1/","link":"","permalink":"https://alonealive.github.io/Blog/2020/10/15/2020/201015_android_SurfaceFlinger1/","excerpt":"在HWUI渲染完成后，Buffer会在frameworks/native/libs/gui/BufferQueueProducer.cpp中通过queueBuffer放入BufferQueue，在该函数中调用frameAvailableListener-&gt;onFrameAvailable(item)通知consumer消费者，从而触发SurfaceFlinger合成。","text":"在HWUI渲染完成后，Buffer会在frameworks/native/libs/gui/BufferQueueProducer.cpp中通过queueBuffer放入BufferQueue，在该函数中调用frameAvailableListener-&gt;onFrameAvailable(item)通知consumer消费者，从而触发SurfaceFlinger合成。 onFrameAvailable触发合成 上面的frameAvailableListener对象类型是sp&lt;IConsumerListener&gt; frameAvailableListener; 参考Android 图形显示框架中的《Surface创建流程》，在该流程中会创建BufferQueue，调用BufferQueue::createBufferQueue函数。 而class ProxyConsumerListener : public BnConsumerListener...是IConsumerListener接口的Bn端，所以会调用到下面代码： BufferQueue中的frameAvailableListener，是一个IConsumerListener的接口，对应的Binder的Bn端实现为ProxyConsumerListener。 frameworks/native/libs/gui/BufferQueue.cpp12345678910//头文件中wp&lt;ConsumerListener&gt; mConsumerListener;void BufferQueue::ProxyConsumerListener::onFrameAvailable( const BufferItem&amp; item) &#123; sp&lt;ConsumerListener&gt; listener(mConsumerListener.promote()); if (listener != nullptr) &#123; listener-&gt;onFrameAvailable(item); &#125;&#125; 在ConsumerBase.h中该类继承ConsumerListener。所以此处的mConsumerListener是ConsumerBase中的实现。 frameworks/native/libs/gui/include/gui/ConsumerBase.h12class ConsumerBase : public virtual RefBase, protected ConsumerListener &#123;...&#125; frameworks/native/libs/gui/ConsumerBase.cpp1234567891011121314void ConsumerBase::onFrameAvailable(const BufferItem&amp; item) &#123; CB_LOGV(\"onFrameAvailable\"); sp&lt;FrameAvailableListener&gt; listener; &#123; // scope for the lock Mutex::Autolock lock(mFrameAvailableMutex); listener = mFrameAvailableListener.promote(); &#125; if (listener != nullptr) &#123; CB_LOGV(\"actually calling onFrameAvailable\"); listener-&gt;onFrameAvailable(item); &#125;&#125; 在BufferQueueLayer中，class BufferQueueLayer : public BufferLayer, public BufferLayerConsumer::ContentsChangedListener{......}。 而class BufferLayerConsumer : public ConsumerBase... frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243void BufferQueueLayer::onFrameAvailable(const BufferItem&amp; item) &#123; ATRACE_CALL(); // Add this buffer from our internal queue tracker &#123; // Autolock scope if (mFlinger-&gt;mUseSmart90ForVideo) &#123; const nsecs_t presentTime = item.mIsAutoTimestamp ? 0 : item.mTimestamp; mFlinger-&gt;mScheduler-&gt;addLayerPresentTimeAndHDR(mSchedulerLayerHandle, presentTime, item.mHdrMetadata.validTypes != 0); &#125; Mutex::Autolock lock(mQueueItemLock); // FrameNumber被重置时，同时重置mLastFrameNumberReceived if (item.mFrameNumber == 1) &#123; mLastFrameNumberReceived = 0; &#125; //确保mFrameNumber的顺序 while (item.mFrameNumber != mLastFrameNumberReceived + 1) &#123; status_t result = mQueueItemCondition.waitRelative(mQueueItemLock, ms2ns(500)); if (result != NO_ERROR) &#123; ALOGE(\"[%s] Timed out waiting on callback\", mName.string()); &#125; &#125; //将新的buffer放入Layer队列中，同时对mQueuedFrames+1操作 mQueueItems.push_back(item); mQueuedFrames++; // Wake up any pending callbacks mLastFrameNumberReceived = item.mFrameNumber; mQueueItemCondition.broadcast(); &#125; //buffer属性保存到mInterceptor中 mFlinger-&gt;mInterceptor-&gt;saveBufferUpdate(this, item.mGraphicBuffer-&gt;getWidth(), item.mGraphicBuffer-&gt;getHeight(), item.mFrameNumber); if (isRemovedFromCurrentState()) &#123; fakeVsync(); &#125; else &#123; //触发LayerUpdate mFlinger-&gt;signalLayerUpdate(); &#125; mConsumer-&gt;onBufferAvailable(item);&#125; 类图 BufferQueueLayer有专门的Consumer，即BufferLayerConsumer。BufferLayerConsumer继承ConsumerBase。ConsumerBase通过IGraphicBufferConsumer和BufferQueue进行通信。 BufferQueue中的frameAvailableListener，是一个IConsumerListener的接口，对应的Binder的Bn端实现为ProxyConsumerListener。 BufferQueueLayer实现了ContentsChangedListener，ContentsChangedListener继承FrameAvailableListener。BufferQueueLayer的Listener实现，被传给了ConsumerBase。 ConsumerBase实现ConsumerListener接口，构建ConsumerBase时，会创建ProxyConsumerListener，将ConsumerBase实现的Listener接口传给ProxyConsumerListener。 BufferQueue中Listener回调时，会回调到ConsumerBase中。ConsumerBase中再通过BufferQueueLayer实现的，传下来的Listener回调到BufferLayer中。 MessageQueue消息队列 Android的消息处理机制请参考：Android Handler消息循环处理机制(例ActivityThread) 在SurfaceFlinger模块有单独的MessageQueue处理流程。在SF创建的时候，构造函数会创建meventqueue对象。在其onFirstRef函数中调用mEventQueue-&gt;init(this);进行初始化。 MessageQueue初始化时，创建了一个Looper和Handler。 frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp12345void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123; mFlinger = flinger; mLooper = new Looper(true); mHandler = new Handler(*this);&#125; setEventThread变更在Android Q中，EventThread的setEventThread操作具体在SurfaceFlinger::enableVSyncInjections中进行。 而非之前的是在SurfaceFlinger的init初始化函数中。 SF.cpp12345678910111213141516171819202122232425262728293031//头文件//mEventQueue是MessageQueue的一个栈对象std::unique_ptr&lt;MessageQueue&gt; mEventQueue;status_t SurfaceFlinger::enableVSyncInjections(bool enable) &#123; postMessageSync(new LambdaMessage([&amp;] &#123; ...... // TODO(b/128863962): Part of the Injector should be refactored, so that it // can be passed to Scheduler. if (enable) &#123; ALOGV(\"VSync Injections enabled\"); if (mVSyncInjector.get() == nullptr) &#123; mVSyncInjector = std::make_unique&lt;InjectVSyncSource&gt;(); mInjectorEventThread = std::make_unique&lt; impl::EventThread&gt;(mVSyncInjector.get(), impl::EventThread::InterceptVSyncsCallback(), \"injEventThread\"); &#125; mEventQueue-&gt;setEventThread(mInjectorEventThread.get(), std::move(resyncCallback)); &#125; else &#123; ALOGV(\"VSync Injections disabled\"); mEventQueue-&gt;setEventThread(mScheduler-&gt;getEventThread(mSfConnectionHandle), std::move(resyncCallback)); &#125; mInjectVSyncs = enable; &#125;)); return NO_ERROR;&#125; setEventThread函数做了两件事： 创建一个BitTube对象mEventTube 创建一个EventConnection frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp1234567891011121314151617181920212223242526272829//头文件，是BitTube对象gui::BitTube mEventTube;void MessageQueue::setEventThread(android::EventThread* eventThread, ResyncCallback resyncCallback) &#123; if (mEventThread == eventThread) &#123; return; &#125; if (mEventTube.getFd() &gt;= 0) &#123; mLooper-&gt;removeFd(mEventTube.getFd()); &#125; mEventThread = eventThread; mEvents = eventThread-&gt;createEventConnection(std::move(resyncCallback)); //将mEventTube和EventConnection关联 mEvents-&gt;stealReceiveChannel(&amp;mEventTube); //将fd添加到MessageQueue的Looper中 //Looper的callback（入参）为MessageQueue::cb_eventReceiver //一旦有数据到来就会调用cb_eventReceiver mLooper-&gt;addFd(mEventTube.getFd(), 0, Looper::EVENT_INPUT, MessageQueue::cb_eventReceiver, this);&#125;//data为MessageQueue本身有数据到来就会调用，作用是负责处理EventThread发送过来的信号int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue*&gt;(data); return queue-&gt;eventReceiver(fd, events);&#125; frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp12345678910111213141516171819202122232425262728//创建connectionsp&lt;EventThreadConnection&gt; EventThread::createEventConnection(ResyncCallback resyncCallback) const &#123; return new EventThreadConnection(const_cast&lt;EventThread*&gt;(this), std::move(resyncCallback));&#125;//Connection创建的时候先调用OnFirstRef进行注册void EventThreadConnection::onFirstRef() &#123; // NOTE: mEventThread doesn't hold a strong reference on us mEventThread-&gt;registerDisplayEventConnection(this);&#125;//注册，将Connection将会被添加到mDisplayEventConnections 中status_t EventThread::registerDisplayEventConnection(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); // this should never happen auto it = std::find(mDisplayEventConnections.cbegin(), mDisplayEventConnections.cend(), connection); if (it != mDisplayEventConnections.cend()) &#123; ALOGW(\"DisplayEventConnection %p already exists\", connection.get()); mCondition.notify_all(); return ALREADY_EXISTS; &#125; mDisplayEventConnections.push_back(connection); //添加 mCondition.notify_all(); return NO_ERROR;&#125; 创建BitTube对象，构造函数会调用init函数： frameworks/native/libs/gui/BitTube.cpp1234567891011121314151617181920212223242526272829static const size_t DEFAULT_SOCKET_BUFFER_SIZE = 4 * 1024;BitTube::BitTube(size_t bufsize) &#123; init(bufsize, bufsize);&#125;//默认创建一个4k的BitTube，BitTube封装的是一对socket，一个发送，一个接收，可传输的Buffer大小为4Kvoid BitTube::init(size_t rcvbuf, size_t sndbuf) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets) == 0) &#123; size_t size = DEFAULT_SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, sizeof(sndbuf)); // since we don't use the \"return channel\", we keep it small... setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size)); fcntl(sockets[0], F_SETFL, O_NONBLOCK); fcntl(sockets[1], F_SETFL, O_NONBLOCK); mReceiveFd.reset(sockets[0]); mSendFd.reset(sockets[1]); &#125; else &#123; mReceiveFd.reset(); ALOGE(\"BitTube: pipe creation failed (%s)\", strerror(errno)); &#125;&#125;int BitTube::getFd() const &#123; return mReceiveFd;&#125; signalLayerUpdate通知Layer更新信息接着上面第一部分的流程，触发SF的合成从signalLayerUpdate开始。 SF.cpp1234void SurfaceFlinger::signalLayerUpdate() &#123; mScheduler-&gt;resetIdleTimer(); mEventQueue-&gt;invalidate();&#125; 调用到MessageQueue的invalidate函数。 frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp123void MessageQueue::invalidate() &#123; mEvents-&gt;requestNextVsync();&#125; 请求下一个Vsync（垂直同步机制），主要作用是通知Vsync机制在下一个SF的Vsync到来的时候唤醒SF进行工作，从而进行合成处理。 frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp12345678910111213141516171819202122232425void EventThreadConnection::requestNextVsync() &#123; ATRACE_NAME(\"requestNextVsync\"); mEventThread-&gt;requestNextVsync(this);&#125;void EventThread::requestNextVsync(const sp&lt;EventThreadConnection&gt;&amp; connection) &#123; if (connection-&gt;resyncCallback) &#123; connection-&gt;resyncCallback(); &#125; std::lock_guard&lt;std::mutex&gt; lock(mMutex); //如果为空，则赋值，并且触发notify if (connection-&gt;vsyncRequest == VSyncRequest::None) &#123; connection-&gt;vsyncRequest = VSyncRequest::Single; mCondition.notify_all(); &#125;&#125;//头文件enum class VSyncRequest &#123; None = -1, Single = 0, Periodic = 1, // Subsequent values are periods.&#125;; 然后会触发threadmain函数，这个和Android P上的threadloop流程是不同的。 frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105void EventThread::threadMain(std::unique_lock&lt;std::mutex&gt;&amp; lock) &#123; DisplayEventConsumers consumers; while (mState != State::Quit) &#123; std::optional&lt;DisplayEventReceiver::Event&gt; event; // Determine next event to dispatch. if (!mPendingEvents.empty()) &#123; event = mPendingEvents.front(); mPendingEvents.pop_front(); //event处理两种事件： //1. 热插拔事件 //2. vsync事件 switch (event-&gt;header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: if (event-&gt;hotplug.connected &amp;&amp; !mVSyncState) &#123; mVSyncState.emplace(event-&gt;header.displayId); &#125; else if (!event-&gt;hotplug.connected &amp;&amp; mVSyncState &amp;&amp; mVSyncState-&gt;displayId == event-&gt;header.displayId) &#123; mVSyncState.reset(); &#125; break; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: if (mInterceptVSyncsCallback) &#123; //有vsync事件要分发 mInterceptVSyncsCallback(event-&gt;header.timestamp); &#125; break; &#125; &#125; bool vsyncRequested = false; // Find connections that should consume this event. auto it = mDisplayEventConnections.begin(); while (it != mDisplayEventConnections.end()) &#123; if (const auto connection = it-&gt;promote()) &#123; vsyncRequested |= connection-&gt;vsyncRequest != VSyncRequest::None; if (event &amp;&amp; shouldConsumeEvent(*event, connection)) &#123; consumers.push_back(connection); &#125; ++it; &#125; else &#123; it = mDisplayEventConnections.erase(it); &#125; &#125; if (!consumers.empty()) &#123; //分发事件 dispatchEvent(*event, consumers); consumers.clear(); &#125; State nextState; if (mVSyncState &amp;&amp; vsyncRequested) &#123; nextState = mVSyncState-&gt;synthetic ? State::SyntheticVSync : State::VSync; &#125; else &#123; ALOGW_IF(!mVSyncState, \"Ignoring VSYNC request while display is disconnected\"); nextState = State::Idle; &#125; if (mState != nextState) &#123; if (mState == State::VSync) &#123; mVSyncSource-&gt;setVSyncEnabled(false); &#125; else if (nextState == State::VSync) &#123; mVSyncSource-&gt;setVSyncEnabled(true); &#125; mState = nextState; &#125; if (event) &#123; continue; &#125; // Wait for event or client registration/request. if (mState == State::Idle) &#123; mCondition.wait(lock); &#125; else &#123; // Generate a fake VSYNC after a long timeout in case the driver stalls. When the // display is off, keep feeding clients at 60 Hz. const auto timeout = mState == State::SyntheticVSync ? 16ms : 1000ms; if (mCondition.wait_for(lock, timeout) == std::cv_status::timeout) &#123; ALOGW_IF(mState == State::VSync, \"Faking VSYNC due to driver stall\"); LOG_FATAL_IF(!mVSyncState); mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, systemTime(SYSTEM_TIME_MONOTONIC), ++mVSyncState-&gt;count)); &#125; &#125; &#125;&#125;//头文件 // State machine for event loop. enum class State &#123; Idle, Quit, SyntheticVSync, VSync, &#125;; VSYNC事件到来将会回调onVSyncEvent： frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp1234567void EventThread::onVSyncEvent(nsecs_t timestamp) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); LOG_FATAL_IF(!mVSyncState); mPendingEvents.push_back(makeVSync(mVSyncState-&gt;displayId, timestamp, ++mVSyncState-&gt;count)); mCondition.notify_all();&#125; Hotplug事件到来将会回调onHotplugReceived： frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp123456void EventThread::onHotplugReceived(PhysicalDisplayId displayId, bool connected) &#123; std::lock_guard&lt;std::mutex&gt; lock(mMutex); mPendingEvents.push_back(makeHotplug(displayId, systemTime(), connected)); mCondition.notify_all();&#125; dispatchEvent分发事件从上面的threadMain函数会调用dispatchEvent函数分发事件： Connection通过postEvent将Event抛出来后，通过sendEvents将事件发出去。 frameworks/native/services/surfaceflinger/Scheduler/EventThread.cpp1234567891011121314151617181920212223242526void EventThread::dispatchEvent(const DisplayEventReceiver::Event&amp; event, const DisplayEventConsumers&amp; consumers) &#123; for (const auto&amp; consumer : consumers) &#123; // switch (consumer-&gt;postEvent(event)) &#123; case NO_ERROR: break; case -EAGAIN: // TODO: Try again if pipe is full. ALOGW(\"Failed dispatching %s for %s\", toString(event).c_str(), toString(*consumer).c_str()); break; default: // Treat EPIPE and other errors as fatal. removeDisplayEventConnectionLocked(consumer); &#125; &#125;&#125;status_t EventThreadConnection::postEvent(const DisplayEventReceiver::Event&amp; event) &#123; // ssize_t size = DisplayEventReceiver::sendEvents(&amp;mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR);&#125; DisplayEventReceiver中是通过BitTube将事件发出去，sendObjects注意这里的参数: frameworks/native/libs/gui/DisplayEventReceiver.cpp12345ssize_t DisplayEventReceiver::sendEvents(gui::BitTube* dataChannel, Event const* events, size_t count)&#123; return gui::BitTube::sendObjects(dataChannel, events, count);&#125; MessageQueue处理MessageSF的线程run时，有一个死循环，循环等待事件： SF.cpp123456789void SurfaceFlinger::run() &#123; do &#123; waitForEvent(); &#125; while (true);&#125;void SurfaceFlinger::waitForEvent() &#123; mEventQueue-&gt;waitMessage();&#125; 在MessageQueue中，会有looper一直循环等待消息。 waitMessage，通过采用一个死循环，处理Looper的pollOnce。Looper内部的主要是采用epoll_wait对fd进行监听，BitTube发送Event对象后，epoll_wait结束，调用callback，处理事件。 可参考Handler文章：Android Handler消息循环处理机制 MessageQueue.cpp123456789101112131415161718192021void MessageQueue::waitMessage() &#123; do &#123; IPCThreadState::self()-&gt;flushCommands(); int32_t ret = mLooper-&gt;pollOnce(-1); switch (ret) &#123; case Looper::POLL_WAKE: case Looper::POLL_CALLBACK: continue; case Looper::POLL_ERROR: ALOGE(\"Looper::POLL_ERROR\"); continue; case Looper::POLL_TIMEOUT: // timeout (should not happen) continue; default: // should not happen ALOGE(\"Looper::pollOnce() returned unknown status %d\", ret); continue; &#125; &#125; while (true);&#125; MessageQueue对应的callback为cb_eventReceiver： MessageQueue.cpp123456789101112131415161718192021222324252627282930//头文件 enum &#123; INVALIDATE = 0, REFRESH = 1, &#125;;int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue*&gt;(data); return queue-&gt;eventReceiver(fd, events);&#125;int MessageQueue::eventReceiver(int /*fd*/, int /*events*/) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; while ((n = DisplayEventReceiver::getEvents(&amp;mEventTube, buffer, 8)) &gt; 0) &#123; for (int i = 0; i &lt; n; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; mHandler-&gt;dispatchInvalidate(); break; &#125; &#125; &#125; return 1;&#125;void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125;&#125; sendMessage在Handler.java中调用到MessageQueue.java的enqueueMessage函数，然后调用JNI函数nativeWake，唤醒Looper.java的loop函数。 调用其中的dispatchMessage处理消息。 dispatchMessage函数会调用handleMessage函数，开始处理消息。 123456789101112void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125; onMessageReceived处理INVALIDATE消息MessageQueue触发Handler消息处理机制，开始触发INVALIDATE消息合成。 大体分成两部分： SF更新合成相关的信息（即handleMessageTransaction） SF执行合成相关的操作并显示 SurfaceFlinger.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS &#123; //systrace抓取 ATRACE_CALL(); switch (what) &#123; case MessageQueue::INVALIDATE: &#123; //丢帧处理 bool frameMissed = previousFrameMissed(); bool hwcFrameMissed = mHadDeviceComposition &amp;&amp; frameMissed; bool gpuFrameMissed = mHadClientComposition &amp;&amp; frameMissed; ATRACE_INT(\"FrameMissed\", static_cast&lt;int&gt;(frameMissed)); ATRACE_INT(\"HwcFrameMissed\", static_cast&lt;int&gt;(hwcFrameMissed)); ATRACE_INT(\"GpuFrameMissed\", static_cast&lt;int&gt;(gpuFrameMissed)); if (frameMissed) &#123; mFrameMissedCount++; mTimeStats-&gt;incrementMissedFrames(); &#125; if (hwcFrameMissed) &#123; mHwcFrameMissedCount++; &#125; if (gpuFrameMissed) &#123; mGpuFrameMissedCount++; &#125; if (mUseSmart90ForVideo) &#123; // This call is made each time SF wakes up and creates a new frame. It is part // of video detection feature. mScheduler-&gt;updateFpsBasedOnContent(); &#125; if (performSetActiveConfig()) &#123; break; &#125; if (frameMissed &amp;&amp; mPropagateBackpressure) &#123; if ((hwcFrameMissed &amp;&amp; !gpuFrameMissed) || mPropagateBackpressureClientComposition) &#123; signalLayerUpdate(); break; &#125; &#125; //更新VR updateVrFlinger(); //处理Transition，在合成前更新Layer的信息 bool refreshNeeded = handleMessageTransaction(); // refreshNeeded |= handleMessageInvalidate(); updateCursorAsync(); updateInputFlinger(); refreshNeeded |= mRepaintEverything; if (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123; //如果Transaction事务修改了窗口状态，则发出刷新信号 //一个新的buffer将被请求 signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125; &#125;&#125; 一、丢帧处理frameMissed如果丢帧，则mPropagateBackpressure为true。 该变量是在SurfaceFlinger的构造函数中，由debug.sf.disable_backpressure属性控制。 SF.cpp12345678property_get(\"debug.sf.disable_backpressure\", value, \"0\"); mPropagateBackpressure = !atoi(value); ALOGI_IF(!mPropagateBackpressure, \"Disabling backpressure propagation\"); property_get(\"debug.sf.enable_gl_backpressure\", value, \"0\"); mPropagateBackpressureClientComposition = atoi(value); ALOGI_IF(mPropagateBackpressureClientComposition, \"Enabling backpressure propagation for Client Composition\"); 例如我的一加六 Android Q设备： 12adb shell getprop debug.sf.disable_backpressure1 二、handleMessageTransaction处理TransactionVsync到来后，触发INVALIDATE消息时会先处理Transition。 如上代码先调用handleMessageTransaction。这个过程就是处理应用传过来的各种Transaction。 大致函数调用流程： handleMessageTransaction -&gt; handleTransaction -&gt; handleTransactionLocked -&gt; (processDisplayChangesLocked) -&gt; commitTransaction() handleMessageTransaction主要处理Layer属性变化，显示设备变化等情况，最终将变化的信息mCurrentState提交到mDrawingState, 等待合成处理. 即最终commitTransaction函数会有个状态更替，将mCurrentState赋值给了mDrawingState。 SF.cpp12345678910111213141516171819202122void SurfaceFlinger::commitTransaction()&#123; ..... withTracingLock([&amp;]() &#123; mDrawingState = mCurrentState; // clear the \"changed\" flags in current state mCurrentState.colorMatrixChanged = false; mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; layer-&gt;commitChildList(); if (mOffscreenLayers.count(layer)) &#123; mOffscreenLayers.erase(layer); &#125; &#125;); commitOffscreenLayers(); &#125;); mTransactionPending = false; mAnimTransactionPending = false; mTransactionCV.broadcast();&#125; mCurrentState和mDrawingState 可参考：Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState mCurrentState状态：准备数据，应用传过来的数据保存在mCurrentState中。 mDrawingState状态：进程合成状态，需要进行合成的数据保存在mDrawingState中。 即每次合成时，先更新一下状态数据。每一层Layer也需要去更新状态数据。 handleTransactionLocked1. 检查mCurrentState的Layer的可见区域该函数第一部分就是遍历mCurrentState的Layer，并检查Layer的可见区域VisableRegion是否发生变化。 如果没发生变化则不需要检查layer 如果发生变化，则对比该Layer的显示区域和原来的显示区域是否发生变化，若变化则设置mVisibleRegionsDirty为true SF.cpp12345678910111213141516171819202122232425262728293031void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; //第一部分 // Notify all layers of available frames mCurrentState.traverseInZOrder([](Layer* layer) &#123; layer-&gt;notifyAvailableFrames(); &#125;); //遍历mCurrentState中的所有的layer if ((transactionFlags &amp; eTraversalNeeded) || mTraversalNeededMainThread) &#123; mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123; //根据eTransactionNeeded判断Layer是否发生变化（如果Layer发生变化则会设置这个flag） uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) return; //对发生变化的layer执行doTransaction函数，对比Layer旧的状态和新的状态是否发生变化 const uint32_t flags = layer-&gt;doTransaction(0); //判断Layer的可见区域是否发生变化 //当Layer的可见区域大小发生变化之后，设置mVisibleRegionsDirty为true if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; if (flags &amp; Layer::eInputInfoChanged) &#123; mInputInfoChanged = true; &#125; &#125;); mTraversalNeededMainThread = false; &#125; ...... //第二部分&#125; 2. 检查显示设备是否变化该函数第二部分先调用processDisplayChangesLocked函数。 SF.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; //第一部分 ...... //第二部分 //如果需要，执行显示自己的事务 //遍历并检查所有的显示设备，检查显示设备是否发生了增加或者减少.并做相应的处理 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; processDisplayChangesLocked(); processDisplayHotplugEventsLocked(); &#125; if (transactionFlags &amp; (eDisplayLayerStackChanged|eDisplayTransactionNeeded)) &#123; ...&#125; ......&#125;void SurfaceFlinger::processDisplayChangesLocked() &#123; //定义两个列表保存上次合成时显示设备的信息和当前显示设备的信息 //当前显示设备的信息 const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); //上次合成时的显示设备的信息（上次合成的mDrawingState信息，本地还未开始正式合成操作） const KeyedVector&lt;wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); //判断当前和上次的设备信息是否发生变化 if (!curr.isIdenticalTo(draw)) &#123; mVisibleRegionsDirty = true; const size_t cc = curr.size(); size_t dc = draw.size(); //找到被删除的显示设备(在draw状态而不是current状态的列表中，说明有设备删除) //处理发生变化的设备（两个列表都存在该设备） for (size_t i = 0; i &lt; dc;) &#123; const ssize_t j = curr.indexOfKey(draw.keyAt(i)); if (j &lt; 0) &#123; // 1. 删除显示设备：in drawing state but not in current state if (const auto display = getDisplayDeviceLocked(draw.keyAt(i))) &#123; // 断开前保存设备ID（Save display ID before disconnecting.） const auto displayId = display-&gt;getId(); display-&gt;disconnect(); if (!display-&gt;isVirtual()) &#123; LOG_ALWAYS_FATAL_IF(!displayId); dispatchDisplayHotplugEvent(displayId-&gt;value, false); &#125; &#125; mDisplays.erase(draw.keyAt(i)); &#125; else &#123; //设备在两个列表都存在，但是有信息发生变化 const DisplayDeviceState&amp; state(curr[j]); const wp&lt;IBinder&gt;&amp; displayToken = curr.keyAt(j); const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface); const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface); if (state_binder != draw_binder) &#123; // changing the surface is like destroying and // recreating the DisplayDevice, so we just remove it // from the drawing state, so that it get re-added // below. if (const auto display = getDisplayDeviceLocked(displayToken)) &#123; display-&gt;disconnect(); &#125; mDisplays.erase(displayToken); mDrawingState.displays.removeItemsAt(i); dc--; // at this point we must loop to the next item continue; &#125; //更新显示设备信息 if (const auto display = getDisplayDeviceLocked(displayToken)) &#123; if (state.layerStack != draw[i].layerStack) &#123; //Layer栈 display-&gt;setLayerStack(state.layerStack); &#125; if ((state.orientation != draw[i].orientation) || (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123; //旋转状态、viewport、frame帧 display-&gt;setProjection(state.orientation, state.viewport, state.frame); &#125; if (state.width != draw[i].width || state.height != draw[i].height) &#123; //宽高 display-&gt;setDisplaySize(state.width, state.height); &#125; &#125; &#125; ++i; &#125; //找到新添加的Display设备（在current状态列表，而不再draw列表中） //即创建主屏对应的DisplayDevice for (size_t i = 0; i &lt; cc; i++) &#123; if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123; const DisplayDeviceState&amp; state(curr[i]); sp&lt;compositionengine::DisplaySurface&gt; dispSurface; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferProducer&gt; bqProducer; sp&lt;IGraphicBufferConsumer&gt; bqConsumer; getFactory().createBufferQueue(&amp;bqProducer, &amp;bqConsumer, false); //创建BufferQueue std::optional&lt;DisplayId&gt; displayId; //虚拟显示设备 if (state.isVirtual()) &#123; ...... &#125; else &#123; ALOGE_IF(state.surface != nullptr, \"adding a supported display, but rendering \" \"surface is provided (%p), ignoring it\", state.surface.get()); //给新的显示设备添加Display id，并且创建framebufferSurface消费者 displayId = state.displayId; LOG_ALWAYS_FATAL_IF(!displayId); dispSurface = new FramebufferSurface(getHwComposer(), *displayId, bqConsumer); producer = bqProducer; &#125; const wp&lt;IBinder&gt;&amp; displayToken = curr.keyAt(i); if (dispSurface != nullptr) &#123; mDisplays.emplace(displayToken, setupNewDisplayDeviceInternal(displayToken, displayId, state, dispSurface, producer)); if (!state.isVirtual()) &#123; LOG_ALWAYS_FATAL_IF(!displayId); dispatchDisplayHotplugEvent(displayId-&gt;value, true); &#125; &#125; &#125; &#125; &#125; mDrawingState.displays = mCurrentState.displays;&#125; 3. 更新mCurrentState中Layer的transform hint信息第三部分：继续执行handleTransactionLocked函数，更新transform hint相关信息 4. 更新Layer信息第四部分：更新Layer信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; ...... //第三部分 //当显示设备发生变化或者Layer发生变化，需要修改layer的transform hint，使得Layer视图的矩阵变化 if (transactionFlags &amp; (eDisplayLayerStackChanged|eDisplayTransactionNeeded)) &#123; ...... //遍历mCurrentState所有layer mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123; ... if (!hintDisplay) &#123; //如果显示在过个显示设备上，则使用默认显示设备 hintDisplay = getDefaultDisplayDeviceLocked(); &#125; if (hintDisplay) &#123; //更新layer的transform hint layer-&gt;updateTransformHint(hintDisplay); &#125; first = false; &#125;); &#125; if (mLayersAdded) &#123; mLayersAdded = false; // Layers have been added. mVisibleRegionsDirty = true; &#125; //============================= //第四部分：更新Layer信息 //如果有Layer移除， 该Layer原先的显示区域就是需要更新显示区域 if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; if (mLayersPendingRemoval.indexOf(layer) &gt;= 0) &#123; // this layer is not visible anymore Region visibleReg; visibleReg.set(layer-&gt;getScreenBounds()); invalidateLayerStack(layer, visibleReg); &#125; &#125;); &#125; commitInputWindowCommands(); //所有变化的信息更新完成后，mCurrentState提交到mDrawingState中 commitTransaction(); &#125; &#125; 5. 信息更新完成，mCurrentState提交到mDrawingState执行到commitTransaction函数就代表所有Layer信息更新完成，下一步开始合成显示这些变化后的内容（mDrawingState） 三、handleMessageInvalidateSF.cpp1234567891011121314151617181920212223242526bool SurfaceFlinger::handleMessageInvalidate() &#123; ATRACE_CALL(); //调用handlePageFlip，见下一小节的流程，该函数会从BufferQueue中获取Buffer bool refreshNeeded = handlePageFlip(); ...... for (auto&amp; layer : mLayersPendingRefresh) &#123; Region visibleReg; visibleReg.set(layer-&gt;getScreenBounds()); //见下 invalidateLayerStack(layer, visibleReg); &#125; mLayersPendingRefresh.clear(); return refreshNeeded;&#125;//Android支持多个屏幕，layer可以定制化的只显示到某个显示屏幕上。其中就是靠layerStack(Layer栈)来实现的//Layer的stack值如果和DisplayDevice的stack值一样，说明这个layer是属于这个显示屏幕的void SurfaceFlinger::invalidateLayerStack(const sp&lt;const Layer&gt;&amp; layer, const Region&amp; dirty) &#123; for (const auto&amp; [token, displayDevice] : mDisplays) &#123; auto display = displayDevice-&gt;getCompositionDisplay(); if (display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123; display-&gt;editState().dirtyRegion.orSelf(dirty); &#125; &#125;&#125; handlePageFlipmLayersWithQueuedFrames用于标记有Frame的Layer，详细处理查看上面对BufferQueueLayer::onFrameAvailable函数的注解。 SF.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566bool SurfaceFlinger::handlePageFlip()&#123; ATRACE_CALL(); ALOGV(\"handlePageFlip\"); nsecs_t latchTime = systemTime(); bool visibleRegions = false; bool frameQueued = false; bool newDataLatched = false; //遍历mDrawingState的Layer，将需要合成的layer添加到mLayersWithQueuedFrames列表中 mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123; if (layer-&gt;hasReadyFrame()) &#123; frameQueued = true; nsecs_t expectedPresentTime; expectedPresentTime = mScheduler-&gt;expectedPresentTime(); //frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp:BufferQueueLayer::shouldPresentNow() //此处shouldPresentNow的判断逻辑： //1. 计算期望显示的时间，然后看Buffer的时间戳和期望显示的时间。 //如果Buffer的时间还没到，且和期望显示的时间差不到1秒，则该shouldPresentNow逻辑成立 //否则使用空的DamageRegion if (layer-&gt;shouldPresentNow(expectedPresentTime)) &#123; // mLayersWithQueuedFrames.push_back(layer); &#125; else &#123; ATRACE_NAME(\"!layer-&gt;shouldPresentNow()\"); layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125;); if (!mLayersWithQueuedFrames.empty()) &#123; Mutex::Autolock lock(mStateLock); //遍历mLayersWithQueuedFrames中的Layer for (auto&amp; layer : mLayersWithQueuedFrames) &#123; //latchBuffer是从BufferQueue中获取Buffer，并将其绑定到Layer对应的纹理中 if (layer-&gt;latchBuffer(visibleRegions, latchTime)) &#123; //添加到mLayersPendingRefresh列表中 mLayersPendingRefresh.push_back(layer); &#125; //更新Surface的Damage layer-&gt;useSurfaceDamage(); if (layer-&gt;isBufferLatched()) &#123; newDataLatched = true; &#125; &#125; &#125; mVisibleRegionsDirty |= visibleRegions; //有BufferQueue过来，但是还没有到显示时间（mLayersWithQueuedFrames为空），或者没有获取到Buffer，则重新触发一次更新 if (frameQueued &amp;&amp; (mLayersWithQueuedFrames.empty() || !newDataLatched)) &#123; signalLayerUpdate(); &#125; // enter boot animation on first buffer latch if (CC_UNLIKELY(mBootStage == BootStage::BOOTLOADER &amp;&amp; newDataLatched)) &#123; ALOGI(\"Enter boot animation\"); mBootStage = BootStage::BOOTANIMATION; &#125; return !mLayersWithQueuedFrames.empty() &amp;&amp; newDataLatched;&#125; Note:注意，所有的mLayersWithQueuedFrames都会走上面和下面的流程，每个Layer有自己的BufferLayerConsumer和BufferQueue。 latchBuffer-&gt;updateTexImage-&gt;acquireBuffer 详细流程可参考：Android 图形显示框架之BufferQueue-acquire&amp;release 该函数中调用updateTexImage，而这个关键函数回去获取Buffer。 拿到Buffer后，将Buffer保存在mSlots[slot].mGraphicBuffer中。同时更新mFrameNumber和mFence。 该函数updateTexImage有几种返回处理结果： frameworks/native/services/surfaceflinger/BufferQueueLayer.cpp1234567891011121314151617181920212223status_t BufferQueueLayer::updateTexImage(bool&amp; recomputeVisibleRegions, nsecs_t latchTime) &#123; ... status_t updateResult = mConsumer-&gt;updateTexImage(&amp;r, expectedPresentTime, &amp;mAutoRefresh, &amp;queuedBuffer, maxFrameNumberToAcquire); //PRESENT_LATER：稍后显示，暂时不显示，并且触发SurfaceFlinger刷新（更新Layer数据） if (updateResult == BufferQueue::PRESENT_LATER) &#123; mFlinger-&gt;signalLayerUpdate(); return BAD_VALUE; //BUFFER_REJECTED：Buffer被Reject掉，这一帧数据不再显示，从mQueueItems中删除这一帧，同时mQueuedFrames减一 &#125; else if (updateResult == BufferLayerConsumer::BUFFER_REJECTED) &#123; if (queuedBuffer) &#123; Mutex::Autolock lock(mQueueItemLock); mFlinger-&gt;mTimeStats-&gt;removeTimeRecord(layerID, mQueueItems[0].mFrameNumber); mQueueItems.removeAt(0); mQueuedFrames--; &#125; return BAD_VALUE; //更新失败或出错 &#125; else if (updateResult != NO_ERROR || mUpdateTexImageFailed) &#123; ... &#125;&#125; 调用BufferLayerConsumer的updateTexImage，在acquireBufferLocked请求Buffer后，释放上一个Buffer，更新Buffer frameworks/native/services/surfaceflinger/BufferLayerConsumer.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051status_t BufferLayerConsumer::updateTexImage(BufferRejecter* rejecter, nsecs_t expectedPresentTime, bool* autoRefresh, bool* queuedBuffer, uint64_t maxFrameNumber) &#123; status_t err = acquireBufferLocked(&amp;item, expectedPresentTime, maxFrameNumber); ...... //释放上一个Buffer， 更新Buffer err = updateAndReleaseLocked(item, &amp;mPendingRelease); ... &#125;status_t BufferLayerConsumer::updateAndReleaseLocked(const BufferItem&amp; item, PendingRelease* pendingRelease) &#123; int slot = item.mSlot; ...... //释放旧的Buffer - release old buffer if (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) &#123; if (pendingRelease == nullptr) &#123; status_t status = releaseBufferLocked(mCurrentTexture, mCurrentTextureBuffer-&gt;graphicBuffer()); if (status &lt; NO_ERROR) &#123; BLC_LOGE(\"updateAndRelease: failed to release buffer: %s (%d)\", strerror(-status), status); err = status; // keep going, with error raised [?] &#125; &#125; else &#123; pendingRelease-&gt;currentTexture = mCurrentTexture; pendingRelease-&gt;graphicBuffer = mCurrentTextureBuffer-&gt;graphicBuffer(); pendingRelease-&gt;isPending = true; &#125; &#125; //更新Buffer - Update the BufferLayerConsumer state. mCurrentTexture = slot; mCurrentTextureBuffer = nextTextureBuffer; mCurrentCrop = item.mCrop; mCurrentTransform = item.mTransform; mCurrentScalingMode = item.mScalingMode; mCurrentTimestamp = item.mTimestamp; mCurrentDataSpace = static_cast&lt;ui::Dataspace&gt;(item.mDataSpace); mCurrentHdrMetadata = item.mHdrMetadata; mCurrentFence = item.mFence; mCurrentFenceTime = item.mFenceTime; mCurrentFrameNumber = item.mFrameNumber; mCurrentTransformToDisplayInverse = item.mTransformToDisplayInverse; mCurrentSurfaceDamage = item.mSurfaceDamage; mCurrentApi = item.mApi; computeCurrentTransformMatrixLocked(); return err; 然后将通过消费者acquireBufferLocked函数请求Buffer。 frameworks/native/libs/gui/ConsumerBase.cpp1234567891011status_t ConsumerBase::acquireBufferLocked(BufferItem *item, nsecs_t presentWhen, uint64_t maxFrameNumber) &#123; if (mAbandoned) &#123; CB_LOGE(\"acquireBufferLocked: ConsumerBase is abandoned!\"); return NO_INIT; &#125; status_t err = mConsumer-&gt;acquireBuffer(item, presentWhen, maxFrameNumber); ... return OK;&#125; 四、Invalidate流程小结（正式合成刷新前的准备工作）SF.cpp1234567891011121314151617181920212223242526272829void SurfaceFlinger::onMessageReceived(int32_t what) NO_THREAD_SAFETY_ANALYSIS &#123; //systrace抓取 ATRACE_CALL(); switch (what) &#123; case MessageQueue::INVALIDATE: &#123; ...... //处理Transition，在合成前更新Layer的信息 bool refreshNeeded = handleMessageTransaction(); // refreshNeeded |= handleMessageInvalidate(); updateCursorAsync(); updateInputFlinger(); refreshNeeded |= mRepaintEverything; if (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123; //如果Transaction事务修改了窗口状态，则发出刷新信号 //一个新的buffer将被请求 signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125; &#125;&#125; 上面的分析就是INVALIDATE的基本流程，该过程主要处理SurfaceFlinger距上次合成后的一些变化信息： handleMessageTransaction处理Layer属性变化、显示设备变化、更新显示设备的transform hint信息、处理Layer移除和增加等相关的信息等情况，将变化信息mCurrentState提交到mDrawingState，等待合成处理 handleMessageInvalidate更新了Layer的Buffer内容（通过LatchBuffer函数从BufferQueue中获取）到Layer的纹理 mRepaintEverything表示HWC硬件要求强制刷新 参考文章 SurfaceFlinger合成流程(一) SurfaceFlinger合成流程(二) Android Handler消息循环处理机制 Android 图形显示框架 Android BitTube Android之BitTube 基于Android Q分析SurfaceFlinger启动过程 Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState SurfaceFlinger图像合成[1]","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android protobuf(.proto文件)","slug":"2020/200815_android_protobuf","date":"2020-08-15T13:42:00.000Z","updated":"2020-08-16T11:49:53.973Z","comments":true,"path":"2020/08/15/2020/200815_android_protobuf/","link":"","permalink":"https://alonealive.github.io/Blog/2020/08/15/2020/200815_android_protobuf/","excerpt":"最近碰到一个关于frameworks/base/core/proto/android/providers/settings/secure.proto文件中修改某个属性的问题，所以针对protobuf(.proto文件)进行一个学习了解。Google Protocol Buffers，（简称Protobuf，协议缓冲区），类似json或XML，Google开源的支持多语言、跨平台的结构化数据序列化项目，但是比它们更小、更快、更简单。Protobuf通过编写proto文件来定义消息格式或RPC服务定义。","text":"最近碰到一个关于frameworks/base/core/proto/android/providers/settings/secure.proto文件中修改某个属性的问题，所以针对protobuf(.proto文件)进行一个学习了解。Google Protocol Buffers，（简称Protobuf，协议缓冲区），类似json或XML，Google开源的支持多语言、跨平台的结构化数据序列化项目，但是比它们更小、更快、更简单。Protobuf通过编写proto文件来定义消息格式或RPC服务定义。 proto模块介绍在Framework模块中有个单独的模块：frameworks/base/core/proto/ 查看该模块下的README.md和OWNDER文件有简单介绍。OWNER劝告开发人员需要熟悉该功能，谨慎修改。 README.md文件内容 Android其他版本中，使用四个空格缩进，而非两个 基于Java文件的protos文件，使用该Java文件相同名称的包。例如com.android.server.thing代替com.android.server.thing.proto 如果proto描述了dumpsys的顶级输出，他就应该包含dump。这样更容易理解他是作为某个服务的dump输出，而不是该服务的数据结构。例如WindowManagerServiceDumpProto和WindowManagerServiceProto 含有poroto后缀的message名称，他的内嵌的message的名称不需要有proto后缀，例如：12345678910111213message FooProto &#123; message Bar &#123; ... &#125;&#125;&amp;&amp;message FooProto &#123; message BarProto &#123; //没必要有proto后缀 ... &#125;&#125; 如果proto代表一个对象的结构，后缀应该要有proto。并且还请包含该原是对象的完整包路径，来作为对这个proto message的注释。 在字段中包含单位名字，例如：screen_time_ms VS screen_time, or file_size_bytes or file_size_mebibytes VS file_size 保留字段号50000-100000，供原始设备制造商使用。 编写proto文件范例helloworld.proto 代码在https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto helloworld.proto1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F;版本号，默认版本是2syntax &#x3D; &quot;proto3&quot;; option java_multiple_files &#x3D; true;option java_package &#x3D; &quot;io.grpc.examples.helloworld&quot;;option java_outer_classname &#x3D; &quot;HelloWorldProto&quot;;option objc_class_prefix &#x3D; &quot;HLW&quot;; package helloworld; &#x2F;&#x2F; The greeting service definition.service Greeter &#123; &#x2F;&#x2F; Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;&#125; &#x2F;&#x2F; The request message containing the user&#39;s name.&#x2F;&#x2F; 一个message类型看上去像是Java class，由多个字段组成&#x2F;&#x2F;每一个字段都由类型、名称组成，位于等号右边的值不是字段默认值，而是字段编号，可以理解为字段身份的标识符，类似于数据库中的主键，不可重复&#x2F;&#x2F;标识符用于在编译后的二进制消息格式中对字段进行识别，一旦投入使用，字段的标识就不应该再改变。&#x2F;&#x2F;数字标签的范围是[1, 536870911]，其中19000～19999是保留数字。message HelloRequest &#123; string name &#x3D; 1;&#125;&#x2F;&#x2F; The response message containing the greetingsmessage HelloReply &#123; string message &#x3D; 1;&#125;message SearchRequest &#123; required string query &#x3D; 1; required int32 page_number &#x3D; 2; optional int32 result_per_page &#x3D; 3;&#125; protobuf和其他编程语言的类型比较 字段编号字段编号是Protobuf的重要组成部分。它们用于标识二进制编码数据中的字段，这意味着它们不能从版本更改为服务版本。优点在于可以实现向后兼容性和向前兼容性。只要处理丢失值的可能性，客户端和服务就会忽略他们不知道的字段编号。 在二进制格式中，字段号与类型标识符组合在一起。1到15之间的字段编号可以使用其类型编码为单字节。从16到2047的数字需要2个字节。如果出于任何原因需要将超过2047个字段，则可以更高。字段号1到15的单字节标识符提供更好的性能，因此，你应将其用于最基本的常用字段。 限定符说明 限定符 说明 required 必须字段，必须设置该字段的值 optional 可选字段，有选择性的设置或者不设置该字段的值 repeated 表示该字段可以被重复任意多次包含 包package可以用指定package以避免类型命名冲突： 12package foo.bar;message Open &#123; ... &#125; 也可以用类型的全限定名来引用它： 12345message Foo &#123; ... foo.bar.Open open &#x3D; 1; ...&#125; Note:指定包名后，会对生成的代码产生影响，以Java为例，生成的类会以你指定的package作为包名。 修改规则如果修改正在使用的proto文件，比如为类型增加一个字段，protobuf支持这种修改而不影响已有的服务，不过需要遵循一定的规则： 不改变已有字段的字段编号 当增加一个新的字段的时候，老系统序列化后的数据依然可以被新的格式所解析，只不过需要处理新加字段的缺省值。 字段也可以被移除，但是建议Reserved这个字段，避免将来会使用这个字段 int32, uint32, int64, uint64 和 bool类型都是兼容的 sint32 和 sint64兼容，但是不和其它整数类型兼容 string 和 bytes兼容，如果 bytes 是合法的UTF-8 bytes的话 嵌入类型和bytes兼容，如果bytes包含一个消息的编码版本的话 fixed32和sfixed32, fixed64和sfixed64 enum和int32, uint32, int64, uint64格式兼容 嵌套类型通过协议缓冲区（Protobuf）可以在其他消息中嵌套消息定义。 下面的示例演示如何创建嵌套消息类型： 123456message Outer &#123; message Inner &#123; string text &#x3D; 1; &#125; Inner inner &#x3D; 1;&#125; repeated修饰符如果一个字段被repeated修饰，则表示它是一个列表类型的字段，如下所示： 123message SearchRequest &#123; repeated string args &#x3D; 1 &#x2F;&#x2F; 等价于java中的List&lt;string&gt; args&#125; 如果希望可以预留一些数字标签或者字段可以使用reserved修饰符： 12345message Foo &#123; reserved 2, 15, 9 to 11; reserved &quot;foo&quot;, &quot;bar&quot;; &#x2F;&#x2F; string foo &#x3D; 3 &#x2F;&#x2F;编译报错，因为‘foo’已经被标为保留字段&#125; 保留字段reservedProtobuf中的向后兼容性保证依赖于始终表示相同数据项的字段编号。如果从服务新版本中的消息中删除了字段，则不应重复使用该字段编号。 可以使用reserved关键字强制执行此情况。 如果定义Stock的消息中删除某字段，则应保留其字段编号，如以下示例所示。 123456789syntax &quot;proto3&quot;;message Stock &#123; reserved 3, 4; int32 id &#x3D; 1; string symbol &#x3D; 2;&#125; 还可以将reserved关键字用作将来可能添加的字段的占位符。 您可以使用to关键字将连续字段数表示为范围。 1234567syntax &quot;proto3&quot;;message Info &#123; reserved 2, 9 to 11, 15; &#x2F;&#x2F; ...&#125; Any和OneOf字段Protobuf提供了两个用于处理可能属于多个类型的值的更简单选项。 Any类型可以表示任何已知的Protobuf消息类型。 使用oneof关键字来指定在任何消息中只能设置一个字段范围中的一个字段。 Any是Protobuf的”已知类型”：一系列有用的可重复使用的消息类型，具有所有支持语言的实现。若要使用Any类型，必须导入google/protobuf/any.proto定义 12345678910111213141516syntax &quot;proto3&quot;import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;message Stock &#123; &#x2F;&#x2F; Stock-specific data&#125;message Currency &#123; &#x2F;&#x2F; Currency-specific data&#125;message ChangeNotification &#123; int32 id &#x3D; 1; google.protobuf.Any instrument &#x3D; 2;&#125; Oneof是一项语言功能：编译器在生成message类时处理oneof关键字。使用oneof指定ChangeNotification消息可能如下所示： 在整个消息声明中，oneof集内的字段必须具有唯一的字段编号。 123456789101112131415message Stock &#123; &#x2F;&#x2F; Stock-specific data&#125;message Currency &#123; &#x2F;&#x2F; Currency-specific data&#125;message ChangeNotification &#123; int32 id &#x3D; 1; oneof instrument &#123; Stock stock &#x3D; 2; Currency currency &#x3D; 3; &#125;&#125; Note: 设置属于oneof集一部分的任何字段都将自动清除该集中的任何其他字段。不能将repeated与oneof一起使用。相反，可以创建包含重复字段或oneof集的嵌套消息，以解决此限制。 oneof块中的字段不支持repeated。 枚举上面使用枚举来确定Oneof字段的类型。可以定义自己的枚举类型，Protobuf将它们编译为C#（或者其他语言）枚举类型。 由于Protobuf可以用于各种语言，因此枚举的命名约定与C#约定不同。 但是，代码生成器将名称转换为传统的C#大小写。如果字段名称的Pascal大小写以枚举名称开头，则将其删除。 例如，在下面的Protobuf枚举中，字段用预缀为ACCOUNT_STATUS。 第一个枚举值的数值必须是0且至少有一个枚举值，否则编译报错。编译后编译器会为你生成对应语言的枚举类。 1234567enum AccountStatus &#123; ACCOUNT_STATUS_UNKNOWN &#x3D; 0; ACCOUNT_STATUS_PENDING &#x3D; 1; ACCOUNT_STATUS_ACTIVE &#x3D; 2; ACCOUNT_STATUS_SUSPENDED &#x3D; 3; ACCOUNT_STATUS_CLOSED &#x3D; 4;&#125; 由于编码原因，出于效率考虑，官方不推荐使用负数作为枚举值的数值。 类型默认值 string类型的默认值是空字符串 bytes类型的默认值是空字节 bool类型的默认值是false 数字类型的默认值是0 enum类型的默认值是第一个定义的枚举值 message类型的默认值与语言相关 repeated修饰的字段默认值是空列表 import public的传递引用功能12345678910111213&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 文件：new.proto&#x2F;&#x2F; 原来在old.proto文件中的定义移到这里&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 文件：old.protoimport public &quot;new.proto&quot;; &#x2F;&#x2F; 把引用传递给上层使用方import &quot;other.proto&quot;; &#x2F;&#x2F; 引用old.proto本身使用的定义&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F; 文件：client.protoimport &quot;old.proto&quot;;&#x2F;&#x2F; 此处可以引用old.proto和new.proto中的定义，但不能使用other.proto中的定义 从这个例子中可以看到import关键字导入的定义仅在当前文件有效，不能被上层使用方引用（client.proto无法使用other.proto中的定义） 而import public关键字导入的定义可以被上层使用方引用（client.proto可以使用new.proto中的定义），import public的功能可以看作是import的超集，在import的功能上还具有传递引用的作用。 option选项选项不对message的定义产生任何的效果，只会在一些特定的场景中起到作用： option java_package = &quot;com.example.foo&quot;; 编译器为以此作为生成的Java类的包名，如果没有该选项，则会以pb的package作为包名。 option java_multiple_files = true; 该选项为true时，生成的Java类将是包级别的，否则会在一个包装类中。 option optimize_for = CODE_SIZE; 该选项会对生成的类产生影响，作用是根据指定的选项对代码进行不同方面的优化。 int32 old_field = 6 [deprecated=true]; 把字段标为过时的。 protoBuf缺点Protbuf相比XML来说，主要优点是性能高。也有不足之处，功能简单，无法用来表示复杂的概念。 由于文本并不适合用来描述数据结构，所以Protobuf也不适合用来对基于文本的标记文档（如HTML建模。另外，由于XML具有某种程度上的自解释性，它可以被人直接读取编辑，在这一点上Protobuf以二进制的方式存储，除非有.proto定义，否则无法直接读出Protobuf的任何内容。 参考文献 Google官方文档 Protobuf Github项目文档地址 Protobuf 保留字段 在Golang中安装使用Protobuf Protobuf3学习笔记","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android ANR基本Log分析","slug":"2020/200806_android_ANR_BaseLog","date":"2020-08-06T13:52:00.000Z","updated":"2020-08-07T13:40:32.855Z","comments":true,"path":"2020/08/06/2020/200806_android_ANR_BaseLog/","link":"","permalink":"https://alonealive.github.io/Blog/2020/08/06/2020/200806_android_ANR_BaseLog/","excerpt":"ANR（Application Not Responding），字面意思是应用无响应，即用户的一些操作无法从应用中获取反馈。关于发生ANR的trace.txt文件的请参考Android ANR traces.txt文件分析","text":"ANR（Application Not Responding），字面意思是应用无响应，即用户的一些操作无法从应用中获取反馈。关于发生ANR的trace.txt文件的请参考Android ANR traces.txt文件分析 触发原因Android系统中的应用被Activity Manager及Window Manager两个系统服务监控着，Android系统会在如下情况触发ANR： Input事件超过5s没有被处理完，即5秒内无法对输入事件（按键及触摸）做出响应 Service处理超时，前台20s，后台200s BroadcastReceiver（广播接收器）处理超时，前台10S，后台60s ContentProvider执行超时，比较少见 出现ANR之后一个直观现象就是系统会展示出一个ANR弹框。 从发生的原因分： 主线程有耗时操作，如有复杂的layout布局，IO操作等。 被Binder对端block 被子线程同步锁block Binder被占满导致主线程无法和SystemServer通信 得不到系统资源（CPU/RAM/IO） 从进程的角度分： 问题出在当前进程: 主线程本身耗时, 或则主线程的消息队列存在耗时操作; 主线程被本进程的其他子线程所blocked; 问题出在远端进程(一般是binder call或socket等通信方式) 基本log解读1234567891011121314151617181920212223242526272829303132333435&#x2F;&#x2F;进程是30970&#x2F;&#x2F;特殊情况下，如果PID是0，说明发生ANR之前，这个进程被LowMemoryKiller杀死了或者出现了Crash。这种情况下，是无法接收到系统的广播或者按键消息的，故而出现ANR&#x2F;&#x2F;ANR具体发生的包名08-01 19:17:05.155 1000 1304 1328 I am_anr : [0,30970,com.android.systemui,551042573,Input dispatching timed out (StatusBar, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago. Wait queue length: 54. Wait queue head age: 9044.8ms.)]&#x2F;&#x2F;ANR具体发生的包名08-01 19:17:28.258 1000 1304 1328 E ActivityManager: ANR in com.android.systemui&#x2F;&#x2F;ANR发生的原因是Input dispatching timed out08-01 19:17:28.258 1000 1304 1328 E ActivityManager: PID: 3097008-01 19:17:28.258 1000 1304 1328 E ActivityManager: Reason: Input dispatching timed out (StatusBar, Waiting to send non-key event because the touched window has not finished processing certain input events that were delivered to it over 500.0ms ago. Wait queue length: 54. Wait queue head age: 9044.8ms.)&#x2F;&#x2F;三个数字分别是1分钟、5分钟、15分钟内系统的平均负荷&#x2F;&#x2F;当CPU完全空闲的时候，平均负荷为0；当CPU工作量饱和的时候，平均负荷为1，通过Load可以判断系统负荷是否过重&#x2F;&#x2F;大致可以这样区分：&#x2F;&#x2F;当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。&#x2F;&#x2F;当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。&#x2F;&#x2F;当系统负荷达到5.0，就表明你的系统有很严重的问题08-01 19:17:28.258 1000 1304 1328 E ActivityManager: Load: 46.53 &#x2F; 37.82 &#x2F; 34.77&#x2F;&#x2F;ANR发生的时候，Top进程的Cpu占用情况，user代表是用户空间，kernel是内核空间&#x2F;&#x2F;查看每个CPU的使用频度：adb shell cat &#x2F;sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu1&#x2F;cpufreq&#x2F;stats&#x2F;time_in_state&#x2F;&#x2F;一般如下规律：&#x2F;&#x2F;1. kswapd0 cpu占用率偏高，系统整体运行会缓慢，从而引起各种ANR。把问题转给&quot;内存优化&quot;，请他们进行优化&#x2F;&#x2F;2. logd CPU占用率偏高，也会引起系统卡顿和ANR，因为各个进程输出LOG的操作被阻塞从而执行的极为缓慢&#x2F;&#x2F;3. Vold占用CPU过高，会引起系统卡顿和ANR，请负责存储的同学先调查&#x2F;&#x2F;4. qcom.sensor CPU占用率过高，会引起卡顿，请系统同学调查&#x2F;&#x2F;5. 应用自身CPU占用率较高，高概率应用自身问题&#x2F;&#x2F;6. 应用处于D状态，发生ANR，如果最后的操作是refriger，那么是应用被冻结了，正常情况下是功耗优化引起的。08-01 19:17:28.258 1000 1304 1328 E ActivityManager: CPU usage from 0ms to 23321ms later (2020-08-01 19:17:04.850 to 2020-08-01 19:17:28.171) with 99% awake:08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 36% 30970&#x2F;com.android.systemui: 25% user + 10% kernel &#x2F; faults: 11945 minor 24 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 35% 20903&#x2F;com.tencent.mobileqq:video: 28% user + 6.4% kernel &#x2F; faults: 6413 minor 23 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 28% 555&#x2F;surfaceflinger: 16% user + 12% kernel &#x2F; faults: 1846 minor 2 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 26% 498&#x2F;android.hardware.audio@5.0-service-***: 21% user + 4.9% kernel &#x2F; faults: 13 minor08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 18% 1304&#x2F;system_server: 9.5% user + 8.7% kernel &#x2F; faults: 9666 minor 329 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 17% 3919&#x2F;com.***.service: 10% user + 6.7% kernel &#x2F; faults: 8604 minor 30 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 16% 28827&#x2F;com.tencent.qqmusic: 9.2% user + 7.3% kernel &#x2F; faults: 9299 minor 18 major08-01 19:17:28.258 1000 1304 1328 E ActivityManager: 16% 142&#x2F;kswapd0: 0% user + 16% kernel... 系统耗时分析方案系统做一些耗时分析的操作会有一些Log标志： binder_sample： 功能说明: 监控每个进程的主线程的binder transaction的耗时情况, 当超过阈值时,则输出相应的目标调用信息，默认1000ms打开。 log格式: 52004 binder_sample (descriptor|3),(method_num|1|5),(time|1|3),(blocking_package|3),(sample_percent|1|6) log实例: 2754 2754 I binder_sample: [android.app.IActivityManager,35,2900,android.process.media,5] 从上面的log中可以得出: 主线程2754; 执行android.app.IActivityManager接口 所对应方法code =35(即STOP_SERVICE_TRANSACTION), 所花费时间为2900ms 该block所在package为 android.process.media，最后一个参数是sample比例(没有太大价值) dvm_lock_sample 功能说明: 当某个线程等待lock的时间blocked超过阈值,则输出当前的持锁状态 ; log格式: 20003 dvm_lock_sample (process|3),(main|1|5),(thread|3),(time|1|3),(file|3),(line|1|5),(ownerfile|3),(ownerline|1|5),(sample_percent|1|6) 进程名，主线程？线程名，锁等待时间，下个持有者文件名，行号，上个持有者文件名（如果和下个相同，则是-），行号，等待百分比 log实例: dvm_lock_sample: [system_server,1,Binder_9,1500,ActivityManagerService.java,6403,-,1448,0] 意思是system_server: Binder_9,执行到ActivityManagerService.java的6403行代码,一直在等待AMS锁, 而该锁所同一文件的1448行代码所持有, 从而导致Binder_9线程被阻塞1500ms. binder starved 功能说明:当system_server等进程的线程池使用完, 无空闲线程时, 则binder通信都处于饥饿状态, 则饥饿状态超过一定阈值则输出信息; 云控参数: persist.sys.binder.starvation (默认值16ms) log实例: 1232 1232 &quot;binder thread pool (16 threads) starved for 100 ms&quot; 解析: system_server进程的 线程池已满的持续长达100ms kswapd0 CPU占用率很高如果出现kswapd0 cpu 占用率很高，可以先查看内存使用情况。 /proc/meminfo内存使用信息例如以下，可用内存只有62MB。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859------ MEMORY INFO (&#x2F;proc&#x2F;meminfo) ------&#x2F;&#x2F;所有可用RAM大小 （即物理内存减去一些预留位和内核的二进制代码大小）&#x2F;&#x2F;可以认为是系统可供分配的内存总大小, 通常大小会比实际物理内存小MemTotal: 3844700 kB&#x2F;&#x2F;LowFree与HighFree的总和&#x2F;&#x2F;当前系统空闲的内存大小，对应所有处于NR_FREE_PAGES状态的页框MemFree: 62100 kB&#x2F;&#x2F;MemFree + Active(file) + Inactive(file) + SReclaimable 此外还考虑了内存压力水位(watermark)的情况，计算比较复杂，详细见 si_mem_available(). 这只是理论上系统可用的内存，即理论上可回收的内存，但是实际上能用的达不到这么多MemAvailable: 396584 kB&#x2F;&#x2F;用来给块设备做的缓冲大小（只记录文件系统的metadata以及 tracking in-flight pages，就是说 buffers是用来存储，目录里面有什么内容，权限等等。）Buffers: 10160 kB&#x2F;&#x2F;用来给文件做缓冲大小（直接用来记忆我们打开的文件）. 它不包括SwapCachedCached: 554704 kB&#x2F;&#x2F;已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I&#x2F;O端口SwapCached: 25312 kB&#x2F;&#x2F;最近经常被使用的内存，除非非常必要否则不会被移作他用Active: 1317228 kB&#x2F;&#x2F;最近不经常被使用的内存，非常用可能被用于其他途径Inactive: 659868 kBActive(anon): 1179772 kBInactive(anon): 403532 kBActive(file): 137456 kBInactive(file): 256336 kBUnevictable: 162512 kBMlocked: 162512 kB&#x2F;&#x2F;交换空间的总和SwapTotal: 2113488 kB&#x2F;&#x2F;从RAM中被替换出暂时存在磁盘上的空间大小SwapFree: 405628 kB&#x2F;&#x2F;等待被写回到磁盘的内存大小Dirty: 1652 kB&#x2F;&#x2F;正在被写回到磁盘的内存大小Writeback: 20 kBAnonPages: 1571688 kB&#x2F;&#x2F;影射文件的大小Mapped: 340044 kBShmem: 9360 kB&#x2F;&#x2F;内核数据结构缓存Slab: 233948 kBSReclaimable: 66952 kBSUnreclaim: 166996 kBKernelStack: 72480 kBPageTables: 109660 kBNFS_Unstable: 0 kBBounce: 0 kBWritebackTmp: 0 kBCommitLimit: 4035836 kBCommitted_AS: 125397000 kB&#x2F;&#x2F;vmalloc内存大小VmallocTotal: 263061440 kB&#x2F;&#x2F;已经被使用的虚拟内存大小VmallocUsed: 0 kBVmallocChunk: 0 kBCmaTotal: 344064 kBCmaFree: 2736 kB... dumpsys meminfo直接dumpsys meminfo，是查看整体的内存占用情况，具体的还是需要加上process name。 1234567891011121314151617181920&#x2F;&#x2F;对应上面MemTotalTotal RAM: 3,844,700K (status normal)&#x2F;&#x2F;cached pss对应变量cachedPss的值。这部分进程占用的内存并没有被释放，而由于他们都已切换到后台，且adj较低，系统认为可以释放掉这部分内存。所以对于这部分进程，系统最好有机制能及时清理掉从而释放内存。&#x2F;&#x2F;cached kernel对应&quot;Buffers+Cached+SReclaimable-Mapped&quot;这部分的内存由于理论上是可以被Kernel回收的，所以这里也计算在free中，但是这是一个理论上的值，实际上很难做到全部回收。&#x2F;&#x2F;free对应MemFree Free RAM: 1,003,024K ( 400,796K cached pss + 509,892K cached kernel + 1,136K cached ion + 91,200K free)&#x2F;&#x2F;kernel对应&quot;Shmem+SUnreclaim+VmallocUsed+PageTables+KernelStack&quot;,其中VmallocUsed是统计&#x2F;proc&#x2F;vmallocinfo中除ioremap,map_lowmem,vm_map_ram之外的和&#x2F;&#x2F;详细见&quot;Debug.get_allocated_vmalloc_memory()&quot;这部分即是对kernel的内存占用的一个统计，如果要统计kernel的内存占用，这个稍微准确一些 Used RAM: 4,340,042K (3,862,614K used pss + 477,428K kernel)&#x2F;&#x2F;对应MemTotal - (totalPss - totalSwapPss) - MemFree - (cached kernel) - (kernel) - zramtotal Lost RAM: 135,889K&#x2F;&#x2F;第一个数 用变量zramtotal来代替，表示zram实际占用的物理内存，是从&#x2F;sys&#x2F;block&#x2F;zram0&#x2F;mm_stat中统计而来&#x2F;&#x2F;第二个数 对应 SwapTotal - SwapFree , 是已经在swap区的内存大小&#x2F;&#x2F;第三个数 对应 SwapTotal， 是整个swap区的大小 ZRAM: 528,592K physical used for 1,757,284K in swap (2,113,488K total swap) Tuning: 384 (large 512), oom 645,120K, restore limit 107,520K (high-end-gfx) 参考 应用与系统稳定性第一篇—ANR问题分析的一般套路 Android应用ANR分析 android 查看内存使用情况 Android内存占用分析","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android 图形显示框架","slug":"2020/200730_android_GraphicsFramework","date":"2020-07-30T13:52:00.000Z","updated":"2020-07-30T09:15:39.000Z","comments":true,"path":"2020/07/30/2020/200730_android_GraphicsFramework/","link":"","permalink":"https://alonealive.github.io/Blog/2020/07/30/2020/200730_android_GraphicsFramework/","excerpt":"本篇对Android图形显示框架做一个概述，内容主要包含：SurfaceSession创建和销毁（添加/删除窗口），Surface创建和销毁，BufferQueue创建，以及BufferQueue的dequeueBuffer和queueBuffer、acquire和release大致流程梳理。","text":"本篇对Android图形显示框架做一个概述，内容主要包含：SurfaceSession创建和销毁（添加/删除窗口），Surface创建和销毁，BufferQueue创建，以及BufferQueue的dequeueBuffer和queueBuffer、acquire和release大致流程梳理。 显示框架概述Android与用户进行图形界面的交互，例如各个应用程序，他们的对话框、按钮、菜单等图形窗口。这些窗口的管理都是由WindowManager负责，窗口管理位于Java层，真正的实现者是运行在System_server进程空间中的WindowManagerService。 frameworks/base/services/java/com/android/server/SystemServer.java123456789101112131415161718/** * Starts a miscellaneous grab bag of stuff that has yet to be refactored and organized. */private void startOtherServices() &#123; ....... traceBeginAndSlog(\"StartWindowManagerService\"); // WMS needs sensor service ready ConcurrentUtils.waitForFutureNoInterrupt(mSensorServiceStart, START_SENSOR_SERVICE); mSensorServiceStart = null; wm = WindowManagerService.main(context, inputManager, !mFirstBoot, mOnlyCore, new PhoneWindowManager(), mActivityManagerService.mActivityTaskManager); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); traceEnd(); ......&#125; 应用程序负责修改绘制窗口中的内容，而WindowManager负责窗口的生命周期、几何属性、坐标变换信息、用户输入焦点、动画等功能。他还管理着窗口状态的变化，如窗口位置、大小、透明度以及Z-order（前后遮盖顺序）等一系列的逻辑判断。这些WindowManager功能由一系列接口或类构成，包括ViewManager、WindowManager、WindowManagerImpl、WindowManagerService等。 SurfaceFlinger负责分配应用程序所需的图形缓冲区，并对系统中的整个图形窗口进行composition（合成）。 最终，图形窗口会更新显示到Display显示器上。 显示过程的三个进程Android显示的整个过程由App进程、System_server进程、SurfaceFlinger进程一起配合完成。 App进程： App需要将自己的内容显示在屏幕上，所以需要负责发起Surface创建的请求。同时触发对控件的测量、布局、绘制以及输入事件的派发处理，这些主要在ViewRootImpl中触发； System_server进程： 主要是WindowManagerService，负责接收App请求，同时和SurfaceFlinger建立连接，向SurfaceFlinger发起具体请求创建Surface，并且创建Surace的辅助管理类SurfaceControl（和window一一对应）(AMS作用是统一调度所有App的Activity)； SurfaceFlinger： 为App创建具体的Surface，在SurfaceFLinger对应成Layer，然后负责管理、合成所有图层，最终显示。 Activity、Window、PhoneWindow、DecorView、View的对应关系 Window：每一个Activity都包含一个Window对象（抽象类，提供了绘制窗口的一组通用API），通常由PhoneWindow实现。 在Activity.java中定义：private Window mWindow; 一个Activity对应创建一个Surface PhoneWindow:继承于Window，是Window类的具体实现。该类内部包含了一个DecorView对象，该DecorView对象是所有应用窗口（Activity界面）的根View。 简而言之，PhoneWindow类是把一个FrameLayout类，即DecorView对象进行一定的包装，将他作为应用窗口的根View，并提供一组通用的窗口操作接口。 PhoneWindow是Android中最基本的窗口系统，每个Activity都会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。 在Activity.java的attach函数实例化：mWindow = new PhoneWindow(this, window, activityConfigCallback); DecorView：PhoneWindow构造函数中定义，继承FrameLayout类，是所有应用窗口的根View。 在PhoneWindow.java中定义，构造函数中初始化：private DecorView mDecor; 相关debug方法： adb shell dumpsys activity adb shell dumpsys window ![window包含关系]](phonewindow.png) Activity生命周期 Activity onResume添加窗口 onCreate方法中调用setContentView来设置布局，此时只是完成了View Tree的创建。此处参考HWUI绘制文章 真正通知WMS添加窗口，是在回调onResume完成的。 调用onResume的方法在ActivityThread.java中是handleResumeActivity。之后调用到WMS.java的addWindow。 App进程中完成添加窗口操作 当一个新窗口(Window)被创建的时候，在ActivityThread.java的handleResumeActivity中调用addView(),然后调用到WindowManagerImpl的addView()函数。 frameworks/base/core/java/android/view/WindowManagerImpl.java12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 这个函数将实际操作委托给mGlobal成员完成，这个成员随着WindowManagerImpl的创建而被初始化：private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); WindowManagerGlobal是一个单例模式，即一个进程中最多仅有一个WindowManagerGlobal实例。 调用mGlobal的addView函数后，将会创建一个ViewRootImpl对象，并且将窗口的控件、布局参数、ViewRootImpl对象入参到setView函数中，这个动作将导致ViewRootImpl向WMS添加新的窗口、申请Surface创建、绘制动作等。这才真正意义的完成了窗口的添加操作。 frameworks/base/core/java/android/view/WindowManagerGlobal.java1234567891011121314151617181920212223public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; 窗口移除序列图（Activity destroy）窗口被删除，Activity执行了handleDestroyActivity函数： Surface Destroy（Activity pause或者stop状态） 可以结合以下Surface创建部分一起梳理，针对的情况是Surface被destroy，从framework/base到SurfaceFlinger模块Layer析构的流程。但是就Activity而言，并没有被销毁，而是类似按了home键返回桌面，或者在后台运行的状态，具体可以通过日志观察。 SurfaceSession创建 此处是接着上面添加窗口的流程，分为以下两部分。 mGlobal.addView中创建ViewRootImpl对象 新建ViewRootImpl对象的时候，调用构造函数，会从WindowManagerGlobal中获取一个窗口session。 mWindowSession = WindowManagerGlobal.getWindowSession(); 在WindowManagerGlobal中会通过Binder IPC跨进程创建一个session。 Session主要用于进程间通信，其他应用程序想要和WMS通信就需要经过Session，每个应用程序进程都会对应一个Session，WMS保存这些Session用来记录所有向WMS提出窗口管理服务的客户端。 frameworks/base/core/java/android/view/WindowManagerGlobal.java1234567891011121314151617181920212223242526@UnsupportedAppUsage public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; // Emulate the legacy behavior. The global instance of InputMethodManager // was instantiated here. // TODO(b/116157766): Remove this hack after cleaning up @UnsupportedAppUsage InputMethodManager.ensureDefaultInstanceForDefaultDisplayIfNecessary(); //获取WMS对象 IWindowManager windowManager = getWindowManagerService(); //创建Session sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125; &#125; WMS继承IWindowManager.Stub，调用到openSessio函数，创建一个新的session对象, 返回值是IWindowSession类型。用于在APP进程和WMS之间建立联系。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java1234567final class H extends android.os.Handler &#123; @Override public IWindowSession openSession(IWindowSessionCallback callback) &#123; return new Session(this, callback); &#125;&#125; mGlobal.addView中调用ViewRootImpl.setView在前面mGlobal创建ViewRootImpl对象之后，会调用ViewRootImpl对象的setView，然后通知到WMS创建一个SurfaceSession，建立WindowManagerService和Surfacelinger的连接。 一个SurfaceSession代表着一个到SurfaceFlinger的连接会话，在这个连接会话里，可以创建一个或多个surface，最后这些surface被合成送到Display上显示。 大致过程：（查看下面的序列图） 在setView()中调用mWindowSession.addToDisplay, mWindowSession是IWindowSession接口类型，而Session.java实现了该接口； Session.java 中调用mService.addWindow(…), mService是WMS类型； WMS.java的addWindow()创建WindowState对象win，调用win.attach() frameworks/base/services/core/java/com/android/server/wm/WindowState.java 调用attach frameworks/base/services/core/java/com/android/server/wm/Session.java 调用windowAddedocked，创建SurfaceSession类型的mSurfaceSession frameworks/base/core/java/android/view/SurfaceSession.java 构造函数调用JNI，然后在android_view_SurfaceSession.cpp中的nativeCreate创建SurfaceComposerClient, 调用Refase的incStrong然后实现onFirstRef,通过调用CreateConnection()建立和SF的连接; SF.cpp 调用CreateConnection()返回SF的Client类的Binder代理BpSurfaceComposerClient; Surface创建App进程请求创建SurfaceSurface是Android图形系统的核心部分，图形界面上的一个窗口或对话框等都对应着一个Surface。 而这个Surface是一块绘制区域的抽象，它对应着Server服务端Surfacelinger中的一个图层Layer，这个图层的背后是一块图形缓冲区GraphicBuffer，Client客户端的应用程序的UI使用软件绘制、硬件绘制在Surface上各种渲染操作时，绘制操作的结果其实也就是在该图形缓冲区中。 这部分的内容是梳理Surface创建的过程。 在ViewRootImpl对象中，setView到requestLayout函数请求布局，到调用scheduleTraversals，该函数里面在Choreographer.java层层调用到Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); 此处的action即是新的线程启动。 启动ViewRootImp中单独的线程TraversalRunnable，然后调用到关键函数performTraversals()。 这个关键函数有两个主要的函数: relayoutWindow() -&gt;布局窗口 performDraw() -&gt;绘制渲染 请求创建Surface就从relayoutWindow函数开始。 在这个方法中调用IWindowSession的relayout，会调用到Session.java，然后调用到WMS的relayoutWindow从而达到跨进程：（流程图查看下面单独章节的序列图） frameworks/base/core/java/android/view/ViewRootImpl.java1234567891011121314151617private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ...... //此处relayout会调用到WMS的relayoutWindow int relayoutResult = mWindowSession.relayout(mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, frameNumber, mTmpFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingDisplayCutout, mPendingMergedConfiguration, mSurfaceControl, mTempInsets); if (mSurfaceControl.isValid()) &#123; mSurface.copyFrom(mSurfaceControl); &#125; else &#123; destroySurface(); &#125; &#125; System_server进程 —— WMS 跨进程到WMS后，从relayoutWindow函数调用到createSurfaceControl(outSurfaceControl)。 （1）然后先是在WindowStateAnimator创建一个WindowSurfaceController对象，作为调用到WindowStateAnimator.java的createSurfaceLocked函数的返回值。 在createSurfaceLocked函数中，会new一个WindowSurfaceController对象，从而调用他的构造函数。 在他的构造函数中会创建一个SurfaceControl内部类Builder对象，调用该对象的build函数； (2) WMS.java中调用WindowStateAnimator.java的createSurfaceLocked函数之后，会执行以下逻辑： a. 如果surfaceController不为空，调用WindowSurfaceController的getSurfaceControl； b. WindowSurfaceController.java调用getSurfaceControl, outSurfaceControl.copyFrom(mSurfaceControl);，而mSurfaceControl就是之前的构造函数创建的。此处的copyFrom会经过JNI调用到Native层, 然后读取SurfaeControl。 在Builder内部类的build函数中创建Java层的SurfaceControl对象，在SurfaceControl的构造函数中调用JNI层的nativeCreate函数； android_view_SurfaceControl.cpp的nativeCreate函数会调用SurfaceComposerClient.cpp的createSurfaceChecked函数，创建一个surface（实际上是SurfaceControl），然后将surface返回。 SurfaceFlinger进程SurfaceComposerClinet.cpp位于frameworks/native/libs/gui模块。而libgui库主要被JNI层中的代码调用，从而和Surfacelinger进程进行交互，可以看做是Java层的Bn端，是SurfaceFlinger的Bp端。 比如此处的SurfaceComposerClinet通过Binder IPC（ISurfaceComposerClinet.cpp），跨进程到SurfaceFlinger进程。 SurfaceComposerClinet作为Bp客户端调用： frameworks/native/libs/gui/SurfaceComposerClient.cpp1234567891011121314151617181920212223242526status_t SurfaceComposerClient::createSurfaceChecked(const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, sp&lt;SurfaceControl&gt;* outSurface, uint32_t flags, SurfaceControl* parent, LayerMetadata metadata) &#123; sp&lt;SurfaceControl&gt; sur; status_t err = mStatus; if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IBinder&gt; parentHandle; sp&lt;IGraphicBufferProducer&gt; gbp; if (parent != nullptr) &#123; parentHandle = parent-&gt;getHandle(); &#125; err = mClient-&gt;createSurface(name, w, h, format, flags, parentHandle, std::move(metadata), &amp;handle, &amp;gbp); ALOGE_IF(err, \"SurfaceComposerClient::createSurface error %s\", strerror(-err)); if (err == NO_ERROR) &#123; *outSurface = new SurfaceControl(this, handle, gbp, true /* owned */); &#125; &#125; return err;&#125; Bn服务端是surfaceflinger模块的Client.cpp，此时跨进程到SurfaceFlinger进程，调用createSurface，从而请求到SurfaceFlinger创建Surface： frameworks/native/services/surfaceflinger/Client.cpp12345678status_t Client::createSurface(const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, const sp&lt;IBinder&gt;&amp; parentHandle, LayerMetadata metadata, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; // We rely on createLayer to check permissions. return mFlinger-&gt;createLayer(name, this, w, h, format, flags, std::move(metadata), handle, gbp, parentHandle);&#125; 在SurfaceFlinger::createLayer中创建Layer（创建surface的请求到SurfaceFlinger进程中就是创建Layer），创建的Layer有四种： （1）createBufferQueueLayer（2）createBufferStateLayer（3）createColorLayer（4）createContainerLayer 通常情况下创建的是第一种Layer——BufferQueueLayer（在P中是BufferLayer），会创建一个&lt;sp&gt;BufferQueueLayer强指针对象。 SF.cpp123456789101112131415161718status_t SurfaceFlinger::createBufferQueueLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, LayerMetadata metadata, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer) &#123;..... sp&lt;BufferQueueLayer&gt; layer = getFactory().createBufferQueueLayer( LayerCreationArgs(this, client, name, w, h, flags, std::move(metadata))); status_t err = layer-&gt;setDefaultBufferProperties(w, h, format); if (err == NO_ERROR) &#123; *handle = layer-&gt;getHandle(); *gbp = layer-&gt;getProducer(); *outLayer = layer; &#125; ALOGE_IF(err, \"createBufferQueueLayer() failed (%s)\", strerror(-err)); &#125; 序列图 该序列图包含上面部分的流程，包含APP进程和WMS进程之间的Session创建、SurfaceSession创建、Surface创建。 BufferQueue 关于BufferQueue只大致梳理他的创建流程，以及在渲染过程中的dequeuebuffer和queuebuffer流程、在合成过程中的acquire和release流程。关于和GraphicsBuffer和再底层的逻辑，暂时不梳理。 BufferQueue概述创建BuffeQueueLayer对象的onFirstRef中会创建一个BufferQueue。BufferQueue是buffer流转的中转站。具体分成四个步骤： 生产者dequeue一块buffer，buffer状态-&gt;DEQUEUED，持有者-&gt;Producer，之后生产者可以填充数据（渲染绘制）。在dequeueBuffer之前，buffer状态是free，持有者是BufferQueue； 生产者填充完数据后，进行queue操作，buffer-&gt;QUEUED，持有者-&gt;BufferQueue。操作后producer会回调BufferQueue的onFrameAvailable函数，通知消费者有可用的buffer; 消费者进行acquire取出Buffer，buffer-&gt;ACQUIRED，持有者-&gt;Consumer; 消费者消费完这块buffer（已经合成），进行release操作释放，归还给BufferQueue BufferQueue状态 DEQUEUED 状态： Producer dequeue一个Buffer后，这个Buffer就变为DEQUEUED状态，release Fence发信号后，Producer就可以修改Buffer的内容，我们称为release Fence。此时Buffer被Producer占用。 DEQUEUED状态的Buffer可以迁移到 QUEUED 状态，通过queueBuffer或attachBuffer流程。也可以迁移到FREE装，通过cancelBuffer或detachBuffer流程。 QUEUED 状态： Buffer绘制完后，queue到BufferQueue中，给Consumer进行消费。此时Buffer可能还没有真正绘制完成，必现要等对应的Fence发信号出来后，才真正完成。此时Buffer是BufferQueue持有，可以迁移到ACQUIRED状态，通过acquireBuffer流程。而且可以迁移到FREE状态，如果另外一个Buffer被异步的queue进来。 ACQUIRED 状态： Buffer已经被Consumer获取，但是也必须要等对应的Fence发信号才能被Consumer读写，找个Fence是从Producer那边，queueBuffer的时候传过来的。我们将其称为acquire fence。此时，Buffer被Consumer持有。状态可以迁移到FREE状态，通过releaseBuffer或detachBuffer流程。除了从acquireBuffer流程可以迁移到ACQUIRED状态，attachBuffer流程也可以迁移到ACQUIRED状态。 FREE 状态： FREE状态，说明Buffer被BufferQueue持有，可以被Producer dequeue，它将迁移到DEQUEUED状态，通过dequeueBuffer流程。 SHARED状态： SHARED状态是一个特殊的状态，SHARED的Buffer并不参与前面所说的状态迁移。它说明Buffer被用与共享Buffer模式。除了FREE状态，它可以是其他的任何状态。它可以被多次dequeued, queued, 或者 acquired。这中共享Buffer的模式，主要用于VR等低延迟要求的场合。 BufferQueue创建以及创建一个监听在BufferQueueLayer::onFirstRef调用BufferQueue::createBufferQueue()创建了bufferQueue、生产者、消费者，在创建生产者和消费者的过程中，将他们绑定到同一个BufferQueue上。 之后会创建一个BufferLayerConsumer对象mConsumer，这个对象继承了ConsumerBase类，所以会回调基类的构造函数，注册一个监听对象到BufferQueue（空对象）。 真正的监听是在mConsumer-&gt;setContentsChangedListener(this)基类构造函数中还会调用consumerConnect将消费者关联到BufferQueue中。此时监听对象就赋给了BufferQueue的mConsumerListener成员（调用BufferQueueConsumer的connect函数）。 这个监听对象会在queueBuffer是触发，由生产者回调注册到BufferQueue的帧可用通知。 DequeuBufferBufferQueue创建后，首先由生产者执行dequeueBuffer请求一块Buffer。 Dequeue和Queue的操作都是在硬件渲染(软件绘制暂不考虑)的过程中，在ThreadedRenderer::draw函数中，updateRootDisplayList创建好一个RootDisplayList后，开始渲染一帧，在这时调用父类的syncAndDrawFrame函数，这个函数层层调到CanvasContext::draw函数，然后依次调用三个函数： mRenderPipeline-&gt;getFrame 执行dequeueBuffer请求一块buffer draw 填充buffer mRenderPipeline-&gt;swapBuffers 执行queueBuffer送到BufferQueue 在此处dequeuBuffer和queueBuffer两个操作调到gui/Surface.cpp的两个对应函数，这个流程基本一样。 大致都从SkiaOpenPipeline.cpp -&gt; EglManager.cpp -&gt; eglApi.cpp -&gt; ANativeWindow.cpp，之后到Bp客户端libgui库的Surface.cpp，执行具体操作。 Surface::dequeueBuffer中调用IGraphicBufferProducer::dequeueBuffer。然后remote()-&gt;transact(DEQUEUE_BUFFER,data,&amp;reply)调用到Bn端BufferQueueProducer::dequeueBuffer函数。 首先查找mSlots[found]的序列号found，mSlots是存放Buffer的地方，他的数量是64。即至多存放64个buffer。 found是从waitForFreeSlotThenRelock中获取： 从非Free的buffer中统计dequeue和acquire的数量； 判断dequeueBufferCount数量不能大于最大允许dequeueBuffer的数量； slot的获取主要来自两个集合，mFreeSlots和mFreeBuffers；两者包含的所有状态都是free，区别在于前者没有attached，后者以及attached；如果调用来自dequeueBuffer优先选择前者，如果调用来自attachBuffer，优先选择后者； 如果没找到符合要求的buffer或者queue的buffer还有太多没有完成，就要等待这个buffer被acquired或者released，或者修改最大的buffer数量。 找到可用的slot，还要判断是否重新分配空间：如果Buffer（本质上是GraphicBuffer）是空，并且需要重新分配空间，则对这个mSlots[found]初始化； new GraphicBuffer为mSlots分配一个GraphicBuffer，赋值给BufferQueueCore中的变量mSlots[]的mGraphicBuffer； mSlots[*outSlot].mGraphicBuffer = graphicBuffer; Surface::dequeueBuffer从服务端申请到Buffer后，通过requestBuffer将客户端的buffer和服务端的buffer指向同一块物理内存。 具体是IGraphicBufferPruducer代理中通过REQUEST_BUFFER状态，在onTransact中将申请的GraphicBuffer，即mSlots[slot].mGraphicBuffer。将其写入reply，等待客户端读取。 QueueBufferqueueBuffer是在渲染一帧后通过mRenderPipeline-&gt;swapBuffers调用到Surface::queueBuffer。将填充完数据的buffer放入BufferQueue，并且通过监听者通知消费者对象开始消费。 在Bn端BufferQueueProducer::queueBuffer L977中调用：frameAvailableListener-&gt;onFrameAvailable(item); 通知消费者，在BufferQueueLayer::onFrameAvailable中调用：mFlinger-&gt;signalLayerUpdate(); 触发SurfaceFlinger的消息循环机制，开始处理SurfaceFlinger合成事件。 序列图 acquire &amp; release消费者SurfaceFlinger通过acquire从BufferQueue取出一块buffer消费。消费（合成）之后释放。 序列图","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"},{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android NE分析（二）","slug":"2020/200727_android_NE_Two","date":"2020-07-27T13:52:00.000Z","updated":"2021-05-31T12:52:03.454Z","comments":true,"path":"2020/07/27/2020/200727_android_NE_Two/","link":"","permalink":"https://alonealive.github.io/Blog/2020/07/27/2020/200727_android_NE_Two/","excerpt":"了解gcc将*.c/cpp编译成*.o，再将其链接为可执行程序或/lib库的过程，有助于我们将native从编译/加载/执行到崩溃一条路贯通起来。Android的Makefile只需要将source file填入LOCAL_SRC_FILES，然后include $(BUILD_SHARED_LIBRARY)或$(BUILD_EXECUTABLE)就可以将*.c/cpp/s编译为动态库或可执行程序。","text":"了解gcc将*.c/cpp编译成*.o，再将其链接为可执行程序或/lib库的过程，有助于我们将native从编译/加载/执行到崩溃一条路贯通起来。Android的Makefile只需要将source file填入LOCAL_SRC_FILES，然后include $(BUILD_SHARED_LIBRARY)或$(BUILD_EXECUTABLE)就可以将*.c/cpp/s编译为动态库或可执行程序。 native编译编译为obj 在build/core/definitions.mk有定义transform-c-or-s-to-o-no-deps和transform-cpp-to-o，分别将每个.c/s和.cpp编译成*.o，里面传了很多参数给gcc -fpic -fPIE PIC是Position-Independent Code的缩写，经常被用在共享库中，这样就能将相同的库代码为每个程序映射到一个位置，不用担心覆盖掉其他程序或共享库。 PIE是Position-Independent-Executable的缩写，只能应用在可执行程序中。PIE和PIC很像，但做了一些调整（不用PLT，使用PC相关的重定位）。-fPIE给编译用，-pie给链接(ld)用。 例如，一个程序没有使用PIC被链接到0地址，那么系统将其加载到0地址。 -fstack-protector 顾名思义就是保护堆栈，每一个函数在运行时都有自己的栈帧，如果代码没有写好，很可能将自己甚至是其他的栈帧踩坏，那如何防护呢？简单的方法就是在栈帧头部也就是在局部变量开始之前多存储一个stack_chk_guard值，用于在函数返回前取出来和_stack_chk_guard做对比，失败则调用stack_chk_fail函数，这个就是该参数完成的行为。 静态链接build/core/combo/TARGET_linux-arm.mk里有定义transform-o-to-static-executable-inner，将*.o链接成静态可执行程序，静态可执行程序是一个完整的程序，不需要额外的共享库即可执行，比如/init,/sbin/adbd等。 链接器用的是arm-linux-androideabi-g++ 动态链接build/core/combo/TARGET_linux-arm.mk里有定义transform-o-to-executable-inner和transform-o-to-shared-lib-inner，分别将*.o链接为动态可执行程序和共享库。动态可执行程序需要linker才能进一步运行的。 链接器也是用arm-linux-androideabi-g++ tombstone定位错误方法signum一般debuggerd关注的是SIGILL，SIGBUS，SIGABRT，SIGFPE，SIGSEGV，SIGPIPE等。而这里，估计九成都是SIGSEGV (即signal 11)，段错误，和非法内存访问等。 *sigcode SEGV_MAPERR：访问一个没有映射到任何内容的地址，这种情况通常就是野指针，或者越界访问，访问空指针也是属于这类 SEGV_ACCERR：试图访问您无权访问的地址。说明访问出错地址，被map到地址空间来了，但是没访问权限。基本上是指针越界或野指针，比如写只读map的内存地址 例如： 12345678910signal 11 (SIGSEGV), code 2 (SEGV_ACCERR), fault addr 0x7ecbf6a000 &#x2F;&#x2F;SEGV_ACCERR表示试图访问您无权访问的地址 x0 0000007e44001c30 x1 0000000000000000 x2 0000000000000000 x3 0000007e44001c30 x4 0000007ecbf6a008 x5 0000007e44001c98 x6 0000000000000000 x7 0000000000000000 x8 0000000000000000 x9 0000000000000000 x10 0000000000000000 x11 0000000000000000 x12 0000000000000000 x13 0000000000000000 x14 0000000000000001 x15 0000007ecbe3f540 x16 0000007eca917290 x17 0000007ec94ea480 x18 0000007e42e9c000 x19 0000007ecbdf5400 x20 0000000000000001 x21 0000007e44001c30 x22 0000000000000001 x23 0000007e44002020 x24 0000007ecb6bf045 x25 0000007ecb6bf260 x26 0000007ecb6bf278 x27 0000007ecb6bf041 x28 0000007ecb6bf044 x29 0000007e44001bf0 sp 0000007e44001bd0 lr 0000007eca910618 pc 0000007ec94ea460 tombstone日志当中也提供了出错时寄存器地址里面的临近内存信息，信息量同样很丰富。查看0000007e44001c30附近的内存情况。 1234567891011121314151617memory near x0: 0000007e44001c10 0000000000030d40 00000000ffffffff @............... 0000007e44001c20 0000007e44001cf0 0000007ecb6b83f0 ...D~.....k.~... 0000007e44001c30 0000000000000000 0000000000000000 ................ 0000007e44001c40 0000000000000000 0000000000000000 ................ 0000007e44001c50 0000000000000000 0000000000000000 ................ 0000007e44001c60 0000000000000000 0000000000000000 ................ 0000007e44001c70 0000000000000000 0000000000000000 ................ 0000007e44001c80 0000000000000000 0000000000000000 ................ 0000007e44001c90 0000000000000000 1c86a694ed72c72c ........,.r..... 0000007e44001ca0 0000000000000001 00000000000fd000 ................ 0000007e44001cb0 0000007ecb6b8170 0000007e44001d50 p.k.~...P..D~... 0000007e44001cc0 0000007e44001d50 0000007e44001dd8 P..D~......D~... 0000007e44001cd0 00000207000005ea 0000007e44001d50 ........P..D~... 0000007e44001ce0 0000007ec954e5f0 0000007e44001d50 ..T.~...P..D~... 0000007e44001cf0 0000007e44001d10 0000007ec954e618 ...D~.....T.~... 0000007e44001d00 0000007e44001d50 0000000000000000 P..D~........... 参考 Android Native/Tombstone Crash Log 详细分析：https://blog.csdn.net/u011006622/article/details/51496693 Android Native程序crash的一些定位方法简介：https://msd.misuland.com/pd/300217191876268032 ARM64-memcpy.S 汇编源码分析：https://blog.csdn.net/ffmxnjm/article/details/68065090 android bionic memcpy 汇编源码解析：https://blog.csdn.net/qq_28637193/article/details/103681746 PIC和PIE：https://www.cnblogs.com/sword03/p/9385660.html","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android debug","slug":"android-debug","permalink":"https://alonealive.github.io/Blog/tags/android-debug/"},{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android NE分析（一）","slug":"2020/200724_android_NE","date":"2020-07-24T12:52:00.000Z","updated":"2021-04-14T12:58:53.928Z","comments":true,"path":"2020/07/24/2020/200724_android_NE/","link":"","permalink":"https://alonealive.github.io/Blog/2020/07/24/2020/200724_android_NE/","excerpt":"任何软件都可能存在BUG，调试和修复BUG伴随着整个开发流程，因此异常分析非常重要。如果是native层发生异常，我们一般称之为叫NE（native exception）","text":"任何软件都可能存在BUG，调试和修复BUG伴随着整个开发流程，因此异常分析非常重要。如果是native层发生异常，我们一般称之为叫NE（native exception） 异常可能发生任何一层，如果是： kernel层发生异常，叫KE（kernel exception） native层发生异常，叫NE（native exception） java成异常，叫JE（java exception） NE简介 Native层是由各种lib/binary组成，这一层发生异常，我们称之为NE（native exception）一般我们用offline调试，通过coredump借助gdb或trace32来调试。首先要先熟悉下linux信号和ptrace机制，coredump是通过信号触发生成的。coredump是进程空间保存到文件系统的镜像，因此能看到异常时刻的所有变量值，就可以知道问题出在哪里。Android是基于linux的，发生异常时，Android扩展了调试机制，这个机制是debuggerd机制。在没有coredump下，debuggerd以log或者tombstone的方式输出异常信息。 本地应用程序是指可以直接运行在操作系统上，并且处理器直接执行机器码的程序。 在Android上，OS是linux，因此各种bin程序就是所谓的natvie application，比如/system/bin目录下的所有文件。 这些应用程序都是由GCC(c/c++)编译生成。 在Android软件架构里，这些应用程序组成了native layer: native layer里的应用程序崩溃统称为Native Exception，即NE，比如空指针，非法指针，程序跑飞，内存踩坏等。 发生NE流程原始的linux，对于用户进程崩溃之后，处理方式有2种： 直接终止进程； 输出coredump再终止进程 而在Android，为了方便调试，在收到崩溃信号后，会先输出tombstone，然后在根据设置是否抓取coredump，最后再终止进程。 如果发生NE，内核会抛出信号，可以通过kernel log搜索sig 11/7等几个可以导致进程崩溃的关键字判断。 此处的信号注册是发生在动态链接程序加载的时候，链接器（linker）负责将应用程序所需的库加载到进程空间内，然后跑应用程序大妈。linker在执行期间会注册信号。 流程：__linker_init() -&gt; __linker_init_post_relocation() -&gt; debuggerd_init() 信号处理目前会产生native exception（NE）的几个信号需要特别掌握产生的原因，这样才能进一步分析问题所在。 内核发送信号过来后会执行debuggerd_init()里注册的函数debugger_signal_handler()，该函数会打印基本信息到main log： logSignalSummary()函数会输出基本异常信息，类似libc: Fatal signal 11(SIGSEGV) at 0x000 ...日志打印。 然后连接debuggerd的socket，将pid等信息发送给debuggerd，请它帮忙后续的处理。之后将对应的信号恢复为默认，等待debuggerd处理完后抓取coredump。 debuggerd服务关于上面的debuggerd服务，是由init.rc启动起来，具体代码在system/core/debuggerd/。 debuggerd起来后会创建1个socket，然后监听，等待别人通过socket请求服务，服务可以是生成tombstone或调用栈。 使用debuggerd命令查看指定tid的调用栈和tombstone adb shell debuggerd -b $tid：抓取指定tid的调用栈 adb shell debuggerd $tid：抓取指定tid的tombstone ptrace attach/detach通过socket拿到tid等资料后，使用ptrace attach上目标tid，之后就可以通过ptrace访问目标进程空间，然后打印一些NE相关的寄存器/调用栈等信息。 ptrace attach：ptrace attach会发送sig 19给对应的进程。在这里，我们将进程内所有线程都attach上，防止有线程提前退出。 ptrace cont：attach之后还不能直接访问目标进程，因为目标进程还处于信号处理函数里面，我们需要让它恢复到异常现场，因此需要用ptrace cont让其继续执行。 waitpid：程序接着往下跑必然会再次发生异常（如果是SIGABRT,SIGFPE,SIGPIPE,SIGSTKFLT，则会在信号处理函数重发一次信号），kernel会再次发出信号，只不过由于进程被ptrace了，信号会送给debuggerd。到这里，目标进程已经收到2次同样的信号了 tombstone:debuggerd收到信号后，就可以生成tombstone了 ptrace detach: 完成工作后，需要detach ptrace，然后发送sig 18让其继续奔跑。如果是访问空指针等错误，程序会再次发生异常，由于在信号处理函数里已经将对应信号恢复默认，因此可能会产生coredump。 产生db文件 debuggerd完成之后会通知aee，aee就开始了打包db的工作，具体生成在/data/aee_exp目录 1个完整的NE的db，里面除了coredump还有其他文件，包含log文件(main/event/radio)，详细的NE信息文件(_exp_main/_exp_detail)等，这些文件绝大部分是通过aee_dumpstate保存起来的。 PROCESS_MAPS文件描述进程空间db中有些文件对分析NE是至关重要的，比如PROCESS_MAPS，这文件就是/proc/$pid/maps，里面是对进程空间的描述。 例如以下部分截取的内容： 123456&#x2F;&#x2F;1-进程里地址范围 2-虚拟内存的权限（r&#x3D;读&#x2F;w&#x3D;写&#x2F;x&#x3D;可执行&#x2F;s&#x3D;共享&#x2F;p&#x3D;私有）&#x2F;&#x2F;3-空间所映射的文件的偏移量 4-空间所映射的文件的主次设备号&#x2F;&#x2F;5-空间所映射的文件的节点号（0表示没有节点映射到内存） 6-空间所映射的文件的路径7ec808a000-7ec808b000 --xp 00001000 fd:01 3989 &#x2F;system&#x2F;lib64&#x2F;libhardware.so7ec808b000-7ec808c000 rw-p 00002000 fd:01 3989 &#x2F;system&#x2F;lib64&#x2F;libhardware.so7ec808c000-7ec808d000 r--p 00003000 fd:01 3989 &#x2F;system&#x2F;lib64&#x2F;libhardware.so Tombstone Android Native程序本质上就是一个Linux程序，因此当它在执行时发生严重错误，也会导致程序crash，然后产生一个记录crash的现场信息的文件，而这个文件在Android系统中就是tombstone文件。 从上面的分析看，发生NE的时候会创建tombstone文件，最多存在10个，如果已存在10个，会覆盖最旧的文件。 组成部分： 版本信息：主要是fingerprint，可以看出异常版本是eng还是user 寄存器信息：主要查看是哪个进程崩溃，信号是什么。寄存器信息需要配合下面的调用栈信息及数据信息结合GNU的工具（objdump -S反汇编）分析。 调用栈信息：是最直接可以看出异常的信息（可以使用addr2line定位地址的代码函数对应位置） 其他线程信息：如果异常线程和其他线程有逻辑关系的话，可以查看对应线程的信息 main log信息：全面的log建议还是查看main log 调用栈最直接查看栈的位置就是log和Tombstone文件中。 C/C++语言的过程调用都需要栈，正在执行的函数有属于自己的栈帧，函数内部的局部变量就放在栈帧里，当然还会存放函数的返回地址，这样函数执行结束之后才知道返回到哪里。 不同的栈帧关联在一起就会形成一个调用链，最顶端表示当前正在执行的函数，第2行表示调用它的函数，以此类推（先进后出）。 例如以下栈： 库里的偏移：库默认都加载在0地址的，由OS随机加载在mmap区域，因此实际上库函数的地址都是基址+偏移量，其中的基址就是库加载的地址，这个地址可以从/proc/$pid/maps看到每个库的基址。 123456backtrace: #00 pc 00000000000e2f88 &#x2F;apex&#x2F;com.android.runtime&#x2F;lib64&#x2F;bionic&#x2F;libc.so (pthread_mutex_lock) (BuildId: ceedf0f98da575de138b0c631aceca44) &#x2F;&#x2F;栈帧 + 地址 + 函数 + 该函数的偏移量（+32） #01 pc 00000000000c39a0 &#x2F;system&#x2F;lib64&#x2F;libgui.so (android::SurfaceControl::getHandle() const+32) (BuildId: d26a01ac90bf9cf5c7585e3fbbdbb327) #02 pc 0000000000120a28 &#x2F;system&#x2F;lib64&#x2F;libandroid_runtime.so (android::nativeGetHandle(_JNIEnv*, _jclass*, long)+40) (BuildId: 5bd8af36fc54644383069436f63eec83)... addr2line命令针对发生Native Crash的堆栈，将地址转换为地址所在的文件及行数(显示所在函数) 该命令可以用来解析so动态链接库（Symbol目录），分析单个pc地址对应的函数，然后参照代码寻找问题发生处。 含有调试信息的库或程序必须和手机里的库或程序是同一次编译生成的，否则得到的PC值和库里的调试信息不匹配。 如何确定库或程序含有调试信息呢？或者说如何确定库能不能用来调试呢？是不是symbol目录下的库呢？ 用file命令即可查看：file xxx 如果没有含debug信息的话，会显示：xxx: ELF 32-bit LSB shared object, ARM, version 1 (SYSV), dynamically linked, stripped 含有调试信息的话，则显示：xxx: ELF 32-bit LSB shared object, ARM, version 1 (SYSV), dynamically linked, not stripped 例如：（需要在Symbol目录下） addr2line -Cfe .so address 12&#x2F;out&#x2F;target&#x2F;product&#x2F;product&#x2F;symbols&#x2F;system&#x2F;lib64$ addr2line -f -e libgui.so 00000000000c39a0_ZNK7android12SortedVectorINS_12DisplayStateEE16do_move_backwardEPvPKvm 解释：-e 后加上.so的文件名；-f 可同时输出函数名称 -e --exe=&lt;executable&gt;: 设置要查询地址的文件(默认: a.out)一般是.so/.a和可执行程序。此文件必须带有debug信息，在android codebase里是放在out/target/product/$project/symbols目录下 -f –functions: 显示地址所在的函数名 -C --demangle[=style]: 反重整函数名为可读方式 objdumpobjdump –S **.so &gt; **.asm 该命令是用来把相应的so变成汇编语言的asm文件，然后根据地址信息就可以找到更加详细的相关函数信息。 即查看对象文件(.so/.a或应用程序)的内容信息 或者 symbols/out/target/product/project/symbols$ objdump -tT system/lib64/libgui.so 后缀 含义 -S 或 –source 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数 -t 或 –syms 显示文件的符号表入口。类似于nm -s提供的信息 -T 或 –dynamic-syms 显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于`nm -D nm命令作用是：列出该文件的符号(函数，变量，文件等)，包含名字、地址、大小 ndk-stack 用来把log信息全部翻译成更加详细的带源码行数信息的log，相当于是在整个crash堆栈信息都执行addr2line命令。 ndk-stack -sym […/obj/local/{ABI类型}/] -dump crash.log readelf查看elf文件(.so/.a或应用程序)的内容信息，可以使用readelf -a [.so/.bin]解析库地址。 c++filt反重整C++符号为可读方式。 根据解析结果查询函数，C++在linux系统编译后会变成类似_ZNK...的修饰名。使用c++filt获取函数的原始名称。 c++filt [_ZNK...函数修饰名] 参考 关于不同版本aee db文件的抓取：https://blog.csdn.net/topsecrethhh/article/details/81453414 coredump配置、产生、分析以及分析示例：https://www.cnblogs.com/arnoldlu/p/11160510.html Android Debuggerd 简要介绍和源码分析：https://www.cnblogs.com/lance-ehf/p/4249605.html","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android debug","slug":"android-debug","permalink":"https://alonealive.github.io/Blog/tags/android-debug/"},{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"C++ 对象和类（案例代码）","slug":"2020/200715_cpp_ObjAndClass","date":"2020-07-15T15:52:00.000Z","updated":"2020-07-20T14:00:11.522Z","comments":true,"path":"2020/07/15/2020/200715_cpp_ObjAndClass/","link":"","permalink":"https://alonealive.github.io/Blog/2020/07/15/2020/200715_cpp_ObjAndClass/","excerpt":"C++类的声明、实现和使用，以及构造函数和析构函数。包含案例代码，可编译运行。","text":"C++类的声明、实现和使用，以及构造函数和析构函数。包含案例代码，可编译运行。 类的声明、实现、使用类的成员访问控制：公有/私有无论类成员是数据成员还是成员函数，都可以在类的公有部分或私有部分中声明他。 而隐藏数据是OOP（面向对象）主要的目标之一，因此数据项通常放在私有部分，组成类接口的成员函数放在公有部分（否则就无法从程序中调用这些函数） 也可以把成员函数放在私有部分中，不能直接从程序中调用这种函数，但是公有方法却可以使用他们。通常，程序员使用私有成员函数处理不属于公有接口的实现细节。 类声明中的关键字private是类对象的默认访问控制，可以不用写出来。 1234567class A &#123; float mass; //private by default ...public: void call(void); ...&#125; Note：结构的默认访问类型是public，而类为private，可以不用再写出来。 类成员函数实现类声明后，需要具体实现原型表示的成员函数。成员函数有函数头和函数体，也可以有返回类型和参数，而其和常规函数的不同之处： 定义成员函数时，使用作用域解析运算符::来标识函数所属的类。例如void A::update(double price)...，这意味着update()函数是A类的成员。同时意味着可以将另一个类的成员函数也命名成update()，例如void B::update()...。因此作用域解析运算符确定了方法定义对应的类。 类方法可以访问类的private私有成员，即定义的私有变量这些。 案例 头文件： stock00.h123456789101112131415161718192021222324252627//stock00.h -- Stock class interfate#ifndef STOCK00_H_#define STOCK00_H_#include &lt;string&gt;class Stock &#123;private: //can remove std::string company; long shares; double share_val; double total_val; //定义于类声明中的函数将自动成为内联函数 //等价于在头文件的类外面使用inline void Stock::set_tot() &#123;...&#125; void set_tot() &#123; total_val = shares * share_val; &#125;public: //对某公司股票的首次购买 void acquire(const std::string &amp; co, long n, double pr); //管理增加/减少持有的股票，确保买入或者卖出的股票不为负数 void buy(long num, double price); void sell(long num, double price); void update(double price); void show();&#125;;#endif 函数实现文件： stock00.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//stock00.cpp -- implementing the Stokc class#include &lt;iostream&gt;#include \"stock00.h\"void Stock::acquire(const std::string &amp; co, long n, double pr) &#123; company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; \"Number of shares can't be negative, \" &lt;&lt; company &lt;&lt; \" shares set to 0.\\n\"; shares = 0; &#125; else shares = n; share_val = pr; set_tot();&#125;void Stock::buy(long num, double price) &#123; if (num &lt; 0) &#123; std::cout &lt;&lt; \"Number of shares purchased can't be negative, \" &lt;&lt; \"Transaction is aborted.\\n\"; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price) &#123; using std::cout; if (num &lt; 0) &#123; std::cout &lt;&lt; \"Number of shares purchased can't be negative, \" &lt;&lt; \"Transaction is aborted.\\n\"; &#125; else if (num &gt; shares) &#123; std::cout &lt;&lt; \"You can't sell more than you have, \" &lt;&lt; \"Transaction is aborted.\\n\"; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price) &#123; share_val = price; set_tot();&#125;void Stock::show() &#123; std::cout &lt;&lt; \"Company: \" &lt;&lt; company &lt;&lt; \" Share: \" &lt;&lt; shares &lt;&lt; '\\n' &lt;&lt; \" Share Price: $\" &lt;&lt; share_val &lt;&lt; \" Total Worth: $\" &lt;&lt; total_val &lt;&lt; '\\n';&#125; 类使用 usestock00.cpp 1234567891011121314151617181920212223//usestock00.cpp -- the client program#include &lt;iostream&gt;#include \"stock00.h\"int main() &#123; Stock f; f.acquire(\"NanoSmart\", 20, 12.50); f.show(); f.buy(15, 18.125); f.show(); f.sell(400, 20.00); f.show(); f.buy(300000, 40.125); f.show(); f.sell(30000, 0.125); f.show(); return 0;&#125; 多个文件编译命令： 123ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ -c stock00.cppubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ -c usestock00.cppubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ g++ stock00.o usestock00.o -o usestock00 执行结果： 123456789101112ubuntu@ubuntu-xm:~&#x2F;Documents&#x2F;sunwg&#x2F;cpp$ .&#x2F;usestock00 Company: NanoSmart Share: 20 Share Price: $12.5 Total Worth: $250Company: NanoSmart Share: 35 Share Price: $18.125 Total Worth: $634.375You can&#39;t sell more than you have, Transaction is aborted.Company: NanoSmart Share: 35 Share Price: $18.125 Total Worth: $634.375Company: NanoSmart Share: 300035 Share Price: $40.125 Total Worth: $1.20389e+07Company: NanoSmart Share: 270035 Share Price: $0.125 Total Worth: $33754.4 类的构造函数和析构函数声明构造函数构造函数专门用于构造新对象、将值赋给他们的数据成员。 例如:Stock::Stock(const string &amp; co, long n, double pr) {...} 此处构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能与类成员相同，否则会造成混乱。 常见的做法是在数据成员名中使用m_前缀或者使用后缀_。 例如： 123456class Stock &#123; private: string m_company; long m_shares; ...&#125; 或者 123456class Stock &#123; private: string company_; long shares_; ...&#125; 使用构造函数两种使用构造函数初始化对象的方式： 显式调用构造函数：Stock food = Stock(&quot;World&quot;, 250, 1.25); 隐式调用构造函数：Stock garment(&quot;Good&quot;, 50, 2.5);，等价于显式的方法：Stock garment = Stock(&quot;Good&quot;, 50, 2.5); 创建类对象的时候，C++都会使用类的构造函数：Stock *pstock = new Stock(&quot;Best&quot;, 18, 1.9); 此处创建了一个Stock对象，并调用构造函数初始化为参数提供的值，将对象的地址赋给pstock指针。此时对象没有名称，但是可以使用指针来管理该对象。 使用对象调用方法：stock1.show(); 析构函数如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。 如果Stock的构造函数没有使用new，则析构函数实际上没有需要完成的任务。在这种情况下，只需让编译器生成一个什么都不做的隐式析构函数即可。 析构函数可以没有返回值和声明类型。 和构造函数不同，析构函数没有参数。 例如Stock析构函数的原型：~Stock(); 或者： 123Stock::~Sotck &#123; cout &lt;&lt; \"Bye\" &lt;&lt;endl;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Android HWUI绘制流程","slug":"2020/200707_android_HWUI_Draw","date":"2020-07-07T13:12:00.000Z","updated":"2020-07-30T12:25:29.326Z","comments":true,"path":"2020/07/07/2020/200707_android_HWUI_Draw/","link":"","permalink":"https://alonealive.github.io/Blog/2020/07/07/2020/200707_android_HWUI_Draw/","excerpt":"Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。","text":"Android中绘图的API有很多，比如2D的绘图skia；3D的绘图OpenGLES，Vulkan等。Android在后来完善3D API支持的同时，也在更新View Widget渲染机制，提出了硬件加速机制。 HWUI绘制的大致流程是先初始化绘制环境（创建rendernode、渲染线程RenderThread、Context上下文、RenderProxy代理对象），之后是创建DisplayList显示列表，然后开始视图绘制，视图绘制结束后开始同步帧数据。 硬件加速：作用：是将2D的绘图操纵转换为对应的3D绘图操纵。需要显示的时候，再用OpenGLES通过GPU渲染。过程：界面创建时，第一次全部渲染，后续界面如果只有部分区域的widget更新，只需要重新渲染更新的widget。渲染好的绘图保存在一个显示列表DisplayList中，需要真正显示到界面的时候，直接显示DisplayList中的绘图。好处：一方面利用GPU去渲染，比Skia要快；另一方面，采用DisplayList，再次渲染只更新部分区域，最大程度利用上一帧的数据，提高效率。 使用Android Q AOSP源码梳理流程。 GPU渲染（硬件加速）介绍在Android应用程序中是通过Canvas API来绘制UI元素的。在硬件加速渲染环境中,这些Canvas API调用最终会转化为OpenGL API调用(转化过程对应用程序来说是透明的)。由于OpenGL API调用要求发生在Open GL环境中,因此在每当有新的Activity窗口启动时,系统都会为其初始化好OpenGL环境。 这里的渲染,主要是Android硬件加速,即GPU渲染。android上就是通过libhwui调用OpenGL api来渲染, Android P上libhwui 会调用skia,再调用GLES相关的API进行渲染。 GPU作为一个硬件 , 用户空间是不可以直接使用的, 它是由GPU厂商按照Open GL规范实现的驱动间接进行使用的。也就是说 , 如果一个设备支持GPU硬件加速渲染, 那么当Android应用程序调用OpenGL接口来绘制UI时 ,Android应用程序的UI就是通过硬件加速技术进行渲染的。 名词介绍： GPU:一个类似于CPU的专门用来处理Graphics的处理器, 作用用来帮助加快栅格化操作, 当然, 也有相应的缓存数据(例如缓存已经光栅化过的bitmap等)机制。 OpenGL ES:是手持嵌入式设备的3DAPI, 跨平台的、功能完善的2D和3D图形应用程序接口API, 有一套固定渲染管线流程 DisplayList:在Android把XML布局文件转换成GPU能够识别并绘制的对象。这个操作是在DisplayList的帮助下完成的。DisplayList持有所有将要交给GPU绘制到屏幕上的数据信息。 栅格化:是将图片等矢量资源, 转化为一格格像素点的像素图, 显示到屏幕上。 垂直同步VSYNC:让显卡的运算和显示器刷新率一致以稳定输出的画面质量。它告知GPU在载入新帧之前,要等待屏幕绘制完成前一帧。 RefreshRate:屏幕一秒内刷新屏幕的次数, 由硬件决定, 例如60Hz Frame Rate:GPU一秒绘制操作的帧数, 单位是fps Android 5.0 之后的渲染框架在Android应用程序窗口中, 每一个View都抽象为一个Render Node, 而且如果一个View设置有Background, 这个background 也被抽象为一个Render Node 。 这是由于在OpenGLRenderer库中, 并没有View的概念, 所有的一切可绘制的元素都抽象为一个Render Node。 每一个Render Node都关联有一个DisplayList Renderer, Display List是一个绘制命令缓冲区。当View的成员函数onDraw被调用时, 我们调用通过参数传递进来的Canvas的drawXXX成员函数绘制图形时, 我们实际上只是将对应的绘制命令以及参数保存在一个Display List中。接下来再通过DisplayList Renderer执行这个Display List的命令, 这个过程称为Display List Replay。 Android应用程序窗口的View是通过树形结构来组织的。这些View不管是通过硬件加速渲染还是软件渲染, 或者是一个特殊的TextureView,在它们的成员函数onDraw被调用期间, 它们都是将自己的UI绘制在ParentView的DisplayList中。 其中, 最顶层的Parent View是一个Root View, 它关联的RootNode称为Root Render Node。也就是说, 最终Root Render Node的DisplayList将会包含一个窗口的所有绘制命令。 在绘制窗口的下一帧时, RootRender Node的Display List都会通过一个OpenGL Renderer真正地通过Open GL命令绘制在一个Graphic Buffer中。 最后这个 Graphic Buffer 被交给 SurfaceFlinger 服务进行合成和显示。 Android原生硬件绘制案例 这个案例是用的SurfaceView.java的流程。这个流程和实际上从ViewRootImpl.java中通过performDraw的流程类似。可以互相借鉴参考。 Android原生的硬件绘制案例，在frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java： HardwareCanvasSurfaceViewActivity.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static class RenderingThread extends Thread &#123; private final SurfaceHolder mSurface; private volatile boolean mRunning = true; private int mWidth, mHeight; //应用拿到一个Surface public RenderingThread(SurfaceHolder surface) &#123; mSurface = surface; &#125; void setSize(int width, int height) &#123; mWidth = width; mHeight = height; &#125; @Override public void run() &#123; float x = 0.0f; float y = 0.0f; float speedX = 5.0f; float speedY = 3.0f; Paint paint = new Paint(); paint.setColor(0xff00ff00); while (mRunning &amp;&amp; !Thread.interrupted()) &#123; //先调用Surface的lockHardwareCanvas函数 final Canvas canvas = mSurface.lockHardwareCanvas(); try &#123; //绘制 canvas.drawColor(0x00000000, PorterDuff.Mode.CLEAR); canvas.drawRect(x, y, x + 20.0f, y + 20.0f, paint); &#125; finally &#123; //绘制完成后 mSurface.unlockCanvasAndPost(canvas); &#125; if (x + 20.0f + speedX &gt;= mWidth || x + speedX &lt;= 0.0f) &#123; speedX = -speedX; &#125; if (y + 20.0f + speedY &gt;= mHeight || y + speedY &lt;= 0.0f) &#123; speedY = -speedY; &#125; x += speedX; y += speedY; try &#123; //每个15s循环一次 Thread.sleep(15); &#125; catch (InterruptedException e) &#123; // Interrupted &#125; &#125; &#125; void stopRendering() &#123; interrupt(); mRunning = false; &#125; &#125; Java层相关流程（frameworks/base的View模块和graphics模块） 首先调用关键函数lockHardwareCanvas，在frameworks/base/core/java/android/view/SurfaceView.java： frameworks/base/core/java/android/view/SurfaceView.java1234567891011121314151617181920212223242526272829303132333435@Overridepublic Surface getSurface() &#123; return mSurface;&#125;public Canvas lockHardwareCanvas() &#123; return internalLockCanvas(null, true); &#125; private Canvas internalLockCanvas(Rect dirty, boolean hardware) &#123; mSurfaceLock.lock(); Canvas c = null; if (!mDrawingStopped &amp;&amp; mSurfaceControl != null) &#123; try &#123; if (hardware) &#123; //hardware传递的是true，执行lockHardwareCanvas c = mSurface.lockHardwareCanvas(); &#125; else &#123; c = mSurface.lockCanvas(dirty); &#125; &#125; catch (Exception e) &#123; Log.e(LOG_TAG, \"Exception locking surface\", e); &#125; &#125; if (c != null) &#123; mLastLockTime = SystemClock.uptimeMillis(); return c; &#125; ...... mLastLockTime = now; mSurfaceLock.unlock(); return null; &#125; 然后就调用Surface.java的lockHardwareCanvas函数，此处封装了一个HwuiContext对象，构造函数如下： frameworks/base/core/java/android/view/Surface.java12345678910111213141516171819202122232425 public Canvas lockHardwareCanvas() &#123; Log.d(TAG, \"lockHardwareCanvas\"); synchronized (mLock) &#123; checkNotReleasedLocked(); if (mHwuiContext == null) &#123; //Step 1 创建HwuiContext，调用构造函数 mHwuiContext = new HwuiContext(false); &#125; //Step 2 调用他的lockCanvas函数 return mHwuiContext.lockCanvas( nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject)); &#125; &#125; //从上面调用到 Canvas lockCanvas(int width, int height) &#123; if (mCanvas != null) &#123; throw new IllegalStateException(\"Surface was already locked!\"); &#125; //调用RenderNode的beginRecording函数 mCanvas = mRenderNode.beginRecording(width, height); return mCanvas; &#125; .....&#125; 创建RenderNode RenderNode用以绘图操纵的批处理，当绘制的时候，可以store和apply。java层的代码如下：其实RenderNode就对应前面我们所说的ViewGroup，有一个RootView，同样也有一个RootNode。 在上面Surface.java调用HwuiContext构造函数的时候，会创建RenderNode对象： Surface.java1234567891011private final class HwuiContext &#123; //创建RenderNode和HwuiRender private final RenderNode mRenderNode; private long mHwuiRenderer; private RecordingCanvas mCanvas; private final boolean mIsWideColorGamut; //构造函数 HwuiContext(boolean isWideColorGamut) &#123; //创建一个RenderNode mRenderNode = RenderNode.create(\"HwuiCanvas\", null); ...... 创建RenderNode对象： frameworks/base/graphics/java/android/graphics/RenderNode.java123456789public static RenderNode create(String name, @Nullable AnimationHost animationHost) &#123; return new RenderNode(name, animationHost);&#125;private RenderNode(String name, AnimationHost animationHost) &#123; mNativeRenderNode = nCreate(name); NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mNativeRenderNode); mAnimationHost = animationHost;&#125; JNI层： frameworks/base/core/jni/android_view_RenderNode.cpp1234567891011121314151617181920static const JNINativeMethod gMethods[] = &#123;// ----------------------------------------------------------------------------// Regular JNI// ---------------------------------------------------------------------------- &#123; \"nCreate\", \"(Ljava/lang/String;)J\", (void*) android_view_RenderNode_create &#125;, &#123; \"nGetNativeFinalizer\", \"()J\", (void*) android_view_RenderNode_getNativeFinalizer &#125;, &#123; \"nOutput\", \"(J)V\", (void*) android_view_RenderNode_output &#125;, ...static jlong android_view_RenderNode_create(JNIEnv* env, jobject, jstring name) &#123; //创建一个native层的rendernode对象 RenderNode* renderNode = new RenderNode(); renderNode-&gt;incStrong(0); if (name != NULL) &#123; const char* textArray = env-&gt;GetStringUTFChars(name, NULL); renderNode-&gt;setName(textArray); env-&gt;ReleaseStringUTFChars(name, textArray); &#125; return reinterpret_cast&lt;jlong&gt;(renderNode);&#125; Native层，创建好RenderNode是提供给DisplayListCanvas。 frameworks/base/libs/hwui/RenderNode.cpp12345678RenderNode::RenderNode() : mUniqueId(generateId()) , mDirtyPropertyFields(0) , mNeedsDisplayListSync(false) , mDisplayList(nullptr) , mStagingDisplayList(nullptr) , mAnimatorManager(*this) , mParentCount(0) &#123;&#125; beginRecording初始化DisplayList 在Surface.java中通过lockCanvas调用RenderNode对象的beginRecording函数。 frameworks/base/graphics/java/android/graphics/RenderNode.java12345678public @NonNull RecordingCanvas beginRecording(int width, int height) &#123; if (mCurrentRecordingCanvas != null) &#123; throw new IllegalStateException( \"Recording currently in progress - missing #endRecording() call?\"); &#125; mCurrentRecordingCanvas = RecordingCanvas.obtain(this, width, height); return mCurrentRecordingCanvas; &#125; 接着调用RecordingCanvas的obtain函数： 类的继承关系： RecordingCanvas类继承DisplayListCanvas，而DisplayListCanvas继承BaseRecordingCanvas，BaseRecordingCanvas继承Canvas（继承BaseCanvas）。 frameworks/base/graphics/java/android/graphics/RecordingCanvas.java1234567891011121314151617181920212223242526public final class RecordingCanvas extends DisplayListCanvas &#123; //构造函数 /** @hide */ protected RecordingCanvas(@NonNull RenderNode node, int width, int height) &#123; super(nCreateDisplayListCanvas(node.mNativeRenderNode, width, height)); mDensity = 0; // disable bitmap density scaling &#125; static RecordingCanvas obtain(@NonNull RenderNode node, int width, int height) &#123; if (node == null) throw new IllegalArgumentException(\"node cannot be null\"); RecordingCanvas canvas = sPool.acquire(); if (canvas == null) &#123; canvas = new RecordingCanvas(node, width, height); &#125; else &#123; //创建一个native的DisplayListCanvas对象（即显示列表的Canvas） //JNI通过mNativeCanvasWrapper（BaseCanvas.java创建）找对应的Native的Canvas nResetDisplayListCanvas(canvas.mNativeCanvasWrapper, node.mNativeRenderNode, width, height); &#125; canvas.mNode = node; canvas.mWidth = width; canvas.mHeight = height; return canvas; &#125; ...&#125; 查看测试案例代码中的canvas.drawColor和canvas.drawRect函数，是调用了其父类BaseCanvas的对应方法。 frameworks/base/graphics/java/android/graphics/Canvas.java1234567public void drawColor(@ColorLong long color) &#123; super.drawColor(color, BlendMode.SRC_OVER);&#125; public void drawRect(@NonNull RectF rect, @NonNull Paint paint) &#123; super.drawRect(rect, paint);&#125; 父类BaseCanvas.java： frameworks/base/graphics/java/android/graphics/BaseCanvas.java12345678 public void drawColor(@ColorInt int color, @NonNull PorterDuff.Mode mode) &#123; nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt); &#125;public void drawRect(@NonNull Rect r, @NonNull Paint paint) &#123; throwIfHasHwBitmapInSwMode(paint); drawRect(r.left, r.top, r.right, r.bottom, paint); &#125; Native层Canvas创建（JNI和HWUI模块） 1.在上面RecordingCanvas.java的构造函数中调用了nCreateDisplayListCanvas函数，对饮的JNI实现： frameworks/base/core/jni/android_view_DisplayListCanvas.cpp123456789101112131415161718192021222324252627282930const char* const kClassPathName = \"android/graphics/RecordingCanvas\";static JNINativeMethod gMethods[] = &#123; // ------------ @FastNative ------------------ &#123; \"nCallDrawGLFunction\", \"(JJLjava/lang/Runnable;)V\", (void*) android_view_DisplayListCanvas_callDrawGLFunction &#125;, // ------------ @CriticalNative -------------- &#123; \"nCreateDisplayListCanvas\", \"(JII)J\", (void*) android_view_DisplayListCanvas_createDisplayListCanvas &#125;, &#123; \"nResetDisplayListCanvas\", \"(JJII)V\", (void*) android_view_DisplayListCanvas_resetDisplayListCanvas &#125;, &#123; \"nGetMaximumTextureWidth\", \"()I\", (void*) android_view_DisplayListCanvas_getMaxTextureSize &#125;, &#123; \"nGetMaximumTextureHeight\", \"()I\", (void*) android_view_DisplayListCanvas_getMaxTextureSize &#125;, &#123; \"nInsertReorderBarrier\", \"(JZ)V\", (void*) android_view_DisplayListCanvas_insertReorderBarrier &#125;, &#123; \"nFinishRecording\", \"(J)J\", (void*) android_view_DisplayListCanvas_finishRecording &#125;, &#123; \"nDrawRenderNode\", \"(JJ)V\", (void*) android_view_DisplayListCanvas_drawRenderNode &#125;, &#123; \"nDrawTextureLayer\", \"(JJ)V\", (void*) android_view_DisplayListCanvas_drawTextureLayer &#125;, &#123; \"nDrawCircle\", \"(JJJJJ)V\", (void*) android_view_DisplayListCanvas_drawCircleProps &#125;, &#123; \"nDrawRoundRect\", \"(JJJJJJJJ)V\",(void*) android_view_DisplayListCanvas_drawRoundRectProps &#125;, &#123; \"nDrawWebViewFunctor\", \"(JI)V\", (void*) android_view_DisplayListCanvas_drawWebViewFunctor &#125;,&#125;;//具体实现，此处的renderNodePtr变量是RenderNode在native层的对象（地址）static jlong android_view_DisplayListCanvas_createDisplayListCanvas(jlong renderNodePtr, jint width, jint height) &#123; RenderNode* renderNode = reinterpret_cast&lt;RenderNode*&gt;(renderNodePtr); return reinterpret_cast&lt;jlong&gt;(Canvas::create_recording_canvas(width, height, renderNode));&#125; 调用到frameworks/base/libs/hwui/hwui/Canvas.cpp，在Andorid Q中，此处只调用了SkiaRecordingCanvas函数。使用skia进行绘制。 frameworks/base/libs/hwui/hwui/Canvas.cpp123Canvas* Canvas::create_recording_canvas(int width, int height, uirenderer::RenderNode* renderNode) &#123; return new uirenderer::skiapipeline::SkiaRecordingCanvas(renderNode, width, height);&#125; 然后初始化DisplayList： frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.h123explicit SkiaRecordingCanvas(uirenderer::RenderNode* renderNode, int width, int height) &#123; initDisplayList(renderNode, width, height);&#125; frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp123456789101112131415void SkiaRecordingCanvas::initDisplayList(uirenderer::RenderNode* renderNode, int width, int height) &#123; mCurrentBarrier = nullptr; SkASSERT(mDisplayList.get() == nullptr); if (renderNode) &#123; mDisplayList = renderNode-&gt;detachAvailableList(); &#125; if (!mDisplayList) &#123; mDisplayList.reset(new SkiaDisplayList()); &#125; mDisplayList-&gt;attachRecorder(&amp;mRecorder, SkIRect::MakeWH(width, height)); SkiaCanvas::reset(&amp;mRecorder);&#125; Draw绘制操纵 正常流程的绘制是在frameworks/base/core/java/android/view/ThreadedRenderer.java的updateRootDisplayList函数中。调用到drawRnderNode函数绘制。 Java层：上面案例中的drawColor和drawRect实际调用的是在frameworks/base/graphics/java/android/graphics/BaseCanvas.java中： frameworks/base/graphics/java/android/graphics/BaseCanvas.java12345678 public void drawColor(@ColorInt int color, @NonNull PorterDuff.Mode mode) &#123; nDrawColor(mNativeCanvasWrapper, color, mode.nativeInt); &#125;public void drawRect(@NonNull Rect r, @NonNull Paint paint) &#123; throwIfHasHwBitmapInSwMode(paint); drawRect(r.left, r.top, r.right, r.bottom, paint); &#125; 调用JNI层在： frameworks/base/core/jni/android_graphics_Canvas.cpp12345678910111213141516171819202122static const JNINativeMethod gDrawMethods[] = &#123; &#123;\"nDrawColor\",\"(JII)V\", (void*) CanvasJNI::drawColor&#125;, &#123;\"nDrawColor\",\"(JJJI)V\", (void*) CanvasJNI::drawColorLong&#125;, &#123;\"nDrawPaint\",\"(JJ)V\", (void*) CanvasJNI::drawPaint&#125;, &#123;\"nDrawPoint\", \"(JFFJ)V\", (void*) CanvasJNI::drawPoint&#125;, &#123;\"nDrawPoints\", \"(J[FIIJ)V\", (void*) CanvasJNI::drawPoints&#125;, &#123;\"nDrawLine\", \"(JFFFFJ)V\", (void*) CanvasJNI::drawLine&#125;, &#123;\"nDrawLines\", \"(J[FIIJ)V\", (void*) CanvasJNI::drawLines&#125;, &#123;\"nDrawRect\",\"(JFFFFJ)V\", (void*) CanvasJNI::drawRect&#125;, ......&#125;static void drawColor(JNIEnv* env, jobject, jlong canvasHandle, jint color, jint modeHandle) &#123; SkBlendMode mode = static_cast&lt;SkBlendMode&gt;(modeHandle); get_canvas(canvasHandle)-&gt;drawColor(color, mode);&#125;static void drawRect(JNIEnv* env, jobject, jlong canvasHandle, jfloat left, jfloat top, jfloat right, jfloat bottom, jlong paintHandle) &#123; const Paint* paint = reinterpret_cast&lt;Paint*&gt;(paintHandle); get_canvas(canvasHandle)-&gt;drawRect(left, top, right, bottom, *paint);&#125; Native层：因为class SkiaCanvas : public Canvas，所以调用到SkiaCanvas类中的具体实现： 调用 frameworks/base/libs/hwui/SkiaCanvas.cpp12345678void SkiaCanvas::drawColor(int color, SkBlendMode mode) &#123; mCanvas-&gt;drawColor(color, mode);&#125;void SkiaCanvas::drawRect(float left, float top, float right, float bottom, const SkPaint&amp; paint) &#123; if (CC_UNLIKELY(paint.nothingToDraw())) return; mCanvas-&gt;drawRect(&#123;left, top, right, bottom&#125;, *filterPaint(paint));&#125; 调用到external/skia图形库模块： Skia是Google一个底层的图形、图像、动画、SVG、文本等多方面的图形库，是Android中图形系统的引擎。Skia作为第三方软件放在目录：external/skia/。 主要包含三个库： libcorecg.so: 包含/skia/src/core的部分内容，比如其中的Region、Rect是在SurfaceFlinger里面用来计算可视区域的； libsgl.so: 包含/skia/src/core|effects|images|ports|utils的部分和全部内容，这个实现了skia大部分的图形效果，以及图形格式的编解码； libskiagl.so: 包含/skia/src/gl里面的内容，主要用来调用opengl实现部分效果。 external/skia/src/core/SkCanvas.cpp12345678910111213void SkCanvas::drawColor(SkColor c, SkBlendMode mode) &#123; SkPaint paint; paint.setColor(c); paint.setBlendMode(mode); this-&gt;drawPaint(paint);&#125;void SkCanvas::drawRect(const SkRect&amp; r, const SkPaint&amp; paint) &#123; TRACE_EVENT0(\"skia\", TRACE_FUNC); // To avoid redundant logic in our culling code and various backends, we always sort rects // before passing them along. this-&gt;onDrawRect(r.makeSorted(), paint);&#125; HwuiContext和HwuiRendererJava层从上面的Surface.java中看到，nHwuiCreate创建HwuiRenderer。 Surface.java1234//创建一个native的HwuiRender对象mHwuiRenderer = nHwuiCreate(mRenderNode.mNativeRenderNode, mNativeObject, isWideColorGamut); ...... JNI层frameworks/base/core/jni/android_view_Surface.cpp1234567891011121314151617181920212223242526272829303132333435static const JNINativeMethod gSurfaceMethods[] = &#123; ...... // HWUI context &#123;\"nHwuiCreate\", \"(JJZ)J\", (void*) hwui::create &#125;, &#123;\"nHwuiSetSurface\", \"(JJ)V\", (void*) hwui::setSurface &#125;, &#123;\"nHwuiDraw\", \"(J)V\", (void*) hwui::draw &#125;, &#123;\"nHwuiDestroy\", \"(J)V\", (void*) hwui::destroy &#125;,&#125;;//=========================================具体实现namespace uirenderer &#123;using namespace android::uirenderer::renderthread;class ContextFactory : public IContextFactory &#123;......static jlong create(JNIEnv* env, jclass clazz, jlong rootNodePtr, jlong surfacePtr, jboolean isWideColorGamut) &#123; RenderNode* rootNode = reinterpret_cast&lt;RenderNode*&gt;(rootNodePtr); sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface*&gt;(surfacePtr)); ContextFactory factory; //创建一个RenderProxy对象，并作为返回对象 RenderProxy* proxy = new RenderProxy(false, rootNode, &amp;factory); proxy-&gt;loadSystemProperties(); if (isWideColorGamut) &#123; proxy-&gt;setWideGamut(true); &#125; proxy-&gt;setSwapBehavior(SwapBehavior::kSwap_discardBuffer); proxy-&gt;setSurface(surface); // Shadows can't be used via this interface, so just set the light source // to all 0s. proxy-&gt;setLightAlpha(0, 0); proxy-&gt;setLightGeometry((Vector3)&#123;0, 0, 0&#125;, 0); return (jlong) proxy;&#125; 以下流程部分是和通常的HWUI环境初始化流程相同的。 *native层：调用RenderProxy.cpp构造函数该构造函数的几个重要成员变量： RenderProxy是一个代理者，严格的单线程。所有的方法都必须在自己的线程中调用。MainThread通过这个代理对象想Task Queue发送drawFrame命令； RenderThread（即构造函数中的mRenderThread）：渲染线程，是一个单例，也就是说，一个进程中只有一个，所有的绘制操纵都必须在这个线程中完成。应用端很多操纵，都以RenderTask的形式post到RenderThread线程中完成。（在Android 5.0之后独立出来的应用程序的OpenGL线程） CanvasContext（即构造函数中的mContext）：上下文，由于OpenGL是单线程的，所以，我们给到GPU的绘图命令都封装在各自的上下文中。这个和上层的HwuiRenderer是对应的。（将窗口绑定到Open GL渲染上下文中，从而使后面的渲染操作都是针对被绑定窗口的） DrawFrameTask（即构造函数中的mDrawFrameTask）：一个用来执行渲染任务的task，MainThread通过他向RenderThread线程发送渲染下一帧的命令。（比较特殊的一个RenderTask，可重复使用的绘制Task。） frameworks/base/libs/hwui/renderthread/RenderProxy.cpp1234567891011121314namespace android &#123;namespace uirenderer &#123;namespace renderthread &#123;RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory) : mRenderThread(RenderThread::getInstance()), mContext(nullptr) &#123; //Step1 创建RenderThread渲染线程 mContext = mRenderThread.queue().runSync([&amp;]() -&gt; CanvasContext* &#123; return CanvasContext::create(mRenderThread, translucent, rootRenderNode, contextFactory); //Step2 创建CanvasContext渲染上下文 &#125;); mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);&#125;...... 创建RenderThread渲染线程 从上面构造函数中的RenderThread::getInstance()调用下去。创建一个RenderThread线程。 而该类的父类是ThreadBase.h，父类的父类是Thread.h frameworks/base/libs/hwui/renderthread/RenderThread.cpp12345678910111213141516171819202122RenderThread&amp; RenderThread::getInstance() &#123; // This is a pointer because otherwise __cxa_finalize // will try to delete it like a Good Citizen but that causes us to crash // because we don't want to delete the RenderThread normally. static RenderThread* sInstance = new RenderThread(); gHasRenderThreadInstance = true; return *sInstance;&#125;RenderThread::RenderThread() : ThreadBase() , mVsyncSource(nullptr) , mVsyncRequested(false) , mFrameCallbackTaskPending(false) , mRenderState(nullptr) , mEglManager(nullptr) , mFunctorManager(WebViewFunctorManager::instance()) , mVkManager(nullptr) &#123; Properties::load(); //实现父类的函数，调用run start(\"RenderThread\");&#125; 父类创建looper循环和start函数实现，然后开始线程循环： frameworks/base/libs/hwui/thread/ThreadBase.h123456ThreadBase() : Thread(false) , mLooper(new Looper(false)) , mQueue([this]() &#123; mLooper-&gt;wake(); &#125;, mLock) &#123;&#125;void start(const char* name = \"ThreadBase\") &#123; Thread::run(name); &#125; 开始线程循环，调用ThreadLoop开始工作。 frameworks/base/libs/hwui/renderthread/RenderThread.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869bool RenderThread::threadLoop() &#123; ... initThreadLocals(); while (true) &#123; waitForWork(); processQueue(); if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123; drainDisplayEventQueue(); mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end()); mPendingRegistrationFrameCallbacks.clear(); requestVsync(); &#125; if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123; requestVsync(); &#125; &#125; return false;&#125;//以下流程会处理vsync信号void RenderThread::initThreadLocals() &#123; setupFrameInterval(); initializeDisplayEventReceiver(); mEglManager = new EglManager(); mRenderState = new RenderState(*this); mVkManager = new VulkanManager(); mCacheManager = new CacheManager(DeviceInfo::get()-&gt;displayInfo());&#125;void RenderThread::initializeDisplayEventReceiver() &#123; if (!Properties::isolatedProcess) &#123; ... // Register the FD mLooper-&gt;addFd(receiver-&gt;getFd(), 0, Looper::EVENT_INPUT, RenderThread::displayEventReceiverCallback, this); mVsyncSource = new DisplayEventReceiverWrapper(std::move(receiver), [this] &#123; DeviceInfo::get()-&gt;onDisplayConfigChanged(); setupFrameInterval(); &#125;); &#125; else &#123; mVsyncSource = new DummyVsyncSource(this); &#125;&#125;int RenderThread::displayEventReceiverCallback(int fd, int events, void* data) &#123; ... reinterpret_cast&lt;RenderThread*&gt;(data)-&gt;drainDisplayEventQueue(); return 1; // keep the callback&#125;void RenderThread::drainDisplayEventQueue() &#123; ATRACE_CALL(); nsecs_t vsyncEvent = mVsyncSource-&gt;latestVsyncEvent(); if (vsyncEvent &gt; 0) &#123; mVsyncRequested = false; if (mTimeLord.vsyncReceived(vsyncEvent) &amp;&amp; !mFrameCallbackTaskPending) &#123; ATRACE_NAME(\"queue mFrameCallbackTask\"); mFrameCallbackTaskPending = true; nsecs_t runAt = (vsyncEvent + mDispatchFrameDelay); queue().postAt(runAt, [this]() &#123; dispatchFrameCallbacks(); &#125;); &#125; &#125;&#125; CanvasContext渲染上下文该函数中会选择渲染绘制方式（渲染管线）。在Android Q中取消了OpenGL渲染。 Android P之前：enum class RenderPipelineType { OpenGL = 0, SkiaGL, SkiaVulkan, NotInitialized = 128 }; Android Q：enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 }; frameworks/base/libs/hwui/renderthread/CanvasContext.cpp123456789101112131415161718192021222324252627282930313233343536373839CanvasContext* CanvasContext::create(RenderThread&amp; thread, bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory) &#123; //获取渲染方式getRenderPipelineType auto renderType = Properties::getRenderPipelineType(); switch (renderType) &#123; case RenderPipelineType::SkiaGL: return new CanvasContext(thread, translucent, rootRenderNode, contextFactory, std::make_unique&lt;skiapipeline::SkiaOpenGLPipeline&gt;(thread)); case RenderPipelineType::SkiaVulkan: return new CanvasContext(thread, translucent, rootRenderNode, contextFactory, std::make_unique&lt;skiapipeline::SkiaVulkanPipeline&gt;(thread)); default: LOG_ALWAYS_FATAL(\"canvas context type %d not supported\", (int32_t)renderType); break; &#125; return nullptr;&#125;RenderPipelineType Properties::getRenderPipelineType() &#123; sRenderPipelineType = peekRenderPipelineType(); return sRenderPipelineType;&#125;RenderPipelineType Properties::peekRenderPipelineType() &#123; // If sRenderPipelineType has been locked, just return the locked type immediately. if (sRenderPipelineType != RenderPipelineType::NotInitialized) &#123; return sRenderPipelineType; &#125; bool useVulkan = use_vulkan().value_or(false); char prop[PROPERTY_VALUE_MAX]; //PROPERTY_RENDERER \"debug.hwui.renderer\" //enum class RenderPipelineType &#123; SkiaGL, SkiaVulkan, NotInitialized = 128 &#125;; property_get(PROPERTY_RENDERER, prop, useVulkan ? \"skiavk\" : \"skiagl\"); if (!strcmp(prop, \"skiavk\")) &#123; return RenderPipelineType::SkiaVulkan; &#125; return RenderPipelineType::SkiaGL;&#125; mRenderPipeline有几种类型，创建CanvasContext时（create函数），会根据pipeline的类型，创建对应的Pipeline。（即调用getRenderPipelineType函数） 渲染类型：enum class RenderPipelineType { SkiaGL, SkiaVulkan, NotInitialized = 128 }; frameworks/base/libs/hwui/renderthread/CanvasContext.cpp1234567891011121314151617//构造函数CanvasContext::CanvasContext(RenderThread&amp; thread, bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory, std::unique_ptr&lt;IRenderPipeline&gt; renderPipeline) : mRenderThread(thread) , mGenerationID(0) , mOpaque(!translucent) , mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord())) , mJankTracker(&amp;thread.globalProfileData(), DeviceInfo::get()-&gt;displayInfo()) , mProfiler(mJankTracker.frames(), thread.timeLord().frameIntervalNanos()) , mContentDrawBounds(0, 0, 0, 0) , mRenderPipeline(std::move(renderPipeline)) &#123; rootRenderNode-&gt;makeRoot(); mRenderNodes.emplace_back(rootRenderNode); //是前面创建的RenderNode mProfiler.setDensity(DeviceInfo::get()-&gt;displayInfo().density); setRenderAheadDepth(Properties::defaultRenderAhead);&#125; 在上面调用nHwuiCreate的JNI层，会创建ContextFactory，然后在此处的构造函数中会使用到。主要用来创建AnimationContext，即mAnimationContext(contextFactory-&gt;createAnimationContext(mRenderThread.timeLord())) AnimationContext主要用来处理动画Animation。 frameworks/base/core/jni/android_view_Surface.cpp123456class ContextFactory : public IContextFactory &#123;public: virtual AnimationContext* createAnimationContext(renderthread::TimeLord&amp; clock) &#123; return new AnimationContext(clock); &#125;&#125;; CanvasContext实现了IFrameCallback接口，所以，CanvasContext能接收编舞者Choreographer的callback，处理实时动画。class CanvasContext : public IFrameCallback {...} RenderThread渲染线程 RenderThread渲染运行模型:空闲的时候, RenderThread睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnceh中。当其他线程需要调度RenderThread, 会向他的任务队列添加一个任务, 然后唤醒RenderThread进行处理。RenderThread通过processQueue方法处理任务。 frameworks/base/libs/hwui/renderthread/RenderThread.h1234//继承ThreadBase，而ThreadBase是继承基类Threadclass RenderThread : private ThreadBase &#123; //组织拷贝构造函数和重载 PREVENT_COPY_AND_ASSIGN(RenderThread); 调用构造函数中，同时启动了渲染线程RenderThread： frameworks/base/libs/hwui/renderthread/RenderThread.cpp123456789101112RenderThread::RenderThread() : ThreadBase() , mVsyncSource(nullptr) , mVsyncRequested(false) , mFrameCallbackTaskPending(false) , mRenderState(nullptr) , mEglManager(nullptr) , mFunctorManager(WebViewFunctorManager::instance()) , mVkManager(nullptr) &#123; Properties::load(); start(\"RenderThread\"); //线程启动&#125; 查看父类的构造函数： frameworks/base/libs/hwui/thread/ThreadBase.h123456ThreadBase() : Thread(false) , mLooper(new Looper(false)) , mQueue([this]() &#123; mLooper-&gt;wake(); //此处调用是唤醒mLooper，线程开始工作 &#125;, mLock) &#123;&#125; 在渲染线程启动后，会调用RenderThread.cpp的threadLoop函数。 123456789101112131415161718192021222324252627282930313233bool RenderThread::threadLoop() &#123; setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY); Looper::setForThread(mLooper); if (gOnStartHook) &#123; gOnStartHook(\"RenderThread\"); &#125; //初始化Thread的本地变量 initThreadLocals(); while (true) &#123; //没有任务就等在此处 waitForWork(); processQueue(); if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123; drainDisplayEventQueue(); mFrameCallbacks.insert(mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end()); mPendingRegistrationFrameCallbacks.clear(); requestVsync(); &#125; if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123; // TODO: Clean this up. This is working around an issue where a combination // of bad timing and slow drawing can result in dropping a stale vsync // on the floor (correct!) but fails to schedule to listen for the // next vsync (oops), so none of the callbacks are run. requestVsync(); &#125; &#125; return false;&#125; DrawFrameTask构造函数在RenderProxy调用构造函数时，会创建DrawFrameTask，同时调用其setContext函数： frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp1234567891011121314DrawFrameTask::DrawFrameTask() : mRenderThread(nullptr) , mContext(nullptr) , mContentDrawBounds(0, 0, 0, 0) , mSyncResult(SyncResult::OK) &#123;&#125;DrawFrameTask::~DrawFrameTask() &#123;&#125;void DrawFrameTask::setContext(RenderThread* thread, CanvasContext* context, RenderNode* targetNode) &#123; mRenderThread = thread; mContext = context; mTargetNode = targetNode;&#125; syncAndDrawFrame绘制帧 从上面的分析看，DisplayList和RenderThread都创建好了，正常绘制的时候会调用到syncAndDrawFrame： 从ViewRootImpl的performDraw函数调用到draw，在调用到 ThreadedRenderer.java的draw函数。开始绘制： ThreadedRenderer.java123456789void draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123; final Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer; choreographer.mFrameInfo.markDrawStart(); //绘制每个视图的内容（在文章下面会梳理） updateRootDisplayList(view, callbacks); //绘制一帧的内容 int syncResult = syncAndDrawFrame(choreographer.mFrameInfo); ... &#125; frameworks/base/libs/hwui/renderthread/RenderProxy.cpp123int RenderProxy::syncAndDrawFrame() &#123; return mDrawFrameTask.drawFrame();&#125; frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp123456789101112131415int DrawFrameTask::drawFrame() &#123; LOG_ALWAYS_FATAL_IF(!mContext, \"Cannot drawFrame with no CanvasContext!\"); mSyncResult = SyncResult::OK; mSyncQueued = systemTime(CLOCK_MONOTONIC); postAndWait(); return mSyncResult;&#125;void DrawFrameTask::postAndWait() &#123; AutoMutex _lock(mLock); mRenderThread-&gt;queue().post([this]() &#123; run(); &#125;); //执行此处的run函数 mSignal.wait(mLock);&#125; 此时，drawFrame，也就通过RenderThread，post一个WorkItem到RenderThread的队列里面，在RenderThread线程中执行的。 然后RenderThread处理Queue时，执行的会是DrawFrameTask的run函数。 frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void DrawFrameTask::run() &#123; ATRACE_NAME(\"DrawFrame\"); bool canUnblockUiThread; bool canDrawThisFrame; &#123; //info，即描述Viewtree的，也就是RenderNode tree //此处的mode是MODE_FULL，即只有primary的node是FULL，其他都是实时 ** TreeInfo info(TreeInfo::MODE_FULL, *mContext); //同步Frame帧状态 canUnblockUiThread = syncFrameState(info); //判断是否可以绘制这一帧 canDrawThisFrame = info.out.canDrawThisFrame; if (mFrameCompleteCallback) &#123; mContext-&gt;addFrameCompleteListener(std::move(mFrameCompleteCallback)); mFrameCompleteCallback = nullptr; &#125; &#125; // Grab a copy of everything we need CanvasContext* context = mContext; std::function&lt;void(int64_t)&gt; callback = std::move(mFrameCallback); mFrameCallback = nullptr; ...... if (CC_LIKELY(canDrawThisFrame)) &#123; //**绘制 context-&gt;draw(); &#125; else &#123; // wait on fences so tasks don't overlap next frame context-&gt;waitOnFences(); &#125; if (!canUnblockUiThread) &#123; unblockUiThread(); &#125;&#125;//同步Frame的Statebool DrawFrameTask::syncFrameState(TreeInfo&amp; info) &#123; ATRACE_CALL(); int64_t vsync = mFrameInfo[static_cast&lt;int&gt;(FrameInfoIndex::Vsync)]; mRenderThread-&gt;timeLord().vsyncReceived(vsync); //通知GPU处理当前的Context上下文 bool canDraw = mContext-&gt;makeCurrent(); //hwui为了提高速度，对各种object都做了cache，此处unpin，就是让cache去做unpin，其他都不要了 mContext-&gt;unpinImages(); for (size_t i = 0; i &lt; mLayers.size(); i++) &#123; mLayers[i]-&gt;apply(); &#125; mLayers.clear(); //设置绘制的区域大小 mContext-&gt;setContentDrawBounds(mContentDrawBounds); //**Android View是树型结构的，这就是在绘制之前，去准备这些Tree节点的绘图操作 //准备绘制一帧的数据 mContext-&gt;prepareTree(info, mFrameInfo, mSyncQueued, mTargetNode); // This is after the prepareTree so that any pending operations // (RenderNode tree state, prefetched layers, etc...) will be flushed. if (CC_UNLIKELY(!mContext-&gt;hasSurface() || !canDraw)) &#123; if (!mContext-&gt;hasSurface()) &#123; mSyncResult |= SyncResult::LostSurfaceRewardIfFound; &#125; else &#123; // If we have a surface but can't draw we must be stopped mSyncResult |= SyncResult::ContextIsStopped; &#125; info.out.canDrawThisFrame = false; &#125; if (info.out.hasAnimations) &#123; if (info.out.requiresUiRedraw) &#123; mSyncResult |= SyncResult::UIRedrawRequired; &#125; &#125; if (!info.out.canDrawThisFrame) &#123; mSyncResult |= SyncResult::FrameDropped; &#125; // If prepareTextures is false, we ran out of texture cache space return info.prepareTextures;&#125; prepareTree 调用函数prepareTree： frameworks/base/libs/hwui/renderthread/CanvasContext.cpp1234567891011121314151617181920212223242526272829void CanvasContext::prepareTree(TreeInfo&amp; info, int64_t* uiFrameInfo, int64_t syncQueued, RenderNode* target) &#123; mRenderThread.removeFrameCallback(this);...... mAnimationContext-&gt;startFrame(info.mode); mRenderPipeline-&gt;onPrepareTree(); //Context可能会有多个Node for (const sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123; //即只有Primary的node是 FULL，其他都是实时 info.mode = (node.get() == target ? TreeInfo::MODE_FULL : TreeInfo::MODE_RT_ONLY); //此处遍历，对每个RenderNode都进行prepare node-&gt;prepareTree(info); GL_CHECKPOINT(MODERATE); &#125; mAnimationContext-&gt;runRemainingAnimations(info); GL_CHECKPOINT(MODERATE); freePrefetchedLayers(); GL_CHECKPOINT(MODERATE); mIsDirty = true; //如果窗口已经没有Native Surface，这一帧就丢掉！！ if (CC_UNLIKELY(!hasSurface())) &#123; mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame); info.out.canDrawThisFrame = false; return; &#125;...... &#125; 遍历RenderNode的prepareTree方法： frameworks/base/libs/hwui/RenderNode.cpp12345678910void RenderNode::prepareTree(TreeInfo&amp; info) &#123; ATRACE_CALL(); LOG_ALWAYS_FATAL_IF(!info.damageAccumulator, \"DamageAccumulator missing\"); MarkAndSweepRemoved observer(&amp;info); const int before = info.disableForceDark; //具体实现 prepareTreeImpl(observer, info, false); LOG_ALWAYS_FATAL_IF(before != info.disableForceDark, \"Mis-matched force dark\");&#125; prepareTreeImpl是RenderNode真正进行Prepare的地方。 damageAccumulator是从CanvasContext中传过来的，是CanvasContext的成员，damage的叠加器。主要是用来标记，屏幕的那些区域被破坏了，需要重新绘制，所有的RenderNode累加起来，就是总的。 frameworks/base/libs/hwui/RenderNode.cpp123456789101112131415161718192021void RenderNode::prepareTreeImpl(TreeObserver&amp; observer, TreeInfo&amp; info, bool functorsNeedLayer) &#123; if (mDamageGenerationId == info.damageGenerationId) &#123; info.damageAccumulator-&gt;dirty(DIRTY_MIN, DIRTY_MIN, DIRTY_MAX, DIRTY_MAX); &#125; //Step 1 info.damageAccumulator-&gt;pushTransform(this); if (info.mode == TreeInfo::MODE_FULL) &#123; //property是对RenderNode的描述，也就是对View的描述，比如大小，位置等。 //有两个状态，正在使用的syncProperties和待处理的mStagingProperties。 //syncProperties时，将mStagingProperties赋值给syncProperties pushStagingPropertiesChanges(info); &#125;...... pushLayerUpdate(info); if (!mProperties.getAllowForceDark()) &#123; info.disableForceDark--; &#125; info.damageAccumulator-&gt;popTransform();&#125; 调用pushTransform函数，damage累加器中，每一个元素由DirtyStack描述，分两种类型：TransformMatrix4和TransformRenderNode。采用一个双向链表mHead进行管理。 frameworks/base/libs/hwui/DamageAccumulator.cpp12345678910111213141516void DamageAccumulator::pushCommon() &#123; if (!mHead-&gt;next) &#123; DirtyStack* nextFrame = mAllocator.create_trivial&lt;DirtyStack&gt;(); nextFrame-&gt;next = nullptr; nextFrame-&gt;prev = mHead; mHead-&gt;next = nextFrame; &#125; mHead = mHead-&gt;next; mHead-&gt;pendingDirty.setEmpty();&#125;void DamageAccumulator::pushTransform(const RenderNode* transform) &#123; pushCommon(); mHead-&gt;type = TransformRenderNode; mHead-&gt;renderNode = transform;&#125; 此时prepare完成后，绘制一帧的数据就准备好了。 绘制帧数据 从syncAndDrawFrame绘制帧上面的章节，此处会调用到HardwareRenderer.java父类函数； 然后JNI到Native层，调用到RenderProxy.cpp的该函数， 再到frameworks/base/libs/hwui/renderthread/DrawFrameTask.cpp的drawFrame函数，开始绘制一帧数据， 此时启动RenderThread线程的run函数，调用到关键函数CanvasContext::draw() Android Q中，具体绘制是在各自的pipeline中进行的。（在frameworks/base/libs/hwui/pipeline/） 在Android P中，一般是执行的frameworks/base/libs/hwui/renderthread/OpenGLPipeline.cpp 在Android Q中，可以看出Google在慢慢用Vulkan替代OpenGL。 frameworks/base/libs/hwui/renderthread/CanvasContext.cpp123456789101112131415161718192021222324252627282930void CanvasContext::draw() &#123; SkRect dirty; mDamageAccumulator.finish(&amp;dirty); //跳过绘制条件：脏区域为空、空帧数据、不需要重绘 if (dirty.isEmpty() &amp;&amp; Properties::skipEmptyFrames &amp;&amp; !surfaceRequiresRedraw()) &#123; mCurrentFrameInfo-&gt;addFlag(FrameInfoFlags::SkippedFrame); return; &#125;...... mCurrentFrameInfo-&gt;markIssueDrawCommandsStart(); //获取frame(一帧数据信息，主要是ufferAge、Surface等) Frame frame = mRenderPipeline-&gt;getFrame(); setPresentTime(); SkRect windowDirty = computeDirtyRect(frame, &amp;dirty); //绘制 bool drew = mRenderPipeline-&gt;draw(frame, windowDirty, dirty, mLightGeometry, &amp;mLayerUpdateQueue, mContentDrawBounds, mOpaque, mLightInfo, mRenderNodes, &amp;(profiler())); int64_t frameCompleteNr = mFrameCompleteCallbacks.size() ? getFrameNumber() : -1; waitOnFences(); bool requireSwap = false; //绘制完成后调用 bool didSwap = mRenderPipeline-&gt;swapBuffers(frame, drew, windowDirty, mCurrentFrameInfo, &amp;requireSwap);......&#125; 绘制完成后unlockCanvasAndPost流程回到绘制案例，此时，RenderThread，DrawFrameTask，CanvasContext等已经就绪，绘制操纵已经被添加到了DisplayList中。 绘制完成，然后会在frameworks/base/tests/HwAccelerationTest/src/com/android/test/hwui/HardwareCanvasSurfaceViewActivity.java中调用到方法unlockCanvasAndPost。 SurfaceHolder直接调的Surface的unlockCanvasAndPost。 frameworks/base/core/java/android/view/Surface.java123456789101112131415161718192021222324252627 public void unlockCanvasAndPost(Canvas canvas) &#123; synchronized (mLock) &#123; checkNotReleasedLocked(); if (mHwuiContext != null) &#123; //硬件加速执行此处 mHwuiContext.unlockAndPost(canvas); &#125; else &#123; //软件绘制 unlockSwCanvasAndPost(canvas); &#125; &#125; &#125;private final class HwuiContext &#123; ...... //HwuiContext的unlockAndPost函数 void unlockAndPost(Canvas canvas) &#123; if (canvas != mCanvas) &#123; throw new IllegalArgumentException(\"canvas object must be the same instance that \" + \"was previously returned by lockCanvas\"); &#125; mRenderNode.endRecording(); mCanvas = null; nHwuiDraw(mHwuiRenderer); &#125;&#125; 上面代码看到，在lockHardwareCanvas的时候有相同流程，会调用mRenderNode.beginRecording。 此处就对应的调用到mRenderNode.endRecording();，结束RenderNode，保存数据。 frameworks/base/graphics/java/android/graphics/RenderNode.java12345678910111213public void endRecording() &#123; if (mCurrentRecordingCanvas == null) &#123; throw new IllegalStateException( \"No recording in progress, forgot to call #beginRecording()?\"); &#125; RecordingCanvas canvas = mCurrentRecordingCanvas; mCurrentRecordingCanvas = null; //Step1 先结束Canvas的录制 long displayList = canvas.finishRecording(); //Step2 然后将录制的list给mNativeRenderNode nSetDisplayList(mNativeRenderNode, displayList); canvas.recycle(); &#125; 首先finishRecording函数通过JIN层android_view_DisplayListCanvas.cpp调用到Native层。 返回录制好的mDisplayList。 frameworks/base/libs/hwui/pipeline/skia/SkiaRecordingCanvas.cpp123456uirenderer::DisplayList* SkiaRecordingCanvas::finishRecording() &#123; // close any existing chunks if necessary insertReorderBarrier(false); mRecorder.restoreToCount(1); return mDisplayList.release();&#125; 第二步的nSetDisplayList通过JNI层android_view_RenderNode.cpp调用到Native层。 将displayList给到RenderNode的mStagingDisplayList。 frameworks/base/libs/hwui/RenderNode.cpp123456void RenderNode::setStagingDisplayList(DisplayList* displayList) &#123; mValid = (displayList != nullptr); mNeedsDisplayListSync = true; delete mStagingDisplayList; mStagingDisplayList = displayList;&#125; Activity HWUI渲染环境初始化流程（RenderThreadc创建） 主要是通过setView创建rendernode，渲染线程RenderThread，Context上下文，RenderProxy代理对象等。 附序列图 Java层 Activity.java开始设置view： frameworks/base/core/java/android/app/Activity.java12345678public Window getWindow() &#123; return mWindow; &#125;public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar(); &#125; PhoneWindow继承Window抽象类调用setContentView函数： frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java123456789101112131415161718192021222324252627282930313233public class PhoneWindow extends Window implements MenuBuilder.Callback &#123;...@Override public void setContentView(View view) &#123; //新对象ViewGroup setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; @Override public void setContentView(View view, ViewGroup.LayoutParams params) &#123; if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; //调用此处添加一个view到Parent View中 mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true; &#125;...&#125; 此处的mContentParent.addView(view, params);，mContentParent是ViewGroup类型对象。 ViewGroup实现接口ViewManager，而interface WindowManager extends ViewManager，WindowManagerImpl.java又是接口WindowManager的实现类。所以会同时调用WindowManagerImpl类的addView函数。 WindowManagerImpl.java调用addView函数。 frameworks/base/core/java/android/view/WindowManagerImpl.java12345@Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow); &#125; 调用windowManagerGlobal的addView函数。 frameworks/base/core/java/android/view/WindowManagerGlobal.java12345678910111213141516171819public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... // do this last because it fires off messages to start doing things try &#123; //调用ViewRootImpl的setView函数 root.setView(view, wparams, panelParentView); &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125; ViewRootImpl.java中调用流程： frameworks/base/core/java/android/view/ViewRootImpl.java123456789101112131415161718192021222324252627282930313233343536/** * We have one child */public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; //设置根节点视图（顶层视图） mView = view; ... // If the application owns the surface, don't enable hardware acceleration if (mSurfaceHolder == null) &#123; // While this is supposed to enable only, it can effectively disable // the acceleration too. //启动硬件加速！ enableHardwareAcceleration(attrs); final boolean useMTRenderer = MT_RENDERER_AVAILABLE &amp;&amp; mAttachInfo.mThreadedRenderer != null; if (mUseMTRenderer != useMTRenderer) &#123; // Shouldn't be resizing, as it's done only in window setup, // but end just in case. endDragResizing(); mUseMTRenderer = useMTRenderer; ... &#125; &#125; &#125; &#125;&#125;@UnsupportedAppUsageprivate void enableHardwareAcceleration(WindowManager.LayoutParams attrs) &#123; ... mAttachInfo.mThreadedRenderer = ThreadedRenderer.create(mContext, translucent, attrs.getTitle().toString()); ...&#125; 在ThreadedRenderer的create函数中new了一个该对象，从而调用其构造函数。构造函数的super()调用基类HardwareRenderer的构造函数。 frameworks/base/graphics/java/android/graphics/HardwareRenderer.java1234567891011121314151617/** * Creates a new instance of a HardwareRenderer. The HardwareRenderer will default * to opaque with no light source configured. */ //创建硬件渲染rendernode对象public HardwareRenderer() &#123; //创建一个窗口的Root Render Node，并用Java层的RenderNode封装起来，即adopt通过new对象返回一个java层的RenderNode对象 mRootNode = RenderNode.adopt(nCreateRootRenderNode()); mRootNode.setClipToBounds(false); //调用到JNI层，创建一个RenderProxy（即MainThread的代理对象） mNativeProxy = nCreateProxy(!mOpaque, mRootNode.mNativeRenderNode); if (mNativeProxy == 0) &#123; throw new OutOfMemoryError(\"Unable to create hardware renderer\"); &#125; Cleaner.create(this, new DestroyContextRunnable(mNativeProxy)); ProcessInitializer.sInstance.init(mNativeProxy);&#125; Native层 从上面的nCreateRootRenderNode函数调用到JNI层的android_view_ThreadedRenderer.cpp文件中。 创建一个窗口的Root Render Node。 之后创建RenderProxy对象。 123456789101112131415static jlong android_view_ThreadedRenderer_createRootRenderNode(JNIEnv* env, jobject clazz) &#123; //new对象 RootRenderNode* node = new RootRenderNode(env); node-&gt;incStrong(0); node-&gt;setName(\"RootRenderNode\"); return reinterpret_cast&lt;jlong&gt;(node);&#125;static jlong android_view_ThreadedRenderer_createProxy(JNIEnv* env, jobject clazz, jboolean translucent, jlong rootRenderNodePtr) &#123; RootRenderNode* rootRenderNode = reinterpret_cast&lt;RootRenderNode*&gt;(rootRenderNodePtr); ContextFactoryImpl factory(rootRenderNode); //new对象 return (jlong) new RenderProxy(translucent, rootRenderNode, &amp;factory);&#125; 之后调用RenderProxy构造函数，就同上面Google原生绘制案例的流程分析相同RenderProxy::RenderProxy(){...}，负责从MainThread向RenderThread发送命令。 参考上面的native层：调用RenderProxy.cpp构造函数和CanvasContext渲染上下文章节 ThreadedRenderer架构图 Activity 窗口绘制流程 由ViewRootImpl的成员函数performTraversals发起。 在绘制之前，首先需要创建一个Surface，即描述一个窗口（创建Surface的流程后续单独整理） 一旦获得对应的Surface， 就需要将其绑定到RenderThread中。 Activity窗口对应的Surface是通过ViewRootImpl类的成员函数relayoutWindow向WindowManagerService服务请求创建和返回的，并且保存在ViewRootImpl类的成员变量mSurface中。 如果Surface是新创建的，将调用ViewRootImpl类的成员变量mAttachInfo指向的AttachInfo函数。对象的成员变量mHardwareRenderer描述的一个HardwareRenderer对象的成员函数initialize将它绑定到RenderThread中。 最后, 如果需要绘制当前的Activity窗口, 那会调用 iewRootImpl类的另外一个成员函数performDraw 此处在performTraversals函数中，先是用relayoutWindow创建mSurface，将Native层之前通过构造函数创建的Surface copy过来。而后是三个主要流程：performMeasure测量、performLayout布局、performDraw绘制 绘制序列图 ViewRootImpl中的软/硬件绘制区分在ViewRootImpl.java的draw函数中： frameworks/base/core/java/android/view/ViewRootImpl.java1234567891011121314151617181920212223242526private boolean draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; if (!surface.isValid()) &#123; return false; &#125; // Draw with hardware renderer. mIsAnimating = false; ... if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mThreadedRenderer != null &amp;&amp; mAttachInfo.mThreadedRenderer.isEnabled()) &#123; ... //硬件加速 mAttachInfo.mThreadedRenderer.draw(mView, mAttachInfo, this); &#125; else &#123; ... //软件绘制 if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; if (DEBUG_DRAW) &#123; Log.v(mTag, \"drawSoftware return: this = \" + this); &#125; return false; &#125; &#125; &#125; drawSoftware中会调用到Surface.java的lockCanvas和unlockCanvasAndPost函数。 frameworks/base/core/java/android/view/Surface.java123456789101112131415161718192021222324public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123; synchronized (mLock) &#123; /// M: add for white list @&#123; //如果在白名单，则返回，仍使用硬件绘制 if (mSurfaceExt.isInWhiteList()) &#123; return lockHardwareCanvas(); &#125; /// @&#125; ... mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas; &#125; &#125;private void unlockSwCanvasAndPost(Canvas canvas) &#123; ...... try &#123; nativeUnlockCanvasAndPost(mLockedObject, canvas); &#125; finally &#123; nativeRelease(mLockedObject); mLockedObject = 0; &#125; &#125; 初始化DisplayList updateRootDisplayList方法的作用是先初始化DIsplayList（即调用beginRecording，流程同上面案例中的分析），然后绘制整个树型视图结构，从顶层视图开始，每个视图节点逐一绘制，最终目的是触发每个视图的Canvas#draw***方法。 syncAndDrawFrame查看上面章节绘制准备，同步帧 updateRootDisplayList方法分成两步： 先顶层视图结构遍历绘制，更新DisplayList数据， 第二步是ThreadedRenderer的根RenderNode绘制，同样，通过根RenderNode创建DisplayListCanvas，通过它的drawRenderNode方法，负责绘制顶层视图DecorView的RenderNode节点。 frameworks/base/core/java/android/view/ThreadedRenderer.java123456789101112131415161718192021222324252627282930313233343536373839void draw(View view, AttachInfo attachInfo, DrawCallbacks callbacks) &#123; final Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer; choreographer.mFrameInfo.markDrawStart(); // updateRootDisplayList(view, callbacks); ... //同步帧数据，最终目的OpenGL指令写入gpu int syncResult = syncAndDrawFrame(choreographer.mFrameInfo); ... &#125;private void updateRootDisplayList(View view, DrawCallbacks callbacks) &#123; //Step1 初始化DisplayList，从顶层视图开始，更新所有视图的DisplayList updateViewTreeDisplayList(view); //Step2 根节点绘制顶层视图RenderNode if (mRootNodeNeedsUpdate || !mRootNode.hasDisplayList()) &#123; //参考上面目录`beginRecording创建DisplayList`小节 RecordingCanvas canvas = mRootNode.beginRecording(mSurfaceWidth, mSurfaceHeight); try &#123; final int saveCount = canvas.save(); canvas.translate(mInsetLeft, mInsetTop); callbacks.onPreDraw(canvas); canvas.enableZ(); //此处还会调用一次根View的updateDisplayListIfDirty方法，不会再进行一次View树绘制 //这时的view还是DecorView，它的DisplayListCanvas已经end结束记录 //并且，View的RenderNode节点mValid已有效，且mRecreateDisplayList标志已被恢复。 canvas.drawRenderNode(view.updateDisplayListIfDirty()); canvas.disableZ(); callbacks.onPostDraw(canvas); canvas.restoreToCount(saveCount); mRootNodeNeedsUpdate = false; &#125; finally &#123; mRootNode.endRecording(); &#125; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; 绘制view视图 参考上面目录beginRecording初始化DisplayList小节 updateViewTreeDisplayList方法，从顶层视图DecorView开始，遍历树形视图结构的每一个节点，利用视图内的RenderNode创建Canvas，绘制。 利用ThreadedRenderer的根RootRenderNode创建Canvas，绘制顶层RenderNode节点 frameworks/base/core/java/android/view/ThreadedRenderer.java12345678910111213private void updateViewTreeDisplayList(View view) &#123; view.mPrivateFlags |= View.PFLAG_DRAWN; //判断视图的PFLAG_INVALIDATED标志 //有这个标志，在调用每个View的updateDisplayListIfDirty()时，才会创建Canvas //当一个视图需要绘制时，上层肯定会设置该标志 //最后会将重建标志还原 view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED) == View.PFLAG_INVALIDATED; view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED; //此处会用到mRecreateDisplayList进行判断是否创建DisplayListCanvas view.updateDisplayListIfDirty(); view.mRecreateDisplayList = false; &#125; 每个视图的流程是一样的，都有三个步骤，第一次绘制时，每个视图都要建立Canvas。 通过视图RenderNode节点start方法，创建DisplayListCanvas画布对象（调用beginRecording，流程同上面案例中的分析） 通过View的draw(canvas)方法，实现具体记录绘制操作，(绘制自身与派发)，draw方法包括很多步骤，包括递归到子视图的updateDisplayListIfDirty方法。 最后，RenderNode结束记录endRecording方法。 draw实现视图绘制六个步骤第二步的draw实现视图绘制。参数就是上面创建的DisplayListConvas画布，视图有一些公用绘制，例如背景，滚定条，修饰等。 frameworks/base/core/java/android/view/View.java123public void draw(Canvas canvas) &#123; ......&#125; 具体视图绘制六个步骤： 绘制背景:drawBackground(canvas) 这里会先得到一个mBGDrawable对象 然后根据layout过程确定的视图位置来设置背景的绘制区域 之后再调用Drawable的draw()方法来完成背景的绘制工作 必要时保存canvas的layers，绘制边缘fade onDraw方法：绘制视图内容，调用Canvas API，此处是空方法，子类会实现。例如TextView、ImageView等类的源码，它们都有重写onDraw()这个方法，并且在里面执行了相当不少的绘制逻辑。绘制的方式主要是借助Canvas这个类，它会作为参数传入到onDraw()方法中，供给每个视图使用，可以将其当成一块画布 下面有个APP代码案例 dispatchDraw派发绘制子视图，空方法，容器类视图会重写。如果有跳过标志，将不会来到draw方法，直接去dispatchDraw。 frameworks/base/core/java/android/view/ViewGroup.java12345678910111213@Overrideprotected void dispatchDraw(Canvas canvas) &#123; for (int i = 0; i &lt; childrenCount; i++) &#123; if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) &#123; more |= drawChild(canvas, child, drawingTime); &#125; &#125;&#125;protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123; return child.draw(canvas, this, drawingTime);&#125; 此处调用View.java的三个参数的draw函数中，也会调用updateDisplayListIfDirty()函数。并且如果是硬件绘制会重新判断mRecreateDisplayList。 这样就实现了View视图的递归绘制。 12345678910boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) &#123; ... if (hardwareAcceleratedCanvas) &#123; // Clear INVALIDATED flag to allow invalidation to occur during rendering, but // retain the flag's value temporarily in the mRecreateDisplayList flag mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0; mPrivateFlags &amp;= ~PFLAG_INVALIDATED; &#125; ...&#125; 如有绘制fading edges，恢复canvas’ layers。 绘制修饰，如滚动条。 APP绘制案例代码 假如APP代码中创建一个非常简单的视图，并且用Canvas随便绘制了一点东西，代码如下所示： 1234567891011121314151617public class MyView extends View &#123; private Paint mPaint; public MyView(Context context, AttributeSet attrs) &#123; super(context, attrs); mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); &#125; @Override protected void onDraw(Canvas canvas) &#123; mPaint.setColor(Color.YELLOW); canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint); mPaint.setColor(Color.BLUE); mPaint.setTextSize(20); String text = \"Hello View\"; canvas.drawText(text, 0, getHeight() / 2, mPaint); &#125;&#125; 此处创建了一个自定义的MyView继承自View，并在MyView的构造函数中创建了一个Paint对象。Paint就像是一个画笔一样，配合着Canvas就可以进行绘制。 绘制逻辑比较简单，在onDraw()方法中先是把画笔设置成黄色，然后调用Canvas的drawRect()方法绘制一个矩形。然后在把画笔设置成蓝色，并调整了一下文字的大小，然后调用drawText()方法绘制了一段文字。 然后在XML布局假如这个视图，将MyView的宽度设置成200dp，高度设置成100dp。 123456789&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;com.example.diyview.MyView android:layout_width=\"200dp\" android:layout_height=\"100dp\" /&gt;&lt;/LinearLayout&gt; 关闭硬件加速android提供了以下四个级别的硬件加速控制： Application：&lt;application android:hardwareAccelerated=&quot;true&quot; ...&gt; Activity：例如启用全局的硬件加速，但却禁止了一个Activity的硬件加速： 1234&lt;application android:hardwareAccelerated=\"true\"&gt; &lt;activity ... /&gt; &lt;activity android:hardwareAccelerated=\"false\" /&gt;&lt;/application&gt; Window：针对给定的Window来启用硬件加速： 123getWindow().setFlags( WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED, WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED); View级别：针对一个独立的View对象使用下列代码来禁止硬件加速：myView.setLayerType(View.LAYER_TYPE_SOFTWARE, null); android关闭硬件加速的方法： APK中，在AndroidManifest.xml中设置android:hardwareAccelerated=&quot;false&quot;，这是关闭整个app的硬件加速，慎用！ View有个方法支持单独的View关闭硬件加速，可以设置mView.setLaterType(View.LAYER_TYPE_SOFTWARE);，或者关闭某一个控件的硬件加速功能使用findViewById(R.id.btn).setLayerType(View.LAYER_TYPE_SOFTWARE,null); 总结 在Java层，硬件渲染由ThreadedRenderer负责，每个窗体根视图ViewRootImpl下都有一个ThreadedRenderer，保存在AttachInfo，它的draw方法是硬件渲染绘制的入口。 从ViewRootImpl开始，一般视图会创建ThreadedRenderer，启用硬件渲染，关键点在遍历每一个视图，根据视图RenderNode创建画布，有效绘制记录存储在RenderNode关联的底层DisplayListData 绘制架构包含RenderNode节点，DisplayListCanvas画布，底层DisplayListData对象，CanvasState状态存储对象，做完这些初始化工作，就可以在Java层画布上执行绘制操作方法。树形视图结构每一节点都有一个DisplayListCanvas，利用Canvas#drawXxx方法分别记录一些绘制操作，drawXxx画点、圆、矩形等操作，将这些操作存储在一个DisplayList集合中，这是App的UI线程负责的任务 onDraw方法自己在APP中重写，View和ViewGroup有什么自己需要的绘制在这里完成。 View的dispatchDraw是空方法，不做任何操作。ViewGroup重写dispatchDraw方法，实现绘制派发到子视图。容器视图一般没有自己要绘制的东西，可能在updateDisplayListIfDirty方法就已经选择dispatchDraw了； 顶层视图绘制入口是draw(一个参数)方法，在draw(一个参数)中，包含六个步骤，第四步会派发每个子视图，子视图绘制入口是draw(三个参数)，在draw(三个参数)中，会根据硬件渲染，进入每个子视图updateDisplayListIfDirty方法，实现递归绘制； 当走到RenderNode的endRecording方法时，表示视图本身以及子视图已经全部绘制完毕，也就是说当DecorView的RenderNode#end方准备执行时，所有draw已经完成 View构造方法创建每一个视图的RenderNode。每一个RenderNode都会创建DisplayListCanvas，使用时是一一对应关系； 相关参考 Android Q AOSP： http://aosp.opersys.com/xref/android-10.0.0_r39/ Android P 图像显示系统（三）Android HWUI 绘制流程： https://www.jianshu.com/p/abfaea892611 硬件渲染一绘制阶段上层基本流程：https://www.jianshu.com/p/85d38ef937e9 Android视图绘制流程之onDraw()：https://www.jianshu.com/p/f0f44cd58711 Android硬件加速（译文）：https://www.jianshu.com/p/601a21b00475","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android ANR traces.txt文件分析","slug":"2020/200611_android_tracetxt","date":"2020-06-11T15:52:00.000Z","updated":"2020-07-22T12:03:21.223Z","comments":true,"path":"2020/06/11/2020/200611_android_tracetxt/","link":"","permalink":"https://alonealive.github.io/Blog/2020/06/11/2020/200611_android_tracetxt/","excerpt":"trace.txt生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。","text":"trace.txt生成:当APP(包括系统APP和用户APP)进程出现ANR、应用响应慢或WatchDog的监视没有得到回馈时,系统会dump此时的top进程,进程中Thread的运行状态就都dump到这个Trace文件中了。 ANR:Application Not Responding，即应用无响应 ANR类型一般有三种类型: KeyDispatchTimeout(5 seconds) –主要类型：按键或触摸事件在特定时间内无响应 BroadcastTimeout(10 seconds) –BroadcastReceiver：在特定时间内无法处理完成 ServiceTimeout(20 seconds) –小概率类型：Service在特定的时间内无法处理完成 另外还有ProviderTimeout和WatchDog看门狗等导致的ANR。 还有当系统内存或CPU资源不足时容易出现ANR， 一般这种情况会有lowmemorykill的log打印。 应用ANR产生的时候，在ActivityManagerService中会调用appNotResponding方法, 然后在/data/anr/traces.txt文件中写入ANR相关信息。 trace.txt获取 adb shell进入手机的/data/anr文件目录下面查看生成的trace.txt文件(如果ls查看文件列表没有权限,可以先adb root一下) adb pull /data/anr/ 将该文件导出,然后分析 log打印了ANR的基本信息(adb shell top查看进程, adb logcat -v process |grep PID查看日志), 可以分析CPU使用率得知ANR的简单情况; 如果CPU使用率很高,接近100%,可能是在进行大规模的计算更可能是陷入死循环; 如果CUP使用率很低,说明主线程被阻塞了,并且当IOwait很高,可能是主线程在等待I/O操作的完成。 对于ANR只是分析Log， 很难知道问题所在,我们还需要通过Trace文件分析stack调用情况,在log中显示的pid在traces文件中与之对应, 然后通过查看堆栈调用信息分析ANR的代码。 注:trace 文件的分析参考 https://blog.csdn.net/qq_25804863/article/details/49111005 Trace分析Traces中显示的线程状态都是C代码定义的，可以通过查看线程状态对应的信息分析ANR问题。 如: TimedWaiting对应的线程状态是TIMED_WAITING； kTimedWaiting, // TIMED_WAITING TS_WAIT in Object.wait() with a timeout执行了无超时参数的wait函数； kSleeping, // TIMED_WAITING TS_SLEEPING in Thread.sleep()执行了带有超时参数的 sleep 函数； ZOMBIE 线程死亡,终止运行 RUNNING/RUNNABLE 线程可运行或正在运行 TIMED_WAIT 执行了带有超时参数的 wait、sleep 或 join 函数 MONITOR 线程阻塞,等待获取对象锁 WAIT 执行了无超时参数的 wait 函数 INITIALIZING 新建,正在初始化,为其分配资源 STARTING 新建,正在启动 NATIVE 正在执行 JNI 本地函数 VMWAIT 正在等待 VM 资源 SUSPENDED 线程暂停,通常是由于 GC 或 debug 被暂停","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"}]},{"title":"Android 开发者选项的“指针位置”坐标值","slug":"2020/200610_android_pointerDraw","date":"2020-06-10T15:52:00.000Z","updated":"2020-06-13T13:34:23.321Z","comments":true,"path":"2020/06/10/2020/200610_android_pointerDraw/","link":"","permalink":"https://alonealive.github.io/Blog/2020/06/10/2020/200610_android_pointerDraw/","excerpt":"打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？","text":"打开开发者选项中的“指针位置”，界面上方状态栏处会显示当前触屏的X/Y坐标，那么这个坐标值是怎么打印出来的呢？ 代码分析在frameworks/base/core/java/com/android/internal/widget/PointerLocationView.java的onDraw方法中，在触屏的时候会实时打印底层读取的X/Y值。 如下代码（Android Q AOSP源码）,ps.mCoords.x和ps.mCoords.y是底层传递读取的坐标值，float类型。 最后会显示成类似X:500.5 Y:200.6 PointerLocationView.java12345678910111213141516171819202122232425262728293031@Overrideprotected void onDraw(Canvas canvas) &#123; final int w = getWidth(); final int itemW = w/7; final int base = -mTextMetrics.ascent+1; final int bottom = mHeaderBottom; final int NP = mPointers.size(); // Labels if (mActivePointerId &gt;= 0) &#123; final PointerState ps = mPointers.get(mActivePointerId); canvas.drawRect(0, 0, itemW-1, bottom,mTextBackgroundPaint); canvas.drawText(mText.clear() .append(\"P: \").append(mCurNumPointers) .append(\" / \").append(mMaxNumPointers) .toString(), 1, base, mTextPaint); final int N = ps.mTraceCount; if ((mCurDown &amp;&amp; ps.mCurDown) || N == 0) &#123; canvas.drawRect(itemW, 0, (itemW * 2) - 1, bottom, mTextBackgroundPaint); canvas.drawText(mText.clear() .append(\"X: \").append(ps.mCoords.x, 1) .toString(), 1 + itemW, base, mTextPaint); canvas.drawRect(itemW * 2, 0, (itemW * 3) - 1, bottom, mTextBackgroundPaint); canvas.drawText(mText.clear() .append(\"Y: \").append(ps.mCoords.y, 1) .toString(), 1 + itemW * 2, base, mTextPaint); &#125;...... 问题案例问题描述 如果此时设备的分辨率是1080x2340，“指针位置”坐标值边缘滑动需要显示到1079x2339。而现在出现了问题：在竖屏的时候只能显示到1078x2338，横屏（两种横屏情况）只能显示到1079x2338和1078xz2339？此处如何进行修改？ 分析首先要对此处读取的ps.mCoords.x和ps.mCoords.y值打印，发现在滑动到边缘的时候，应该显示1079，打印的值大约是1078.0001；应该显示2339的时候，打印的值大约是2038.0001。 所以在此处需要判断，在大于1078或2339的时候，使用进一法，将其作加一操作。 同时还要考虑到横屏和竖屏两种状态。 修改因为PointerLocationView.java继承view.java，可以使用getResources().getConfiguration();来获取设备参数，从而获取到当前横竖屏的状态。 123456789101112131415161718192021222324252627282930313233//如果是true，则对坐标加一操作private boolean mRealX = false;private boolean mRealY = false;//获取当前设备横竖屏状态private int mOrientation;@Overrideprotected void onDraw(Canvas canvas) &#123; ...... //获取横屏、竖屏状态并判断 Configuration mConfiguration = getResources().getConfiguration(); mOrientation = mConfiguration.orientation; if (mOrientation == mConfiguration.ORIENTATION_PORTRAIT) &#123; mRealX = ps.mCoords.x &gt; 972.0f &amp;&amp; ps.mCoords.x &lt; 1079.0f; mRealY = ps.mCoords.y &gt; 2106.0f &amp;&amp; ps.mCoords.y &lt; 2339.0f; &#125; else if (mOrientation == mConfiguration.ORIENTATION_LANDSCAPE) &#123; mRealX = ps.mCoords.x &gt; 2106.0f &amp;&amp; ps.mCoords.x &lt; 2339.0f; mRealY = ps.mCoords.y &gt; 972.0f &amp;&amp; ps.mCoords.y &lt; 1079.0f; &#125; //绘制的时候判断是否加一 canvas.drawText(mText.clear() .append(\"X: \").append(mRealX ? ps.mCoords.x + 1.0f : ps.mCoords.x, 1) .toString(), 1 + itemW, base, mTextPaint); canvas.drawRect(itemW * 2, mHeaderPaddingTop, (itemW * 3) - 1, bottom, mTextBackgroundPaint); canvas.drawText(mText.clear() .append(\"Y: \").append(mRealY ? ps.mCoords.y + 1.0f : ps.mCoords.y, 1) .toString(), 1 + itemW * 2, base, mTextPaint); mRealX = false; mRealY = false; &#125; else &#123;......","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"}]},{"title":"Android 屏幕旋转流程","slug":"2020/200601_android_rotation","date":"2020-06-01T15:52:00.000Z","updated":"2020-06-13T13:34:42.781Z","comments":true,"path":"2020/06/01/2020/200601_android_rotation/","link":"","permalink":"https://alonealive.github.io/Blog/2020/06/01/2020/200601_android_rotation/","excerpt":"Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。","text":"Android支持横屏和竖屏，用户可以选择锁定(rotation lock)也可以选择让传感器来自动转屏。而转屏时为了使用户体验更流畅，会对屏幕截屏，然后使用截屏的图来做转屏动画，直到转屏动作结束。 参考：https://blog.csdn.net/jinzhuojun/article/details/50085491参考：https://blog.csdn.net/kc58236582/article/details/53741445 调试方法打开debug log开关frameworks/base/services/core/java/com/android/server/wm/WindowManagerDebugConfig.java123static final String TAG_WM = \"WindowManager\";static final boolean DEBUG_ORIENTATION = false; //truestatic final boolean DEBUG_APP_ORIENTATION = false; //true adb logcat -v threadtime|grep -Ei &quot;rotation|ActivityTaskManager|WindowOrientationListener&quot; Settings设置开启/关闭自动旋转屏幕是否要自动转屏是在Setting中设置的。为了监听Setting中的改动，系统启动时，PhoneWindowManager的init()函数中创建了SettingsObserver对象。 它的observe()方法会监听Settings.System.USER_ROTATION的值（Android Q中此处没有这个property了）。 123456public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) &#123; ... mSettingsObserver = new SettingsObserver(mHandler); mSettingsObserver.observe(); ... 当用户在Setting中设置自动转屏后，会触发以下流程： public boolean onPreferenceTreeClick(Preference preference)：packages/apps/Settings/src/com/android/settings/accessibility/AccessibilitySettings.java handleLockScreenRotationPreferenceClick()：被调用 setRotationLockForAccessibility(Context context, final boolean enabled) frameworks/base/core/java/com/android/internal/view/RotationPolicy.java1234567public static void setRotationLockForAccessibility(Context context, final boolean enabled) &#123; Settings.System.putIntForUser(context.getContentResolver(), Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? 1 : 0, UserHandle.USER_CURRENT); setRotationLock(enabled, NATURAL_ROTATION);&#125; setRotationLockForAccessibility frameworks/base/core/java/com/android/internal/view/RotationPolicy.java1234567public static void setRotationLockForAccessibility(Context context, final boolean enabled) &#123; Settings.System.putIntForUser(context.getContentResolver(), Settings.System.HIDE_ROTATION_LOCK_TOGGLE_FOR_ACCESSIBILITY, enabled ? 1 : 0, UserHandle.USER_CURRENT); setRotationLock(enabled, NATURAL_ROTATION);&#125; setRotationLock(final boolean enabled, final int rotation)调用wm.freezeRotation或者wm.thawRotation frameworks/base/core/java/com/android/internal/view/RotationPolicy.java1234567891011121314151617private static void setRotationLock(final boolean enabled, final int rotation) &#123; AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; IWindowManager wm = WindowManagerGlobal.getWindowManagerService(); if (enabled) &#123; wm.freezeRotation(rotation); &#125; else &#123; wm.thawRotation(); &#125; &#125; catch (RemoteException exc) &#123; Log.w(TAG, \"Unable to save auto-rotate setting\"); &#125; &#125; &#125;);&#125; thawRotation()，此处在Android Q中有变化。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java12345678910111213141516171819public void thawRotation() &#123; if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION, \"thawRotation()\")) &#123; throw new SecurityException(\"Requires SET_ORIENTATION permission\"); &#125; if (DEBUG_ORIENTATION) Slog.v(TAG_WM, \"thawRotation: mRotation=\" + getDefaultDisplayRotation()); long origId = Binder.clearCallingIdentity(); try &#123; mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_FREE, 777); // rot not used free &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; updateRotationUnchecked(false, false); //查看下面第十步分析 &#125; 而freezeRotation函数，只是调用PhoneWindowManager的setUserRotationMode的参数不一样，这里是Locked，而thawRotation传下去的参数是free。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java1234567891011121314151617181920212223242526@Override public void freezeRotation(int rotation) &#123; // TODO(multi-display): Track which display is rotated. if (!checkCallingPermission(android.Manifest.permission.SET_ORIENTATION, \"freezeRotation()\")) &#123; throw new SecurityException(\"Requires SET_ORIENTATION permission\"); &#125; if (rotation &lt; -1 || rotation &gt; Surface.ROTATION_270) &#123; throw new IllegalArgumentException(\"Rotation argument must be -1 or a valid \" + \"rotation constant.\"); &#125; final int defaultDisplayRotation = getDefaultDisplayRotation(); if (DEBUG_ORIENTATION) Slog.v(TAG_WM, \"freezeRotation: mRotation=\" + defaultDisplayRotation); long origId = Binder.clearCallingIdentity(); try &#123; mPolicy.setUserRotationMode(WindowManagerPolicy.USER_ROTATION_LOCKED, rotation == -1 ? defaultDisplayRotation : rotation); //lock &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; updateRotationUnchecked(false, false); &#125; setUserRotationMode(int mode, int rot)：此处是设置property（即Settings数据库），然后会触发到上面初始化的mSettingsObserver对象的onChange函数。 触发监听SettingsObserver.onChange()， 其中主要调用了updateSettings()和updateRotation()两个函数。 简单地说，主要的工作是根据需要监听传感器数据，据此判断是否要转屏。如果需要就是对configuration的各种更新。过程中会冻结屏幕，同时截屏并以此作为转屏动画。另外还需要将新configuration传给AMS，广播该事件给需要的模块，同时App也会被调度来响应变更。 frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java123456789101112131415161718192021222324252627282930313233343536373839404142 // User rotation: to be used when all else fails in assigning an orientation to the device @Override public void setUserRotationMode(int mode, int rot) &#123; ContentResolver res = mContext.getContentResolver(); // mUserRotationMode and mUserRotation will be assigned by the content observer if (mode == WindowManagerPolicy.USER_ROTATION_LOCKED) &#123; Settings.System.putIntForUser(res, Settings.System.USER_ROTATION, rot, UserHandle.USER_CURRENT); Settings.System.putIntForUser(res, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT); &#125; else &#123; Settings.System.putIntForUser(res, Settings.System.ACCELEROMETER_ROTATION, 1, UserHandle.USER_CURRENT); &#125; &#125;...... @Override public void onChange(boolean selfChange) &#123; updateSettings(); //以下8,9步骤 updateRotation(false); //以下10-步骤 &#125;......public void updateSettings() &#123; ContentResolver resolver = mContext.getContentResolver(); boolean updateRotation = false; synchronized (mLock) &#123; ... int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED; if (mUserRotationMode != userRotationMode) &#123; mUserRotationMode = userRotationMode; updateRotation = true; updateOrientationListenerLp(); //传感器相关操作 &#125; 第一个函数updateSettings()如它的名字主要更新设置信息。 如果UserRotation（朝向信息，如Surface.ROTATION_0）和UserRotationMode（USER_ROTATION_FREE vs. USER_ROTATION_LOCKED）有更新，就设置标记updateRotation为true，表示接下去需要更新rotation相关信息。 此外，如果UserRotationMode的配置有变，由于需要传感器信息的配合，还需调用updateOrientationListenerLp()来设置或取消监听传感器。 这里假设设置为自动旋转，那么PhoneWindowManager会通过MyOrientationListener来监听传感器信息。MyOrientationListener是WindowOrientationListener的继承类。它的enable()函数中调用SensorManager提供的registerListener()接口来设置Sensor信息的listener。 updateOrientationListenerLp()：作用是enable和disable传感器 其中的mOrientationListener.enable和mOrientationListener.disable是注册传感器回调和去除传感器回调。 12345678910111213141516171819202122232425262728293031void updateOrientationListenerLp() &#123; if (!mOrientationListener.canDetectOrientation()) &#123; // If sensor is turned off or nonexistent for some reason return; &#125; if (localLOGV) Slog.v(TAG, \"mScreenOnEarly=\" + mScreenOnEarly + \", mAwake=\" + mAwake + \", mCurrentAppOrientation=\" + mCurrentAppOrientation + \", mOrientationSensorEnabled=\" + mOrientationSensorEnabled + \", mKeyguardDrawComplete=\" + mKeyguardDrawComplete + \", mWindowManagerDrawComplete=\" + mWindowManagerDrawComplete); boolean disable = true; if (mScreenOnEarly &amp;&amp; mAwake &amp;&amp; ((mKeyguardDrawComplete &amp;&amp; mWindowManagerDrawComplete))) &#123; if (needSensorRunningLp()) &#123; disable = false; //enable listener if not already enabled 启动传感器监听！！ if (!mOrientationSensorEnabled) &#123; mOrientationListener.enable(true /* clearCurrentRotation */); if(localLOGV) Slog.v(TAG, \"Enabling listeners\"); mOrientationSensorEnabled = true; &#125; &#125; &#125; //check if sensors need to be disabled if (disable &amp;&amp; mOrientationSensorEnabled) &#123; mOrientationListener.disable(); //关闭传感器 if(localLOGV) Slog.v(TAG, \"Disabling listeners\"); mOrientationSensorEnabled = false; &#125; &#125; mOrientationListener是MyOrientationListener对象，而MyOrientationListener类继承父类WindowOrientationListener，从而会调用父类的enable函数。 该函数中会调用registerListener向SensorManager注册一个监听。 frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java1234567891011121314151617181920212223public void enable(boolean clearCurrentRotation) &#123; synchronized (mLock) &#123; if (mSensor == null) &#123; Slog.w(TAG, \"Cannot detect sensors. Not enabled\"); return; &#125; if (mEnabled) &#123; return; &#125; if (LOG) &#123; Slog.d(TAG, \"WindowOrientationListener enabled clearCurrentRotation=\" + clearCurrentRotation); &#125; mOrientationJudge.resetLocked(clearCurrentRotation); if (mSensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123; mSensorManager.registerListener( mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler); //mOrientationJudge的回调 &#125; else &#123; mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, mHandler); &#125; mEnabled = true; &#125; &#125; registerListener()的具体实现在frameworks/base/core/java/android/hardware/SensorManager.java中。 然后调用SystemSensorManager.java的registerListenerImpl()，其中会创建SensorEventQueue对象（基类为BaseEventQueue），它是传感器事件的队列，记录需要监听哪些传感器信息。 SensorEventQueue queue = mSensorListeners.get(listener); 同时它也负责与SensorService的连接和通信，可以说是SensorEventListener与SensorService间的桥梁。 SensorEventListener和SensorEventQueue之间是1:1的关系，它们的映射关系保存在成员mSensorListeners中。如果这里注册的SensorEventListener还没有相应的SensorEventQueue，则新建一个，然后通过addSensor()方法将要关注的传感器进行注册。这个过程中addSensor()调用了enableSensor()，它最终是通过SensorService的enableDisable()方法来完成注册工作的。 这样，SensorService就开始监听该Sensor，当底层有传感器数据来时，SensorService主线程中会调用相应SensorEventConnection的sendEvents()将之发给对应的Client。 前面初始化SensorEventQueue时会创建Receiver，它是一个Looper的回调对象，在Client端收到从SensorService来的数据后被回调。 当有数据收到时Receiver的handleEvent()被调用，继而通过JNI调用到SystemSensorManager::dispatchSensorEvent()。 接着就调到了WindowOrientationListener的onSensorChanged()函数。该函数计算是否需要转屏。如果需要转屏，将计算结果传给onProposedRotationChanged()。 比如以下函数的日志打印，在旋转手机，传感器会触发屏幕旋转打印这部分log： frameworks/base/services/core/java/com/android/server/policy/WindowOrientationListener.java123456789101112@Override public void onSensorChanged(SensorEvent event) &#123; ...... // Tell the listener. if (proposedRotation != oldProposedRotation &amp;&amp; proposedRotation &gt;= 0) &#123; if (LOG) &#123; Slog.v(TAG, \"Proposed rotation changed! proposedRotation=\" + proposedRotation + \", oldProposedRotation=\" + oldProposedRotation); &#125; onProposedRotationChanged(proposedRotation); &#125; &#125; 另一处updateRotation(false)函数会调用到WMS.java，然后调用到updateRotationUnchecked函数。 最终在该函数中调用rotationChanged = displayContent.updateRotationUnchecked(); 屏幕旋转假设现在用户转了屏幕，期望转屏事件发生。如上面第九步的代码，onProposedRotationChanged()被调用。 最后就调用其run函数，run函数先会提升性能（cpu频率），然后调用了updateRotation，这个函数一样就到WMS的updateRotationUnchecked函数。 frameworks/base/services/core/java/com/android/server/policy/PhoneWindowManager.java123456789101112131415161718192021222324252627282930313233class MyOrientationListener extends WindowOrientationListener &#123;... private class UpdateRunnable implements Runnable &#123; private final int mRotation; UpdateRunnable(int rotation) &#123; mRotation = rotation; &#125; @Override public void run() &#123; // send interaction hint to improve redraw performance mPowerManagerInternal.powerHint(PowerHint.INTERACTION, 0); if (isRotationChoicePossible(mCurrentAppOrientation)) &#123; final boolean isValid = isValidRotationChoice(mCurrentAppOrientation, mRotation); sendProposedRotationChangeToStatusBarInternal(mRotation, isValid); &#125; else &#123; updateRotation(false); &#125; &#125; &#125; @Override public void onProposedRotationChanged(int rotation) &#123; if (localLOGV) Slog.v(TAG, \"onProposedRotationChanged, rotation=\" + rotation); Runnable r = mRunnableCache.get(rotation, null); if (r == null)&#123; r = new UpdateRunnable(rotation); mRunnableCache.put(rotation, r); &#125; mHandler.post(r); //发送了一个消息 &#125; &#125; updateRotation()中主要是执行两个函数：updateRotationUnchecked()（displayContent.updateRotationUnchecked()）和sendNewConfiguration()。前者执行转屏动作，包含转屏动画等。后者使AMS获取当前新的configuration，并且广播该事件给所有相应的listener。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java12345678910111213141516171819202122232425262728293031323334 @Override public void updateRotation(boolean alwaysSendConfiguration, boolean forceRelayout) &#123; updateRotationUnchecked(alwaysSendConfiguration, forceRelayout);&#125; //上面settings中设置自动旋转屏幕也会调用到（thawRotation和freezeRotation函数） private void updateRotationUnchecked(boolean alwaysSendConfiguration, boolean forceRelayout) &#123; if(DEBUG_ORIENTATION) Slog.v(TAG_WM, \"updateRotationUnchecked:\" + \" alwaysSendConfiguration=\" + alwaysSendConfiguration + \" forceRelayout=\" + forceRelayout); ... try &#123; // TODO(multi-display): Update rotation for different displays separately. final boolean rotationChanged; final int displayId; synchronized (mWindowMap) &#123; final DisplayContent displayContent = getDefaultDisplayContentLocked(); Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"updateRotation: display\"); //Step 1 rotationChanged = displayContent.updateRotationUnchecked(); ... &#125; if (rotationChanged || alwaysSendConfiguration) &#123; Trace.traceBegin(TRACE_TAG_WINDOW_MANAGER, \"updateRotation: sendNewConfiguration\"); //Step 2 sendNewConfiguration(displayId); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; finally &#123; Binder.restoreCallingIdentity(origId); Trace.traceEnd(TRACE_TAG_WINDOW_MANAGER); &#125; &#125; Note:: 其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的updateOrientationFromAppTokensLocked()方法）。 updateRotationUnchecked函数frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java1234567891011121314151617181920212223242526boolean updateRotationUnchecked(boolean forceUpdate) &#123; final int oldRotation = mRotation; final int lastOrientation = mLastOrientation; final boolean oldAltOrientation = mAltOrientation; //先调用PhoneWindowManager的rotationForOrientationLw函数来获取rotation，然后与之前的mRotation对比是否有变化 //没有变化直接返回false。有变化将mRotation重新赋值 //函数rotationForOrientationLw作用：获取sensor的rotation，然后计算返回我们需要的rotation final int rotation = mService.mPolicy.rotationForOrientationLw(lastOrientation, oldRotation, isDefaultDisplay); if (DEBUG_ORIENTATION) Slog.v(TAG_WM, \"Computed rotation=\" + rotation + \" for display id=\" + mDisplayId + \" based on lastOrientation=\" + lastOrientation + \" and oldRotation=\" + oldRotation);... if (oldRotation == rotation &amp;&amp; oldAltOrientation == altOrientation) &#123; //没有变化 // No change. return false; &#125; ... mRotation = rotation; //有变化则赋值 mAltOrientation = altOrientation; ... updateDisplayAndOrientation(getConfiguration().uiMode); ... mService.mDisplayManagerInternal.performTraversal(getPendingTransaction()); ...&#125; updateDisplayAndOrientation函数还会调用到updateDisplayAndOrientation函数，会把各种数据更新下放到DisplayInfo中，最后调用了DisplayManagerService的setDisplayInfoOverrideFromWindowManager函数。 frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java12345678910111213141516171819202122232425262728293031323334private DisplayInfo updateDisplayAndOrientation(int uiMode) &#123; // Use the effective \"visual\" dimensions based on current rotation final boolean rotated = (mRotation == ROTATION_90 || mRotation == ROTATION_270); final int realdw = rotated ? mBaseDisplayHeight : mBaseDisplayWidth; final int realdh = rotated ? mBaseDisplayWidth : mBaseDisplayHeight; int dw = realdw; int dh = realdh; ... final int appWidth = mService.mPolicy.getNonDecorDisplayWidth(dw, dh, mRotation, uiMode, mDisplayId, displayCutout); final int appHeight = mService.mPolicy.getNonDecorDisplayHeight(dw, dh, mRotation, uiMode, mDisplayId, displayCutout); mDisplayInfo.rotation = mRotation; mDisplayInfo.logicalWidth = dw; mDisplayInfo.logicalHeight = dh; mDisplayInfo.logicalDensityDpi = mBaseDisplayDensity; mDisplayInfo.appWidth = appWidth; mDisplayInfo.appHeight = appHeight; if (isDefaultDisplay) &#123; mDisplayInfo.getLogicalMetrics(mRealDisplayMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, null); &#125; mDisplayInfo.displayCutout = displayCutout.isEmpty() ? null : displayCutout; mDisplayInfo.getAppMetrics(mDisplayMetrics); if (mDisplayScalingDisabled) &#123; mDisplayInfo.flags |= Display.FLAG_SCALING_DISABLED; &#125; else &#123; mDisplayInfo.flags &amp;= ~Display.FLAG_SCALING_DISABLED; &#125; ... mService.mDisplayManagerInternal.setDisplayInfoOverrideFromWindowManager(mDisplayId, overrideDisplayInfo); ... &#125; setDisplayInfoOverrideFromWindowManager会调用setDisplayInfoOverrideFromWindowManagerInternal，然后调用display.setDisplayInfoOverrideFromWindowManagerLocked(info)函数，最后到LogicalDisplay的setDisplayInfoOverrideFromWindowManagerLocked函数中，把DisplayInfo数据放到了mOverrideDisplayInfo中。 frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java12345678910111213141516171819public boolean setDisplayInfoOverrideFromWindowManagerLocked(DisplayInfo info) &#123; if (info != null) &#123; if (mOverrideDisplayInfo == null) &#123; mOverrideDisplayInfo = new DisplayInfo(info); mInfo = null; return true; &#125; if (!mOverrideDisplayInfo.equals(info)) &#123; mOverrideDisplayInfo.copyFrom(info); //拷贝到mOverrideDisplayInfo中 mInfo = null; return true; &#125; &#125; else if (mOverrideDisplayInfo != null) &#123; mOverrideDisplayInfo = null; mInfo = null; return true; &#125; return false; &#125; performTraversal处理显示Layer的大小宽高尺寸调用到DisplayManagerService.java中，然后调用performTraversalInternal函数。 frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java12345678910111213141516171819202122232425262728293031323334353637383940414243 void performTraversalInternal(SurfaceControl.Transaction t) &#123; synchronized (mSyncRoot) &#123; if (!mPendingTraversal) &#123; return; &#125; mPendingTraversal = false; //遍历所有的Device performTraversalLocked(t); &#125; // List is self-synchronized copy-on-write. for (DisplayTransactionListener listener : mDisplayTransactionListeners) &#123; listener.onDisplayTransaction(); &#125; &#125;private void performTraversalLocked(SurfaceControl.Transaction t) &#123; // Clear all viewports before configuring displays so that we can keep // track of which ones we have configured. clearViewportsLocked(); // 遍历所有的Device final int count = mDisplayDevices.size(); for (int i = 0; i &lt; count; i++) &#123; DisplayDevice device = mDisplayDevices.get(i); //step 1：找到那个LogicalDisplay 然后调用其configureDisplayInTransactionLocked函数（看上面的将参数赋值到mOverrideDisplayInfo中） configureDisplayLocked(t, device); //step 2:调用了各个Device的performTraversalInTransactionLocked，而普通的Device的为空 device.performTraversalLocked(t); &#125; // Tell the input system about these new viewports. if (mInputManagerInternal != null) &#123; mHandler.sendEmptyMessage(MSG_UPDATE_VIEWPORT); &#125; &#125; private void configureDisplayLocked(SurfaceControl.Transaction t, DisplayDevice device) &#123; ... //设置长宽，旋转角度等 display.configureDisplayLocked(t, device, info.state == Display.STATE_OFF); ... &#125; configureDisplayLocked函数的这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layer。 frameworks/base/services/core/java/com/android/server/display/LogicalDisplay.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//这部分代码就是设置layer的显示大小，例如viewport，通过Dump SF可以查看layerpublic void configureDisplayLocked(SurfaceControl.Transaction t, DisplayDevice device, boolean isBlanked) &#123; ... //step 1. 获取mInfo的数据，而mOverrideDisplayInfo如有数据就要copy到mInfo中去 final DisplayInfo displayInfo = getDisplayInfoLocked(); final DisplayDeviceInfo displayDeviceInfo = device.getDisplayDeviceInfoLocked(); // Set the viewport. // This is the area of the logical display that we intend to show on the // display device. For now, it is always the full size of the logical display. mTempLayerStackRect.set(0, 0, displayInfo.logicalWidth, displayInfo.logicalHeight); ... mTempDisplayRect.left += mDisplayOffsetX; mTempDisplayRect.right += mDisplayOffsetX; mTempDisplayRect.top += mDisplayOffsetY; mTempDisplayRect.bottom += mDisplayOffsetY; //step 2 device.setProjectionLocked(t, orientation, mTempLayerStackRect, mTempDisplayRect); &#125;public DisplayInfo getDisplayInfoLocked() &#123; if (mInfo == null) &#123; mInfo = new DisplayInfo(); mInfo.copyFrom(mBaseDisplayInfo); if (mOverrideDisplayInfo != null) &#123; mInfo.appWidth = mOverrideDisplayInfo.appWidth; mInfo.appHeight = mOverrideDisplayInfo.appHeight; mInfo.smallestNominalAppWidth = mOverrideDisplayInfo.smallestNominalAppWidth; mInfo.smallestNominalAppHeight = mOverrideDisplayInfo.smallestNominalAppHeight; mInfo.largestNominalAppWidth = mOverrideDisplayInfo.largestNominalAppWidth; mInfo.largestNominalAppHeight = mOverrideDisplayInfo.largestNominalAppHeight; mInfo.logicalWidth = mOverrideDisplayInfo.logicalWidth; mInfo.logicalHeight = mOverrideDisplayInfo.logicalHeight; mInfo.overscanLeft = mOverrideDisplayInfo.overscanLeft; mInfo.overscanTop = mOverrideDisplayInfo.overscanTop; mInfo.overscanRight = mOverrideDisplayInfo.overscanRight; mInfo.overscanBottom = mOverrideDisplayInfo.overscanBottom; mInfo.rotation = mOverrideDisplayInfo.rotation; mInfo.displayCutout = mOverrideDisplayInfo.displayCutout; mInfo.logicalDensityDpi = mOverrideDisplayInfo.logicalDensityDpi; mInfo.physicalXDpi = mOverrideDisplayInfo.physicalXDpi; mInfo.physicalYDpi = mOverrideDisplayInfo.physicalYDpi; &#125; &#125; return mInfo; &#125; setProjectionLocked会调用SurfaceControl的SurfaceControl函数。然后在SurfaceControl中调用nativeSetDisplayProjection函数，通过JNI调用到Native层。 frameworks/base/services/core/java/com/android/server/display/DisplayDevice.java1234567 public final void setProjectionLocked(SurfaceControl.Transaction t, int orientation, Rect layerStackRect, Rect displayRect) &#123;... t.setDisplayProjection(mDisplayToken, orientation, layerStackRect, displayRect); &#125; &#125; 此时Java层的updateRotationUnchecked函数分析完。 sendNewConfiguration函数从上面的updateRotation()函数中看到，除了调用updateRotationUnchecked()（即displayContent.updateRotationUnchecked()），还会调用sendNewConfiguration()。 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java123456789void sendNewConfiguration(int displayId) &#123; try &#123; final boolean configUpdated = mActivityManager.updateDisplayOverrideConfiguration( null /* values */, displayId);... &#125; &#125; catch (RemoteException e) &#123; &#125; &#125; frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111@Override public boolean updateDisplayOverrideConfiguration(Configuration values, int displayId) &#123; enforceCallingPermission(CHANGE_CONFIGURATION, \"updateDisplayOverrideConfiguration()\"); synchronized (this) &#123; ... if (values == null &amp;&amp; mWindowManager != null) &#123; // sentinel: fetch the current configuration from the window manager //Step 1 获取一些配置信息 values = mWindowManager.computeNewConfiguration(displayId); &#125; final long origId = Binder.clearCallingIdentity(); try &#123; if (values != null) &#123; Settings.System.clearConfiguration(values); &#125; //Step 2 updateDisplayOverrideConfigurationLocked(values, null /* starting */, false /* deferResume */, displayId, mTmpUpdateConfigurationResult); return mTmpUpdateConfigurationResult.changes != 0; &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125; &#125; &#125; private boolean updateDisplayOverrideConfigurationLocked(Configuration values, ActivityRecord starting, boolean deferResume, int displayId, UpdateConfigurationResult result) &#123; ... try &#123; if (values != null) &#123; if (displayId == DEFAULT_DISPLAY) &#123; //Step 1:调用 changes = updateGlobalConfigurationLocked(values, false /* initLocale */, false /* persistent */, UserHandle.USER_NULL /* userId */, deferResume); &#125; else &#123; // changes = performDisplayOverrideConfigUpdate(values, deferResume, displayId); &#125; &#125; //Step 2 kept = ensureConfigAndVisibilityAfterUpdate(starting, changes); &#125; finally &#123; if (mWindowManager != null) &#123; mWindowManager.continueSurfaceLayout(); &#125; &#125; if (result != null) &#123; result.changes = changes; result.activityRelaunched = !kept; &#125; return kept; &#125;private int updateGlobalConfigurationLocked(@NonNull Configuration values, boolean initLocale, boolean persistent, int userId, boolean deferResume) &#123; //把Configuration数据保存在mTempConfig mTempConfig.setTo(getGlobalConfiguration()); final int changes = mTempConfig.updateFrom(values); if (changes == 0) &#123; performDisplayOverrideConfigUpdate(values, deferResume, DEFAULT_DISPLAY); return 0; &#125; //会发送ACTION_CONFIGURATION_CHANGED广播，然后获取当前最上面活动的Activity，调用ActivityStack的ensureActivityConfigurationLocked函数和ActivityStackSupervisor的ensureActivitiesVisibleLocked函数。 Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED); intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_FOREGROUND | Intent.FLAG_RECEIVER_VISIBLE_TO_INSTANT_APPS); broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, OP_NONE, null, false, false, MY_PID, SYSTEM_UID, UserHandle.USER_ALL);...... &#125; private int performDisplayOverrideConfigUpdate(Configuration values, boolean deferResume, int displayId) &#123; mTempConfig.setTo(mStackSupervisor.getDisplayOverrideConfiguration(displayId)); //把Configuration数据保存在mTempConfig final int changes = mTempConfig.updateFrom(values); ... &#125; private boolean ensureConfigAndVisibilityAfterUpdate(ActivityRecord starting, int changes) &#123; boolean kept = true; final ActivityStack mainStack = mStackSupervisor.getFocusedStack(); // mainStack is null during startup. if (mainStack != null) &#123; if (changes != 0 &amp;&amp; starting == null) &#123; // If the configuration changed, and the caller is not already // in the process of starting an activity, then find the top // activity to check if its configuration needs to change. starting = mainStack.topRunningActivityLocked(); &#125; //先后调用两个函数 if (starting != null) &#123; kept = starting.ensureActivityConfiguration(changes, false /* preserveWindow */); // And we need to make sure at this point that all other activities // are made visible with the correct configuration. mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes, !PRESERVE_WINDOWS); &#125; &#125; return kept; &#125; 应用强制设置屏幕方向之前提过，其它途径可能会触发转屏，比如应用请求转屏。例如需要横屏的游戏（通过frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java的updateOrientationFromAppTokensLocked()方法）。 首先调用AMS的setRequestedOrientation函数，然后调用到ActivityRecord的setRequestedOrientation函数。 frameworks/base/services/core/java/com/android/server/am/ActivityRecord.java12345678910111213141516171819void setRequestedOrientation(int requestedOrientation) &#123; final int displayId = getDisplayId(); final Configuration displayConfig = mStackSupervisor.getDisplayOverrideConfiguration(displayId); //Step 1 final Configuration config = mWindowContainerController.setOrientation(requestedOrientation, displayId, displayConfig, mayFreezeScreenLocked(app)); if (config != null) &#123; frozenBeforeDestroy = true; //Step 2：当返回false，就是现在的状态要改变（比如重启Activity） //然后就调用ActivityStackSupervisor的resumeTopActivitiesLocked函数来启动最上面的Activity。 if (!service.updateDisplayOverrideConfigurationLocked(config, this, false /* deferResume */, displayId)) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(); &#125; &#125; service.mTaskChangeNotificationController.notifyActivityRequestedOrientationChanged( task.taskId, requestedOrientation); &#125; 其中调用到frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java的mWindowContainerController.setOrientation函数。 frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java12345678910111213141516public Configuration setOrientation(int requestedOrientation, int displayId, Configuration displayConfig, boolean freezeScreenIfNeeded) &#123; synchronized(mWindowMap) &#123; if (mContainer == null) &#123; Slog.w(TAG_WM, \"Attempted to set orientation of non-existing app token: \" + mToken); return null; &#125; mContainer.setOrientation(requestedOrientation); final IBinder binder = freezeScreenIfNeeded ? mToken.asBinder() : null; //调用WMS的该函数旋转屏幕！！ return mService.updateOrientationFromAppTokens(displayConfig, binder, displayId); &#125; &#125; 该函数调用到WMS的updateOrientationFromAppTokensLocked函数。这个函数先调用另一个updateOrientationFromAppTokensLocked函数，根据这个函数的返回值，返回true代表要旋转，就调用computeNewConfigurationLocked计算Configuration返回。 WMS.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private Configuration updateOrientationFromAppTokensLocked(Configuration currentConfig, IBinder freezeThisOneIfNeeded, int displayId, boolean forceUpdate) &#123; if (!mDisplayReady) &#123; return null; &#125; Configuration config = null; if (updateOrientationFromAppTokensLocked(displayId, forceUpdate)) &#123; // If we changed the orientation but mOrientationChangeComplete is already true, // we used seamless rotation, and we don't need to freeze the screen. if (freezeThisOneIfNeeded != null &amp;&amp; !mRoot.mOrientationChangeComplete) &#123; final AppWindowToken atoken = mRoot.getAppWindowToken(freezeThisOneIfNeeded); if (atoken != null) &#123; atoken.startFreezingScreen(); &#125; &#125; config = computeNewConfigurationLocked(displayId); &#125; else if (currentConfig != null) &#123; ...... &#125; &#125; return config; &#125;boolean updateOrientationFromAppTokensLocked(int displayId, boolean forceUpdate) &#123; long ident = Binder.clearCallingIdentity(); try &#123; final DisplayContent dc = mRoot.getDisplayContent(displayId); //获取上次强制设置的方向 final int req = dc.getOrientation(); //如果和上次设置的方向不同 if (req != dc.getLastOrientation() || forceUpdate) &#123; dc.setLastOrientation(req); //send a message to Policy indicating orientation change to take //action like disabling/enabling sensors etc., // TODO(multi-display): Implement policy for secondary displays. if (dc.isDefaultDisplay) &#123; mPolicy.setCurrentOrientationLw(req); &#125; return dc.updateRotationUnchecked(forceUpdate); &#125; return false; &#125; finally &#123; Binder.restoreCallingIdentity(ident); &#125; &#125; 应用Activity强制设置方向 Activity： 如果要强制设置一个Activity的横竖屏可以通过Manifest去设置，跟Activity相关的信息都会保存在ActivityInfo当中。 12345android:screenOrientation&#x3D;[&quot;unspecified&quot; | &quot;user&quot; | &quot;behind&quot; | &quot;landscape&quot; | &quot;portrait&quot; | &quot;reverseLandscape&quot; | &quot;reversePortrait&quot; | &quot;sensorLandscape&quot; | &quot;sensorPortrait&quot; | &quot;sensor&quot; | &quot;fullSensor&quot; | &quot;nosensor&quot;] Window 如果是要强制设置一个Window的横竖屏可以通过LayoutParams.screenOrientation来设置。在通过WindowManager.addView的时候把对应的LayoutParams传递给WMS。 1WindowManager.LayoutParams.screenOrientation","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"}]},{"title":"Android InputDispatcher获取点击事件","slug":"2020/200520_android_input_notifyMotion","date":"2020-05-20T15:52:00.000Z","updated":"2021-05-31T12:52:52.107Z","comments":true,"path":"2020/05/20/2020/200520_android_input_notifyMotion/","link":"","permalink":"https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/","excerpt":"","text":"Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。参考上一篇《Android 触控事件分析》 Input down/up事件查看在开发者选项打开“显示点按操作反馈”和“指针位置”，通过adb shell getevent -lrt命令，然后点击屏幕可以查看到控制台的打印。 查看帮助：adb shell getevent -h 打印结果包含Input的down/up事件，以及点击点的坐标（十六进制）: 123456789101112[ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TRACKING_ID 0000003b [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_POSITION_X 0000017e &#x2F;&#x2F;横坐标X&#x3D;382 十六进制转成十进制&#x3D;》 1*16*16+7*16+14*1&#x3D;382[ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_POSITION_Y 0000032d &#x2F;&#x2F;纵坐标Y&#x3D;813 十六进制转成十进制&#x3D;》 3*16*16+2*16+13*1&#x3D;813 [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TOUCH_MAJOR 0000000a [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_PRESSURE 000003e8 [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY BTN_TOUCH DOWN [ 1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN SYN_REPORT 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TOUCH_MAJOR 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_PRESSURE 00000000 [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS ABS_MT_TRACKING_ID ffffffff [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY BTN_TOUCH UP [ 1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN SYN_REPORT 00000000 rate 0 systrace分析抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。(参考：《Android 触控事件分析》) input debug开关打开抓取日志分析1234567adb rootadb shell setprop sys.input.TouchFilterEnable trueadb shell setprop sys.input.TouchFilterLogEnable trueadb shell dumpsys window -d enable DEBUG_FOCUSadb shell dumpsys window -d enable DEBUG_INPUTadb shell setprop sys.inputlog.enabled trueadb shell dumpsys input 然后抓取log可以看到类似InputDispatcher: notifyMotion、dispatchMotion这些日志打印。 日志打印分析代码流程inputReader通过QueuedInputListener负责读取触摸事件交给 InputDispatcher 进行事件派发。 首先在构造函数中new一个QueueListener对象： frameworks/native/services/inputflinger/InputReader.cpp123456789101112InputReader::InputReader(const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; policy, const sp&lt;InputListenerInterface&gt;&amp; listener) : mContext(this), mEventHub(eventHub), mPolicy(policy), mNextSequenceNum(1), mGlobalMetaState(0), mGeneration(1), mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX), mConfigurationChangesToRefresh(0) &#123; /// M: for nwk @&#123; void *func; /// @&#125; mQueuedListener = new QueuedInputListener(listener); ...... 在InputReader::loopOnce()循环等待消息 12345678void InputReader::loopOnce() &#123; int32_t oldGeneration; int32_t timeoutMillis; bool inputDevicesChanged = false; std::vector&lt;InputDeviceInfo&gt; inputDevices; ... mQueuedListener-&gt;flush();&#125; flush刷新将遍历QueuedInputListener中mArgsQueue的数组元素，触发每一个元素NotifyArgs的notify方法，交给内部InputDispatcher，清空数组。 frameworks/native/services/inputflinger/InputListener.cpp123456789void QueuedInputListener::flush() &#123; size_t count = mArgsQueue.size(); for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args; &#125; mArgsQueue.clear();&#125; 结构体NotifyMotionArgs/NotifySwitchArgs/NotifyDeviceResetArgs继承自NotifyArgs，所以执行NotifyArgs的notify函数。调用派发者InputDispatcher的通知notifyMotion，将自己交给派发者。 frameworks/native/services/inputflinger/InputListener.cpp123void NotifyMotionArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123; listener-&gt;notifyMotion(this);&#125; InputDispatcher获取数据 触发InputDispatcher.cpp的notifyMotion函数，读取线程InputReaderThread在处理事务，notifyMotion方法之后会唤醒分发线程，接下来的任务就由分发线程处理。 frameworks/native/services/inputflinger/InputDispatcher.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344void InputDispatcher::notifyMotion(const NotifyMotionArgs* args) &#123;#if DEBUG_INBOUND_EVENT_DETAILS //打开了input debug log后会打印以下log ALOGD(\"notifyMotion - eventTime=%\" PRId64 \", deviceId=%d, source=0x%x, displayId=%\" PRId32 \", policyFlags=0x%x, \" \"action=0x%x, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x,\" \"edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%\" PRId64, args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, args-&gt;policyFlags, args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState, args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime); for (uint32_t i = 0; i &lt; args-&gt;pointerCount; i++) &#123; ALOGD(\" Pointer %d: id=%d, toolType=%d, \" \"x=%f, y=%f, pressure=%f, size=%f, \" \"touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, \" \"orientation=%f\", i, args-&gt;pointerProperties[i].id, args-&gt;pointerProperties[i].toolType, args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR), args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION)); &#125;#endif...... // Just enqueue a new motion event. //将NotifyMotionArgs的数据封装为MotionEntry MotionEntry* newEntry = new MotionEntry(args-&gt;sequenceNum, args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags, args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState, args-&gt;classification, args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime, args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, 0, 0); //插入InputDispatcher的mInboundQueue队列中 needWake = enqueueInboundEventLocked(newEntry); mLock.unlock(); &#125; // release lock if (needWake) &#123; //需要唤醒分发线程 mLooper-&gt;wake(); //TODO &#125;&#125; Note：注意：mLooper属于InputDispatcher，InputManager创建InputDispatcher时，在其构造方法同时创建mLooper，创建的线程是服务线程，并非读取或分发线程这里只是借用了Looper提供的epoll唤醒与休眠机制，在分发线程中InputDispatcherThread中使用mLooper休眠，读取线程负责唤醒。 数据封装成MotionEntry，然后作为enqueueInboundEventLocked函数的入参，插入到mInboundQueue队列尾部。 frameworks/native/services/inputflinger/InputDispatcher.cpp1234bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; bool needWake = mInboundQueue.isEmpty(); mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); InputDispatcherThread分发线程被唤醒 参考：http://wizzie.top/2020/05/10/2020/200510_android_inputANR/ 在InputDispatcherThread线程threadLoop循环中，触发InputDispatcher的dispatchOnce方法。然后调用dispatchOnce方法。 frameworks/native/services/inputflinger/InputDispatcher.cpp123456789101112131415161718192021222324252627282930bool InputDispatcherThread::threadLoop() &#123; mDispatcher-&gt;dispatchOnce(); return true;&#125;void InputDispatcher::dispatchOnce() &#123; //下次唤醒事件，设置无限大 nsecs_t nextWakeupTime = LONG_LONG_MAX; &#123; // acquire lock std::scoped_lock _l(mLock); mDispatcherIsAlive.notify_all(); //mCommandQueue为空时，触发dispatchOnceInnerLocked if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; //mCommandQueue为空时是false nextWakeupTime = LONG_LONG_MIN; &#125; &#125; // release lock // Wait for callback or timeout or wake. (make sure we round up, not down) nsecs_t currentTime = now(); //计算下一次唤醒时间，比当前时间大 int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime); mLooper-&gt;pollOnce(timeoutMillis);&#125; 利用Looper在epoll_wait处进入休眠，休眠timeoutMillis时间仍无事件，threadLoop会一直循环，继续dispatchOnce。当被唤醒时，执行switch循环进入dispatchOnceInnerLocked取出队列中的事件。 frameworks/native/services/inputflinger/InputDispatcher.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); ... // Ready to start a new event. // If we don't already have a pending event, go grab one. if (! mPendingEvent) &#123; if (mInboundQueue.isEmpty()) &#123; ... &#125; else &#123; // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.dequeueAtHead(); traceInboundQueueLengthLocked(); &#125; // Poke user activity for this event. if (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123; pokeUserActivityLocked(mPendingEvent); &#125; // Get ready to dispatch the event. resetANRTimeoutsLocked(); &#125; ... //mPendingEvent的type做区分处理，此处对motion事件分析 ALOG_ASSERT(mPendingEvent != nullptr); ... switch (mPendingEvent-&gt;type) &#123; ... case EventEntry::TYPE_MOTION: &#123; MotionEntry* typedEntry = static_cast&lt;MotionEntry*&gt;(mPendingEvent); //如果没有及时响应窗口切换操作 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123; dropReason = DROP_REASON_APP_SWITCH; &#125; //事件过期 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; //阻碍其他窗口获取事件 if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; //此处执行事件 done = dispatchMotionLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; ... Notes:Looper借助epoll机制实现线程休眠，它本身内部有套接字mWakeEventFd，在rebuildEpollLocked建立时，注册到epoll_ctl监听。因此wake方法就是向mWakeEventFd套接字发送一段字符，促使epoll_wait处的线程能监听到，从而InputDispatcherThread线程被唤醒。 InputDispatcher事件处理 InputDispatcher#dispatchMotionLocked处理MotionEntry。此处函数开头会有类似InputDispatcher: dispatchMotion - eventTime= ...的日志打印。 frameworks/native/services/inputflinger/InputDispatcher.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//入参：dropReason代表了事件丢弃的原因，它的默认值为DROP_REASON_NOT_DROPPED，代表事件不被丢弃bool InputDispatcher::dispatchMotionLocked( nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ATRACE_CALL(); //systrace抓取 //*************1**************// // Preprocessing. 即标记当前已经进入分发的过程 if (! entry-&gt;dispatchInProgress) &#123; entry-&gt;dispatchInProgress = true; logOutboundMotionDetails(\"dispatchMotion - \", entry); //log打印 &#125; //*************2**************// // Clean up if dropping the event. 如果事件是需要丢弃的，则返回true，不会去为该事件寻找合适的窗口 if (*dropReason != DROP_REASON_NOT_DROPPED) &#123; setInjectionResult(entry, *dropReason == DROP_REASON_POLICY ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED); return true; //此时就是事件被丢弃了，分发任务就没有完成！ &#125; //**************3*************// bool isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER; // 目标窗口信息列表会存储在inputTargets中 std::vector&lt;InputTarget&gt; inputTargets; bool conflictingPointerActions = false; int32_t injectionResult; //事件处理的结果交由injectionResult if (isPointerEvent) &#123; //1. 处理点击形式的事件，比如触摸屏幕 injectionResult = findTouchedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions); &#125; else &#123; //2. 处理非触摸形式的事件，比如轨迹球 injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); &#125; //**************4*************// //1. 如果injectionResult的值为INPUT_EVENT_INJECTION_PENDING，这说明找到了窗口并且窗口无响应输入事件被挂起，这时就会返回false if (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123; return false; &#125; setInjectionResult(entry, injectionResult); //2. 如果injectionResult的值不为INPUT_EVENT_INJECTION_SUCCEEDED，这说明没有找到合适的窗口，输入事件没有分发成功，这时就会返回true //输入事件被挂起，说明找到了窗口并且窗口无响应 if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123; if (injectionResult != INPUT_EVENT_INJECTION_PERMISSION_DENIED) &#123; CancelationOptions::Mode mode(isPointerEvent ? CancelationOptions::CANCEL_POINTER_EVENTS : CancelationOptions::CANCEL_NON_POINTER_EVENTS); CancelationOptions options(mode, \"input event injection failed\"); synthesizeCancelationEventsForMonitorsLocked(options); &#125; return true; &#125; //**************5*************// //分发目标添加到inputTargets列表中 // Add monitor channels from event's or focused display. addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry)); if (isPointerEvent) &#123; ssize_t stateIndex = mTouchStatesByDisplay.indexOfKey(entry-&gt;displayId); if (stateIndex &gt;= 0) &#123; const TouchState&amp; state = mTouchStatesByDisplay.valueAt(stateIndex); if (!state.portalWindows.empty()) &#123; // The event has gone through these portal windows, so we add monitoring targets of // the corresponding displays as well. for (size_t i = 0; i &lt; state.portalWindows.size(); i++) &#123; const InputWindowInfo* windowInfo = state.portalWindows[i]-&gt;getInfo(); addGlobalMonitoringTargetsLocked(inputTargets, windowInfo-&gt;portalToDisplayId, -windowInfo-&gt;frameLeft, -windowInfo-&gt;frameTop); &#125; &#125; &#125; &#125; // Dispatch the motion. if (conflictingPointerActions) &#123; CancelationOptions options(CancelationOptions::CANCEL_POINTER_EVENTS, \"conflicting pointer actions\"); synthesizeCancelationEventsForAllConnectionsLocked(options); &#125; //将事件分发给inputTargets列表中的目标 dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125;...... InputTarget结构体InputTarget结构体可以说是inputDispatcher与目标窗口的转换器。其分为两大部分： 一个是枚举中存储的inputDispatcher与目标窗口交互的标记， 另一部分是inputDispatcher与目标窗口交互参数，比如： inputChannel，它实际上是一个SocketPair，SocketPair用于进程间双向通信，这非常适合inputDispatcher与目标窗口之间的通信，因为inputDispatcher不仅要将事件分发到目标窗口，同时inputDispatcher也需要得到目标窗口对事件的响应。 xOffset和yOffset，屏幕坐标系相对于目标窗口坐标系的偏移量，MotionEntry(MotionEvent)中的存储的坐标是屏幕坐标系，因此就需要注释2和注释3处的参数，来将屏幕坐标系转换为目标窗口的坐标系。 frameworks/native/services/inputflinger/InputDispatcher.h12345678910111213141516171819struct InputTarget &#123; enum &#123; //此标记表示事件正在交付给前台应用程序 FLAG_FOREGROUND = 1 &lt;&lt; 0, //此标记指示MotionEvent位于目标区域内 FLAG_WINDOW_IS_OBSCURED = 1 &lt;&lt; 1, ... &#125;; //inputDispatcher与目标窗口的通信管道 sp&lt;InputChannel&gt; inputChannel;//1 //事件派发的标记 int32_t flags; //屏幕坐标系相对于目标窗口坐标系的偏移量 float xOffset, yOffset;//2 //屏幕坐标系相对于目标窗口坐标系的缩放系数 float scaleFactor;//3 BitSet32 pointerIds;&#125; 处理点击事件findTouchedWindowTargetsLocked 参考：https://www.codercto.com/a/52484.html在函数dispatchMotionLocked中，会分别对Motion事件中的点击形式事件和非触摸形式事件做了处理。其中点击事件调用函数findTouchedWindowTargetsLocked。 函数末尾会打印类似日志InputDispatcher: findTouchedWindow finished: injectionResult=0, injectionPermission=1, timeSpentWaitingForApplication=0.0ms，injectionResult=0是succeed，injectionPermission=1是允许。 frameworks/native/services/inputflinger/InputDispatcher.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime, const MotionEntry* entry, std::vector&lt;InputTarget&gt;&amp; inputTargets, nsecs_t* nextWakeupTime, bool* outConflictingPointerActions) &#123; ATRACE_CALL(); //systrace... if (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123; /* Case 1: New splittable pointer going down, or need target for hover or scroll. */ //从MotionEntry中获取坐标点 int32_t pointerIndex = getMotionEventActionPointerIndex(action); int32_t x = int32_t(entry-&gt;pointerCoords[pointerIndex]. getAxisValue(AMOTION_EVENT_AXIS_X)); int32_t y = int32_t(entry-&gt;pointerCoords[pointerIndex]. getAxisValue(AMOTION_EVENT_AXIS_Y)); bool isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN; ... //将符合条件的窗口放入TempTouchState中，以便后续处理 mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds); &#125; mTempTouchState.addGestureMonitors(newGestureMonitors); &#125; else &#123; /* Case 2: Pointer move, up, cancel or non-splittable pointer down. */ ... //此处说明窗口已经查找成功 injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED; //为每个mTempTouchState中的窗口生成InputTargets addWindowTargetLocked(focusedWindowHandle, InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(0), inputTargets); // Done. Unresponsive: // Reset temporary touch state to ensure we release unnecessary references to input channels. //重置TempTouchState mTempTouchState.reset(); nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime); updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);#if DEBUG_FOCUS //日志打印输出 ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \" \"timeSpentWaitingForApplication=%0.1fms\", injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);#endif return injectionResult;&#125; dispatchEventLocked向目标窗口发送事件 上面函数dispatchMotionLocked的末尾，会执行dispatchEventLocked函数，将事件分发给inputTargets列表中的分发目标（目标窗口）。 frameworks/native/services/inputflinger/InputDispatcher.cpp12345678910111213141516171819202122232425262728void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const std::vector&lt;InputTarget&gt;&amp; inputTargets) &#123; ATRACE_CALL();#if DEBUG_DISPATCH_CYCLE ALOGD(\"dispatchEventToCurrentInputTargets\");#endif ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); // should already have been set to true pokeUserActivityLocked(eventEntry); //遍历inputTargets列表，获取每一个inputTarget for (const InputTarget&amp; inputTarget : inputTargets) &#123; //1. 根据inputTarget内部的inputChannel来获取Connection的索引 ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; //2. 根据索引，获取保存在mConnectionsByFd容器中的Connection（可以理解为InputDispatcher和目标窗口的连接，其内部包含了连接的状态、InputChannel、InputWindowHandle和事件队列等） sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); //3. 根据inputTarget，开始事件发送循环 prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; else &#123;#if DEBUG_FOCUS ALOGD(\"Dropping event delivery to target with channel '%s' because it \" \"is no longer registered with the input dispatcher.\", inputTarget.inputChannel-&gt;getName().c_str());#endif &#125; &#125;&#125; 开始事件发送，最终会通过inputTarget中的inputChannel和窗口进行进程间通信，最终将Motion事件发送给目标窗口。 123456789101112131415161718void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; if (ATRACE_ENABLED()) &#123; std::string message = StringPrintf( \"prepareDispatchCycleLocked(inputChannel=%s, sequenceNum=%\" PRIu32 \")\", connection-&gt;getInputChannelName().c_str(), eventEntry-&gt;sequenceNum); ATRACE_NAME(message.c_str()); &#125;#if DEBUG_DISPATCH_CYCLE //日志打印！ ALOGD(\"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, \" \"xOffset=%f, yOffset=%f, globalScaleFactor=%f, \" \"windowScaleFactor=(%f, %f), pointerIds=0x%x\", connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags, inputTarget-&gt;xOffset, inputTarget-&gt;yOffset, inputTarget-&gt;globalScaleFactor, inputTarget-&gt;windowXScale, inputTarget-&gt;windowYScale, inputTarget-&gt;pointerIds.value); ... 然后调用startDispatchCycleLocked（在函数dispatchMotionLocked末尾处），最终调用两种事件的connection-&gt;inputPublisher...函数，至此，InputDisapatcher结束。 12345678910111213141516171819202122232425262728293031323334353637void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; if (ATRACE_ENABLED()) &#123; std::string message = StringPrintf(\"startDispatchCycleLocked(inputChannel=%s)\", connection-&gt;getInputChannelName().c_str()); ATRACE_NAME(message.c_str()); &#125;#if DEBUG_DISPATCH_CYCLE //日志打印！ ALOGD(\"channel '%s' ~ startDispatchCycle\", ... case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, keyEntry-&gt;displayId, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125;.... case EventEntry::TYPE_MOTION: &#123; // Publish the motion event. status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq, motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId, dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton, dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags, motionEntry-&gt;metaState, motionEntry-&gt;buttonState, motionEntry-&gt;classification, xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision, motionEntry-&gt;downTime, motionEntry-&gt;eventTime, motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties, usingCoords); break; &#125; ......","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"input","slug":"input","permalink":"https://alonealive.github.io/Blog/tags/input/"}]},{"title":"Android Input事件ANR流程","slug":"2020/200510_android_inputANR","date":"2020-05-10T15:32:00.000Z","updated":"2020-05-20T16:37:09.890Z","comments":true,"path":"2020/05/10/2020/200510_android_inputANR/","link":"","permalink":"https://alonealive.github.io/Blog/2020/05/10/2020/200510_android_inputANR/","excerpt":"Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听/dev/input产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。常说的Input ANR超时，都是指的是Input事件分发超时。","text":"Android Input体系中，大致有两种类型的事件：实体按键key事件，屏幕点击触摸事件。如果根据事件类型的不同，还能细分为基础实体按键的key(power，volume up/down，recents，back，home)，实体键按键，屏幕点击(多点，单点)，屏幕滑动等事件。在Android整个Input体系中有三个格外重要的成员：Eventhub，InputReader，InputDispatcher。它们分别担负着各自不同的职责，Eventhub负责监听/dev/input产生的Input事件；InputReader负责从Eventhub读取事件，并将读取的事件发给InputDispatcher；InputDispatcher则根据实际的需要具体分发给当前手机获得焦点实际的Window。常说的Input ANR超时，都是指的是Input事件分发超时。 参考：https://blog.csdn.net/abm1993/article/details/80461752参考：https://blog.csdn.net/abm1993/article/details/80497039参考：https://www.jianshu.com/p/f05d6b05ba17 问题日志从下面的log可以看到超过了5s导致发生Input ANR事件。 main log： 123404-22 10:49:36.222646 1270 1376 I InputDispatcher: Application is not responding: AppWindowToken&#123;e4f7c16 token&#x3D;Token&#123;8a1cd31 ActivityRecord&#123;21295d8 u0 com.android.PACKAGE&#x2F;.PACKAGE_Activity t10&#125;&#125;&#125;. It has been 5008.2ms since event, 5005.5ms since wait started. Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.04-22 10:49:36.342164 1270 1407 E TAG : 82 Tanet......04-22 10:49:41.347174 1270 1376 I InputDispatcher: Dropped event because it is stale. system log： 1234504-22 10:49:31.216699 1270 1376 D PowerManagerService: getScreenOffTimeoutLocked: isTestFlag &#x3D; false04-22 10:49:31.216986 1270 1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182 com.android.server.input.InputManagerService.interceptKeyBeforeDispatching:1839 &lt;bottom of call stack&gt; 04-22 10:49:36.224611 1270 1376 I WindowManager: Input event dispatching timed out . Reason: Waiting because no window has focus but there is a focused application that may eventually add a window when it finishes starting up.04-22 10:49:36.341180 1270 1407 W InputManager: Input event injection from pid 6143 timed out.04-22 10:49:36.342467 1270 1376 W WindowManager: Failed looking up window callers&#x3D;com.android.server.wm.InputManagerCallback.interceptKeyBeforeDispatching:182 代码分析循环读取分发Input事件在frameworks/native/services/inputflinger/InputDispatcher.cpp中，流程从InputDispatcherThread::threadLoop()线程循环开始，方法体只调用循环一个函数mDispatcher-&gt;dispatchOnce()。 如果没有等待的命令，则会循环运行主要函数dispatchOnceInnerLocked不断的读取并分发Input事件： frameworks/native/services/inputflinger/InputDispatcher.cpp12345678910111213141516171819202122232425262728293031323334void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); //记录事件的当前时间点... case EventEntry::TYPE_KEY: &#123; //点击事件 KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); if (isAppSwitchDue) &#123; if (isAppSwitchKeyEvent(typedEntry)) &#123; resetPendingAppSwitchLocked(true); isAppSwitchDue = false; &#125; else if (dropReason == DROP_REASON_NOT_DROPPED) &#123; dropReason = DROP_REASON_APP_SWITCH; &#125; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123; dropReason = DROP_REASON_STALE; &#125; if (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123; dropReason = DROP_REASON_BLOCKED; &#125; done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); //执行该函数 break; &#125;... if (done) &#123; if (dropReason != DROP_REASON_NOT_DROPPED) &#123; dropInboundEventLocked(mPendingEvent, dropReason); &#125; mLastDropReason = dropReason; releasePendingEventLocked(); *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately &#125;&#125; 该函数最后调用了dropInputEvent事件dropInboundEventLocked(mPendingEvent, dropReason); 若case EventEntry::TYPE_KEY如果是Key事件，则会执行InputDispatcher::dispatchKeyLocked函数。然后在该函数中调用findFocusedWindowTargetsLocked 1234567891011121314151617181920212223bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ...... // Identify targets. std::vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); if (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123; return false; &#125; setInjectionResult(entry, injectionResult); if (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123; return true; &#125; // Add monitor channels from event's or focused display. addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry)); // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; 在函数findFocusedWindowTargetsLocked中开始就会进行判断，当focusedWindowHandle == nullptr但是focusedApplicationHandle != nullptr的时候调用handleTargetsNotReadyLocked报出ANR的错误日志。 frameworks/native/services/inputflinger/InputDispatcher.cpp12345678910111213141516int32_t InputDispatcher::findFocusedWindowTargetsLocked(nsecs_t currentTime, const EventEntry* entry, std::vector&lt;InputTarget&gt;&amp; inputTargets, nsecs_t* nextWakeupTime) &#123; ...... // If there is no currently focused window and no focused application // then drop the event. if (focusedWindowHandle == nullptr) &#123; if (focusedApplicationHandle != nullptr) &#123; //monkey test的时候经常遇到类似log的ANR。典型的无窗口，有应用的ANR问题，这里我们就需要了解Android应用的启动流程了，一般此类问题都是Android应用首次启动时会发生此类问题，此时我们应用本身需要检查一下我们的Android应用重写的Application onCreate方法，Android应用的启动界面是否在onCreate onStart方法中是否存在耗时操作。当然不排除系统原因造成的启动慢，直接导致ANR问题发生的情况 injectionResult = handleTargetsNotReadyLocked(currentTime, entry, focusedApplicationHandle, nullptr, nextWakeupTime, \"Waiting because no window has focus but there is a \" \"focused application that may eventually add a window \" \"when it finishes starting up.\"); goto Unresponsive; &#125;.... InputDispatcher::handleTargetsNotReadyLocked执行代码： frameworks/native/services/inputflinger/InputDispatcher.cpp123456789101112131415161718192021222324252627282930313233343536373839404142int32_t InputDispatcher::handleTargetsNotReadyLocked(nsecs_t currentTime, const EventEntry* entry, //点击触摸事件 const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle, const sp&lt;InputWindowHandle&gt;&amp; windowHandle, nsecs_t* nextWakeupTime, const char* reason) &#123; ....if (mInputTargetWaitCause != INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY) &#123;//这里一般是有应用（application已经创建），无窗口，或者有应用，有窗口ANR的情形，一般同一个窗口至进入一次该方法 nsecs_t timeout; //int64类型秒数 if (windowHandle != nullptr) &#123; timeout = windowHandle-&gt;getDispatchingTimeout(DEFAULT_INPUT_DISPATCHING_TIMEOUT); &#125; else if (applicationHandle != nullptr) &#123; //执行这个，有应用无窗口 timeout = applicationHandle-&gt;getDispatchingTimeout( DEFAULT_INPUT_DISPATCHING_TIMEOUT); //5s超时 &#125; else &#123; timeout = DEFAULT_INPUT_DISPATCHING_TIMEOUT; //5s &#125;mInputTargetWaitCause = INPUT_TARGET_WAIT_CAUSE_APPLICATION_NOT_READY;//超时等待原因mInputTargetWaitStartTime = currentTime;//函数入参当前时间，此处就是当前input事件的第一次分发时间mInputTargetWaitTimeoutTime = currentTime + timeout; //设置超时 //无窗口 if (windowHandle != NULL) &#123; mInputTargetWaitApplicationHandle = windowHandle-&gt;inputApplicationHandle;//记录当前等待的应用 &#125; //TODO 记录当前等待的应用，针对无窗口，有应用 if (mInputTargetWaitApplicationHandle == NULL &amp;&amp; applicationHandle != NULL) &#123; mInputTargetWaitApplicationHandle = applicationHandle;... //当前时间已经大于超时时间，说明应用有时间分发超时了，需要触发ANR if (currentTime &gt;= mInputTargetWaitTimeoutTime) &#123; //应该是超时5s onANRLocked(currentTime, applicationHandle, windowHandle, entry-&gt;eventTime , mInputTargetWaitStartTime, reason); // Force poll loop to wake up immediately on next iteration once we get the // ANR response back from the policy. *nextWakeupTime = LONG_LONG_MIN; return INPUT_EVENT_INJECTION_PENDING; &#125; ANR的函数调用onANRLocked最后发生ANR调用InputDispatcher::onANRLocked frameworks/native/services/inputflinger/InputDispatcher.cpp12345678910void InputDispatcher::onANRLocked( nsecs_t currentTime, const sp&lt;InputApplicationHandle&gt;&amp; applicationHandle, const sp&lt;InputWindowHandle&gt;&amp; windowHandle, nsecs_t eventTime, nsecs_t waitStartTime, const char* reason) &#123; float dispatchLatency = (currentTime - eventTime) * 0.000001f; float waitDuration = (currentTime - waitStartTime) * 0.000001f; ALOGI(\"Application is not responding: %s. \" \"It has been %0.1fms since event, %0.1fms since wait started. Reason: %s\", getApplicationWindowLabel(applicationHandle, windowHandle).c_str(), dispatchLatency, waitDuration, reason); 分析方法 抓取systrace分析：可以分析Input事件的部分 系统的Trace log：系统生成的Trace文件保存在data/anr,可以用过命令adb pull data/anr/取出。 抓取日志分析 可能导致ANR的原因 怀疑是不是在Activty oncreate和onstart耗时太多，导致窗口还未创建好，input事件超时5s应用窗口是在onResume中才去向WindowManager添加注册的。因此在注册添加窗口之前，application或者启动的Activity的生命周期onCreate，onStart的任意方法，做了耗时操作，或者他们加载一起的执行时间过长，都是能够导致无窗口，有应用类型的Input ANR问题发生的。所以实际开发应用的时候，就要尽可能的把耗时的操作，异步处理。具体异步实现思路可以使用new thread + handler，Asynctask，HandlerThread等等，这里推荐使用HandlerThread，因为google封装的接口，使用起来简单。 可能是UI主线程做了耗时的操作。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"input","slug":"input","permalink":"https://alonealive.github.io/Blog/tags/input/"}]},{"title":"C++字符串比较函数strcmp和strstr的用法","slug":"2020/200413_cpp_strstrTostrcmp","date":"2020-04-14T15:32:00.000Z","updated":"2020-04-13T14:12:25.215Z","comments":true,"path":"2020/04/14/2020/200413_cpp_strstrTostrcmp/","link":"","permalink":"https://alonealive.github.io/Blog/2020/04/14/2020/200413_cpp_strstrTostrcmp/","excerpt":"今天碰到一个细节bug，使用strcmp来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用strstr函数。","text":"今天碰到一个细节bug，使用strcmp来比较两个字符串是否完全相同。但是忽略了一个问题，如果存在一个字符串包含在另一个字符串呢？此时就会发现需要用strstr函数。 strcmp函数比较字符串大小设这两个字符串为str1、str2， 若str1 == str2，则返回零； 若str1 &lt; str2，则返回负数； 若str1 &gt; str2，则返回正数。 测试类： testFunc_strcmp.cpp 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include &lt;cstring&gt;#define PROPERTY_VALUE_MAX 92int main() &#123; using namespace std; char char1[PROPERTY_VALUE_MAX] = &#123;0&#125;; char char2[PROPERTY_VALUE_MAX] = &#123;0&#125;; bool con = true; char isCon[20] = \"y\"; while (con) &#123; cout &lt;&lt; \"Compare two char by func strcmp(char1, char2):\" &lt;&lt;endl; cout &lt;&lt; \"Enter char1: \"; cin.getline(char1, PROPERTY_VALUE_MAX); cout &lt;&lt; \"Enter char2: \"; cin.getline(char2, PROPERTY_VALUE_MAX); cout &lt;&lt; \"Result: strcmp(\" &lt;&lt; char1 &lt;&lt; \", \" &lt;&lt; char2 &lt;&lt; \"): \" &lt;&lt;endl; cout &lt;&lt; strcmp(char1, char2) &lt;&lt;endl; cout &lt;&lt; \"Continue? y/n\" &lt;&lt;endl; cin.getline(isCon, 20); if(strcmp(isCon, \"n\") == 0) &#123; con = false; &#125; &#125; return 0;&#125; 运行： 12345678910111213141516171819202122232425262728Compare two char by func strcmp(char1, char2):Enter char1: sunEnter char2: wenResult: strcmp(sun, wen): -4Continue? y&#x2F;nyCompare two char by func strcmp(char1, char2):Enter char1: wenEnter char2: ganResult: strcmp(wen, gan): 16Continue? y&#x2F;nyCompare two char by func strcmp(char1, char2):Enter char1: wizzieEnter char2: wizzieResult: strcmp(wizzie, wizzie): 0Continue? y&#x2F;nyCompare two char by func strcmp(char1, char2):Enter char1: wizzie_testEnter char2: wizzieResult: strcmp(wizzie_test, wizzie): 95Continue? y&#x2F;nn strstr函数比较字符串是否相同或者存在包含关系如果两个字符串可能存在相同，并且可能会有包含关系，则需要使用strstr函数来比较字符串。如果不包含（或相同），则返回NULL。 测试类： testFunc_strstr.cpp1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include &lt;cstring&gt;#define PROPERTY_VALUE_MAX 92int main() &#123; using namespace std; char char1[PROPERTY_VALUE_MAX] = &#123;0&#125;; char char2[PROPERTY_VALUE_MAX] = &#123;0&#125;; bool con = true; char isCon[20] = \"y\"; cout &lt;&lt; \"*** Determine whethe char2 is in char1. ***\" &lt;&lt; endl; while (con) &#123; cout &lt;&lt; \"Input two char by func strstr(char1, char2):\" &lt;&lt;endl; cout &lt;&lt; \"Enter char1: \"; cin.getline(char1, PROPERTY_VALUE_MAX); cout &lt;&lt; \"Enter char2: \"; cin.getline(char2, PROPERTY_VALUE_MAX); cout &lt;&lt; \"Result: strstr(\" &lt;&lt; char1 &lt;&lt; \", \" &lt;&lt; char2 &lt;&lt; \"): \" &lt;&lt;endl; if (strstr(char1, char2) != NULL) cout &lt;&lt; \"Success: char2 is in char1!\" &lt;&lt; endl; else cout &lt;&lt; \"Error: char2 is not in char1!\" &lt;&lt; endl; cout &lt;&lt; \"Continue? y/n\" &lt;&lt;endl; cin.getline(isCon, 20); if(strcmp(isCon, \"n\") == 0) &#123; con = false; &#125; &#125; return 0;&#125; 运行： 1234567891011121314151617181920*** Determine whethe char2 is in char1. ***Input two char by func strstr(char1, char2):Enter char1: sunEnter char2: sunResult: strstr(sun, sun): Success: char2 is in char1!Continue? y&#x2F;nyInput two char by func strstr(char1, char2):Enter char1: sunwengangEnter char2: wenResult: strstr(sunwengang, wen): Success: char2 is in char1!Continue? y&#x2F;nyInput two char by func strstr(char1, char2):Enter char1: sunEnter char2: sunwengangResult: strstr(sun, sunwengang): Error: char2 is not in char1!","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Android HWC2硬件合成","slug":"2020/200401_android_HWC2_Display","date":"2020-04-01T15:32:00.000Z","updated":"2020-04-01T12:55:07.459Z","comments":true,"path":"2020/04/01/2020/200401_android_HWC2_Display/","link":"","permalink":"https://alonealive.github.io/Blog/2020/04/01/2020/200401_android_HWC2_Display/","excerpt":"转载夕月风大佬博客： https://www.jianshu.com/p/824a9ddf68b9参考Android P AOSP源码添加修改部分内容参考源码： http://aosp.opersys.com/xref/android-10.0.0_r14/","text":"转载夕月风大佬博客： https://www.jianshu.com/p/824a9ddf68b9参考Android P AOSP源码添加修改部分内容参考源码： http://aosp.opersys.com/xref/android-10.0.0_r14/ 显示屏Display 显示屏Display是合成的另一个重要单元，系统可以有多个显示设备，并且在正常系统操作期间可以添加/删除显示设备。该添加/删除操作可以对应HWC设备的热插拔请求，或者应客户端的请求进行，这允许创建虚拟显示设备，其内容会渲染到离屏缓冲区（而不是物理显示设备）。 可以通过Dump SF查看display的layer信息，同时也可以根据layerstack异同判断多个display是否用的同一个layer。 HWC中，SurfaceFlinger中创建的Layer，在合成开始时，将被指定到每个Display上，此后合成过程中，每个Display合成指定给自己的Layer。 SurfaceFlinger前端，每个显示屏用DisplayDevice类描述，在后端显示数据用DisplayData描述。而在HWC2的Client端，定义了Display类进行描述。对于HWC2服务端则用hwc2_display_t描述，他只是一个序号，Vendor具体实现时，才具体的去管理Display的信息。 HWC2提供相应函数来确定给定显示屏的属性，在不同配置（例如4K/1080分辨率）和颜色模式（例如Native颜色或者真彩sRGB）之间切换，以及打开/关闭显示设备或者将其切换到低功率模式（如果支持）。 HWC设备composerDeviceNote:注意显示屏Display和合成设备的区别，HWC合成设备只有一个，定义在头文件： hardware/libhardware/include/hardware/hwcomposer2.h123456789typedef struct hwc2_device &#123; struct hw_device_t common; void (*getCapabilities)(struct hwc2_device* device, uint32_t* outCount, int32_t* /*hwc2_capability_t*/ outCapabilities); hwc2_function_pointer_t (*getFunction)(struct hwc2_device* device, int32_t /*hwc2_function_descriptor_t*/ descriptor);&#125; hwc2_device_t; HWC合成服务hardware/interfaces/graphics/composer/2.1/default这个HWC的的默认服务。SurfaceFlinger初始化时，可以通过属性debug.sf.hwc_service_name来制定，默认为default。在编译时，manifest.xml中配置的也是default。 1234567//frameworks/native/services/surfaceflinger/SurfaceFlinger.cppstd::string getHwcServiceName() &#123; char value[PROPERTY_VALUE_MAX] = &#123;&#125;; property_get(\"debug.sf.hwc_service_name\", value, \"default\"); ALOGI(\"Using HWComposer service: '%s'\", value); return std::string(value);&#125; HWC服务分两部分： 可以执行程序android.hardware.graphics.composer@2.1-service（在目录/vendor/bin/hw/） 其main函数如下，通过defaultPassthroughServiceImplementation函数注册IComposer服务。 123456789101112131415161718//hardware/interfaces/graphics/composer/2.1/default/service.cppint main() &#123; // the conventional HAL might start binder services android::ProcessState::initWithDriver(\"/dev/vndbinder\"); android::ProcessState::self()-&gt;setThreadPoolMaxThreadCount(4); android::ProcessState::self()-&gt;startThreadPool(); // same as SF main thread struct sched_param param = &#123;0&#125;; param.sched_priority = 2; if (sched_setscheduler(0, SCHED_FIFO | SCHED_RESET_ON_FORK, &amp;param) != 0) &#123; ALOGE(\"Couldn't set SCHED_FIFO: %d\", errno); &#125; return defaultPassthroughServiceImplementation&lt;IComposer&gt;(4);&#125; 对应.rc文件： 123456service vendor.hwcomposer-2-1 &#x2F;vendor&#x2F;bin&#x2F;hw&#x2F;android.hardware.graphics.composer@2.1-service class hal animation user system group graphics drmrpc capabilities SYS_NICE onrestart restart surfaceflinger 实现库android.hardware.graphics.composer@2.1-impl.so hwc的执行程序中，注册的IComposer，将调到对应的FETCH函数，FETCH函数实现及是so库中。FETCH如下： 123456789101112131415IComposer* HIDL_FETCH_IComposer(const char*)&#123; const hw_module_t* module = nullptr; int err = hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;module); if (err) &#123; ALOGI(\"falling back to FB HAL\"); err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module); &#125; if (err) &#123; ALOGE(\"failed to get hwcomposer or fb module\"); return nullptr; &#125; return new HwcHal(module);&#125; FETCH函数中，才正在去加载Vendor的实现，通过统一的接口hw_get_module根据IDHWC_HARDWARE_MODULE_ID去加载。加载完成后，创建HAL描述类似HwcHal。 1234567891011121314151617HwcHal::HwcHal(const hw_module_t* module) : mDevice(nullptr), mDispatch(), mMustValidateDisplay(true), mAdapter() &#123; uint32_t majorVersion; if (module-&gt;id &amp;&amp; strcmp(module-&gt;id, GRALLOC_HARDWARE_MODULE_ID) == 0) &#123; majorVersion = initWithFb(module); &#125; else &#123; majorVersion = initWithHwc(module); &#125; initCapabilities(); if (majorVersion &gt;= 2 &amp;&amp; hasCapability(HWC2_CAPABILITY_PRESENT_FENCE_IS_NOT_RELIABLE)) &#123; ALOGE(\"Present fence must be reliable from HWC2 on.\"); abort(); &#125; initDispatch();&#125; 如果是FrameBuffer驱动，通过initWithFb初始化。如果是HWC驱动，通过initWithHwc初始化。我们需要的是HWC2的接口，如果不是HWC2的HAl实现，那么需要做适配。 Client和Server的通信SurfaceFlinger和HWC服务之间，很多函数，并没有直接的调用，而是通过Buffer的读写来实现调用和参数的传递的。所以，Client端和Server端通信，基本通过以下相关的途径： 通过IComposerClient.hal接口 通过IComposer.hal接口 通过command Buffer Server端回调Client端，通过IComposerCallback.hal接口。 hal接口的方式，其本质就是Binder。又加了一个command Buffer的方式，其实这是为了解决Binder通信慢的问题。 HWC2中Fence的更改HWC 2.0 中同步栅栏的含义相对于以前版本的HAL已有很大的改变。 在 HWC v1.x 中，释放Fence和退出Fence是推测性的。在帧 N 中检索到的Buffer的释放Fence或显示设备的退出Fence不会先于在帧 N + 1 中检索到的Fence变为触发状态。换句话说，该Fence的含义是“不再需要您为帧 N 提供的Buffer内容”。这是推测性的，因为在理论上，SurfaceFlinger 在帧 N 之后的一段不确定的时间内可能无法再次运行，这将使得这些栅栏在该时间段内不会变为触发状态。 在 HWC 2.0 中，释放Fence和退出Fence是非推测性的。在帧 N 中检索到的释放Fence或退出Fence，将在相关Buffer的内容替换帧 N - 1 中缓冲区的内容后立即变为触发状态，或者换句话说，该Fence的含义是“您为帧 N 提供的缓冲区内容现在已经替代以前的内容”。这是非推测性的，因为在硬件呈现此帧的内容之后，该栅栏应该在 presentDisplay 被调用后立即变为触发状态。 Notes: 关于Fence同步机制需要单独拎出来梳理学习。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"智能健身车","slug":"2020/200401_diary_exerciseBike","date":"2020-04-01T13:32:00.000Z","updated":"2020-07-16T13:57:25.515Z","comments":true,"path":"2020/04/01/2020/200401_diary_exerciseBike/","link":"","permalink":"https://alonealive.github.io/Blog/2020/04/01/2020/200401_diary_exerciseBike/","excerpt":"市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。","text":"市面上关于智能健身车的款式还是太少了，以智能健身车品牌KM1930实景智能健身车来看，价钱也是偏贵。大部分都还只能算是普通的动感单车。 但是提到顽鹿竞技、zwift，就有很多骑手会用骑行台、自己的自行车等设备在家模拟骑行，智能健身车目前的方向就是将这些一体化，而且更偏向智能、简约、便捷。 智能健身车智能健身车可以具备接入互联网（一般都是通过蓝牙）、能够进行独立数据采集处理运算能力的健身车。也就是说，健身车成了像手机、智能手表等等一样的智能硬件。当下的智能健身车一般会具备以下智能体验，最起码包括： 运动数据检测以及采集、运算、反馈的体验（比如说心率、踏频这些运动数据的获取）； 在线社交的体验，比如国内的顽鹿竞技，国外的zwift，健身车可以通过蓝牙连接到这些APP，通过数据的传输，模拟骑车，而且能够多人一起竞赛； 自动调节阻力，能够根据路况调节阻力。 两千内的智能健身车这两天一直想入手一辆智能健身车，下班之余可以在家运动运动。通过一些模拟骑行APP更有趣，边骑车边玩游戏，和VR眼镜打游戏一样，让运动更加游戏性。在网上查了资料，比较倾向于2000以内的几种款型，以下这三种：骑纪智能健身车、小米NEXGIM智能健身车、顽鹿健身车。 - 骑纪智能健身车 小米NEXGIM智能健身车 顽鹿游戏功率健身车（京东众筹） 价钱 1578 1699 999（众筹活动） 尺寸 长86高110宽44，折叠后长63高54宽44 长88宽50.5高121 长85宽54高127 电源 插电 插电 内置两节5号电池 重量 N/A 28kg 25.1kg 阻力 精密电机磁控,32档智能阻力控制，自动换挡，根据上下坡度自动调节 自动调节电机阻力 磁控阻力调节，非自动换挡，8级速度档位匹配 蓝牙 智能蓝牙5.0 蓝牙 普通蓝牙连接 心率测量 有 无 N/A 踏频记录 有 测量踩踏功率 有 静音磁控 有 静音 有 实时功率 有 有 有 功率精度 N/A 50W以上&gt;=90% 50W以上+-5% 车身 车把角度可以调整 多功能控制旋钮，手动调节阻力大小、档位高低、，可查看时间、扭力、功率、踏频等 飞轮 全包金属 全包活飞 全包 传动方式 N/A 皮带传动 皮带传动 游戏模式 自己微信小程序、zwift,Kinomap,Ride Social,Trainer Road,FulGaz，顽鹿 zwift,顽鹿，自己的APP-NEXGIM 顽鹿、zwift 其他 卡路里、距离、速度，智能芯片手动升级，可折叠 N/A 坐凳可以前后调节","categories":[{"name":"diary","slug":"diary","permalink":"https://alonealive.github.io/Blog/categories/diary/"}],"tags":[{"name":"diary","slug":"diary","permalink":"https://alonealive.github.io/Blog/tags/diary/"}]},{"title":"Android 两种实时获取FPS的方法","slug":"2020/200330_android_getFPS","date":"2020-03-31T15:32:00.000Z","updated":"2020-03-31T13:27:43.706Z","comments":true,"path":"2020/03/31/2020/200330_android_getFPS/","link":"","permalink":"https://alonealive.github.io/Blog/2020/03/31/2020/200330_android_getFPS/","excerpt":"通过ADB命令实时获取FPS帧率有两种方式，一种是dump gfxinfo，一种是dump SF --latency。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。","text":"通过ADB命令实时获取FPS帧率有两种方式，一种是dump gfxinfo，一种是dump SF --latency。其他还可以通过三方APP GameBooster（Google PlayStore可以下载）打开实时FPS监控查看。如果是查看动画是否丢帧，可以通过视频工具QuickTime Player逐帧查看需要测试的动画的拍摄视频。一般每4帧会出现一个新的动画，录制视频查看这个过程是有动画虚影的。 dumpsys gfxinfo dumpsys是一款运行在设备上的Android工具，将 gfxinfo命令传递给dumpsys可在logcat中提供输出，其中包含各阶段发生的动画以及帧相关的性能信息。但是gfxinfo不统计SurfaceView。 步骤： 打开开发者选项中的HWUI呈现模式分析，选择“在adb shell dumpsys gfxinfo中” 在需要测试的界面获取包名，可以使用dump SF/activity获取 清空后台任务，操作UI滑动，然后执行获取adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats信息和frame耗时信息通常为2s收集一次（一次120帧，一帧16ms，耗时约2s）。如果要重置所有计数器重新收集帧率数据，执行adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; reset 案例例如测试我的设备一加六滑动桌面的帧率，执行上述的前两步： 12adb shell dumpsys activity top|grep ACTIVITY ACTIVITY net.oneplus.launcher&#x2F;.Launcher 5f5af6c pid&#x3D;4077 然后滑动桌面执行adb shell dumpsys gfxinfo net.oneplus.launcher，获取到128帧的数据。 1234567891011121314151617181920212223242526272829303132333435363738394041&gt; adb shell dumpsys gfxinfo net.oneplus.launcherApplications Graphics Acceleration Info:Uptime: 594308934 Realtime: 1044551416** Graphics info for pid 4077 [net.oneplus.launcher] ** &#x2F;&#x2F;表明当前dump的界面和进程IDStats since: 573121582148193nsTotal frames rendered: 17625 &#x2F;&#x2F;本次dump搜集了17625帧的信息Janky frames: 1735 (9.84%) &#x2F;&#x2F;有1735帧超过了16.6ms.卡帧率是9.84%50th percentile: 6ms 90th percentile: 16ms95th percentile: 20ms99th percentile: 38msNumber Missed Vsync: 72 &#x2F;&#x2F;垂直同步失败的帧Number High input latency: 8269 &#x2F;&#x2F;处理input时间超时的帧Number Slow UI thread: 482 &#x2F;&#x2F;因为UI线程的工作超时导致的帧数Number Slow bitmap uploads: 101 &#x2F;&#x2F;因为bitmap加载耗时的帧数Number Slow issue draw commands: 31 &#x2F;&#x2F;因为绘制导致超时的帧数Number Frame deadline missed: 544HISTOGRAM: 5ms&#x3D;7576 6ms&#x3D;2645 7ms&#x3D;1902 ... &#x2F;&#x2F;直方图数据，表面耗时为0~5ms的帧数是7576，同理类推......Profile data in ms: net.oneplus.launcher&#x2F;net.oneplus.launcher.Launcher&#x2F;android.view.ViewRootImpl@3b33fe6 (visibility&#x3D;0) Draw Prepare Process Execute 6.94 0.40 2.69 1.70 &#x2F;&#x2F;四个加起来小于16.6ms属于正常的一帧，超过则是jank（丢帧） 2.86 0.35 5.19 2.36 2.55 0.32 1.10 0.98 2.77 0.34 1.39 1.49 2.16 0.31 1.38 1.34 2.32 0.30 1.09 0.66 2.05 0.25 1.04 0.83 2.13 0.25 1.04 1.16 1.99 0.30 1.11 1.51 3.09 0.44 3.01 2.22 2.34 0.72 2.40 1.68 2.28 0.36 2.49 1.84 2.58 0.48 2.90 1.64 2.31 0.40 2.13 1.78...... 解析： Draw：构建java显示列表DisplayList的时间，也就是执行每一个View的onDraw方法,创建或者更新每一个View的DisplayList对象的时间。 Prepare：准备函数的执行耗时 Process：小号在Android的2D渲染器执行显示列表的时间，view越多，要执行的绘制命令就越多，耗时越长 Execture：消耗在排列每个发送过来的帧的顺序的时间.或者说是CPU告诉GPU渲染一帧的时间,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复。所以这个时间，一般都很短。 Draw + Prepare+Process + Execute = 完整显示一帧 ，这个时间要小于16ms才能保存每秒60帧。 参数framestats如果需要获取详细的帧信息，可以使用Android 6引入的新参数framestats，执行adb shell dumpsys gfxinfo &lt; PACKAGE_NAME &gt; framestats 结果会打印额外的信息，以CSV格式输出。每一行代表应用程序生成的一帧。每一行的列数都相同，每列对应描述帧在不同的时间段的耗时情况。 12345---PROFILEDATA---Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,0,594399833469194,594399833469194,9223372036854775807,0,594399833992420,594399834015180,594399834093462,594399835255753,594399835397316,594399835719034,594399835808878,594399836632628,594399837228514,96000,146000,0,594429840570165,594429840570165,9223372036854775807,0,594429841649231,594429841736940,594429841741471,594429842202356,594429845314544,594429847401106,594429847993190,594429853626210,594429854321679,264000,326000,...... 解析： flags：FLAGS列为’0’的行可以通过从FRAME_COMPLETED列中减去INTENDED_VSYNC列计算其总帧时间。如果非零，则该行应该被忽略，因为该帧的预期布局和绘制时间超过16ms，为异常帧。 *IntendedVsync：帧的的预期起点。如果此值与VSYNC不同，是由于UI线程中的工作使其无法及时响应垂直同步信号所造成的； Vsync：花费在vsync监听器和帧绘制的时间（Choreographer frame回调，动画，View.getDrawingTime（）等）； OldestInputEvent：输入队列中最旧输入事件的时间戳，如果没有输入事件，则输入Long.MAX_VALUE。此值主要用于平台工作，对应用程序开发人员的用处有限。 NewestInputEvent：输入队列中最新输入事件的时间戳，如果帧没有输入事件，则为0。此值主要用于平台工作，对应用程序开发人员的用处有限。然而，通过查看（FRAME_COMPLETED - NEWEST_INPUT_EVENT），可以大致了解应用程序添加的延迟时间。 HandleInputStart：将输入事件分派给应用程序的时间戳（deliverInputEvent函数）。通过查看这段时间和ANIMATION_START之间的时间，可以测量应用程序处理输入事件的时间。如果这个数字很高（&gt; 2ms），这表明程序花费了非常长的时间来处理输入事件。例如View.onTouchEvent（），也就是说此工作需要优化，或者分发到不同的线程。请注意，某些情况下这是可以接受的，例如发起新活动或类似活动的点击事件，并且此数字很大。 AnimationStart：运行Choreographer注册动画的时间戳。通过查看这段时间和PERFORM_TRANVERSALS_START之间的时间，可以确定评估运行的所有动画器（ObjectAnimator，ViewPropertyAnimator和常用转换器）需要多长时间。如果此数字很高（&gt; 2ms），请检查您的应用是否编写了自定义动画以确保它们适用于动画。 PerformTraversalsStart：计算PERFORM_TRAVERSALS_STAR-DRAW_START，则可以获取到布局和测量阶段完成的时间。（注意，在滚动或动画期间，希望这应该接近于零） DrawStart：performTraversals的绘制阶段开始的时间。这是录制任何无效视图的显示列表的起点。这和SYNC_START之间的时间是在树中所有无效视图上调用View.draw（）所花费的时间。 SyncQueued：同步请求发送到RenderThread的时间。如果此时间和SYNC_START之间的时间很长（&gt; 0.1ms左右），则意味着RenderThread忙于处理不同的帧。在内部，这被用来区分帧做了太多的工作，超过了16ms的预算，由于前一帧超过了16ms的预算，帧被停止了。 SYNC_START：绘图的同步阶段开始的时间。如果此时间与ISSUE_DRAW_COMMANDS_START之间的时间很长（&gt; 0.4ms左右），则通常表示有许多新的位图必须上传到GPU。 IssueDrawCommandsStart：硬件渲染器开始向GPU发出绘图命令的时间。这段时间和FRAME_COMPLETED之间的时间间隔显示了应用程序正在生产多少GPU。像这样出现太多透支或低效率渲染效果的问题。 SwapBuffers：eglSwapBuffers被调用的时间。 *FrameCompleted：帧的完整时间。花在这个帧上的总时间可以通过FRAME_COMPLETED - INTENDED_VSYNC来计算。 这些数据可以直接通过修改开发者选项的HWUI呈现模式分析为在屏幕显示为条形图，如图： dumpsys SurfaceFlinger –latency adb shell dumpsys SurfaceFlinger --latency LayerName命令主要用于获取游戏/视频应用的fps数据。 12345678910111213141516666666597043335926672 597043380168807 597043346611672597043352801411 597043396837974 597043363218234597043368960943 597043413558338 597043379891672597043385568078 597043430198078 597043396569641597043405252505 597043446885266 597043413698495597043421909328 597043463546203 597043430320943597043718620370 597043747090734 597043725964432597043729160422 597043763770213 597043730802818597043745858911 597043780445786 597043747847765597043758497193 597043797131620 597043764349745597043775327557 597043813810786 597043781148963597043791070734 597043830486880 597043796912974597043808038338 597043847152140 597043813671047...... 第一行数据，表示刷新的时间间隔refresh_period，我的机器打印出来的间隔期是。即Dump SF里面的VSYNC period。剩下的127行（127帧）数据分为三部分，每一列表是一种类型。 第一列：表示应用绘制图像的时间点 第二列：SF将帧提交给H/W(硬件)绘制之前的垂直同步时间。 第三列：在SF将帧提交给H/W的时间点，算是H/W接受完SF发来数据的时间点，绘制完成的时间点。s 计算方式：一般打印出来的数据是129行（部分机型打印两次257行，但是第一部分是无效数据，取后半部分），取len-2的第一列数据为end_time，取len-128的第一列数据为start_time。 fps = 127/((end_time - start_time) / 1000000.0) 除以1000000是因为命令打印出来的是纳秒单位，要转为毫秒进行计算，127就是因为命令一次打印出来127帧的数据而已。 参考：https://blog.csdn.net/itfootball/article/details/43084527/ 参考：https://www.jianshu.com/p/6c0cfc25b038 参考：https://blog.csdn.net/luoshengyang/article/details/7846923","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android SELinux权限笔记","slug":"2020/200325_android_sepolicy_study","date":"2020-03-25T14:32:00.000Z","updated":"2020-03-25T14:39:15.576Z","comments":true,"path":"2020/03/25/2020/200325_android_sepolicy_study/","link":"","permalink":"https://alonealive.github.io/Blog/2020/03/25/2020/200325_android_sepolicy_study/","excerpt":"在新增一个HIDL Service后，需要对其进行权限配置，不然通过adb shell ps -A|grep NAService会发现该service无法启动，也会通过抓取log发现一堆的avc: denied权限问题。关于SELinux可以推荐文档：https://www.pianshen.com/article/6549296922/， 非常详细，本文只是作为记录部分常用的笔记。","text":"在新增一个HIDL Service后，需要对其进行权限配置，不然通过adb shell ps -A|grep NAService会发现该service无法启动，也会通过抓取log发现一堆的avc: denied权限问题。关于SELinux可以推荐文档：https://www.pianshen.com/article/6549296922/， 非常详细，本文只是作为记录部分常用的笔记。 Android sepolicy，SEAndroid是一种基于安全策略的MAC安全机制。SEAndroid安全机制中的安全策略就是在安全上下文的基础上进行描述的，也就是说，它通过主体和客体的安全上下文，定义主体是否有权限访问客体。 例如添加一个service，在.rc文件定义了service，还需要在sepolicy的file_context中添加权限。 selinux相关命令12345&#x2F;&#x2F; 查看进程的sContextps -Z&#x2F;&#x2F; 查看文件权限ls -Z 查看selinux开关状态：adb shell getenforce 可能返回结果有三种：Enforcing、Permissive 和 Disabled。Disabled 代表 SELinux 被禁用，Permissive 代表仅记录安全警告但不阻止可疑行为，Enforcing 代表记录警告且阻止可疑行为。 一般调试通过以下命令关闭SELinux权限（需重启生效）： 12adb rootadb shell setenforce 0 抓取SELinux Log 抓kernel log，adb shell dmesg 抓kernel log，使用命令,可以直接提出avc的log：adb shell &quot;cat /proc/kmsg | grep avc&quot; &gt; avc_log.txt adb logcat –b events,搜索关键字：avc: denied File_contexts 用于声明文件的安全上下文，plat前缀的文件用于声明system、rootfs、data等与设备无关的文件。Nonplat 用于声明vendor、data/vendor等文件。 domain.te 该策略文件会限制一些特征文件的权限，一般不建议修改。 selinux没有对某个文件的权限（有neverAllow）处理方法 参考：https://blog.csdn.net/ly890700/article/details/54645212 101-01 08:03:22.410000 217 217 W applypatch: type&#x3D;1400 audit(0.0:16): avc: denied &#123; read &#125; for name&#x3D;&quot;mmcblk0p15&quot; dev&#x3D;&quot;tmpfs&quot; ino&#x3D;3364 scontext&#x3D;u:r:install_recovery:s0 tcontext&#x3D;u:object_r:block_device:s0 tclass&#x3D;blk_file permissive&#x3D;0 意思是说明install_revovery没有block_device的权限 只要在install_recovery.te中加入下面权限就可以了。 allow install_recovery recover_block_device:blk_file { open read write }; Service_contexts 用于声明java service 的安全上下文， O上将该文件拆分为plat和nonplat前缀的两个文件，但nonplat前缀的文件并没有具体的内容（vendor和system java service不允许binder操作）。 Property_contexts 用于声明属性的安全上下文，plat 前缀的文件用于声明system属性，nonplat前缀的文件用于声明vendor 属性。ril.开头的属性的安全上下文为u:object_r:radio_prop:s0，这意味着只有有权限访问Type为radio_prop的资源的进程才可以访问这些属性。 Hwservice_contexts新增文件，用于声明HIDL service 安全上下文。 123456789101112android.hardware.vibrator::IVibrator u:object_r:hal_vibrator_hwservice:s0android.hardware.vr::IVr u:object_r:hal_vr_hwservice:s0android.hardware.weaver::IWeaver u:object_r:hal_weaver_hwservice:s0android.hardware.wifi::IWifi u:object_r:hal_wifi_hwservice:s0android.hardware.wifi.hostapd::IHostapd u:object_r:hal_wifi_hostapd_hwservice:s0android.hardware.wifi.offload::IOffload u:object_r:hal_wifi_offload_hwservice:s0android.hidl.allocator::IAllocator u:object_r:hidl_allocator_hwservice:s0android.hidl.base::IBase u:object_r:hidl_base_hwservice:s0android.hidl.manager::IServiceManager u:object_r:hidl_manager_hwservice:s0android.hidl.memory::IMapper u:object_r:hidl_memory_hwservice:s0android.hidl.token::ITokenManager u:object_r:hidl_token_hwservice:s0android.system.net.netd::INetd u:object_r:system_net_netd_hwservice:s0 te语法 allow signal： 12allow domain domain : process signal; # 每个进程都能向它自己和其它进程发送signal allow domain self : process signal; # 每个进程都能向它自己发送signal 参考文档： https://blog.csdn.net/ch853199769/article/details/82501078 https://blog.csdn.net/innost/article/details/19299937","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android RC文件分析","slug":"2020/200320_android_rcFile_study","date":"2020-03-20T15:32:00.000Z","updated":"2020-08-05T11:50:21.492Z","comments":true,"path":"2020/03/20/2020/200320_android_rcFile_study/","link":"","permalink":"https://alonealive.github.io/Blog/2020/03/20/2020/200320_android_rcFile_study/","excerpt":"Android中最熟知的RC文件就是init.rc了，而在Hal接口服务定义中也会创建.rc文件。init.rc的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。.rc文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用.rc资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。","text":"Android中最熟知的RC文件就是init.rc了，而在Hal接口服务定义中也会创建.rc文件。init.rc的语法分为行为(Actions),、命令(Commands) 、服务(Services)、选项(Options)。.rc文件是资源文件，包括比如对话框、菜单、图标、字符串等资源信息。使用.rc资源文件的目的是为了对程序中用到的大量的资源进行统一的管理。 android rc文件分析模板 结构：service关键字声明了你要定义一个service，而test就是这个service的名字，至于后面的目录则是这个service对应的可执行文件在系统中的位置（adb shell，即编译后的系统目录）。 init是分段(section)解析init.rc的，在keywords.h中可以查看关键字的定义。结合init.rc的内容，可以看出，init是以on 和 service来分段标记的。 1234service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]* &lt;option&gt; &lt;option&gt; ... 例如： 12345678service test /system/bin/vold \\ --blkid_context=u:r:blkid:s0 --blkid_untrusted_context=u:r:blkid_untrusted:s0 \\ --fsck_context=u:r:fsck:s0 --fsck_untrusted_context=u:r:fsck_untrusted:s0 class core socket vold stream 0660 root mount socket cryptd stream 0660 root mount ioprio be 2 writepid /dev/cpuset/foreground/tasks 关键字解释： 语法 关键字 说明 SECTION on 触发条件 同上.. service 解析service COMMAND chdir 更改当前工作目录 同上.. chroot 更改参考的根目录位置 .. class_start 开启class start all services(启动某个设置了class名称的服务) .. class_stop 停止某个设置了class名称的服务 .. domainname 域名 .. exec [ [ [ ] * ] ] – [ ] * 调用程序并转移进程(Fork一个进程然后执行命令) .. export 提交变量 .. hostname 主机名 .. ifup 激活网卡 .. insmod 挂载模块(安装一个module) .. import 引入init文件，比如etc下的一些rc文件，和java中的import差不多 .. mkdir [mode] [owner] [group] 建立目录 .. mount 挂载文件系统 .. setkey 从源码看，应该是设置一个命令的关键字缩写，比如可以将domainname映射为dn .. setprop 设置一个属性 .. setrlimit 设置当前程序可以打开的最大文件数到系统规定程序可以打开的最大文件数 .. start 启动服务 .. stop 停止服务 .. symlink 建立软链接 .. sysclktz 设置基准时间 .. loglevel Log输出级别，低于这个级别的就输出 .. restart 重启服务,类似stop 但是不会disable service .. bootchart_init 开启bootcharting .. chmod 改变文件执行权限 .. chown 改变文件的owner group .. enable 将一个disabled的service变成enabled。且start .. load_all_props 加载system vendor的属性 .. load_persist_props 加载data下面的persist属性 .. mount_all 挂载fstab中的设备 .. mount &lt;type&gt; &lt;device&gt; &lt;dir&gt; [ &lt;flag&gt; ]* [&lt;option&gt;] 挂载设备 .. powerctl 对sys.powerctl属性的respond .. restorecon &lt;path&gt; [ &lt;path&gt; ] * 恢复文件到sercurity context在file_contexts配置的 .. restorecon_recursive &lt;path&gt; [ &lt;path&gt; ]* 递归的恢复目录中的文件到sercurity context .. trigger &lt;event&gt; 触发触发器 .. wait &lt;path&gt; [ &lt;timeout&gt; ] poll for 给定的文件 或者 timeout时间到。如果时间没有设定，默认为5秒 .. write &lt;path&gt; &lt;content&gt; 打开文件，write string到给定文件。没有文件会被创建。有的话，会truncated OPTION(用来初始化Service的) capability 能力，也就是系统对进程的一种权限控制。 同上.. class 设置class name .. console 启用控制台 .. critical 是否关键，也就是4分钟之内重启超过4次的话，重启之后就进入recovery模式 .. disabled 当它的class启动时，Service不会自动开启。必须显示的started by name(用其名字) .. group [ ]* 组归属（改变username当执行这个Service之前） .. oneshot 只启动一次，意外退出后不必重启 .. onrestart 执行一个命令，当Service重启时 .. setenv 增加环境变量 .. socket 申请socket资源 .. user 用户归属（改变username当执行这个Service之前） .. ioprio io调度优先级 .. writepid &lt;file…&gt; 当fork一个子进程时，写子进程的pid到一个给定的文件。是给cgroup/cpuset使用 .. Triggers Triggers被用来匹配事件，然后加入执行队列。 .. boot 当init开启时，这是第一个执行的trigger class &lt;name&gt; class &lt;name&gt;意思是为该服务定义一个类名，所有在这个类名下的服务都将一起启动和停止、如果没有定义class选项，则默认class deafult。 定义为核心service，当class core服务启动时，这个vold启动。如果是定义class hal，是不会自动启动的。可以定义为class main能够自动启动。 通过adb shell ps -A|grep 关键字查看进程服务。 on &lt;name&gt;1234on &lt;trigger&gt; &lt;command&gt; &lt;command&gt; &lt;command&gt; on属于行为。 on early-init: init之前、加载完所有rc文件后即执行，init.rc在early-init执行的是start ueventd，根据keywords.h的定义，start是个命令(COMMAND)。 on init: 加载propety各项属性文件之前执行，在init变为propety service之前都属于init阶段。 on early-boot: 启动属性服务后即执行。 on boot: boot的时候执行。 on property:xxxxx=x: 当某个属性设置为预期值时执行。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android 触控事件分析","slug":"2020/200317_adnroid_touchEvent","date":"2020-03-17T14:32:00.000Z","updated":"2021-05-31T12:53:12.899Z","comments":true,"path":"2020/03/17/2020/200317_adnroid_touchEvent/","link":"","permalink":"https://alonealive.github.io/Blog/2020/03/17/2020/200317_adnroid_touchEvent/","excerpt":"我们常见的触摸事件除了按下，弹起，移动之外还有很多，诸如长按，双击，Scroll，Fling等，他们是怎么判断的，还有这些长按，双击等事件的时间能否自由设置。可以在开发者选项中打开“显示点按操作反馈”和“指针位置”，同时可以打开inputflinger模块的log开关做一些调试，分析TP报点。 一般当我们需要处理触摸事件时有两种方式： 委托式 ： 将事件委托给监听器来进行处理。即定义一个View.onTouchListener()子类的监听器，由其onTouch()方法来处理。 回调式 ： 通过重写View类自己的onTouchEvent()方法来处理，在执行时会回调该方法，在其中执行自定义的代码。","text":"我们常见的触摸事件除了按下，弹起，移动之外还有很多，诸如长按，双击，Scroll，Fling等，他们是怎么判断的，还有这些长按，双击等事件的时间能否自由设置。可以在开发者选项中打开“显示点按操作反馈”和“指针位置”，同时可以打开inputflinger模块的log开关做一些调试，分析TP报点。 一般当我们需要处理触摸事件时有两种方式： 委托式 ： 将事件委托给监听器来进行处理。即定义一个View.onTouchListener()子类的监听器，由其onTouch()方法来处理。 回调式 ： 通过重写View类自己的onTouchEvent()方法来处理，在执行时会回调该方法，在其中执行自定义的代码。 关于主触点，副触点：发送触屏事件的时候，除了此触屏事件所对应的触点之外，如果当前触点多于一个或者等于一个，则此事件为副触点事件，发送此事件的触点叫做副触点。否则为主触点事件，发送此事件的触点为主触点。 MotionEvent对象事件处理在MotionEvent.java中,ACTION动作事件定义 1234567ACTION_DOWN = 0;ACTION_UP = 1;ACTION_MOVE = 2;ACTION_CANCEL =3 ;ACTION_POINTER_DOWN = 5; //A non-primary pointer has gone down.ACTION_POINTER_UP = 6;ACTION_SCROLL = 8; //the most event contains relative vertical and/or horizontal scroll offset. （1） 首先当点击下屏幕，触屏事件从View.java的onTouchEvent()开始处理： 1234567891011121314......case MotionEvent.ACTION_DOWN: // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; setPressed(true); checkForLongClick(0); &#125;break; （2） 事件响应是先有按下才会有后续事件。因此先查看ACTION_DOWN。在此case中判断如果是在scrollingContainer中则等待一段时间执行检查是否为Tap事件。因为可能按下之后可能会有scroll操作，如果有将丢弃长按检测。而如果不在container中，则立即执行长按检测。 view.java1234567private final class CheckForTap implements Runnable &#123; public void run() &#123; mPrivateFlags &amp;= ~PFLAG_PREPRESSED; setPressed(true); checkForLongClick(ViewConfiguration.getTapTimeout()); &#125; &#125; （3） 在其中执行了setPressed()操作，其后执行checkForLongClick()，即等待180ms-500ms来执行longPress操作。 12postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); 在其中执行performLongClick()。在该函数中处理长按需要做的事情，例如长按监听器中流程，显示contextMenu，处理长按震动反馈： 123handled = li.mOnLongClickListener.onLongClick(View.this);handled = showContextMenu();performHapticFeedback(HapticFeedbackConstants.LONG_PRESS); Note: 此处有两个时间数据： tapTimeout 和 longPressTimeout。 定义在frameworks/base/core/java/android/view/ViewConfiguration.java，时间是可以自定义的，但最好采用google提供的，这是经过大量积累得来的数据。而此处的longTimeout是设置辅助功能界面中’触摸和按住延迟’选项可设置的，如果没有设置那就是用默认的500ms。 123private static final int TAP_TIMEOUT = 180;private static final int DOUBLE_TAP_TIMEOUT = 300;private static final int DEFAULT_LONG_PRESS_TIMEOUT = 500; MotionEvent底层事件获取（触控事件分发机制）（1） 在onResume时会将view显示出来，跟踪代码到执行时会调用ActivityThread的handleResumeActivity()。可以看到获取window的DecorView，即整个window的顶层View。调用流程为:（创建窗口） WindowManager.addView()； 在实现类WindowManagerImpl中实现addView()； 最后一行通过root.setView()； 在ViewRootImpl中实现setView()； 在其中调用windowSession.add()。 windowSession为客户端，而服务器端为Session.java,在Session中转而调用WindowManagerService的addWindow()来实现add方法。 （2）WindowManagerService中addWindow这里实现了事件信息传递和交互的通道，内部采用socketpair，通过InputChannel来实现。 Note：openInputChannelPair(), 在其中创建socketpair,一个匿名的已连接套接字，一个为发送端，一个为接收端，可以进行双工通讯（UNIX网络编程）。 获取InputChannel, 一个置为Input，一个置为output。RegisterInputChannel中调用nativeRegisterInputChannel。 （3）在WindowManagerService中创建InputManagerService类（InputManagerService.java）对象，并start。 之后通过JNI流程在native中执行，并执行InputManager的start方法。 （4）在创建InputReader时会将dispatcher传入。即InputReader的成员变量mQueuedListener为dispatcher的执行者，具体代码分析flush函数，关注Args，例如MotionArgs, flush执行后，将调用dispatcher-&gt;notifyMotion(); 如果只关注Motion的话，那么就是调用InputDispatcher-&gt;notifyMotion()。 从抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。 systrace查看Input事件流程 参考： https://www.jianshu.com/p/427b084b0d77参考： https://mp.weixin.qq.com/s/Q2k6pLEyXhHZvZOIiU5ucA 触摸屏每隔几毫秒（如果是60刷新率，则一秒扫描屏幕120次，大概8ms扫描一次）扫描一次，如果有触摸事件，那么把事件上报到对应的驱动。 InputReader 读取触摸事件交给 InputDispatcher 进行事件派发。 InputDispatcher 将触摸事件发给注册了 Input 事件的 App。 App 拿到事件之后，进行 Input 事件分发，如果此事件分发的过程中，App 的 UI 发生了变化，那么会请求 Vsync，则进行一帧的绘制。 详细分析所以systrace从InputReader开始：（前面还有一点很短的“binder transaction”的时间） frameworks/native/services/inputflinger/InputReader.cpp123456789101112// Dispatch pointer down events using the new pointer locations.while (!downIdBits.isEmpty()) &#123; uint32_t downId = downIdBits.clearFirstMarkedBit(); dispatchedIdBits.markBit(downId); if (dispatchedIdBits.count() == 1) &#123; // First pointer is going down. Set down time. mDownTime = when; /// M: for input MET systrace @&#123; ScopedTrace _l(ATRACE_TAG_INPUT, \"AppLaunch_dispatchPtr:Down\"); /// @&#125; &#125; 然后会到InputDispatcher的dispatchMotionLocked函数，并且InputDispatcher会从InboundQueue中取出Input事件派发到各个App(连接)的OutBoundQueue(OutboundQueue区域oq) frameworks/native/services/inputflinger/InputDispatcher.cpp123456789bool InputDispatcher::dispatchMotionLocked( nsecs_t currentTime, MotionEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ATRACE_CALL(); // Preprocessing. if (! entry-&gt;dispatchInProgress) &#123; entry-&gt;dispatchInProgress = true; logOutboundMotionDetails(\"dispatchMotion - \", entry); &#125; 然后到deliverInputEvent，说明APP UI Thread被Input事件唤醒；（起始点可以看到当前APP的Launcher是1，value=1表示有一个input事件，如果主线程卡顿没法及时处理Input事件，这里的Value会堆积） 之后则是APP的UI线程启动，然后再触发APP的绘制线程进行绘制等等。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"},{"name":"input","slug":"input","permalink":"https://alonealive.github.io/Blog/tags/input/"}]},{"title":"Android Systrace如何抓取分析问题","slug":"2020/200222_android_systrace_study","date":"2020-02-22T12:32:00.000Z","updated":"2020-03-08T10:26:39.717Z","comments":true,"path":"2020/02/22/2020/200222_android_systrace_study/","link":"","permalink":"https://alonealive.github.io/Blog/2020/02/22/2020/200222_android_systrace_study/","excerpt":"UI流畅平滑的systraceSystrace获取：Android\\Sdk\\platform-tools\\systrace systrace.py：python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal res dalvik bionic power pm ss pdx sched freq idle load binder_driver binder_lock 默认Tag with: sched freq idle res ss gfx input view am","text":"UI流畅平滑的systraceSystrace获取：Android\\Sdk\\platform-tools\\systrace systrace.py：python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal res dalvik bionic power pm ss pdx sched freq idle load binder_driver binder_lock 默认Tag with: sched freq idle res ss gfx input view am 常用：./systrace -t 3 -b 10240 -o test.html sched freq idle res ss gfx input view am hal power wm 需要开的Tag 需求 tags cpu信息 sched/freq/idle 测试列表滑动，桌面滑动等流畅性问题 gfx/view/input/hwui 测试app launch，点击某个应用，点击进入某个界面 gfx/view/input/dalvik/disk 怀疑有power问题（亮灭屏，电量相关） gfx/view/input/res/am/wm/power time和buffer size一般我给的是-t 3 -b 8000 如果抓5s，-b可以给20480（kb） 如果时间再长，-b可以给30720（kb） 视频获取动画过程:指手机画面开始动的前一帧到画面停止动(完全显示，最后一帧)的过程，所以动画过程时间，依据动画不同，记录的时间也会不同。在播放高清视频时，影格数就表示画面所更新的次数，需要仔细观察视频画面。其中一影格就是手机更新画面时动一次，一般在fps为60的平台上，通常是一帧画面就会动一次，也就是一影格，而对于fps为30的平台，通常是两帧表示一影格。 FPS:表示每秒刷新的帧数，是画面流畅性的一个重要指标,那它是如何计算出来的呢（影格数除以动画时间） FPS:特定的区段时间内,每秒平均更新画面的次数。 数值的高低不能代表画面的流畅度 流畅度还是会跟画面的内容有关系（例如分辨率） 目前常用的FPS计算方法： systrace所录到的queuebuffer个数计算区段时间内的刷新次数 高速摄影机在区段时间内的刷新次数 从绘图流程的角度来看,这些FPS的意义是类似的：如果只有单一图层更新的情况,表示从APP画图到display显示的频率。 常见FPS TestCase： App 界面滑动换页的流畅性 browser浏览网页的流畅性 包含列表控件(list menu)界面卷动的流畅性 Contact list界面卷动的流畅性 Launch app 过场动画流畅性 Status bar下拉的流畅性 systrace查看绘制过程是否有问题（FPS）如图： 首先查看VSYNC周期是否正常，是否有进行vsync tunning； 查看是否queuebuffer成功？ 绘制之前调用dequeuebufffer从BufferQueue获取一个buffer，绘制完成会调用queuebuffer放回BufferQueue。 如果正常queuebufffer,则查看SF合成 如果queuebufffer不正常，则查看是否是queuebuffer阻塞？ 如果queuebuffer阻塞，则看GPU 若不是，查看HWUI绘制是否成功？ 如果HWUI没有绘制，则检查UIThread（UI线程） 如果UIThread调用了runnable，则查看SS（不清楚具体表示什么？） 如果skia耗费太长时间，则查看skia的代码（绘制API） 如果是view耗费太长时间，则查看view模块的代码 如果UI线程状态正常，则查看第三方APP是否有问题？ 如果HWUI绘制了，则检查UIThread和RenderThread（绘制线程） UIThread同上 如果HWUI耗时过长，检查是否阻塞在GL？（openGL） 如果是，则检查GPU 如果不是，则检查HWUI模块 上层到底层的模块图(Buffer流程)如图： 从APP开始 –》 然后到View（触发setView，测量布局绘制等操作） –》 然后到绘制，如果是软件绘制就是skia，如果是硬件绘制就是到HWUI，再到OpenGL –》 接着绘制完成，通过BufferQueue，调用queuebuffer函数 –》 触发SF合成 –》 查看合成方式，如果是GPU合成还是观察OpenGL，然后两种合成方式再调用到HWC模块 –》 然后到底层驱动Display Driver模块 –》 然后到硬件LCD Panel屏幕 Note: queubuffer的查看可以分两部分分析： Queue的速度有没有达到预期值？是否时间太长，一直在Queue？ 时间点是否正确，是否绘制完成？是否下一个时间点开始触发SF模块合成流程？ FPS问题关注点如图： APP在收到SW Vsync之后，开始产生新的frame 查看抓取APP的UIThread， 首先是Choreographer#doFrame进行绘制之前的测量、布局，以及reDraw重绘的判断，然后触发HWUI绘制； 查看DrawFrame部分，开始调用dequeubuffer获取buffer，以及其他GL Function； 绘制完成后调用eglSwapBuffers，然后再调用queuebuffer将Buffer放回bufferqueue； SF在收到下一个SW Vsync之后，从bufferqueue取出buffer，调用onMessageReceived，然后在函数latchBuffer到更新纹理updateTextImage（纹理数据可以通过GAPID工具抓取trace查看），再到acquireBuffer取Buffer； 合成完成后，HWC将SF传下来的工作排进内部thread（可以查看Dispatcher_0和DispSync） HWC处理合成之后，传到底层驱动display driver，然后触发驱动driver（可以查看OverlayEngine_0） 然后查看当前的DispSync，在当前的sen_sw_sync结束后将frame送到LCD Vsync周期是否正常如图： 如果是标准60fps刷新率，查看VSYNC的周期是否是16.6ms，绘制是否在这个周期内完成？ 绘制queuebuffer和下一帧合成的时间是否正常？ 底层硬件的FPS是否正常如图： 如果是标准60fps刷新率，查看底层的FPS（HW_VSYNC）是否是16.6ms正常的周期？ 查看queuebuffer周期是否规律如图： hasClientComposition对比hasDeviceComposition两种合成方式。 硬件绘制和软件绘制如何查看硬件绘制 HWUI draw会有Record View#draw() 如图： 软件绘制 SWUI draw会有drawSoftware lockCanvas 如图： view耗时太久如图： 可以分别查看测量、布局、以及软件/硬件绘制的过程。 Draw绘制太长 注意：systrace (don’t turn on hwui/gfx tag) 如图： 查看Choreographer#doFrame时长。 如图： 然后查看draw的耗时（注意是软件绘制SWUI） DrawFrame耗时 注意：systrace (don’t turn on hwui/gfx tag) 如图： 如果是标准60FPS帧率，则该函数耗时不要超过16.6ms OpenGL API绘制是否正常需要以下的函数被systrace抓取到，则需要开启GL trace开关： adb shell setprop debug.egl.trace systrace adb shell stop adb shell start (or make sure your app restart) Run systrace (需要加上tag：view,input,freq,res,hwui/gfx) 如图： 查看systrace的进程状态如图： 选中一个函数的区域（使用箭头）查看进程状态如图： 可以选择整个function的process state并确认统计信息,判断是否有runnable/sleep(D/S)过长的现象。 如图： 以下是确定是哪个部分异常，进一步详细调查的方式。 APP Owner（view模块异常） 如果已经确定Measure/Layout 占的时间很多。 adb shell setprop debug.view.systraceMeasure true adb shell setprop debug.view.systraceLayout true adb shell stop adb shell start (or make sure your app restart) 抓取systrace again 例如下面的例子， 可以发现ListView layout耗时过长。如图： APP Owner（HWUI模块异常） 到这一步已经没有异常耗时的draw operation, 所以主要是分析APP画图的行为。抓取方式： adb shell setprop debug.hwui.log.systrace 1 adb shell dumpsys gfxinfo 抓取 systrace again (must turn on view,input,freq,res,hwui/gfx) 如图： App owner (Consult SS) 进入此状态大多是因为当下系统资源不足而导致，需要case by case 确认可以解决的方案。 如图： 系统配置信息： 需要先确定对比机和测试机的系统配置信息CPU cores/freq 可以直接参考systrace (需确认CPU_FREQUENCY event有打开) 如图： App owner (Consult SF合成) 需要看trace判断具体问题方向，例如以下几种问题： Buffer是新的，但是内容还是和上一帧相同Mali GPU有种smart partial update机制（局部更新）, 不会整个buffer重刷。可以利用debug property先关闭, 视觉上比较容易看： adb shell setprop debug.gpu.hwcrc_disabled 1 adb shell stop adb shell start 如图： 检查buffer fence time同步时间如图： 强制GPU合成检查在开发者选项中打开GPU强制合成，如果关掉就正常, 问题方向转回到 HWC/driver。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android LCD背光驱动节电技术LABC/CABC","slug":"2020/200105_android_lcd_cabc","date":"2020-01-05T12:32:00.000Z","updated":"2020-03-08T10:24:30.225Z","comments":true,"path":"2020/01/05/2020/200105_android_lcd_cabc/","link":"","permalink":"https://alonealive.github.io/Blog/2020/01/05/2020/200105_android_lcd_cabc/","excerpt":"LCD背光驱动节电技术LABC/CABC 手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。主要了解一下背光驱动节电技术CABC的概念和功能。参考博客","text":"LCD背光驱动节电技术LABC/CABC 手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。主要了解一下背光驱动节电技术CABC的概念和功能。参考博客 *OEM和ODMNote: OEM：自主加工，英文全称Original Equipment Manufacturer，即原设备生产商。原始设备生产商(OEM)是指拥有自己的产品或产品理念，但有时会为了开发和/或制造这些产品而购买某些服务的公司。 ODM：自主设计，即ORIGINAL DESIGN MANUFACTURER，意为“原始设计制造商”，是指一家公司根据另一家公司的规格来设计和生产一个产品。例如，计算机公司如HP公司可能会就其想推向市场的一款笔记本电脑作出具体规格。它们会具体地列明产品的外观要求，如屏幕的尺寸和技术要求、输入/输出端口、键盘的前倾度、电脑包的外形和颜色、扬声器的位置等。它们还通常会具体列明对产品的主要内部细节如CPU或视频控制器的规格要求。但是，它们并不设计图样，不具体列明电源用的交换晶体管的型号，也不对背光变流器频率加以选择。这些都是ODM的工作。ODM根据计算机公司提出的规格要求来设计和生产笔记本电脑。有时候，ODM也可根据现有样品来生产。ODM方式往往更加注重合作，而在OEM的情形下，购买方对产品的具体规格基本不参与意见。 OBM：自主品牌 OEM和ODM的区别: OEM和ODM两者最大的区别不单单是名称而已。OEM产品是为品牌厂商度身订造的，生产后也只能使用该品牌名称，绝对不能冠上生产者自己的名称再进行生产。而ODM则要看品牌企业有没有买断该产品的版权。如果没有的话，制造商有权自己组织生产，只要没有企业公司的设计识别即可。 在工业社会中，OEM和ODM可谓司空见惯。因为出于制造成本、运输方便性、节省开发时间等方面的考虑，知名品牌企业一般都愿意找其他厂商OEM或ODM。在找别的企业进行OEM或ODM时，知名品牌企业也要承担不少责任。毕竟产品冠的是自己的牌子，如果产品质量不佳的话，少则有顾客找上门投诉，重则可能要上法庭。所以，品牌企业在委托加工期间肯定会进行严格的质量控制。但代工结束后，质量不敢保证。故此，当有的商家告诉你某件产品的生产商是某大品牌的OEM或ODM产品时，绝不要相信其质量就等同于该品牌。你唯一能够相信的，是这家制造商有一定的生产能力。 背光节电技术显示屏在移动设备里一直的是耗电大户。目前手机背光节电技术，即对应性背光控制技术（Adaptive Brightness Control- ABC），主要有下面2种： LABC：(LightAdaptive Brightness Control) 环境光侦测适应背光控制。根据环境光的变化来控制背光亮度。需要一个光传感器，感应环境光强。 CABC：(ContentAdaptive Brightness Control）显示内容对应背光控制。根据显示内容来调节背光和gamma值，从而降低了背光LED的功耗。其中C是内容的意思，驱动IC新增了一个内容分析器电路。 LABCLABC技术需要搭配光传感器实现，主机端处理器读取光感数值，然后处理器对数值进行处理，直接控制PMIC(MT6329)输出PWM控制背光的亮度。在比较暗光线下，降低背光达到省电效果 CABCCABC功能需要在LCD驱动IC内新增一个内容分析器(imagecontent analyzer)电路，当手机处理器传送了一张图片数据到驱动IC，内容分析器会计算并统计图片的数据后依据设定与算法自动的将其灰阶亮度提高30%（此时图片变亮），再将背光亮度降低30%（此时图片变暗）。由于我们事先已经将图片经过分析器电路补偿亮度，因此使用者可以得到与原先电路相差无几的显示效果，但减少了30%的背光功耗。 简单来说，CABC功能就是根据显示内容来降低背光，然后通过调节gamma(gamma越高灰度越低图像越暗)来补偿显示亮度。CABC就是通过增加内容灰阶标准同时降低背光亮度来达到省功耗的目的。 CABC主要有四种状态： Off Mode，CABC功能全部关闭； UI Image Mode，优化显示UI图片时的功耗，尽可能的保证图片质量的同时可省10%的功耗； Still Image Mode，优化显示静态图片时的功耗，该模式下图片质量损耗在可接受的范围内，同时可省30%的功耗； Moving Image Mode，优化显示动态图片时的功耗，该模式下会最大限度的降低功耗，但是会带来图片质量的损耗，可省30%+的功耗。 自然对应Off Mode，标准对应UI Mode，照片对应UI Mode，电影对应Still Image Mode。用户可根据实际情况自行选择。 三种模式省电级别依次降低: UI mode &lt; Movie mode &lt; Still mode， 也就是说Still mode是最省电的模式。 工作流程工作流程如下： 使能PMIC(MT6329)CABC功能; 设置LCD驱动IC的相关配置(使能CABC和配置gamma参数，需要FAE协助)； CABC模块分析显示内容输出LED_PWM信号给PMIC，PMIC通过一定算法控制driver模块BL_DRV信号的输出波形； 预期结果是背光亮度降低，LCD驱动IC降低gamma值以补偿屏幕亮度。 CABC模块分析显示内容输出PWM波形，占空比越大，表示需要输出的电流越大。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"display","slug":"display","permalink":"https://alonealive.github.io/Blog/tags/display/"}]},{"title":"Android SurfaceFlinger和HWC2概述","slug":"2019/191222_android_HWC2","date":"2019-12-22T15:32:00.000Z","updated":"2020-03-08T10:22:18.357Z","comments":true,"path":"2019/12/22/2019/191222_android_HWC2/","link":"","permalink":"https://alonealive.github.io/Blog/2019/12/22/2019/191222_android_HWC2/","excerpt":"转载夕月风大佬博客： https://www.jianshu.com/p/824a9ddf68b9参考Android Q AOSP源码添加修改部分内容参考源码： http://aosp.opersys.com/xref/android-10.0.0_r14/","text":"转载夕月风大佬博客： https://www.jianshu.com/p/824a9ddf68b9参考Android Q AOSP源码添加修改部分内容参考源码： http://aosp.opersys.com/xref/android-10.0.0_r14/ SurfaceFlinger概述大多数APP在屏幕通常显示三个部分： 屏幕顶部的状态栏 底部或者侧边的导航栏 应用的界面 有些应用会显示更多或者更少的层。例如主屏幕会有一个单独的壁纸层；全屏幕的游戏可能会隐藏状态栏目。这些可以通过Dump Surfacelinger查看BufferLayers部分的信息来获取具体信息（adb shell dumpsys SurfaceFlinger）。从Dump结果看，layer呈树形结构(Tree)分布。 每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。 SurfaceFlinger类定义frameworks/native/services/surfaceflinger/SurfaceFlinger.h123456789class SurfaceFlinger : public BnSurfaceComposer, public PriorityDumper, private IBinder::DeathRecipient, private HWC2::ComposerCallback&#123;public: SurfaceFlingerBE&amp; getBE() &#123; return mBE; &#125; const SurfaceFlingerBE&amp; getBE() const &#123; return mBE; &#125; ...... 继承BnSurfaceComposer，实现ISurfaceComposer接口；实现ComposerCallback；继承辅助类PriorityDumper，主要提供SurfaceFlinger的Dump信息，并且提高提供信息的分离和格式设置。 ISurfaceComposer接口实现ISurfaceComposer是提供给上层Client端的接口（Bp端），此处的SurfaceFlinger是Server端（Bn端）。接口内容包括： frameworks/native/include/gui/ISurfaceComposer.h123456789class ISurfaceComposer: public IInterface &#123;public: DECLARE_META_INTERFACE(SurfaceComposer) ...... /* returns information for each configuration of the given display * intended to be used to get information about built-in displays */ virtual status_t getDisplayConfigs(const sp&lt;IBinder&gt;&amp; display, Vector&lt;DisplayInfo&gt;* configs) = 0; ...... 接口在SurfaceFlinger中都有对应的方法实现。Client端通过Binder跨进程调到SurfaceFlinger中。获取Display的信息，其实现就是SurfaceFlinger的getDisplayConfig函数。 ComposerCallback接口实现ComposerCallback是HWC2的callback接口，包括以下接口： frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h12345678910111213141516171819202122232425namespace HWC2 &#123;class Display;class Layer;// Implement this interface to receive hardware composer events.//// These callback functions will generally be called on a hwbinder thread, but// when first registering the callback the onHotplugReceived() function will// immediately be called on the thread calling registerCallback().//// All calls receive a sequenceId, which will be the value that was supplied to// HWC2::Device::registerCallback(). It's used to help differentiate callbacks// from different hardware composer instances.class ComposerCallback &#123; public: virtual void onHotplugReceived(int32_t sequenceId, hwc2_display_t display, Connection connection) = 0; virtual void onRefreshReceived(int32_t sequenceId, hwc2_display_t display) = 0; virtual void onVsyncReceived(int32_t sequenceId, hwc2_display_t display, int64_t timestamp) = 0; virtual ~ComposerCallback() = default;&#125;;..... Callback提供了注册接口registerCallback，在SurfaceFlinger初始化的时候注册： 123456void SurfaceFlinger::init() &#123; ALOGI( \"SurfaceFlinger's main thread ready to run. \" \"Initializing graphics H/W...\");....mCompositionEngine-&gt;getHwComposer().registerCallback(this, getBE().mComposerSequenceId);.... 此处registerCallback的this就是SurfaceFlinger对ComposerCallback接口的实现。 onHotplugReceived： 热插拔事件的回调，显示屏幕连接或者断开时回调。 onRefreshReceived： 接收底层HWComposer的刷新请求。在repaintEverythingForHWC中，mRepaintEverything为true的时候，将触发一次刷新，重新进行合成显示。重新绘制说明底层配置、参数等有变动，SurfaceFlinger前面给的数据不能用，需要重新根据变动后的配置进行合成，给适合当前配置的显示数据。 frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp123456789101112void SurfaceFlinger::onRefreshReceived(int sequenceId, hwc2_display_t /*hwcDisplayId*/) &#123; Mutex::Autolock lock(mStateLock); if (sequenceId != getBE().mComposerSequenceId) &#123; return; &#125; repaintEverythingForHWC();&#125;void SurfaceFlinger::repaintEverythingForHWC() &#123; mRepaintEverything = true; mEventQueue-&gt;invalidate();&#125; onVsyncReceived： Vsync事件上报，接收底层硬件上报的垂直同步信号。此处可以通过抓取Systrace的方式查看具体的Vsync的信息（底层硬件、SurfaceFlinger、APP三部分的Vsync，一般Android版本升级的时候会进行vsync的tuning） 显示周期Vsync： 设备显示会按照一定速率更新（一般是一秒60帧，即16.6ms刷新一次）。如果显示内容在刷新期间更新，则会出现撕裂现象，因此必须在周期之间更新（这也是vsync tunning的必要性，保持SurfaceFlinger和draw frame都在vsync周期里面，并且不重叠）在可以安全更新内容时，系统便会接收来自显示设备的信号。 刷新率可能会随时间而变化，例如一些设备的刷新范围在58fps至62fps之间，具体视当前条件而定。对于连接了HDMI的电视，刷新率在理论上可以下降到24Hz或者48Hz，以便和视频匹配。由于每个刷新周期只能更新屏幕一次，因此以200fps的刷新率为显示设备提交缓冲区并没有必要性，因为大部分桢不能被看到（人眼合适的是60fps）。SurfaceFlinger不会在应用提交缓冲区时进行操作，而是在显示设备准备好接收新缓冲区的时候才会唤醒。 当Vsync信号到达的时候，SurfaceFlinger会遍历层列表，以寻找新的缓冲区。如果找到会获取该缓冲区，否则会使用以前获取的缓冲区。SurfaceFlinger总是需要可显示的内容，因此会保留一个缓冲区。如果在某个层没有提交缓冲区，则该层会被忽略。 此处会在合成调用到handlePageFlip函数，函数中先调用latchBuffer从BufferQueue取Buffer，然后等待Vsync信号更新到FrameBuffer。 合成方式： 目前SurfaceFlinger支持两种合成方式：一种是Device合成，一种是Client合成。SurfaceFlinger在收集可见层的所有缓冲区之后，便会询问HardwareComposer应该如何进行合成。 Client合成：之前称之为GLES合成，也可以称之为GPU合成，该合成方式是相对于硬件合成来说的，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件Client合成采用RenderEngine进行合成。 Device合成： 用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Device合成的抽象。 合成方式可以从Dump SurfaceFlinger中查看到Layer的具体合成方式，GPU合成一般可以通过开发者选项中启动，强制GPU合成；而Device合成在Dump信息中一般显示成SDE合成。 GPU合成数据后，作为一个特殊的Layer传给显示硬件。 12345678910111213141516171819202122232425262728293031Display 0 HWC layers:------------------------------------------------------------------------------- Layer name Z | Comp Type | Disp Frame (LTRB) | Source Crop (LTRB)------------------------------------------------------------------------------- com.android.systemui.ImageWallpaper#0 rel 0 | Client | 0 0 1080 2280 | 0.0 0.0 1080.0 2280.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - net.oneplus.launcher/net.oneplus.launcher.Launcher#0 rel 0 | Client | 0 0 1080 2280 | 0.0 0.0 1080.0 2280.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - StatusBar#0 rel 0 | Client | 0 0 1080 80 | 0.0 0.0 1080.0 80.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - GestureButtonRegion#0 rel 0 | Client | 0 2216 1080 2280 | 0.0 0.0 1080.0 64.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ScreenDecorOverlay#0 rel 0 | Device | 0 0 1080 106 | 0.0 0.0 1080.0 106.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ScreenDecorOverlayBottom#0 rel 0 | Device | 0 2198 1080 2280 | 0.0 0.0 1080.0 82.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|| Idx | Comp Type | Split | Pipe | W x H | Format | Src Rect (L T R B) | Dst Rect (L T R B) | Z | Flags | Deci(HxV) | CS | Rng ||-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|| 6 | GPU_TARGET | Pipe-1 | 94 | 1088 x 2288 | RGBA_8888_UBWC | 0 0 1080 2280 | 0 0 1080 2280 | 0 | 0x00000002 | 0 x 0 | 0 | 0 || 4 | SDE | Pipe-1 | 103 | 1088 x 112 | RGBA_8888_UBWC | 0 0 1080 106 | 0 0 1080 106 | 1 | 0x00000000 | 0 x 0 | 1 | 1 || 5 | SDE | Pipe-1 | 92 | 1088 x 96 | RGBA_8888_UBWC | 0 0 1080 82 | 0 2198 1080 2280 | 2 | 0x00000000 | 0 x 0 | 1 | 1 ||-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----| SurfaceFlingerBE: 从Android P上分离出来，定义上看是将Surfacelinger分离为前后端。 消息队列和主线程： 和应用进程类似，SurfaceFlinger也有一个主线程，主要是进行显示数据的处理，即合成。Surfacelinger是一个服务，将会响应上层的请求，各个进程的请求都在SurfaceFlinger的各个Binder线程中，如果线程很耗时，那么应用端就会被block。主线程将他们分离开来，各干各的。 Note： SurfaceFligner有两个状态，Layer也有两个状态，一个是mCurrentState，一个是mDrawingState。 两个EventThread，一个是给SurfaceFlinger本身使用，一个是为了给应用分发事件的。 mCurrentState和mDrawingState 这两个成员是Layer类中Layer::State的类型。 Layer.h123456789101112131415161718struct State &#123; Geometry active; //计算后的实际尺寸 Geometry requested; //用户设置的尺寸 int32_t z; //Layer的Z轴值，值越小位置就越靠小 uint32_t layerStack; //和显示设备的关联值 unit8_t alpha; //Layer的透明度 uint8_t flags; //Layer的标志（如果上次绘制后用户改变了Layer） uint8_t reserved[2]; int32_t sequence; //序列值，Layer的属性变化一次就会加一（例如setAlpha,setSize,setLayer等） ... // the transparentRegion hint is a bit special, it's latched only // when we receive a buffer -- this is because it's \"content\" // dependent. Region activeTransparentRegion; //实际的透明区域 Region requestedTransparentRegion; //用户中的透明区域 ...&#125;; Surfacelinger创建Surface的时候，会调用createLayer，然后调用addClientLayer函数，这里会把Layer对象放在mCurrentState的layerSortedByZ对象中。 Surfacelinger合成的时候，调用preComposition函数，会先调用mDrawingState的layerSortedByZ来获取上次绘图的Layer层列表（并不是所有layer都参与屏幕图像的绘制，因此通过State对象记录参与绘制的Layer对象） Layer对象在绘制图形时，使用的是mDrawingState变量；用户调用接口设置Layer对象属性时，设置的值保存在mCurrentState中。这样就不会因为用户的操作而干扰Layer对象的绘制了。 Layer::doTransaction函数会比较这两个成员变量，如果有不同的地方，说明上次绘制后，用户改变了Layer的属性，要把这种变化通过flags返回。 layerStack字段是用户指定的一个值，用户可以给DisplayDevice指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备输出。这样的好处可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放的Surface窗口，但是不显示Activity窗口。 Layer::doTransaction最后会调用commitTransaction函数，就是将mCurrentState赋值给mDrawingState。 以上的是在Layer.cpp中的两个成员变量，而在SurfaceFlinger.cpp也有同名的mCurrentState和mDrawingState两个成员变量（定义在SurfaceFlinger.h中），定义不一样，只是名字相同。 SF.h12345678910111213141516171819202122232425class State &#123;public: explicit State(LayerVector::StateSet set) : stateSet(set), layersSortedByZ(set) &#123;&#125; State&amp; operator=(const State&amp; other) &#123; // We explicitly don't copy stateSet so that, e.g., mDrawingState // always uses the Drawing StateSet. layersSortedByZ = other.layersSortedByZ; displays = other.displays; colorMatrixChanged = other.colorMatrixChanged; if (colorMatrixChanged) &#123; colorMatrix = other.colorMatrix; &#125; return *this; &#125; const LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid; LayerVector layersSortedByZ; //保存所有参与绘制的Layer对象 DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays; //保存所有输出设备的DisplayDeviceState对象 bool colorMatrixChanged = true; mat4 colorMatrix; void traverseInZOrder(const LayerVector::Visitor&amp; visitor) const; void traverseInReverseZOrder(const LayerVector::Visitor&amp; visitor) const;&#125;; SF.cpp中的handleTransactionLocked函数会根据eTraversalNeeded标志决定是否要检查所有的Layer对象。如果某个Layer对象有这个标志，将会调用他的doTransaction函数。Layer::doTransaction函数返回的flags如果有eVisibleRegion说明这个Layer需要更新，就把mVisibleRegionDirty设置为true。 1234567891011121314151617181920212223242526272829void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; // Notify all layers of available frames mCurrentState.traverseInZOrder([](Layer* layer) &#123; layer-&gt;notifyAvailableFrames(); &#125;); /* * Traversal of the children * (perform the transaction for each of them if needed) */ if (transactionFlags &amp; eTraversalNeeded) &#123; mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123; uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) return; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;); &#125; ......//这部分代码是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看LayerStack是否和DisplayDevice的layerStack相同）的TransformHint（主要指设备的显示方向orientation） commitTransaction(); updateCursorAsync();&#125; Note: handleTransaction的作用是处理系统在两次刷新期间的各种变化。Surfacelinger模块中不管是SurfaceFlinger类和Layer类 硬件合成HWC2概述Hardware Composer HAL(HWC)是指硬件完成图像数据组合并显示的能力。 SurfaceFlinger是一个系统服务（系统启动时启动），作用是接收来自多个源的Buffer数据，并进行合成，然后发送到显示设备进行显示。 SurfaceFlinger和HWC的相互配合，实现Android系统的合成和显示（非GPU合成）。 Android 7.0包含新版本的HWC（HWC2），Android需要自行配置。 Android 8.0，HWC2正式开启，并且版本升级为2.1。（/frameworks/native/services/surfaceflinger/DisplayHardware/） HWC2是SurfaceFlinger用来与专门的窗口合成硬件进行通信（Device合成方式）。SurfaceFlinger包含使用3D图形处理器（GPU）执行窗口合成任务的备用途径，但是此路径并不理想（GPU合成方式），因为： 通常，GPU没有针对此进行优化，因此能耗可能大于执行合成所需的能耗； 每次SUrfaceFlinger使用GPU合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是GPU进行合成。 GPU（Client合成）和HWC（Client合成）两种方式对比： 合成类型 耗电情况 性能情况 Alpha处理 DRM内容处理 其他限制 Device合成（HWC） 耗电低 性能高 很多Vendor的HWC不支持Alpha的处理和合成 基本都能访问DRM内容 能合成的Surface层数有限，对每种Surface类型处理层数有限 Client合成（GPU） 耗电高 性能低 能处理每个像素的Alpha及每个Layer的Alpha 早期版本GPU不能访问DRM的内容 目前的处理层数没有限制 Note: Alpha处理： 图片的透明度（0～255或者0.0f~1.0f），数值越小透明度越高 DRM内容处理：（Digital Rights Management）一种业界使用广泛的数字内容版权保护技术。 HWC常规准则Hardware Composer抽象层后的物理显示设备硬件可因设备而异。但是一般来说，遵循以下规则： HWC应至少支持4个叠加层（状态栏、系统栏、应用、壁纸/背景） 层可以大于屏幕，因此HWC应能处理大于显示屏的层（例如壁纸） 应该同时支持预乘每个像素Alpha混合和每个平面Alpha混合 HWC应能够处理GPU、Camera、视频解码器（Video Decoder）生成的相同缓冲区，因此支持以下某些属性会很有帮助： RGBA打包顺序 YUV格式 Tiling,swizzling和步幅属性 为了支持受保护的内容（Secure layer），必须提供受保护视频播放的硬件路径 Note： RGBA是一种颜色值 YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。他与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。从字面意思理解，YUV的含义:Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，如YUV422这是大部分镜头出来的数据，还有许多（yuv420,yuv444等） Tiling简单来说就是将image进行切割，切成M * N小块，最后用的时候再进行拼接，类似铺瓷砖 swizzling是一种拌和技术，这是向量的单元可以被任意的重新排放或重复 HWC专注于优化，智能的选择要发送到叠加硬件的Surface，以最大限度减轻GPU的负载。另一种优化是检测屏幕是否正在更新；如果不是，这将合成委托给OpenGL而不是HWC，以节省电量。但屏幕再次更新时，继续将合成分发给HWC。 为常见的用例做准备，比如： 纵向和横向模式下的全屏游戏 带着字幕和播放控件的全屏视频 主屏幕（状态栏、系统栏目、应用、动态壁纸） 受保护的视频播放 多显示设备支持 HWC2框架从Android 8.0开始的Treble项目，对Android架构做了调整，让制造商以更低的成本更加轻松快速的将设备更新到Android系统。这就对HAL层有了很大的调整，利用提供给Vendor的接口，将Vendor的实现和Android上层分离开来。 这样的架构也使得HWC架构变得复杂，HWC属于Binderized的HAL类型。Binderized类型的HAL将上层Android和底层HAL分别采用两个不同的进程实现，中间采用Binder进行通信，为了和前面的Binder进行区别，这里采用HWBinder。 可以将HWC分为以下几个部分： Binder 1： SurfaceFlinger Service HWC2 Client Binder 2： HWC2 Server HWC2 Vendor Impl 具体解释： Client端：Client就是指SurfaceFlinger。不过SurfaceFlinger采用前后端设计，以后和HWC相关的逻辑应该会放到后端（SurfaceFlingerBE），即/frameworks/native/services/surfaceflinger/ HWC Client端： 这一部分属于SurfaceFlinger进程，直接用过Binder通信，和HWC2的HAL Server交互。在SurfaceFlinger中采用namespace HWC2的命名空间，即frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp。 HWC2 Server端: 这里将建立一个进程实现HWC的Server端。服务端再调用底层Vendor的具体实现。并且，对于底层合成的实现不同，此处会做一些适配（适配HWC1.x），和FrameBuffer的实现。这部分包含三部分：接口、实现、服务，以动态库的形式存在：（hardware/interfaces/graphics/composer/2.1/default/） android.hardware.graphics.composer@2.1.so android.hardware.graphics.composer@2.1-impl.so android.hardware.graphics.composer@2.1-service.so HWC Vendor实现： 这部分是HWC的具体实现，由硬件厂商完成，（例如高通QCOM），代码一般是hardware/qcom/display/。HWC必须采用Binderized HAL模式，但是不一定要实现HWC2的HAL版本。HWC2的实现需要配置，以Android 8.0为例，包含： 添加宏定义TARGET_USERS_HWC2 编译打包HWC2相关的so库 SELinux相关的权限添加 配置manifest.xml：123456789&lt;hal format=\"hidl\"&gt; &lt;name&gt;android.hardware.graphics.composer&lt;/name&gt; &lt;transport&gt;hwbinder&lt;/transport&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;interface&gt; &lt;name&gt;IComposer&lt;/name&gt; &lt;instance&gt;default&lt;/instance&gt; &lt;/interface&gt;&lt;/hal&gt; HWC2数据结构 HWC2的一些常用接口定义在头文件hardware/libhardware/include/hardware/hwcomposer2.h中，一些共用的数据定义是HAL的接口中: hardware/interfaces/graphics/common/1.0/ hardware/interfaces/graphics/composer/2.1/ 图层Layer每个Layer都有一组属性，用来定义和其他Layer的交互方式。他在每一个模块（层）代码定义的实现不一样，但是Layer的理念是一样的。 SurfaceFlinger中 12345678frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger├── Layer.h├── Layer.cpp├── ColorLayer.h├── ColorLayer.cpp├── BufferLayer.h└── BufferLayer.cpp|__ ... HWC2中 123frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;DisplayHardware├── HWC2.h└── HWC2.cpp 在HAL中实现时，定义为hwc2_layer_t，是在头文件hwcomposer2.h中定义的:typedef uint64_t hwc2_layer_t; HIDL中定义为Layer，这个Layer和hwc2_layer_t是一样的：typedef uint64_t Layer; Layer按照类型划分大致分为BufferLayer和COlorLayer（在SF中createLayer中），BufferLayer就是有Buffer的Lyaer（Bufferueue，GraphicsBuffer），需要上层应用Producer生长；ColorLayer可以绘制一种制定的颜色和透明度Alpha（取代之前的Dim Layer）。 Layer按照数据划分大致分为RGB Layer和YUV Layer，前者是RGB格式，比较常见的就是UI界面的数据；后者的Buffer是YUV类型的，平常播放Video，Camera预览等，都是YUV类型的。 Layer属性* Layer的属性定义他和其他模块（层）的关系，和显示屏（DeisplayDevice）的关系等。Layer包含的属性类别如下（上述也有部分内容）： 位置属性 定义层在其显示设备上的现实位置，包含层边缘的位置和其相对于其他层的Z-Order等，并且还定义了很多个区域Region： frameworks/native/services/surfaceflinger/Layer.h123456789class Layer : public virtual RefBase &#123; ... ...public: ... ... // regions below are in window-manager space Region visibleRegion; Region coveredRegion; Region visibleNonTransparentRegion; Region surfaceDamageRegion; Region中是很多个Rect的集合，即一个Layer的visibleRegion可能是几个Rect的集合（rect对象用来存储一个矩形框的左上角坐标、宽度和高度。描述矩形的宽度、高度和原点） SurfaceFlinger中定义的Region都是从上层（WMS）传递过来的。而在HWC中，是用的下面的结构描述： hardware/libhardware/include/hardware/hwcomposer_defs.h123456789101112131415161718192021222324252627282930313233typedef struct hwc_color &#123; uint8_t r; uint8_t g; uint8_t b; uint8_t a;&#125; hwc_color_t;typedef struct hwc_float_color &#123; float r; float g; float b; float a;&#125; hwc_float_color_t;typedef struct hwc_frect &#123; float left; float top; float right; float bottom;&#125; hwc_frect_t;typedef struct hwc_rect &#123; int left; int top; int right; int bottom;&#125; hwc_rect_t;typedef struct hwc_region &#123; size_t numRects; hwc_rect_t const* rects;&#125; hwc_region_t; Transform，这个在SurfaceFlinger中定义的一个重要的结构，意思是变换矩阵，是一个3*3的矩阵。 联系流程：Rect &lt;- Region &lt;- Layer &lt;- State &lt;- Geometry &lt;- Transform &lt;- mat33 Layer的两个状态：mCurrentState和mDrawingState，前者是给SurfaceFlinger的前段准备数据，后者是将数据给到合成。每个状态有两个Geometry的描述request（上层请求的）和active（当前正在使用的）。每个Geometry中有一个Transform矩阵，一个Transform包含一个mat33的整列。 Transform中包含两部分，一部分是位置Postion，另一部分是真正的2D的变换矩阵。通过下面两个函数设置：（对应Layer中的setPostion和setMatrix函数，这是上层WMS设置下来的） frameworks/native/libs/ui/Transform.cpp12345678910111213141516171819202122void Transform::set(float tx, float ty)&#123; mMatrix[2][0] = tx; mMatrix[2][1] = ty; mMatrix[2][2] = 1.0f; if (isZero(tx) &amp;&amp; isZero(ty)) &#123; mType &amp;= ~TRANSLATE; &#125; else &#123; mType |= TRANSLATE; &#125;&#125;void Transform::set(float a, float b, float c, float d)&#123; mat33&amp; M(mMatrix); M[0][0] = a; M[1][0] = b; M[0][1] = c; M[1][1] = d; M[0][2] = 0; M[1][2] = 0; mType = UNKNOWN_TYPE;&#125;...... 内容属性 定义显示的内容如何呈现（即Buffer）。Layer的显示，除了之前的几个区域Region描述，还有很多结构进一步描述才能显示，例如裁减（用来扩展内容的一部分以填充层的边界）和转换（用来显示旋转或者翻转的内容）等信息。HWCInfo结构体中包括了一些这样的信息： frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct OutputLayerCompositionState &#123; // The region of this layer which is visible on this output Region visibleRegion; // If true, client composition will be used on this output bool forceClientComposition&#123;false&#125;; // If true, when doing client composition, the target may need to be cleared bool clearClientTarget&#123;false&#125;; // The display frame for this layer on this output Rect displayFrame; // The source crop for this layer on this output FloatRect sourceCrop; // The buffer transform to use for this layer o on this output. Hwc2::Transform bufferTransform&#123;static_cast&lt;Hwc2::Transform&gt;(0)&#125;; // The Z order index of this layer on this output uint32_t z; /* * HWC state */ struct Hwc &#123; explicit Hwc(std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer) : hwcLayer(hwcLayer) &#123;&#125; // The HWC Layer backing this layer std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer; // The HWC composition type for this layer Hwc2::IComposerClient::Composition hwcCompositionType&#123; Hwc2::IComposerClient::Composition::INVALID&#125;; // The buffer cache for this layer. This is used to lower the // cost of sending reused buffers to the HWC. HwcBufferCache hwcBufferCache; &#125;; // The HWC state is optional, and is only set up if there is any potential // HWC acceleration possible. std::optional&lt;Hwc&gt; hwc; // Debugging void dump(std::string&amp; result) const;&#125;; 关系图： 解释： Layer区域和屏幕区域，就是Layer和屏幕本身的大小区域 sourceCrop：剪切区域，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。 displayFrame：显示区域，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。 visibleRegion：可见区域，displayFrame 区域不一定都能看到的，如果存在上层Layer，那么displayFrame区域可能部分或全部被盖住，displayFrame没有被盖住的部分就是可见区域visibleRegion。 damageRegion 受损区域，或者称之为更新区域。damageRegion表示Layer内容被破坏的区域，也就是说这部分区域的内容变了，所以这个属性一般是和上一帧相比时才有意义。这算是对合成的一种优化，重新合成时，我们只去合成damageRegion区域，其他的可见区域还是用的上一帧的数据。 visibleNonTransparentRegion：可见非透明区域。透明区域transparentRegion是可见区域visibleRegion的一部分，只是这一部分透明的看到的是底层Layer的内容。在SurfaceFlinger的Layer中定义visibleNonTransparentRegion，表示可见而又不透明的部分。 coveredRegion：被覆盖的区域。表示Layer被TopLayer覆盖的区域，一看图就很好理解。从图中，你可以简单的认为是displayFrame和TopLayer区域重合的部分。 注意： 这里之所以说简单的认为，这是因为HWC空间的区域大小是SurfaceFlinger空间的区域经过缩放，经过Transform旋转，移动等后才得出的，要是混淆了就理解不对了。 合成属性（确认用哪种合成方式） 定义层应如何与其他层合成。包括混合模式和用于Alpha合成的全层Alpha值等信息。总的说来，合成分为两个大类：GPU合成和HWC合成。根据具体的情况，分为下列几类： hardware/libhardware/include/hardware/hwcomposer2.h12345678enum class Composition : int32_t &#123; Invalid = HWC2_COMPOSITION_INVALID, Client = HWC2_COMPOSITION_CLIENT, Device = HWC2_COMPOSITION_DEVICE, SolidColor = HWC2_COMPOSITION_SOLID_COLOR, Cursor = HWC2_COMPOSITION_CURSOR, Sideband = HWC2_COMPOSITION_SIDEBAND,&#125;; 释义： Client 相对HWC2硬件合成的概念，主要是处理BufferLayer数据，用GPU处理。 Device HWC2硬件设备，主要处理BufferLayer数据，用HWC处理 SolidColor 固定颜色合成，主要处理ColorLayer数据，用HWC处理或GPU处理。 Cursor 鼠标标识合成，主要处理鼠标等图标，用HWC处理或GPU处理 Sideband Sideband为视频的边频带，一般需要需要硬件合成器作特殊处理，但是也可以用GPU处理。 在合成信息HWCInfo中，包含成的类型。通过Layer的setCompositionType方法进行指定： frameworks/native/services/surfaceflinger/Layer.cpp12345678910111213141516171819202122void Layer::setCompositionType(int32_t hwcId, HWC2::Composition type, bool callIntoHwc) &#123; if (getBE().mHwcLayers.count(hwcId) == 0) &#123; ALOGE(\"setCompositionType called without a valid HWC layer\"); return; &#125; auto&amp; hwcInfo = getBE().mHwcLayers[hwcId]; auto&amp; hwcLayer = hwcInfo.layer; ALOGV(\"setCompositionType(%\" PRIx64 \", %s, %d)\", hwcLayer-&gt;getId(), to_string(type).c_str(), static_cast&lt;int&gt;(callIntoHwc)); //默认true if (hwcInfo.compositionType != type) &#123; ALOGV(\" actually setting\"); hwcInfo.compositionType = type; if (callIntoHwc) &#123; auto error = hwcLayer-&gt;setCompositionType(type); //合成方式 ALOGE_IF(error != HWC2::Error::None, \"[%s] Failed to set \" \"composition type %s: %s (%d)\", mName.string(), to_string(type).c_str(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); &#125; &#125;&#125; 确定合成类型分成三步： SurfaceFlinger制定合成类型，此时callIntoHwc=true，将类型制定给HWC HWC根据实际情况看SurfaceFlinger制定的合成类型是否可以执行，如果不满足，作出修改 SurfaceFlinger根据HWC的修改情况再作出调整，最终确认合成类型，此时callIntoHwc=false 优化属性 提供一些非必须的参数，以供HWC进行合成的优化。包括层的可见区域以及层的哪个部分自上一帧以来已经更新等信息。也就是前面说到的visibleRegion，damageRegion等。 小结 本篇主要是SurfaceFlinger概述，和HWC2的概述，还有Layer的属性和类型，合成方式的内容。另外还有关于HWC的内容，和Display显示设备的信息重新划分单独的一篇学习。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android Binder实例","slug":"2019/191124_android_binder_example","date":"2019-11-24T07:59:40.000Z","updated":"2020-03-08T10:18:54.622Z","comments":true,"path":"2019/11/24/2019/191124_android_binder_example/","link":"","permalink":"https://alonealive.github.io/Blog/2019/11/24/2019/191124_android_binder_example/","excerpt":"Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点： 用驱动程序来推进进程间的通信； 可以通过共享内存的方式来提供性能； 可以为进程请求分配每个进程的线程池； 针对系统中的对象引入了引用计数和跨进程的对象引用映射； 可以方便的进行进程同步调用。","text":"Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点： 用驱动程序来推进进程间的通信； 可以通过共享内存的方式来提供性能； 可以为进程请求分配每个进程的线程池； 针对系统中的对象引入了引用计数和跨进程的对象引用映射； 可以方便的进行进程同步调用。 以下简单的Binder实例参考一位大佬。 文件目录12345678910111213141516cmds&#x2F;helloWorld&#x2F;Android.mk | 29 +++++++++++++++++++++++cmds&#x2F;helloWorld&#x2F;BnHelloWorldService.h | 16 +++++++++++++cmds&#x2F;helloWorld&#x2F;BpHelloWorldService.h | 12 ++++++++++cmds&#x2F;helloWorld&#x2F;HelloWorldService.h | 17 +++++++++++++cmds&#x2F;helloWorld&#x2F;IHelloWorldService.h | 21 +++++++++++++++++cmds&#x2F;helloWorld&#x2F;main_helloworldclient.cpp | 36 ++++++++++++++++++++++++++++cmds&#x2F;helloWorld&#x2F;main_helloworldservice.cpp | 22 +++++++++++++++++libs&#x2F;helloWorld&#x2F;Android.bp | 38 ++++++++++++++++++++++++++++++libs&#x2F;helloWorld&#x2F;BnHelloWorldService.cpp | 24 +++++++++++++++++++libs&#x2F;helloWorld&#x2F;BnHelloWorldService.h | 16 +++++++++++++libs&#x2F;helloWorld&#x2F;BpHelloWorldService.cpp | 25 ++++++++++++++++++++libs&#x2F;helloWorld&#x2F;BpHelloWorldService.h | 12 ++++++++++libs&#x2F;helloWorld&#x2F;HelloWorldService.cpp | 33 ++++++++++++++++++++++++++libs&#x2F;helloWorld&#x2F;HelloWorldService.h | 17 +++++++++++++libs&#x2F;helloWorld&#x2F;IHelloWorldService.cpp | 8 +++++++libs&#x2F;helloWorld&#x2F;IHelloWorldService.h | 21 +++++++++++++++++ cmds/helloWorld/Android.mk1234567891011121314151617181920212223242526272829# Copyright 2019 The Android Open Source Project#LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := main_helloworldservice.cppLOCAL_SHARED_LIBRARIES :=\\ libutils \\ libbinder \\ libhelloworldbase := $(LOCAL_PATH)/../../libs/helloWorldLOCAL_MODULE := helloworldserviceinclude $(BUILD_EXECUTABLE)include $(CLEAR_VARS)LOCAL_SRC_FILES := main_helloworldclient.cppLOCAL_SHARED_LIBRARIES :=\\ libutils \\ libbinder \\ libhelloworldbase := $(LOCAL_PATH)/../../libs/helloWorldLOCAL_MODULE := helloworldclient //编译结果so文件include $(BUILD_EXECUTABLE) cmds/helloWorld/BpHelloWorldService.h 客户端Service头文件，声明BpHelloWorldService函数 1234567891011#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android&#123;class BpHelloWorldService: public BpInterface&lt;IHelloWorldService&gt;&#123;public: BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl); virtual status_t helloWorld(const char *str);&#125;;&#125;; cmds/helloWorld/BnHelloWorldService.h Bn服务端Service头文件，声明onTranscat接口 1234567891011121314#ifndef ANDROID_BNHELLOWORLD_H#define ANDROID_BNHELLOWORLD_H#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android &#123;class BnHelloWorldService : public BnInterface&lt;IHelloWorldService&gt;&#123; public: virtual status_t onTransact ( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0 );&#125;;&#125;;#endif cmds/helloWorld/HelloWorldService.h Bn服务端实现类的头文件，声明helloworld和onTransact函数，和私有类构造函数和析构函数和另一个库的文件同名，继承Bn服务端接口 12345678910111213141516#include &lt;BnHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;class HelloWorldService : public BnHelloWorldService&#123;public: static void instantiate(); virtual status_t helloWorld(const char *str); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);private: HelloWorldService(); virtual ~HelloWorldService();&#125;;&#125;; cmds/helloWorld/IHelloWorldService.h Bp和Bn端的中间接口头文件 1234567891011121314151617181920#ifndef ANDROID_HELLOWORLD_H#define ANDROID_HELLOWORLD_H#include &lt;binder/IInterface.h&gt;namespace android &#123;enum &#123; HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,&#125;;class IHelloWorldService: public IInterface &#123; public: DECLARE_META_INTERFACE(HelloWorldService); virtual status_t helloWorld(const char *str) = 0;&#125;;&#125;;#endif cmds/helloWorld/main_helloworldclient.cpp12345678910111213141516171819202122232425262728293031323334353637#define LOG_TAG \"main_helloworldclient\"#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;utils/Log.h&gt;#include &lt;utils/RefBase.h&gt;#include &lt;IHelloWorldService.h&gt;using namespace android;#define unused(x) x=xint main(int argc, char *argv[])&#123;//ALOGI(\"HelloWorldService client is now starting\");unused(argc);unused(argv);sp&lt;IServiceManager&gt; sm = defaultServiceManager();sp&lt;IBinder&gt; b;sp&lt;IHelloWorldService&gt; sHelloWorldService;do &#123; b = sm-&gt;getService(String16(\"android.apps.IHelloWorldService\")); if (b!=0) break; //ALOGI(\"helloworldservice is not working, waiting ...\"); usleep(500000);&#125; while(true);sHelloWorldService = interface_cast&lt;IHelloWorldService&gt;(b);sHelloWorldService -&gt; helloWorld(\"hello, world\");return(0);&#125; cmds/helloWorld/main_helloworldservice.cpp123456789101112131415161718192021#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;utils/Log.h&gt;#include &lt;IHelloWorldService.h&gt;#include &lt;HelloWorldService.h&gt;using namespace android;#define unused(x) x=xint main(int argc, char *argv[])&#123; unused(argc); unused(argv); HelloWorldService::instantiate(); ProcessState::self()-&gt;startThreadPool(); //ALOGI(\"HelloWorldService is starting now\"); //ALOGI(\"HelloWorldService is starting now tempChar = %s\", tempChar); IPCThreadState::self()-&gt;joinThreadPool(); return 0;&#125; libs/helloWorld/Android.bp1234567891011121314151617181920212223242526272829303132333435363738// Copyright (C) 2010 The Android Open Source Project//// Licensed under the Apache License, Version 2.0 (the \"License\");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an \"AS IS\" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.cc_library_shared &#123; name: \"libhelloworld\", srcs: [ \"BnHelloWorldService.cpp\", \"BpHelloWorldService.cpp\", \"HelloWorldService.cpp\", \"IHelloWorldService.cpp\", ], shared_libs: [ \"libcutils\", \"liblog\", \"libutils\", \"libbinder\", ], include_dirs: [\"frameworks/base/cmds\"], //上面创建的库 cflags: [ \"-Wall\", \"-Wextra\", \"-Werror\", ],&#125; libs/helloWorld/BnHelloWorldService.h123456789101112131415#ifndef ANDROID_BNHELLOWORLD_H#define ANDROID_BNHELLOWORLD_H#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android &#123;class BnHelloWorldService : public BnInterface&lt;IHelloWorldService&gt;&#123; public: virtual status_t onTransact ( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0 );&#125;;&#125;;#endif libs/helloWorld/BnHelloWorldService.cpp123456789101112131415161718192021222324#include &lt;BnHelloWorldService.h&gt;#include &lt;binder/Parcel.h&gt;namespace android &#123;status_t BnHelloWorldService::onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags)&#123; switch(code) &#123; case HW_HELLOWORLD: &#123; CHECK_INTERFACE(IHelloWorldService, data, reply); //检查接口 const char *str; str = data.readCString(); //读取数据 reply-&gt; writeInt32(helloWorld(str)); //写入数据 return NO_ERROR; &#125; break; default: return BBinder::onTransact(code, data, reply, flags); //服务端接口接收数据 &#125;&#125;&#125; libs/helloWorld/BpHelloWorldService.h123456789101112#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android&#123;class BpHelloWorldService: public BpInterface&lt;IHelloWorldService&gt;&#123;public: BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl); virtual status_t helloWorld(const char *str);&#125;;&#125;; libs/helloWorld/BpHelloWorldService.cpp12345678910111213141516171819202122232425#include &lt;binder/Parcel.h&gt;#include &lt;BpHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android&#123;status_t BpHelloWorldService::helloWorld(const char *str) &#123; Parcel data, reply; data.writeInterfaceToken( IHelloWorldService::getInterfaceDescriptor()); data.writeCString(str); //写入数据 status_t status = remote()-&gt;transact(HW_HELLOWORLD, data, &amp;reply); //远程传输数据 if (status != NO_ERROR) &#123; ALOGI(\"print helloworld error : %s\", strerror(-status)); &#125; else &#123; status = reply.readInt32(); //读取数据 &#125; return status;&#125;BpHelloWorldService::BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IHelloWorldService&gt;(impl)&#123;&#125;&#125;; libs/helloWorld/HelloWorldService.h1234567891011121314151617#include &lt;BnHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;//继承Bn服务端class HelloWorldService : public BnHelloWorldService&#123;public: static void instantiate(); virtual status_t helloWorld(const char *str); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);private: HelloWorldService(); virtual ~HelloWorldService();&#125;;&#125;; libs/helloWorld/HelloWorldService.cpp123456789101112131415161718192021222324252627282930313233#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include &lt;BnHelloWorldService.h&gt;#include &lt;HelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;void HelloWorldService::instantiate() &#123; defaultServiceManager()-&gt;addService( String16(\"android.apps.IHelloWorldService\"), new HelloWorldService());&#125;status_t HelloWorldService::helloWorld(const char* str) &#123; ALOGI(\"%s\\n\", str); printf(\"%s\\n\", str); return NO_ERROR;&#125;HelloWorldService::HelloWorldService()&#123; ALOGI(\"HelloWorldService is created\");&#125;HelloWorldService::~HelloWorldService()&#123; ALOGI(\"HelloWorldService is destroyed\");&#125;status_t HelloWorldService::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; return BnHelloWorldService::onTransact(code, data, reply, flags);&#125;&#125;; libs/helloWorld/IHelloWorldService.h1234567891011121314151617181920#ifndef ANDROID_HELLOWORLD_H#define ANDROID_HELLOWORLD_H#include &lt;binder/IInterface.h&gt;namespace android &#123;enum &#123; HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,&#125;;class IHelloWorldService: public IInterface &#123; public: DECLARE_META_INTERFACE(HelloWorldService); virtual status_t helloWorld(const char *str) = 0;&#125;;&#125;;#endif libs/helloWorld/IHelloWorldService.cpp12345678#include &lt;IHelloWorldService.h&gt;#include &lt;BpHelloWorldService.h&gt;namespace android &#123;IMPLEMENT_META_INTERFACE(HelloWorldService, \"android.apps.IHelloWorldService\");&#125;;","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android Graphics 调试技巧（十一月份更新）","slug":"2019/191121_android_debug2","date":"2019-11-23T15:52:00.000Z","updated":"2020-03-08T10:18:54.698Z","comments":true,"path":"2019/11/23/2019/191121_android_debug2/","link":"","permalink":"https://alonealive.github.io/Blog/2019/11/23/2019/191121_android_debug2/","excerpt":"更新adb 更新命令： sudo apt-get install android-tools-adb 查看当前adb指令的目录: which adb 查看版本：adb version","text":"更新adb 更新命令： sudo apt-get install android-tools-adb 查看当前adb指令的目录: which adb 查看版本：adb version adb shell相关ps（正在运行的进程）12345678USER 进程当前用户PID 进程IDPPID 父进程IDVSZ 进程的虚拟内存大小，以KB为单位RSS 实际占用的内存大小，以KB为单位WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从&#x2F;root&#x2F;system.map文件中获得的。PC 计算机中提供要从[存储器]中取出的下一个指令地址的[寄存器]NAME 进程状态及名称 top（CPU使用率） top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用，内存使用和执行时间对任务进行排序。 VIRT：这个内存使用就是一个应用占有的地址空间，只是要应用程序要求的，就全算在这里，而不管它真的用了没有。写程序怕出错，又不在乎占用的时候，多开点内存也是很正常的; RES：resident memory usage。常驻内存。这个值就是该应用程序真的使用的内存，但还有两个小问题，一是有些东西可能放在交换盘上了（SWAP），二是有些内存可能是共享的; SHR：shared memory。共享内存。就是说这一块内存空间有可能也被其他应用程序使用着; DATA：数据占用的内存。这一块是真正的该程序要求的数据空间，是真正在运行中要使用的。 vmstat（显示系统信息的）vmstat是一个显示系统信息的命令。例如，它显示主存储器的可用容量和CPU的操作状态。如果按原样执行vmstat命令，则会显示有关当前进程，内存，交换，设备，中断和CPU的信息。此外，如果附加“ - d”或“ - p”选项，将显示分区和磁盘上的读/写状态等。指定“-f”选项时，从系统启动到命令执行将显示创建进程的次数。 如果在vmstat之后指定以秒为单位的时间间隔，则每隔指定时间显示一次系统状态。此外，当您指定次数时，会显示指定的信息次数。 对于容量，可以使用“-S”选项指定单位。指定“-SM”时，容量单位以M字节显示。 例如：以10秒为间隔显示内存和CPU信息三次： vmstat 10 3 meminfo（内存系统信息）cat /proc/meminfo free（显示内存使用情况） 可以知道当前的内存使用情况。 12345-b 以字节显示容量（默认）-k 显示容量，以千字节为单位-m 显示容量，以MB为单位-h 显示容量单位，包含Ｇ、Ｍ-t 还显示物理内存和交换内存的总和 strace（跟踪进程执行时的系统调用和所接收的信号） strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 通用的完整用法：strace -o output.txt -T -tt -e trace=all -p 12345 上面的含义是跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。 time（linux命令，ADB通用） 测量从调用指定命令到结束所花费的时间，用户CPU时间和系统CPU时间。在指定命令的输出结果之后，将测量结果输出到标准错误输出。命令代码实际使用CPU的时间是用户CPU时间。因此，如果将不存在的命令作为time命令的参数，则用户CPU时间变为0。睡眠时间不计算在内。 例如：显示ls命令的执行时间： time ls -a 123real 0m0.006suser 0m0.006ssys 0m0.000s size 显示一个目标文件或者链接库文件中的目标文件的各个段的大小(可执行文件段的大小,默认为a.out) 例如（linux下）： size libui.so text表示正文段大小，data表示包含静态变量和已经初始化（可执行文件包含了初始化的值）的全局变量的数据段大小，bss由可执行文件中不含其初始化值的全局变量组成。 file（辨识文件类型） file确定并显示文件类型，例如可执行文件或文本或其他数据。 例如：file libui.so或者 adb shell file …… 1234-b 以简单模式显示-i 使文件成为mime类型字符串-z 还要检查压缩文件-v 显示版本 fastboot相关 重启进入Recovery界面： adb reboot recovery 重启进入bootloader界面： adb reboot bootloader 进入Recovery模式 查看设备： adb devices adb root adb shell 进入fastboot： adb reboot fastboot fastboot devices 查看当前使用分区： fastboot getvar current-slot 接着擦除分区和用户数据，然后flash烧录 如果不能识别或者没权限，优先检查lsusb添加序列号到/etc/udev/rules.d/ 如果出现错误:no permissions fastboot 用fastboot命令查看设备提示无权限，如下： 12fastboot -l devicesno permissions fastboot usb:1.2-1 因为权限问题，是fastboot没有权限， 解决步骤： 将fastboot的所有者属性改成root,用which fastboot命令找到fastboot所在的目录，然后进入此目录 用命令chown改其属性:sudo chown root:root fastboot 将其权限更改一下：sudo chmod +s fastboot 还存在一种可能性，就是adb版本过低。 部分参数 fastboot [options] Notes -w 清空用户数据分区和缓存分区.相当于recovery中的”wipe data/factoryreset” -s &lt;串口号&gt; 指定要操作的设备的串口号 -p &lt;产品名&gt; 指定要操作的设备的产品名.比如hero,bravo,dream… -c &lt;命令行&gt; 用命令行替换系统的启动命令行 解析so文件addr2lineaddr2line [address] -e test.so -f或者readelf -a [.so/.bin] 根据解析结果查询函数C++在linux系统编译后会变成类似_ZNK...的修饰名。使用c++filt获取函数的原始名称： c++filt [_ZNK...函数修饰名] 跳过开机向导adb shell settings put global device_provisioned 1（默认是0） Android 10 AOSP源码打开模拟Vsync（Systrace可查看） 源码： Android 10的AOSP 方法： 修改surfaceflinger/Scheduler/DispSync.cpp的static const bool kEnableZeroPhaseTracer = false;为True 另外在查看ZeroPhaseTracer还需要打开mTraceDetailedInfo，即const bool mTraceDetailedInfo = true; 对比文件和文件夹区别（可用于git解决冲突）meld 文件/文件夹 比较文件: vimdiff a.txt b.txt repo Android代码包含几百个git库，下载和管理都需要一个方便的工具，Google开发了repo用来管理多个git库，通过manifest.xml文件将一个个的git库管理起来,形成一个系统。 Gerrit Gerrit是Google开发的一个代码审核工具。它是一个Web工具,它靠git来存放代码,靠repo这个接口来提交和下载修改。 提交到Gerrit时,每个Git库的修改都会变成一次提交,每个提交可以有一个或多个人来review和verify。当你的修改被批准之后,Gerrit会把修改真正提交到指定的分支中。 Gerrit上代码提交的三种状态：Open、Merged、Abandoned Open: 状态的代码需要经过Review,Verify,Submit操作后才会真正入库,即成为Merged状态 Merged: 状态的代码已经入库,不能再Abandoned,只能Revert Open: 状态的代码由于各种原因不能入库的可以放弃,即Abandoned状态。Abandoned 状态的代码不能再入库,如有需要,可以“Restore”。 Jenkins一个持续集成工具,一个运行任务的平台。能实施编译、监控集成中存在的错误，提供详细的日志文件和提醒功能。能用图表形象地展示项目构建的趋势和稳定性。 repo链接指定版本的manifest.xmlrepo init -m manifest_TEST.xml然后可以在目录查看结果，再同步代码。 ssh生成publickey（指定邮箱）ssh-keygen -t rsa -C ****@mail.com Git相关命令git用户设置 git config --global user.name *** git config --global user.email ****@mail.com 查看config： git config -l 生成补丁git format-patch -1 [最近的提交CommitID] 生成指定某个commit提交的补丁git format-patch abc123d^..abc123d 获取补丁 申请生成在本地，但是没有加入暂存区： git apply [PatchA] 直接申请生成提交： git am [PatchB] git add用法 git add .:提交所有修改的文件,包括新增文件,不包括删除文件 git add -u:提交所有修改文件,包括删除文件,不包括新增文件 git add -A:提交包括新增和删除文件的所有文件 从暂存区域移除等其他命令 Command Notes git rm 从暂存区域移除,并连带从工作目录中删除指定的文件 git rm -f 如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项-f git reset HEAD … 取消对文件的修改,把之前版本的文件复制过来重写此文件。 git checkout – … 取消已经暂存的文件 git clean 删除未暂存的文件 git diff 查看尚未暂存的文件更新了哪些部分(和暂存区中) git diff –cached 看已经暂存起来的文件和上次提交时的快照之间的差异 git log –graph 显示图形表示的分支合并历史 git log –since=2.weeks 列出所有最近两周内的提交 git log –p 以patch形式显示提交 git log -p -2 常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新 git log –stat 仅显示简要的增改行数统计。 GDB命令 Command Notes bt 查看各级函数调用及参数 bt full 详细堆栈信息 bt PID 查看PID信息 frame 选择栈帧 info locals 查看当前栈帧局部变量的值 info registers 可以看函数入参 thread n 切换到线程n info threads 查看线程 disassemble 反汇编（默认范围是选择帧的pc附近的函数） info frame 选择堆栈帧 info args 显示函数参数和局部变量的内容 info reg（或者i r） 查看地址 disas 反汇编查看函数（包含地址信息） i proc m （info proc mappings 的简写） 核查零是不是有效地址 Bt 跟踪堆栈的信息: bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-I ip] [-S sp] [pid | task] 1234Bt 无参数则显示当前任务的堆栈信息Bt –a 以任务为单位，显示每个任务的堆栈信息Bt –t 显示当前任务的堆栈中所有的文本标识符Bt –f 显示当前任务的所有堆栈数据，通过用来检查每个函数的参数传递 mod命令 用来加载调试符号，有时一些结构或者函数的符号信息不在调试版本内核里面，需要用gcc -g选项编译自己的模块，然后用mod命令加载里面的调试信息。这样sym和whatis命令就能正确解释我们自己模块里面自定义的结构等信息。 ffmpeg 转换jpg和png格式ffmpeg -i test.png test1.jpg 远程服务器使用ssh链接并且映射在用户根目录的.bashrc添加： 链接：alias sshTest=&#39;function _ssh() { echo &quot;提示信息&quot;; ssh -p 端口 服务器用户名@IP; unset -f ssh; }; _ssh&#39; 映射：alias sshreferenceTest=&#39;echo &quot;提示信息&quot;;sshfs -p 端口 -o cache=yes,reconnect 服务器用户名@IP:/home/服务器映射目录 /home/user/本地映射目录&#39; 执行source .bashrc生效 如果服务器映射报错bad mount point/mnt/‘: Transport endpoint is not connected` 解决方法： sudo umount --all（或者指定目录） 重新mount，即sudo mount --all linux下修改图片尺寸（jpg、png…） sudo apt-get install imagemagick convert example.png -resize 200×100 example.png //按照原有比例缩放 convert example.png -resize 200×100! example.png 查看网络地址情况route -n 文件压缩、解压 zip文件：zip -r a.zip /dir 直接unzip解压 tar.bz：Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。但同时在压缩，解压的过程却是非常耗费CPU时间。 打包压缩格式，举例：tar -jcvf file.tar.bz2 dir #dir目录 解压，举例：tar -jxvf file.tar.bz2tar -jxvf file.tar.bz2 -C /temp ls 命令 Command Notes ls -a 列出文件下所有的文件，包括以“.“开头的隐藏文件（Linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。 ls -l 列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。 ls -F 在每一个文件的末尾加上一个字符说明该文件的类型。”@”表示符号链接、” ls -s 在每个文件的后面打印出文件的大小。 size(大小) ls -t 按时间进行文件的排序 Time(时间) ls -A 列出除了”.”和”..”以外的文件。 ls -R 将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现 ls -L 列出文件的链接名。Link（链接） ls -S 以文件的大小进行排序 ls -h 显示文件大小 firefox修改中文 打开浏览器，在地址栏中输入about:config，然后按下回车。 在列表中找到“general.useragent.locale”，然后双击，将内容改为”zh-CH” 重启之后就会默认为中文了（注：如果想改回英文就改为: en-US ) Ubuntu系统log路径/var/log查看: ls -tl hidl接口生成命令hidl-gen是Android架构HIDL编译工具，可以手动将哈希加到current.txt中，也可以使用以下命令添加：hidl-gen -L hash -r .../interfaces -r android.hidl:...","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"Android @hide接口注释","slug":"2019/191103_android_hideDoc","date":"2019-11-03T04:32:00.000Z","updated":"2020-03-08T10:18:54.622Z","comments":true,"path":"2019/11/03/2019/191103_android_hideDoc/","link":"","permalink":"https://alonealive.github.io/Blog/2019/11/03/2019/191103_android_hideDoc/","excerpt":"@hide和{@hide}类或API是否开放是通过doc的注释｛＠hide｝来控制的 比如android.media.Metadata这个类就是android没有公开的类 因为在frameworks\\base\\media\\libmedia\\Metadata.java文件中，定义Metadata类之前有/*｛＠hide｝/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类","text":"@hide和{@hide}类或API是否开放是通过doc的注释｛＠hide｝来控制的 比如android.media.Metadata这个类就是android没有公开的类 因为在frameworks\\base\\media\\libmedia\\Metadata.java文件中，定义Metadata类之前有/*｛＠hide｝/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类 google 给了两个选择： 在你添加的API或者变量前面增加javadoc 注释＠hide，但是要注意并不是简单写个＠hide或者 /@hide/就可以了，这些都是错误的javadoc注释格式。标准的javadoc都是这样的 /** / 而且对于 format 变量应该加上 { }，所以我们应该这样写/* {@hide} */ 想要生成的javadoc里面出现这个方法或者变量，你必须输入:make update-api。但是如果修改的是google没有开放出来的类，比如RIL、PhoneFactory，就不会出现这个问题。 访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）直接将@hide标记去掉，将重新编译了的android.jar包换掉不过强烈的建议不要这样做，别人隐藏起来的类或者方法肯定是不安全的，如果你把@hide放出来可能引起一些程序不可预知的错误。 利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜修改android.mk文件删除LOCAL_SDK_VERSION := current 将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。这个时候可以在android.mk文件中将LOCAL_PROGUARD_ENABLED := disabled加上。LOCAL_PROGUARD_ENABLED := disabled不使用代码混淆的工具进行代码混淆,如果不设置，默认使用LOCAL_PROGUARD_ENABLED := full.即将该工程代码全部混淆。 Android 10的变化在Android 10对非SDK接口进行了限制，因而@hide注释的方法被列入黑名单，外部不能访问。 但是可以通过adb shell settings put global hidden_api_policy 1命令打开权限访问。 通过adb shell settings delete global hidden_api_policy解除设置。（https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android Shell脚本应用","slug":"2019/191023_android_shell","date":"2019-10-23T15:52:00.000Z","updated":"2020-04-01T12:59:48.661Z","comments":true,"path":"2019/10/23/2019/191023_android_shell/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/23/2019/191023_android_shell/","excerpt":"基本结构.sh（系统中文.ch.sh）#!/bin/bash 脚本开头 #!/bin/csh 是 C shell 的命令解","text":"基本结构.sh（系统中文.ch.sh）#!/bin/bash 脚本开头 #!/bin/csh 是 C shell 的命令解 export 功能说明：设置或显示环境变量。语 法：export [-fnp][变量名称]=[变量设置值]补充说明：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。 用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行 shell 脚本程序。 运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的 shell，另一个是系统为运行脚本程序创建的shell。 当一个脚本程序运行完毕，脚本shell将终止，返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个 shell（称为父 shell）派生的。 在子shell中定义的变量只在该子shell内有效。 如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的 shell 不能引用它，要使某个变量的值可以在其他 shell 中被改变，可以使用 export 命令对已定义的变量进行输出。 export命令将使系统在创建每一个新的shell时，定义这个变量的一个拷贝。这个过程称之为变量输出。 用语句给变量赋值，如将/etc下目录的文件名循环出来123for file in `ls /etc`或for file in $(ls /et) 使用$符号来取一个变量的值，常见的就是$VAR 变量定义：app_name=”test” $、$0、$1、$2..$0就是你写的shell脚本本身的名字，$1是你给你写的shell脚本传的第一个参数，$2是你给你写的shell脚本传的第二个参数。 ps -ef |grep surfaceFlinger |awk ‘{print $2}’的含义 $2：表示第二个字段 print $2：打印第二个字段 -e: 显示所有进程。 -f:全格式 awk &#39;{print $2}&#39; $fileName: 一行一行的读取指定的文件， 以空格作为分隔符，打印每行的第二个字段（即 pid）。 ps: 打印的信息： 字段含义如下：12UID PID PPID C STIME TTY TIME CMDzzw 14124 13991 0 00:38 pts&#x2F;0 00:00:00 grep --color&#x3D;auto dae 两种方式声明函数 ”function”不可以省略(建议)12function find &#123; ...&#125; 不得添加参数12find() &#123; ...&#125; 两种声明方式效果等价。注意：（1）函数名和”{“之间必须有空格；（2）不得声明形式参数；（3）必须在调用前声明；（4）无法重载；（5）后来的声明会覆盖之前的声明 while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为： 1234while conditiondo commanddone 以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1运行上述脚本，返回数字1到5，然后终止。 1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let \"int++\"done $android_serial=$(adb shell getprop “re.serialno”)获取设备序列号adb shell input swipe 359 1600 359 340 500input后可以跟很多参数，text相当于输入内容，keyevent相当于手机物理或是屏幕按键，tap相当于touch事件，swipe相当于滑动。input/swipe模拟的是滑动事件，input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)，需要将起始的坐标传进去。 向左滑动：shell@lentk6735_66t_l1:/ $ input swipe 600 800 300 800 向右滑动：shell@lentk6735_66t_l1:/ $ input swipe 300 800 600 800 滑动：adb shell input swipe 100 100 200 200 300 //从 100 100 经历 300 毫秒滑动到 200 200 长按：adb shell input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000 毫秒 if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi（适合中断，写成一行）123456789if conditionthen command1 command2 ... commandNelse commandfi -eq:等于 -ne:不等于 -le:小于等于 -ge:大于等于 -lt:小于 -gt：大于 -a: 双方都成立（and） 逻辑表达式 –a 逻辑表达式 -o: 单方成立（or） 逻辑表达式 –o 逻辑表达式 sed -i ‘s/^.\\{15\\}//g’ tmp.txtadb shell wm size &gt; tmp.txt //分辨率导出文件 sed -i ‘s/^.\\{15\\}//g’ tmp.txt //此处 \\{是转义成 `{ wm_size=$(cat tmp.txt) sed -i就是直接对文本文件进行操作sed -i &#39;s/原字符串/新字符串/&#39; /home/1.txt sed -i &#39;s/原字符串/新字符串/g&#39; /home/1.txt 正则 ^: 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配\\n或\\r之后的位置。 .: 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。 \\: 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，n匹配字符n。\\n匹配一个换行符。串行\\\\匹配\\而\\(则匹配(。 {n}:n是一个非负整数。匹配确定的n次。例如，o{2}不能匹配Bob中的o，但是能匹配food中的两个o。 sed -n：只打印模式匹配的行 -e：直接在命令行模式上进行 sed 动作编辑，此为默认选项 -f：将 sed 的动作写在一个文件内，用–f filename 执行 filename 内的 sed 动作 -r：支持扩展表达式（配合正则表达式） -i：直接修改文件内容 例如： 删除该行的第一个字符：sed -r &#39;s/^.//g&#39; &lt;&lt;&lt; $line 删除文件每行的第二个字符: sed -r &#39;s/^(.)(.)/\\2/g&#39; passwd 删除文件每行的倒数第二个字符: sed -r &#39;s/(.)(.)$/\\2/g&#39; passwd 交换每行的第一个字符和第二个字符:sed -r &#39;s/^(.)(.)/\\2\\1/g&#39; passwd 交换每行的第一个单词和最后一个单词:sed -r &#39;s/^([a-Z0-9]+)([^a-Z0-9]+)(.+)([^a-Z0-9]+)([a-Z0-9]+)/\\5\\2\\3\\4\\1/g&#39; passwd 多选择语句case1234567891011121314echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esac adb shell pidof ”mediaserver“按名称检查正在运行的进程，可以使用pidof命令：adb shell pidof com.android.phone 如果找到此类进程，则返回PID,否则返回空字符串。 adb shell am start -nadb shell am start -n com.android.camera... //使用组件名方式启动照相机功能 可以使用adb shell activity|grep ACTIVITY 或者dump SF获取Activity名称 adb shell input tap x y模拟点击事件（点击屏幕），可以用来进入清除任务。 adb shell dumpsys window windows |grep Current |tee tmp.txt实现功能： 获得当前活动窗口的信息，包名以及活动窗体。 过滤Current信息，获得window的dump信息。 |tee的作用：输出到控制台 date + %Y%m%d_%H%M%S输出日期输入格式：20181128_174323 date + %N | cut -c -3%N: 纳秒 cut： 从指定的范围中提取字节（-b）、或字符（-c）、或字段（-f） cut -b -3//-3 表示从第一个字节到第三个字节 cut -b 3-//3-表示从第三个字节到行尾 cut -b -3,3- //输出整行，不会出现连续两个重叠的 cat **systrace.html |grep postComp |wc -l （linux 命令）WC：wc - print newline, word, and byte counts for each file 参数及含义： -c: print the byte counts 统计字节数 -l: print the newline counts：统计行数 -m: print the character counts：将每个文件的字符数及文件名输出到屏幕上，如果当前系统不支持多字节字符其将显示与-c 参数相同的结果 -w: print the word counts：统计字数 （视频播放时）旋转屏幕adb shell settings put system user_rotation 1 //获取参数是get shell判断数组中是否包含某个元素1234567ary=(1 2 3)a=2if [[ \"$&#123;ary[@]&#125;\" =~ \"$a\" ]] ; then echo \"a in ary\"else echo \"a not in ary\"fi 解决播放结束后，判断当前activity然后重新播放 adb shell dumpsys activity top | grep &quot;ACTIVITY&quot; //获得当前的 activity adb shell am start -n com.home... //返回桌面 activity 包含关系123456testPlay=$(adb shell dumpsys activity top | grep \"ACTIVITY\")testPlaySuccess=\"com...Activity\" if [[ $testPlay =~ $testPlaySuccess ]];then echo \"包含\" else echo \"不包含\" fi 查找手机文件adb shell find /storage -name &quot;*.mp4&quot; | grep FileName 播放视频adb shell am start -a android.intent.action.VIEW -d &quot;file:///storage/...../Test.mp4&quot; -t &quot;video/&quot; 逐行读某个文件1234while read linedo…done &lt; file // `&lt;`是读，`&gt;`是写入，`&gt;&gt;`是写入到某个文件的末尾","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://alonealive.github.io/Blog/tags/shell/"}]},{"title":"Android色彩空间（ColorSpace）","slug":"2019/191021_android_basis","date":"2019-10-21T15:52:00.000Z","updated":"2020-04-01T13:00:04.937Z","comments":true,"path":"2019/10/21/2019/191021_android_basis/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/21/2019/191021_android_basis/","excerpt":"色彩空间Color Space广色域WCGWCG（Wide Color Gamut），是Adobe System开发的一种RGB色彩空间，使用纯光谱原色提供较大的色域。与Adove RGB和sRGB相比，能够存储更大范围的颜色值。相比之下，WCG包含CIELAB色彩空间可见颜色的77.6%，而Adobe RGB色彩空间仅覆盖52.1%，sRGB仅覆盖35.9%。","text":"色彩空间Color Space广色域WCGWCG（Wide Color Gamut），是Adobe System开发的一种RGB色彩空间，使用纯光谱原色提供较大的色域。与Adove RGB和sRGB相比，能够存储更大范围的颜色值。相比之下，WCG包含CIELAB色彩空间可见颜色的77.6%，而Adobe RGB色彩空间仅覆盖52.1%，sRGB仅覆盖35.9%。 Note：CIELAB色彩空间（也称为CIE Lab，抑或Lab色彩空间），是国际照明委员会（CIE）于1976年定义的色彩空间。它将色彩表示为三个值： 符号 释义 L* 为从黑色（0）到白色（100）的亮度 a* 为从绿色（-）到红色（+）的亮度 b* 为从蓝色（-）到黄色（+）的亮度 CIELAB被设计为从这些值中相同数量的数字变化对应于大致相同数量的视觉感知变化。 sRGB色彩空间sRG色彩空间是惠普和微软于1996年一起开发的用于显示器、打印机、因特网的一种标准RGB色彩空间。最初的目的是作为生成在因特网以及万维网上浏览的图像的通用色彩空间，最后选择的是使用Gamma校准（伽马）系数为2.2的色彩空间，即CRT显示器在这种情况下的平均线性电压响应。 sRGB定义了红色、绿色、蓝色三原色的颜色（又称三基色，用于电视机、投影仪等显示设备，对应RGB），即在其他两种颜色值都为零时该颜色的最大值。在CIE xy（Lab色彩空间）坐标系中坐标如下表。对于任何RGB色彩空间来说，非负的R、G、B都不可能表示超出原色定义的三角形即色域范围，它刚好在人眼的色彩感知范围之内。 颜色 X Y 红色 0.6400 0.3300 绿色 0.3000 0.6000 蓝色 0.1500 0.0600 白色（D65） 0.3127 0.3290 sRGB定义了原色强度与实际保存的数值之间的非线性变化，曲线类似于CRT显示器的伽马响应。这个非线性变化意味着sRGB非常搞笑的使图像文件中的整数值标识了人眼可以分辨的颜色。 但是由于它的色域不够大，尤其是蓝绿颜色色域无法表示SMYK印刷中的所有颜色。所以印刷行业的经常使用的是Adobe RGB色彩空间。 Note:伽马校正（伽马非线性变化、伽马编码），是用来正对影片或者影像系统里对于管线的辉度或者三色刺激值所进行非线性的运算或反运算。 Adobe RGB色彩空间Adobe RGB色彩空间是一种由Adobe System于1998年开发的色彩空间。开发的目的是为了尽可能在CMYK彩色印刷中利用计算机显示器等设备的RGB颜色模式上囊括的更多的颜色。 在Adobe RGB标准中，色彩被指定为（R,G,B）三个组员，其中R，G，B每个的值介于0和1之间。但在显示器显示出来时，白色点(1,1,1)，黑色点（0,0,0），原色点（1,0,0）的准确值会被指定。 与sRGB相比，Adobe RGB中的RGB色彩分量和亮度并不是呈线性关系，他的伽马值是563/256结果是2.19921875。并且三原色点坐标只有绿色坐标不同。 颜色 X Y 红色 0.6400 0.3300 绿色 0.2100 0.7100 蓝色 0.1500 0.0600 白色（D65） 0.3127 0.3290 ProPhoto RGB色彩空间ProPhoto RGB色彩空间（抑或ROMM RGB色彩空间），专为摄影输出所开发设计。该色彩空间的色域十分宽裕，甚至包含CIE Lab色彩空间中90%以上的表面色彩和1980年Poniter所记录的可能出现的表面色彩。该色域的表现范围甚至比WCG色彩空间还要大 标准参考白点由CIE标准光源D50的色度决定。 颜色 X Y 红色 0.7347 0.2653 绿色 0.1596 0.8404 蓝色 0.0366 0.0001 白色（D50） 0.3457 0.3585 缺点是该色彩空间包含大约13%的通常不存在色彩。 DCI-P3色彩空间DCI-P3（抑或DCI/P3）是美国电影行业推出的一种色彩空间。在CIE 1931xy色彩空间中，覆盖了45.5%的全色于和86.9%的常见色域。在CIE 1976uv色度图覆盖率分别是41.7%和85.5%。 DCI-P3将来应该会在电视系统和家庭影院领域有更广泛的应用。 颜色 X Y 红色 0.6800 0.3200 绿色 0.2650 0.6900 蓝色 0.1500 0.0600 白色（D65） 0.3127 0.3290 Display P3色彩空间Display P3使用DCI-P3的原色，但是使用D65白点，这在计算机显示色彩空间中（sRGB,AdobeRGB都使用D65）更为常见。和DCI-P3的纯伽马曲线不同。Display-P3使用sRGB曲线。 Android中启用/禁止WCG功能APP获取设备是否支持WCGAPP通过以下两种API来决定设备是否支持WCG： android.content.res.Configuration::isScreenWideColorGamut：如果display和设备能够支持WCG则返回true。 android.view.Display::isWideColorGamut()：返回显示display设备是否可用于WCG显示。这个并不意味着设备自己可以渲染WCG内容。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"C++ 单例模式","slug":"2019/191020_cpp_singletonMode","date":"2019-10-20T15:39:00.000Z","updated":"2020-03-08T10:17:25.211Z","comments":true,"path":"2019/10/20/2019/191020_cpp_singletonMode/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/20/2019/191020_cpp_singletonMode/","excerpt":"懒汉式单例模式 缺点是延迟加载，比如配置文件，只有在使用的时候才会加载。","text":"懒汉式单例模式 缺点是延迟加载，比如配置文件，只有在使用的时候才会加载。 12345678910111213class CSingleton &#123;public: static CSingleton GetInstance() &#123; if (m_pInstance == NULL) m_pInstance = new CSingleton(); reutrn m_pInstance; &#125;private: CSingleton() &#123;&#125;; static CSingleton * m_pInstace;&#125; 多线程下的懒汉模式 使用double-check来保证线程安全。但是如果处理大量数据时，该锁才成为严重的性能瓶颈。 12345678910111213141516171819202122class Singleton &#123; private: static Singleton* m_instance; Singleton()&#123;&#125; public: static Singleton* getInstance(); &#125;; Singleton* Singleton::getInstance() &#123; if(NULL == m_instance) &#123; Lock(); //借用其它类来实现，如boost if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance; &#125; 饿汉式单例模式 一开始就创建实例对象并且加载，每次使用的时候直接返回就好了。饿汉式会出现线程安全问题，在多线程下，或个线程都初始化一个单例，得到的指针并不是指向同一个地方，就不满足单例类的定义，此时就需要进行修改。 12345678910class CSingletonB &#123;private: CSingletonB () &#123;&#125;public: static CSingletonB * GetInstance() &#123; static CSingleton instance; return &amp;instance; &#125;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Java 单例模式","slug":"2019/191020_java_singletonMode","date":"2019-10-20T14:59:00.000Z","updated":"2020-03-08T10:17:25.211Z","comments":true,"path":"2019/10/20/2019/191020_java_singletonMode/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/20/2019/191020_java_singletonMode/","excerpt":"单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式是一种常用的软件设计模式之一，其目的是保证整个应用中只存在类的唯一个实例。比如我们在系统启动时，需要加载一些公共的配置信息，对整个应用程序的整个生命周期中都可见且唯一，这时需要设计成单例模式。如：spring容器，session工厂，缓存，数据库连接池等等。","text":"单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式是一种常用的软件设计模式之一，其目的是保证整个应用中只存在类的唯一个实例。比如我们在系统启动时，需要加载一些公共的配置信息，对整个应用程序的整个生命周期中都可见且唯一，这时需要设计成单例模式。如：spring容器，session工厂，缓存，数据库连接池等等。 保证实例的唯一: 防止外部初始化 由类本身进行实例化 保证实例化一次 对外提供获取实例的方法 线程安全 饿汉式单例模式 线程安全，调用效率高，但是不能延时加载 直接创建单例对象，使用的时候直接返回即可。缺点是单例在未使用的时候就已经初始化完成，如果程序一直没有使用，单例对象还是会创建，从而造成不必要的资源浪费。 123456789public class TestA &#123; private static TestA t1 = new TestA; private TestA() &#123;&#125; public static TestA getInfo() &#123; return t1; &#125;&#125; 懒汉式单例模式 线程安全，调用效率不高，但是可以延时加载 123456789101112131415public class TestB &#123; //类初始化时，不初始化对象（延时加载，真正使用的时候再创建） private static TestB t2; //构造器私有化 private TestB() &#123;&#125; //方法同步，调用效率低 public static synchronized TestB getInfo() &#123; if (testB == null) &#123; TestB = new TestB(); &#125; return testB; &#125;&#125; 双重锁判断机制（DCL）即Double CheckLock实现单例模式（由于JVM底层模型原因，偶尔会出现问题，不建议使用） 1234567891011121314151617public class TestC &#123; private static TestC t3; private TestC() &#123;&#125; public static TestC getInfo() &#123; if (TestC == null) &#123; synchronized (TestC.class) &#123; if (TestC == null) &#123; TestC = new TestC(); &#125; &#125; &#125; return t3; &#125;&#125; 静态内部类实现单例模式 线程安全，调用效率高，可以延迟加载 12345678910111213public class TestD &#123; private static class GetInfoClass &#123; private static final TestD t4 = new TestD(); &#125; //构造函数 private TestD() &#123;&#125; public static TestA getInfo() &#123; return GetInfoClass.t4; &#125;&#125; 枚举类实现单例模式 线程安全，调用效率高，不能延时加载，可以天然防止反射和反序列化调用） 123456789public class TestE &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void getInfoOperation() &#123; &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://alonealive.github.io/Blog/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://alonealive.github.io/Blog/tags/java/"}]},{"title":"Android Property","slug":"2019/191016_adndroid_property_setTypes","date":"2019-10-16T15:52:00.000Z","updated":"2021-04-14T13:02:41.109Z","comments":true,"path":"2019/10/16/2019/191016_adndroid_property_setTypes/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/16/2019/191016_adndroid_property_setTypes/","excerpt":"property的相关生成文件和设置 android通过SystemProperties的set和get方法来控制很多东西，一般上层添加一个控制开关可以使用这个方法，在系统里面存在很多个prop文件。它们分别是system/build.prop,system/etc/prop.default,vendor/build.prop,vendor/default.prop。下面分别来说下这几个文件的构成。","text":"property的相关生成文件和设置 android通过SystemProperties的set和get方法来控制很多东西，一般上层添加一个控制开关可以使用这个方法，在系统里面存在很多个prop文件。它们分别是system/build.prop,system/etc/prop.default,vendor/build.prop,vendor/default.prop。下面分别来说下这几个文件的构成。 system/build.prop 这个主要是由device***(platform)sample\\product/system.prop,还有在build目录下添加的ADDITIONAL_BUILD_PROPERTIES system/etc/prop.default 主要是系统添加的PRODUCT_SYSTEM_DEFAULT_PROPERTIES vendor/build.prop（比较重要） 主要是系统添加的PRODUCT_PROPERTY_OVERRIDES，添加在device.mk的这个属性会被编译到这里，但是在9.0的系统，加到这里会无效，获取不到值。 vendor/default.prop（会被同目录的build.prop相同property覆盖） 主要是系统添加的PRODUCT_DEFAULT_PROPERTY_OVERRIDES","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android Graphics 调试技巧（十月份更新）","slug":"2019/191012_android_debug1","date":"2019-10-12T15:52:00.000Z","updated":"2020-03-08T10:17:34.591Z","comments":true,"path":"2019/10/12/2019/191012_android_debug1/","link":"","permalink":"https://alonealive.github.io/Blog/2019/10/12/2019/191012_android_debug1/","excerpt":"readelf命令查看ELF格式的文件信息常见的文件比如动态库(*.so)、静态库（*.a），常用命令：readelf -a libgui.so | grep test_string","text":"readelf命令查看ELF格式的文件信息常见的文件比如动态库(*.so)、静态库（*.a），常用命令：readelf -a libgui.so | grep test_string 查看手机内存123456789adb shellcat proc/meminfoMemTotal: 7821184 kBMemFree: 157484 kBMemAvailable: 2765976 kBBuffers: 175624 kBCached: 2264796 kB...... adb logcat缓存管理12345678adb root;adb remount清除缓存 adb logcat -c如果不能清除，就指定区域清除 adb logcat -c main&#x2F;system&#x2F;event&#x2F;kernel&#x2F;all(日志缓冲区)查看缓存 adb logcat -g设置最大logcat缓存 adb logcat -G 100M linux离线翻译工具sdcv1234567安装：sudo apt-get install sdcv使用：sdcv只能翻译单词 apt-get命令列出版本号sudo apt-cache madison openssh-client Linux安装tar.xz软件包1234在linux下(node.js)：解压后将bin目录的命令全局，建立软链接：sudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodesudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm JNI的jlong类型打印不使用%lld和%ld，而是先将其转换成long，然后%ld打印。 1ALOGD(\"Mylog: JNI destroySurface nativeObject=%ld\", (long)nativeObject); monkey测试指令参数12345678910111213adb shell monkey help查看帮助-p 指定包名-v log详细程度（最高支持-v -v -v）-s 种子（指定后，同一个命令在任意时间地点的执行顺序相同）--throttle 单步延时（每步操作间隔，单位ms），如果不知定系统会尽快的发送事件序列--kill-process-offer-error 出错是杀掉进程--ignore-timeouts 忽略超时错误(程序未响应)，不会应ANR而停止--ignore-security-exceptions 忽略证书或认证异常 --hprof 测试前后会生成app内存快照文件（一般在&#x2F;data&#x2F;misc目录下生成hprof文件，可以使用Android Studio查看）--ignore-crashes 忽略crash，不会因crash而停止--ignore-native-crashes 忽略native代码发生的crash崩溃，不会因此停止--monitor-native-crashes 监视native代码发生的崩溃 示例(1) adb shell monkey -p PackageName -v -v -v -s 12 –throttle 500 1000 &gt; monkey.txt随机数种子是12，log详细程度最高，单步延时500ms，总执行1000步，日志输出到monkey.txt (2) adb shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000 (3) adb shell monkey -p PackageName –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes -v -v -v 1000000 &gt; monkeylog.txt (4) 不指定包：adb -s DeviceID shell monkey –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes –ignore-security-exceptions -v -v -v 100 &gt; monkeylog.txt (5) 正常测试验证问题使用（不忽略crash,压力测试，所以不指定间隔时间）：adb -s DeviceID shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000 &gt; monkeyLog.txt 停止monkey测试12(1) ps -A|grep monkey(2) kill pid（11111） 重现monkey测出的bugmonkey日志搜索ANR exception，将之前的事件重新操作。尤其是seed值要一样，如monkey -p PackageName -v seed(-s) 100(seed的值) 500(随机时间次数) dump meminfo123adb shell dumpsys meminfo或者具体包adb shell dumpsys meminfo packageName kernel使用printk调试 打印调试log printk(&quot;%d&quot;,intA); 打印变量所占内存大小 printk(&quot;sizeof(*intA)=%d&quot;,sizeof(*intA); 查看设别是否支持Project TeableProject Treble是在最新的Android上应用兼容的芯片驱动，加快最新系统适配的速度。 adb shell getprop ro.treble.enabled 查看cpu架构adb shell getprop ro.product.cpu.abi Service服务命令12服务列表： adb shell service list检测某服务是否存在： adb shell service check SurfaceFlinger 测试CtsMediaTestCases需要CTS媒体文件（连接外网）Google官网下载，例如CTS媒体文件1.4，解压后阅读README文件，按照提示copy文件到device。 123456chmod 544 copy_media.sh.&#x2F;copy_media.shchmod 544 copy_images.sh.&#x2F;copy_images.sh例如：run cts-dev --module CtsMediaTestCases --compatibility:module-arg CtsMediaTestCases:include-annotation:android.platform.test.annotations.RequiresDevice 当前活动Activiy获取当前ACTIVITYadb shell dumpsys activity top|grep ACTIVITY 命令启动指定Activityadb shell am start -n ActivityName Android SDK抓取systrace12进入Android&#x2F;Sdk&#x2F;platform-tools&#x2F;systrace目录下python systrace.py -b 8000 -t 5 -o systrace.html 打开模拟Vsync，从Systrace查看到 源码： Android 10的AOSP 方法： 修改surfaceflinger/Scheduler/DispSync.cpp的static const bool kEnableZeroPhaseTracer = false;为True adb devices很少识别1234567方法一：lsusb 查看usb是否识别到手机如果没有，检查“开发者选项 -&gt; USB调试”是否打开方法二： 重启ADB服务adb kill-serveradb start-server 添加usb设备自动识别信息/etc/udev/rules.d/1234567（1）lsusb查看usb链接设备（2）然后编辑&#x2F;新增文件(&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;)：sudo vi 51-android.rules 文件内容：SUBSYSTEM&#x3D;&#x3D;&quot;usb&quot;,ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;093a&quot;,ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;120d&quot;,MODE&#x3D;&quot;0666&quot;（3）保存后重启udev服务sudo &#x2F;etc&#x2F;init.d&#x2F;udev restart或者sudo service udev restart（4）重新连接设备测试 adb shell获取设备信息参数（序列号）1234567getprop 查看机器的全部信息参数getprop ro.serialno 查看机器的序列号getprop ro.carrier 查看机器的CID号getprop ro.hardware 查看机器板子代号getprop ro.bootloader 查看SPL(Hboot)版本号getprop ro.build.version.release 查看系统版本（8、9...）getprop ro.build.display.id 获得厂商系统版本 Android中CPU频率查看和修改1234567root权限（直接输入su命令）cd sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreqls文件如下cpuinfo_cur_freq： 当前cpu正在运行的工作频率cpuinfo_max_freq：该文件指定了处理器能够运行的最高工作频率 （单位: 千赫兹）cpuinfo_min_freq ：该文件指定了处理器能够运行的最低工作频率 （单位: 千赫兹） Ubuntu下载更新杀毒软件123456789下载：sudo apt-get updatesudo apt-get install clamavsudo chmod 777 freshclam.lgfreshclamg更新扫描：clamav -a &#x2F; 安装deb包 sudo dpkg -i gapid-1.3.1-linux.deb 查看手机服务 开发者选项 -&gt; Running services可以查看正在运行的服务，以及运行内存情况 查看修改屏幕分辨率和密度123456789101112查看：adb shellwm size 获得手机当前分辨率wm density 获得手机当前屏幕密度（例如560dpi）修改：wm size 1096*2560wm density 420恢复：wm size resetwm density reset 查看进程map虚拟地址12345adb root;adb remountadb shell ps -A|grep camera 查看服务的进程号(例如4712) cd proc&#x2F;4712 进入进程号的文件夹 more maps 查看虚拟内存地址 SELinux模式开启关闭SELinux(Security-Enabled Linux)是美国国家安全局（NSA）对于强制访问控制的实现（安全子系统） 临时生效方法： adb shell setenforce 0（临时生效，关闭SELinux模式） adb shell setenforce 1（启用，开启SELinux模式） adb命令 – 录制手机视频 adb shell screenrecord sdcard/record.mp4 1adb pull sdcard/record.mp4 . adb命令 – 截图 adb shell screencap -p sdcard/1.png adb命令 – 输入文本节省手动输入的时间： adb shell input text **** adb命令 – 获取APP路径 adb shell dumpsys SurfaceFlinger 最下方查看正在运行的APK adb shell pm path &quot;com.**&quot; 获取路径 台式机通过WIFI建立adb连接，实现无线连接手机通常在需要手机连接外设显示设备的同时需要抓取Log、Dump等操作： 两台手机连上同一个无线网 其中一台A关闭开发者选项的USB调试，并且连接到电脑作为热点（无线网卡） 另一台B连接电脑输入adb tcpip 5555，然后输入adb shell ifconfig wlan0查看B的IP地址 连接B手机的IP： adb connect IP 断开B，保持A连接在电脑 连接DP继续dump SurfaceFlinger的方法 连接DP前启动：adb shell dumpsys SurfaceFlinger --file --no-limit 断开DP后再次执行结束Dump：adb shell dumpsys SurfaceFlinger --file --no-limit 接过文件pull出来：adb pull /data/misc/wmtrace/dumpsys.txt md5sum命令检测文件通过md5sum filename查看文件的md5sum值是否一样 GSI含义 GSI是替换成google的frameworks等(即system.img, 即google的原生AOSP)system.img包含整个系统，framework、application等，被挂接到”/“目录下，包含系统的所有二进制文件。大概是编译出来的out/target/product/ProductName/system目录的映射 GSI方法123456常用步骤：adb reboot bootloader (fastboot devices检测设备)fastboot erase systemfastboot -wfastboot flash system GSI(.img file)fastboot reboot CTS VTS跑测注意点 重跑：run retry --retry 序列号 跑测arm64-v8a还是armeabi-v7a等:run cts-suite -s ... -a arm64-v8 -m ... linxu命令查找命令查找字符串 grep -rn 字符串 grep 字符串 -Rin * //查找该目录下包含该字符串的文件 查找文件 find . -iname Test* Git命令 回退到某个commitID： git reset --hard commitID 新建一个Commit用于Revert某个分支： git revert commitID 修改commit信息git commit --amend --author=&quot;**&quot; --date=&quot;**&quot; 修改作者和日期 添加topic的方法(提交到Gerrit)git push origin HEAD:refs/for/BRANCH_Name%topic=&quot;name&quot; 使用新的change ID覆盖原来已经提交的Patchgit push origin HEAD:refs/changes/99999 (gerrit上的已有Commit的Patch ID) git stash暂时储藏用于修改的代码暂时保存起来，并且不影响下次的修改(这个比生成本地补丁方便git format-patch -1 commitID)： git stash save &quot;Remarks&quot; 执行存储，并且添加备注 git stash list 查看储藏列表 git stash show stash@{1} 查看某次储藏的修改 git stash apply stash@{$Num} 应用某次储藏 git stash pop stash@{$Num} 从缓存堆栈中删除某次储藏并且应用到代码中，默认第一个stash git stash drop stash@{$Num} 从列表删除这个存储 git stash clear 删除所有缓存的stash Repo下载项目方法 下载.repo：repo init -u Git远程仓库 -b Branch_Name(分支选择) Sync项目：repo sync -c -j4（当前分支） 如果值Sync指定目录，则在指定目录下执行：repo sync -c . -j4 Android常用编译方式 source build/envsetup.sh lunch //选择指定Product make fullbuild -j4 如果只编译部分模块： framework模块：make framework -j4，结果生成framework.jar包到/system/framework 编译kernal/msm使用： make bootimage -j4 指定目录下执行:mm/mmm/mma(依赖编译)","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"nReal搭建Samepl APK","slug":"2019/190930_nReal_Sample","date":"2019-09-30T13:52:00.000Z","updated":"2021-06-08T14:46:37.130Z","comments":true,"path":"2019/09/30/2019/190930_nReal_Sample/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/30/2019/190930_nReal_Sample/","excerpt":"概述nrsdk是nreal开发混合现实体验的平台。使用简单的开发过程和高级api，nrsdk提供了一组强大的mr特性，并使nreal眼镜能够了解真实世界。","text":"概述nrsdk是nreal开发混合现实体验的平台。使用简单的开发过程和高级api，nrsdk提供了一组强大的mr特性，并使nreal眼镜能够了解真实世界。 nrsdk为开发者提供了五个核心特性： 空间计算使眼镜能够跟踪它们相对于世界的实时位置，并了解周围的环境，例如检测和跟踪平面和图像。 优化的渲染自动应用于应用程序并在后端运行，以最小化延迟并减少抖动，增强总体用户体验。 多模态交互为不同的用例提供了交互的直观选择。 提供了开发工具，以便您可以更好地开发和调试应用程序。 第三方集成是通过为第三方sdk提供数据来实现的，这允许您充分利用nreal light的硬件功能并构建功能强大的mr/ar应用程序。 开发工具包开发混合现实应用程序需要一个nreal开发工具包。开发工具包由一对nreal光学眼镜、nreal计算单元和nreal光学控制器组成。如果没有，请在这里注册nreal开发工具包！到目前为止，你还不能直接在android手机上开发应用程序。安卓手机开发将于2020年初推出。 选择开发平台nrsdk支持许多最流行的开发环境。通过这些功能，您可以构建全新的mr体验，或者使用mr功能增强现有的原生android应用程序。Unity （Support Unity 2018.2.X） Android Native (to be released) Unreal (to be released) 与Android本机应用程序兼容nreal眼镜现在与android原生应用程序兼容，这意味着只要应用程序安装在设备上，用户就可以通过眼镜查看所有应用程序活动。在你这边什么都不需要改变。要使2d应用程序更具沉浸感和三维感，可以使用nrsdk在现有应用程序中添加mr功能或3d虚拟对象。 功能空间计算nreal眼镜使用各种传感器和相机，以建立对周围环境和用户本身的复杂理解，创造身临其境的体验，无缝融合数字世界和现实世界。 HelloMR APP硬件清单 一个nreal计算单元（把它想象成一个没有屏幕的android手机，所以所有的开发过程都将非常类似于移动应用程序开发）。 一副自然光眼镜 没有nreal设备？注册nreal开发工具包！或者尝试仿真器在没有nreal眼镜和计算单元的情况下引导nreal应用程序功能。 连接nReal计算单元和PC的USB-C电缆 不需要Wi-Fi连接。但是，可以使用Wi-Fi Android调试桥（ADB）连接进行调试和测试。 软件清单 Unity 2018.2.x或更高版本，支持Android构建 下载Unity 1.1的nrsdk(sdk作为nrsdkforunity_1.1.unitypackage下载) android sdk 7.0（api级别24）或更高版本，使用android studio中的sdk管理器安装 创建统一项目 打开Unity并创建一个新的3D项目。 set player settings&gt;other settings&gt;scriptping runtime version to.net 4.x等效版本 为unity导入nrsdk 选择“资源&gt;导入包&gt;自定义包”。 选择您下载的nrsdkforunity_1.1.unitypackage。 在“导入包”对话框中，确保选中了所有包选项，然后单击“导入”。 在unity项目窗口中，通过选择assets&gt;nrsk&gt;demos&gt;hellomr找到hellomr示例应用程序。 配置生成设置 转到“文件&gt;生成设置”。 选择android并单击switch platform。 在“生成设置”窗口中，单击“播放器设置”。 在Inspector窗口中，按如下方式配置播放机设置：(https://developer.nreal.ai/develop/unity/android-quickstart) 连接到nReal设备(开发工具包)在计算单元上启用开发人员选项和USB调试。android调试桥（adb）作为默认设置启用，不需要手动设置）。将计算单元连接到Windows PC。 建立并运行 在Unity Build设置窗口中，单击Build。在构建成功后，通过wifi android调试桥（adb）安装应用程序。 断开电脑与电脑的连接，然后将其连接到眼镜上。 如果这是您第一次运行此应用程序，则需要使用某些工具（如scrcpy）对该应用程序进行身份验证。 与nReal Light控制器一起启动应用程序。有关如何使用nReal Light控制器的说明，请参阅控制器指南。 四处移动，直到nrsdk找到一个水平面，检测到的平面将被绿色网格覆盖。 单击触发器按钮在其上放置nReal徽标对象。 （可选）使用android logcat查看记录的消息。我们建议使用WiFi Android调试桥（ADB）连接到您的PC，这样您就不必在大多数时间通过数据线连接。 Sample APP(立体方块)scene设置 在SampleScene删除主摄像头； 将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRCameraRig拖拽到SampleScene中； 将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRInput拖拽到SampleScene中； 将Assets -&gt; NRSDK -&gt; Emulator -&gt; Prefabs -&gt; NRTrackableImageTarget拖拽到SampleScene;在其中可以修改场景图像（Image Target） 在SampleAPP右侧窗口中右击Create -&gt; 3D -&gt; Object -&gt; Cube，创建立方体将Scale均修改成0.25 右击Create Empty,在Inspector中Add Component(1)Script设置为TrackableFoundTest(2)Observer设置为NRTrackableImageTarget(3)Obj设置为Cube 打开Assets -&gt; NRSDK -&gt; Emulator -&gt; Scripts -&gt; TrackableFoundTest,编辑源文件C#，添加Update函数，增加每次点击切换立方体颜色 1234567using NRKernal;... private void Update() &#123; if (NRInput.GetButtonDown(ControllerButton.TRIGGER)) Obj.GetComponent&lt;Renderer&gt;().material.color &#x3D; new Color(Random.value, Random.value, Random.value); &#125; File -&gt; BuildSettings添加SampleAPP，然后选择Android，最后Building 生成APK，安装full screen black 或者在Unity上方点击Play按钮使用Emulator查看，常用按键操作： 1234567WASD控制前后左右；Space+鼠标表示头部旋转；SHIFT+鼠标移动模拟nReal控制器的旋转（3DOF控制器）；单击鼠标左键模拟控制器触发器的单击（此处会触发Update函数变化颜色）；单击鼠标右键以模拟控制器主页按钮的压力；单击鼠标滚轮按钮以模拟控制器的APP按钮的压力；使用箭头键模拟在控制器的触摸板上滑动；","categories":[{"name":"VR","slug":"VR","permalink":"https://alonealive.github.io/Blog/categories/VR/"}],"tags":[{"name":"nReal","slug":"nReal","permalink":"https://alonealive.github.io/Blog/tags/nReal/"}]},{"title":"Android Handler消息循环处理机制(例ActivityThread)","slug":"2019/190922-android-handler-cpp","date":"2019-09-22T07:01:32.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/22/2019/190922-android-handler-cpp/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/22/2019/190922-android-handler-cpp/","excerpt":"整体流程 关键词：Handler、Looper、MessageQueue、handleMessage 消息被存放于消息队列，应用程序的主线程会围绕这个消息队列进入一个无限循环，知道应用程序退出。（消息循环过程是由Looper实现的） 如果队列中有消息，应用程序的主线程会把它取出来，分发给相应的Handler进行处理； 如果队列中没有消息，应用程序的主县城就会进入空闲等待状态，等待下一个消息的到来；","text":"整体流程 关键词：Handler、Looper、MessageQueue、handleMessage 消息被存放于消息队列，应用程序的主线程会围绕这个消息队列进入一个无限循环，知道应用程序退出。（消息循环过程是由Looper实现的） 如果队列中有消息，应用程序的主线程会把它取出来，分发给相应的Handler进行处理； 如果队列中没有消息，应用程序的主县城就会进入空闲等待状态，等待下一个消息的到来； 消息循环（以ActivityThread为例） 应用程序的消息循环是从 ActivityThread 的 main()函数入口的，在 main()函数中会调用Looper.prepareMainLooper();和Looper.loop(); 代码： http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/app/ActivityThread.java#7310 frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format \"seq=114\" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); //消息循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125; 创建Looper对象的时候，会同时创建一个 MessageQueue，保存在 Looper 的成员变量 mQueue 中。Looper和MessageQueue就是这样关联起来的。 JNI层创建 Looper 时会通过 pipe 系统调用来创建一个管道。 frameworks/base/core/java/android/os/Looper.java1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125; 该Looper对象创建好之后会保存在 NativeMessageQueue 对象的成员变量 mLooper 中，这个对象的作用是，通过管道实现以下功能：当Java层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当Java层的消息队列中来了消息时，就唤醒Android应用程序的主线程来处理这个消息。 ActivityThread调用Looper.loop()才会进入消息循环。 进入消息循环后，会不断地从消息队列mQueue中去获取下一个要处理的消息msg，如果消息的target为null，就表示要退出消息循环了，否则就会调用target对象的 dispatchMessage 函数来处理这个消息。 调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。 /frameworks/base/core/java/android/os/Looper.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125; 调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。 消息发送从应用程序启动入口分析下消息发送流程。应用程序启动过程中会调用 sendMessage 函数向应用程序的消息队列中加入一个新的消息。sendMessage将参数封装成Message，然后通过mH.sendMessage把该消息加入消息队列。mH是ActivityThread类的成员变量，它的类型为H，继承于Handler类。 定义： final H mH = new H(); /frameworks/base/core/java/android/app/ActivityThread.java123456789101112131415private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) &#123; Slog.v(TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); &#125; Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; sendMessage函数是继承于Handler的，Handler在它的构造函数中获取了Looper对象和MessageQueue 对象。 frameworks/base/core/java/android/os/Handler.java123456789101112131415161718192021public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; msg.target = this;表示这个消息最终由这个Handler对象来处理，即由ActivityThread对象的mH成员变量来处理。最终会调到MessageQueue的enqueueMessage函数最后会调到Looper.cpp的wake函数。 /frameworks/base/core/java/android/os/Handler.java12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125; frameworks/base/core/java/android/os/MessageQueue.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); //此处调用JNI函数 &#125; &#125; return true; &#125; /frameworks/base/core/jni/android_os_MessageQueue.cpp1234static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; 消息处理ActivityThread的main函数在Looper.loop函数中调用msg.target.dispatchMessage(msg)去处理消息。 frameworks/base/core/java/android/os/Looper.java1234567891011121314151617try &#123; msg.target.dispatchMessage(msg); //处理消息 if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; 消息对象msg的成员变量target是在发送消息的时候设置好的，通过哪个Handler来发送消息，就通过哪个Handler来处理消息。 当时是 H 类把消息加入消息队列的，现在也该由 H 类处理消息。 H类没有实现自己的dispatchMessage函数，但它继承了父类Handler的dispatchMessage函数。 frameworks/base/core/java/android/os/Handler.java123456789101112public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 最终调用handleMessage处理消息。此处既是调用ActivityThread.java的该函数。 /frameworks/base/core/java/android/app/ActivityThread.java12345678910public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ....... SurfaceFlinger的消息处理机制 类似的消息处理机制在SurfaceFlinger也存在，拥有独自的文件frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp等待消息、发送消息、处理消息。从而进行Layer合成事件。 /frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp123456789101112void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android WMS和View基本理解","slug":"2019/190921-android-wms-view-cpp","date":"2019-09-21T13:32:22.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/21/2019/190921-android-wms-view-cpp/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/21/2019/190921-android-wms-view-cpp/","excerpt":"概述 Window 可以看做是Surface的一个包装，本质上，Window的本体就是一片Surface。将操作对象Surface，对象关联属性集以及操作方法等组合在一起便是 Window。Surface 其实是一块画布，应用可以随心所欲地通过 Canvas 或者 OpenGL 在其上作画，然后通过 SurfaceFlinger 将多块 Surface 的内容按照特定的顺序(ZOrder)进行混合并输出到 FrameBuffer，从而将 Android 漂亮的脸蛋显示给用户。既然每个窗口都有一块 Surface 供自己涂鸦，所以必然需要一个角色对所有窗口的 Surface 进行协调管理。于是,WMS 应运而生。 代码： http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/","text":"概述 Window 可以看做是Surface的一个包装，本质上，Window的本体就是一片Surface。将操作对象Surface，对象关联属性集以及操作方法等组合在一起便是 Window。Surface 其实是一块画布，应用可以随心所欲地通过 Canvas 或者 OpenGL 在其上作画，然后通过 SurfaceFlinger 将多块 Surface 的内容按照特定的顺序(ZOrder)进行混合并输出到 FrameBuffer，从而将 Android 漂亮的脸蛋显示给用户。既然每个窗口都有一块 Surface 供自己涂鸦，所以必然需要一个角色对所有窗口的 Surface 进行协调管理。于是,WMS 应运而生。 代码： http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/ 对应的关系： 1 IDirectFB (顶层) &lt;–&gt; N 屏幕(Screens) 1 屏幕(Screen) &lt;–&gt; N 层(Layers) 1 层(Layer) &lt;–&gt; 1 主表面(Primary Surface) 1 层(Layer) &lt;–&gt; N 窗口(Windows) 1 窗口(Window) &lt;–&gt; 1 窗口表面(Window Surface) 1 表面(Surface) &lt;–&gt; N 子表面(Subsurfaces) Dump window信息adb shell dumpsys window windows 123456789101112WINDOW MANAGER WINDOWS (dumpsys window windows) Window #0 Window&#123;bdae67a u0 InputMethod&#125;: mDisplayId=0 stackId=0 mSession=Session&#123;2b3f00f 19539:u0a10056&#125; mClient=android.os.BinderProxy@59092a5 mOwnerUid=10056 mShowToOwnerOnly=true package=com.baidu.input_yijia appop=NONE mAttrs=&#123;(0,0)(fillxwrap) gr=BOTTOM CENTER_VERTICAL sim=&#123;adjust=pan&#125; ty=INPUT_METHOD fmt=TRANSPARENT wanim=0x1030056 fl=NOT_FOCUSABLE LAYOUT_IN_SCREEN SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS&#125; Requested w=1080 h=2280 mLayoutSeq=207584 mIsImWindow=true mIsWallpaper=false mIsFloatingLayer=true mWallpaperVisible=false mBaseLayer=141000 mSubLayer=0 mAnimLayer=0+=0 mLastLayer=0 mToken=WindowToken&#123;92f628b android.os.Binder@c12205a&#125; mViewVisibility=0x8 mHaveFrame=true mObscured=false...... 可以列出当前系统中存在的所有窗口。查看下该命令的输出可以发现Android是一个同时存在着多个窗口的系统。比如 StatusBar、NavigationBar、Activity、InputMethod、WallPaper 等窗口都可能同时存在。因为同时有多个窗口各自为政，所以需要 WMS 作为管理者来协调，以便窗口们能在狭窄的显示屏幕上和睦相处。 作为协调者，WMS的本职工作主要是负责管理各窗口的生命周期（创建/销毁）、各窗口的位置大小（Layout）、各窗口的显示层级（Z-order）以及窗口的显示属性（可见性等）。 相关类 DisplayContent：一个容器，一个 DisplayContent 内收集了所有需要显示到相应屏幕上的窗口 PhoneWindowManager：定义了 Phone 相关的窗口策略，负责为 WMS 提供各种建议，包括布局，事件处理，屏幕旋转等 WindowAnimator WindowStateAnimator AppWindowAnimator： 主要负责 Surface 相关操作，包括创建，销毁，Surface 属性变更，动画等 WindowToken AppWindowToken： WindowToken 的作用是将一组相关性紧密的窗口组织在一起。达到批量管理的效果 WindowState： 一般被认为是 WMS 眼中的窗口，管理着关联窗口的所有属性状态信息 AppWindowToken 根据 AMS 侧 Activity 的顺序有序排列，WindowState 根据 Layer 值有序排列。 WMS添加窗口流程（addView）WindowManagerGlobal，是一个进程唯一的实例，也就是说无论在应用的任何角落调用addView，都会通过WindowManagerGlobal 来处理相应的请求。从理解出发，可以认为WindowManagerGlobal是一个App进程中窗口管理者。 frameworks/base/core/java/android/view/WindowManagerImpl.java12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; 调用WindowManagerGlobal的addView函数： frameworks/base/core/java/android/view/WindowManagerGlobal.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(\"View \" + view + \" has already been added to the window manager.\"); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; //新疆一个ViewRootImpl对象，调用构造函数 root = new ViewRootImpl(view.getContext(), display); //布局参数 view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); //调用setView函数 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125; setView做了很多处理，主要的是调用requestLayout()和 mWindowSession.addToDisplay。见下面： addWindowframeworks/base/core/java/android/view/ViewRootImpl.java12345678910111213141516171819202122232425262728293031323334public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; mAttachInfo.mDisplayState = mDisplay.getState(); mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); ...... try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //添加到Display res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame, mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel, mTempInsets); setFrame(mTmpFrame); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; ..... 这里出现了mWindowSession，它的类型是 IWindowSession，是WindowManagerGlobal#sWindowSession的一个引用，进程唯一的实例。 它是常见的Binder远程调用中IWindowSession的Bp端，Bn端是一个Sessio 实例，存在于WMS所属进程，Session代表了WMS关于窗口管理服务的一个子集，Android 系统中，由App进程端主动向WMS发起的请求，都是通过mWindowSession进行的，也就是说Session提供了所有App进程能够请求WMS的服务请求。 调用到实现类Session.java: frameworks/base/services/core/java/com/android/server/wm/Session.java123456789public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame, outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel, outInsetsState);&#125; 最终调用到WMS.java的addWindow函数。addWindow的工作可以分为4步： WindowToken 检查 WindowState 创建 将新建的 WindowState 插入到现有的 WindowState 有序列表里 给系统中现有的所有 WindowState 重新分配 Layer 1234567891011121314151617 public int addWindow(Session session, IWindow client, int seq, LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) &#123; int[] appOp = new int[1]; int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; boolean reportNewConfig = false; WindowState parentWindow = null; long origId; final int callingUid = Binder.getCallingUid(); final int type = attrs.type;...... relayoutWindow Surface outSurface：输出参数，用于承载该窗口的 Surface，ViewRootImpl 获得此 Surface 便可以调用Draw在上面进行绘制窗口所承载的所有View。 关于 relayoutWindow 的处理内容粗略分为下列： 根据传入参数更新 WindowState 对象的对应属性，这些属性都会在布局的时刻用到。 根据传入的可见性参数处理窗口 Surface 的创建或销毁 处理一些由窗口更新带来的一些变化，如 Focus 变化，输入法窗口/壁纸窗口移动，屏幕构型 Configuration 改变等 执行 performLayoutAndPlaceSurfaceLocked 函数进行布局 View概述View就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而ViewGroup就是一种可以容纳View的矩形容器。 从设计模式的角度看，ViewGroup 和 View 是组合模式的典型应用。View 是基本的控件元素，ViewParent 接口定义了添加、删除 View 的接口 addView、removeView，ViewGroup 实现了 ViewParent 的接口，因此可以作为 View 的容器管理 View，同时 ViewGroup 又继承自 View，可以被其他的 ViewGroup 管理。这样 ViewGroup 和 View 就可以组成上面的树状结构了。 应用程序启动的过程中，会加载一个或者多个 Activity。每个 Activity 对应一个 PhoneWindow。当Activity在onCreate方法中调用 setContentView 的时候，PhoneWindow 会根据布局文件，创建 View 树，同时，根据应用的一些参数设置，得到集合了窗口显示特性的 View 树的根节点 mDecor 。WindowManagerGlobal 会通过数组记录一个应用程序对应的所有 View 树的根节点 mDecor，布局参数，以及对应的 ViewRootImpl。同时，将 mDecor 和布局参数传递给 ViewRootImpl。ViewRootImpl中实现对 View 树的整体控制，包括与 WMS 的通信，View 的描绘处理，输入事件的分发处理等。 View 的结构图如下： 基本元素 View ：最基本的UI组件，表示屏幕上的一个矩形区域 Window ：1〉 表示顶层窗口，管理界面的显示和事件的响应；2 〉每个Activity均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。该Window在Activity的attach方法中通过调用PolicyManager.makeNewWindow创建； DecorView ：是Window中view的RootView WindowManager ：1〉 主要用来管理窗口的一些状态、属性、view 增加、删除、更新、窗口顺序、消息收集和处理等 2〉interface，继承自ViewManager。所在应用进程的窗口管理器；3〉实现类 WindowManagerImpl ViewRootImpl：1 〉界面控制和消息响应；2 〉通过IWindowSession接口与全局窗口管理器WMS进行交互 ActivityThread：1〉 应用程序的主线程，其中会创建关联当前 Activity 与 Window；2〉创建 WindowManager 实现类实例，把当前 DecoView 加入到 WindowManager View处理简单流程VSYNCVSYNC 信号，即 vertical synchronization，可以理解为垂直同步，或者帧同步。是 Android4.1 为了解决 UI 不流畅问题而引入的处理。当需要同步信号的时候，通过 Choreographer 注册回调，等到 VSYNC信号到来的时候，执行相应的回调。这样，一方面可以避免频繁更新导致的画面不流程；另一方面，因为 SYNC 信号的频率大概是 60 次/秒，即可以保证帧率 60，显示效果非常平滑。 由上图可见，View 的描绘工作，是在 performTraversals 中完成的。主要分为三步： performMeasure，负责计算View的尺寸； performLayout，负责计算 View 在界面上的位置； performDraw，根据前面两步的计算结果，完成实际的描绘工作。 performTraversals触发描绘处理View 的描绘是通过 performTraversals 发起的，所以任何调到 performTraversals 的地方，都会触发描绘处理。 ViewRootImpl 中初次添加 View:自上而下发起遍历。 应用主动调用 requestLayout:自下而上通过 mParent 调用父节点的 requestLayout，直至 ViewRootImpl。 应用主动调用 invalidate:自下而上通过 mParent 调用父节点的 invalidateChild，直至 ViewRootImpl。 其他情况：如应用程序的 Visibility 发生变化的时候，LayoutParams 发生变化的时候等，都会触发遍历操作。 performMeasure（测量） frameworks/base/core/java/android/view/ViewRootImpl.java1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; frameworks/base/core/java/android/view/View.java12345678910111213141516171819202122232425262728293031323334353637383940public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; ...... if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); //调用onMeasure函数 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(\"View with id \" + getId() + \": \" + getClass().getName() + \"#onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; ...... 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; performLayout（布局） performDraw（硬件渲染） performDraw调用draw，完成绘制工作。实际绘制操作可以分为硬件渲染和软件渲染两种情况。 Step1. ViewRootImpl.setView当mSurfaceHolder为空，也就是说应用不会要求自己接管对窗口的渲染的情况下，才会开始硬件渲染环境的准备。 Step2. ViewRootImpl.enableHardwareAcceleration frameworks/base/core/java/android/view/ViewRootImpl.java1234567891011121314151617public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; ......// If the application owns the surface, don't enable hardware acceleration if (mSurfaceHolder == null) &#123; // While this is supposed to enable only, it can effectively disable // the acceleration too. enableHardwareAcceleration(attrs); final boolean useMTRenderer = MT_RENDERER_AVAILABLE &amp;&amp; mAttachInfo.mThreadedRenderer != null; if (mUseMTRenderer != useMTRenderer) &#123; // Shouldn't be resizing, as it's done only in window setup, // but end just in case. endDragResizing(); mUseMTRenderer = useMTRenderer; &#125; &#125; 常驻内存的进程，禁止使用硬件加速，因为非常耗费内存。 系统进程一般都要禁用硬件加速，但是以下两种情况除外： (1) 应用启动之前的Starting Window，会通过设置以下flag，标示启用硬件加速，但是不缓存： WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED (2) 锁屏界面，虽然是在系统进程中，但是通过设置以下 flag，可以启用硬件加速： WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED 其他情况，根据 Activity 窗口是否请求硬件加速渲染决定是否开启硬件加速。通过判断flags位 WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED被置为1，同时硬件支持硬件加速，就可以继续后面的初始化工作了。 Step3: ThreaedRenderer.create设备支持 Open GL ES2.0，就创建对象：ThreadedRender。 通过 nCreateRootRenderNode 在 Native 层创建一个 Render Node。 通过 adopt 方法，将 Native 层的 Render Node 封装成 Java 层的 Render Node。 通过 nCreateProxy 在 Native 层创建一个 Render Proxy 对象。该proxy对象以后负责从Main Thread向RenderThread发送命令。 RenderProxy 有三个重要的成员变量： mRenderThread：进程单例，指向 RenderThread 对象，通过它可以向 RenderThread 线程发送命令。 mContext：画布上下文。RenderThread 通过它完成渲染工作。 mDrawFrameTask：指向一个 DrawFrameTask 对象，Main thread 通过它向 Render Thread 线程发送渲染下一帧的命令。 Step4：ViewRootImpl.performTraversals当得到了有效的surface，就通过ThreadedRender的initialize方法，将该surface与RenderThread绑定。 硬件渲染流程图 ThreadedRender.draw主要执行三个操作： 调用成员函数 updateRootDisplayList 构建或者更新应用程序窗口的 Root Render Node 的 DisplayList。RenderNode.start 和 RenderNode.end 直接的处理，与软件渲染的流程一样，只是硬件渲染的时候，只把渲染命令存储到 DisplayList 中，并不真正开始执行渲染操作。 调用成员函数 registerAnimationRenderNode 注册应用程序窗口动画相关的 Render Node 到 native 层。这些RenderNode是用于描述当前窗口设置的动画。 调用成员函数 nSyncAndDrawFrame，通知Render Thread绘制下一帧。其具体实现在 navtive 层。通DrawFrameTask 向 RenderThread 的 task Queue 抛出一个消息，等待 RenderThread 在合适的时候唤醒。 软件渲染在 ViewRootImpld 的 draw()如果不进行硬件渲染，会进行软件渲染drawSoftware() Step1. ViewRootImpl.Draw 计算窗口是否处于滚动状态。 计算 dirty 区域，也就是需要重绘的区域。 Dirty 区域不为空，或者动画进行中，继续判断是否选择了硬件加速，如果没有使用硬件加速，则通过 drawSoftware（）发起软件渲染。 如果动画执行过程中，发起下一次轮询。 frameworks/base/core/java/android/view/ViewRootImpl.java12345678private boolean draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125; ...... Step2. ViewRootImlp.drawSoftware通过 lockCanvas()获取画布。 Step3. Framelayout.draw(Canvas)ViewRootImpl 中，通过 mView.draw(canvas)，调用 DecorView 的 draw 方法；DecorView 通过 super.draw(canvas)，调用父类 Framlayout 的 Draw 方法。 在 FrameLayout 中，通过 super.draw(canvas)方法，调用 View.draw 方法，触发实际的描绘处理。 Step4. View.draw 描绘背景。如果 PFLAG_DIRTY_OPAQUE 被设置，并且 mAttachInfo.mIgnoreDirtyState=flase，说明有不透明子view遮挡了当前的 view，不需要绘制背景。 保存当前画布的堆栈状态，并且创建额外的图层描绘当前视图滑动时的边框渐变效果。FADING_EDGE_VERTICAL 和FADING_EDGE_HORIZONTAL 都没有被设置的时候，不需要执行这步操作。 通过 onDraw 调用子类描绘处理，完成当前视图的描绘。 通过 dispatchDraw 调用子视图的描绘处理。 绘制边框的渐变效果（与步骤 2 对应），并且恢复图层。此步骤不是必需的。 如果需要显示滚动条，通过 onDrawScrollBars 调用描绘滚动条。 Step5. ViewGroup.dispatchDraw FLAG_RUN_ANIMATION被设置，并且允许显示子视图的动画，则通过 bindLayoutAnimation 设置动画。设置完成后，通过LayoutAnimationController 的对象来启动动画，并且调用 mAnimationListener 的 onAnimationStart()来通知动画监听，当前视图开始显示动画了。 如果子视图可见或者有动画需要显示，就通过方法 drawChild 实现子视图的绘制。 如果动画结束，通过notifyAnimationListener发送消息，通知动画监听者，动画已经结束。 Step6. ViewGroup.drawChild调用子 view 的 draw(Canvas, ViewGroup,long)方法，实现子视图的绘制。 Step7. View.draw(Canvas, ViewGroup, long) 通过方法drawAnimation实现动画的绘制。 通过flag检查子视图是否支持缓冲方式绘制。即将子视图缓冲到一个Bitmap中，后续可以通过getDrawingCache获得该bitmap。 以非缓冲的方式绘制：检查 SKIP_DRAW 标记是否被置位，如果为 1，则跳过当前视图的绘制，调用 ViewGroup 的dispatchDraw，重复前面过程，继续该视图的子视图的绘制；否则，通过调用 View.draw(Canvas)，重复 step4 的过程，完成当前视图的绘制以后，再发起子视图的绘制。 以缓冲的方式绘制：通过 canvas.drawBitmap()将上次缓冲的 Bitmap 对象 cache 绘制到画布上。 Step8. ViewRootImpl.drawSoftware循环上面的过程，直到所有子视图都被绘制到画布上，返回 drawSoftware 方法。 通过 surface.unlockCanvasAndPost()方法，请求 SurfaceFlinger 服务渲染这块画布到图形缓冲区。 软件渲染流程图","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"graphics","slug":"graphics","permalink":"https://alonealive.github.io/Blog/tags/graphics/"}]},{"title":"C++ 运算符重载、友元、返回对象","slug":"2019/190916_cpp_useclass","date":"2019-09-16T14:59:00.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/16/2019/190916_cpp_useclass/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/16/2019/190916_cpp_useclass/","excerpt":"运算符重载运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。 例如* 用于地址，将获得存储在这个地址中的值；而用于两个数字之间，得到的是乘积。","text":"运算符重载运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。 例如* 用于地址，将获得存储在这个地址中的值；而用于两个数字之间，得到的是乘积。 要重载运算符，可以使用被称为运算符函数的特殊函数形式，运算符函数的格式如下：operator(argument-list) 例如operator+()重载+运算符，operator*()重载*运算符。op必须是有效的运算符，不能虚构新的符号。比如不存在operator@()。 1234567Time Time::operator+(const Time &amp;t) const &#123; Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum;&#125; 重载限制 重载后的运算符必须至少有一个操作数是用户定义的类型。防止用户为标准类型重载运算符。即不能用减法运算符重载求和，会影响性能。 使用运算符不能违反运算符原来的句法规则。例如不能将求模（余数）运算符重载成使用一个操作数： 12- int x;- % x; //Error 同时不能修改运算符的优先级。 不能创建新运算符，例如不能定义operator**()函数来表示求幂。 不能重载以下运算符： 运算符 释义 sizeof sizeof求长度运算符 . 成员运算符 .* 成员指针运算符 :: 作用域解析运算符 ? 条件运算符 typeid 一个RTTI运算符 const_cast 强制类型转换运算符 dynamic_cast 强制类型转换运算符 reinterpret_cast 强制类型转换运算符 static_cast 强制类型转换运算符 友元 C++控制对类对象私有部分的访问，通常公有类提供唯一的访问途径，但是有时候限制太严格，以致于不适合特定的编程情形。因而C++提供另一种形式的访问权限：友元 ， 有三种： 友元函数 友元类 友元成员函数（通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。） 在为类重载二元运算符时常常需要友元。 创建友元将原型放在类声明中，并在原型声明前加上关键字friend。 friend Time operator* (double m, const Time &amp;t);//goes in class declaration 表明两点： 虽然是在类声明中声明，但不是成员函数，因此不能使用成员运算符调用（.或者-&gt;），不能使用Time::限定符 虽然不是成员函数，但是和成员函数的访问权限相同 在函数实现中不要使用关键字friend 123Time operator*(double m, const Time &amp;t) &#123; ......&#125; 返回对象相关当成员函数或独立的函数返回对象时，有几种返回方式可供选择，可以返回指向对象的引用、指向对象的const引用或const对象。 返回指向const对象的引用使用const引用的常见原因是极高效率，但是对何时可以采用这种方式存在限制。如果函数返回（通过调用对象的方法或者将对象作为参数）传递给他的对象，可以通过返回引用来提高效率。 1234567891011121314151617181920212223Vector force1(50, 60);Vector force2(10, 70);Vector max;max = Max(force1, force2);//version 1 //返回对象将调用复制构造函数Vector Max(const Vector &amp; v1, const Vector &amp; v2) &#123; if (v1.magval() &gt; v2.magval()) return v1; else return v2;&#125;//version 2 //返回引用不会调用构造函数，因而效率更高；//其次引用指向的对象在调用函数时存在（此处的force1和force2在调用函数中定义，满足条件）；//v1和v2都被声明为const引用，因此返回类型必须是const，这样才匹配const Vector &amp; Max(const Vector &amp; v1, const Vector &amp; v2) &#123; if (v1.magval() &gt; v2.magval()) return v1; else return v2;&#125; 返回指向非const对象的引用两种常见的返回非const对象的情形： 重载赋值运算符（旨在提高效率） 重载与const一起使用的&lt;&lt;运算符（必须这么做） 1234//operator=()的返回值用于连续赋值String s1(\"Good stuff\");String s2,s3;s3 = s2 = s1; //s2.operator=()的返回值被赋值给s3，通过使用引用可以避免该函数调用String的复制构造函数来创建一个新的String对象 在这个例子中，返回类型不是const，因为方法operator=()返回一个指向s2的引用，可以对其进行修改。 12String s1(\"Good\");cout &lt;&lt; s1 &lt;&lt; \"is coming\"; 在这个例子中，返回类型必须是ostream&amp; ，而不能仅是ostream，否则将调用ostream类的复制构造函数，而ostream没有共有的复制构造函数。 返回对象如果返回的对象是被调用函数中的局部变量，则不应使用引用方式返回它。因为在被调用函数执行完毕，局部对象将调用其析构函数。 小结指针和对象使用 使用常规表示法来声明指向已有的对象，String * glamour; 可以将指针初始化为指向已有的对象，String * first = &amp;sayings[0]; 可以使用new来初始化指针，这将会创建一个新的对象，String * favorite = new String(sayings[choice]); 对类使用new将调用相应的构造函数来初始化新建的对象 可以使用-&gt;运算符通过指针访问类的方法，shortest-&gt;length() 可以对对象的指针应用解除引用运算符*来获得对象，’if (sayings[i] &lt; *first&gt;)’ 重载&lt;&lt;运算符要重新定义&lt;&lt;运算符，以便将他和cout一起用来显示对象的内容，请定义下面的友元运算符函数： 12345//c_name是类名，如果该类提供了能够返回所需内容的公有方法，则可在运算符函数中使用这些方法，这样编不用将他们设置为友元函数ostream &amp; operator&lt;&lt; (ostream &amp;os, const c_name &amp; obj) &#123; os &lt;&lt; ...; //display object contents return os;&#125; 转换函数要将单个值转换为类类型，需要创建原型如下所示的类构造函数：c_name(type_name value) 其中c_name是类名，type_name是要转换的类型的名称。 要将类转换为其他类型，需要创建类如下所示的类成员函数:operator type_name(); 虽然该函数没有声明返回类型，但应返回所需类型的值。使用转换函数时，可以在声明构造函数中使用关键字explicit，放置它被用于隐式转换。 其构造函数使用new的类 对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存 如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将其设置为空指针 构造函数中要么使用new，要么使用new[]，不能混用。对应的析构函数使用delete，和delete[] 应定义一个分配内存的复制构造函数，这样程序能够将类对象初始化为另一个类对象，通常的函数原型：className(const className &amp;) 应定一个重载赋值运算符的类成员函数，其函数定义如下: 12345678910c_name &amp; c_name::operator=(const c_name &amp; cn) &#123; if (this == &amp;cn) return *this; delete [] c_pointer; //是c_name的类成员，是指向type_name的指针 //set size number of type_name unite to be copied c_pointer = new type_name[size]; //then copy data pointed to by cn.c_pointer to location pointed to by c_pointer ... return *this;&#125; Share一个Ubuntu免费使用ultraEdit的方法在bin目录下建立一个脚本，并且在打开软件前执行： uexClearCache.sh 123rm -rfd ~/.idm/uex rm -rf ~/.idm/*.spl rm -rf /tmp/*.spl","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Android zygote和SystemServer进程","slug":"2019/190910_android_zygote_systemserver","date":"2019-09-10T14:52:00.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/10/2019/190910_android_zygote_systemserver/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/10/2019/190910_android_zygote_systemserver/","excerpt":"zygote和system_server在Android中的Java层很重要。 zygote分析 zygote由init进程根据init.rc的配置项创建的。最初叫app_process，但是在运行过程中，通过Linux的pctrl系统调用将其换成了zygote。通过adb shell ps -ef|grep zygote查看到该进程。","text":"zygote和system_server在Android中的Java层很重要。 zygote分析 zygote由init进程根据init.rc的配置项创建的。最初叫app_process，但是在运行过程中，通过Linux的pctrl系统调用将其换成了zygote。通过adb shell ps -ef|grep zygote查看到该进程。 Android-10.0.0_r2 AOSP源码中，查看其入口函数： frameworks/base/cmds/app_process/app_main.cpp12345678910111213141516171819202122232425262728int main(int argc, char* const argv[])&#123; if (!LOG_NDEBUG) &#123; String8 argv_String; for (int i = 0; i &lt; argc; ++i) &#123; argv_String.append(\"\\\"\"); argv_String.append(argv[i]); argv_String.append(\"\\\" \"); &#125; ALOGV(\"app_process main with argv: %s\", argv_String.string()); &#125; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++;...... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); &#125;&#125; 重要的功能由AppRuntime的start函数完成。而AppRuntime类就在app_main.cpp中，从AndroidRuntime派生而来。 frameworks/base/core/jni/AndroidRuntime.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); static const String8 startSystemServer(\"start-system-server\");...... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; //创建虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; //注册JNI函数 ALOGE(\"Unable to register all android natives\\n\"); return; &#125;..... /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //通过JNI调用Java中ZygoteInit的main函数，进入Java世界...... 创建虚拟机startVM 该函数调用JNI的Dalvik虚拟机创建函数，在sdtartVM中确定创建虚拟机的一些参数 注册JNI函数 startReg 给虚拟机注册一些JNI函数，采用native方式实现。 java入口 CallStaticVoidMethod CallStaticVoidMethod最终调用frameworks/base/core/java/com/android/internal/os/ZygoteInit.java的main函数。 1234567891011121314151617181920212223242526272829 @UnsupportedAppUsage public static void main(String argv[]) &#123; ZygoteServer zygoteServer = null; // Mark zygote start. This ensures that thread creation will throw // an error. ZygoteHooks.startZygoteNoThreadCreation(); // Zygote goes into its own process group. try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to setpgid(0,0)\", ex); &#125; Runnable caller;...... if (startSystemServer) &#123; //启动system_server Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; r.run(); return; &#125; &#125;...... forkSystemServer会创建java世界中系统service所驻留的进程system_server，该进程是framework的核心。 SystemServerSystemServer的进程名叫做system_server，由zygote进程中创建。 forkSystemServer函数中调用handleSystemServerProcess()来处理自己的事务。 调用到systemserver的main函数。 frameworks/base/services/java/com/android/server/SystemServer.java123456789101112131415161718192021222324/** * The main entry point from zygote. */public static void main(String[] args) &#123; new SystemServer().run();&#125;public SystemServer() &#123; // Check for factory test mode. mFactoryTestMode = FactoryTest.getMode(); // Record process start information. // Note SYSPROP_START_COUNT will increment by *2* on a FDE device when it fully boots; // one for the password screen, second for the actual boot. mStartCount = SystemProperties.getInt(SYSPROP_START_COUNT, 0) + 1; mRuntimeStartElapsedTime = SystemClock.elapsedRealtime(); mRuntimeStartUptime = SystemClock.uptimeMillis(); // Remember if it's runtime restart(when sys.boot_completed is already set) or reboot // We don't use \"mStartCount &gt; 1\" here because it'll be wrong on a FDE device. // TODO: mRuntimeRestart will *not* be set to true if the proccess crashes before // sys.boot_completed is set. Fix it. mRuntimeRestart = \"1\".equals(SystemProperties.get(\"sys.boot_completed\"));&#125; 随后会创建一些系统服务，并将调用线程加入到Binder通信中。并且会创建一个单独的线程，用以启动系统的各项服务，例如电池管理服务BatteryService，电源管理服务PowerManagerService，StartWindowManagerService，ActivityManagerService等等。 开机耗时长的原因 ZygoteInit的main函数中的preloadClasses加载了上千个类 开机启动时会对系统所有的APK扫描并收集信息 SystemServer创建的一系列service，占用不少时间 虚拟机heapsize的限制zygote创建虚拟机的时候，系统默认设置的java虚拟机堆栈值（可修改）对于使用较大内存的程序远远不够。zygote通过fork创建子进程，因而本身设置的信息会被子进程全部继承，例如设置堆栈对32MB，则子进程也会使用32MB。 watchdog看门狗watchdog作用是每隔一段时间去检查某个参数是否被设置了，如果发现该参数没有被设置，则判断为系统出错，然后强制重启。 Android对于systemserver的参数是否被设置也增加了一条看门狗。主要检查几个重要的service，如果service出了问题就会杀掉system_server，这回导致zygote也一起杀掉，导致java层重启。 SystemServer和Watchdog的交互大致分为三个步骤(frameworks/base/services/core/java/com/android/server/Watchdog.java)： Watchdog.getInstance().init()初始化 Watchdog.getInstance().start()，派生于Thread类，start启动线程，导致Watchdog的run在另外一个线程中被执行。该函数实现隔一段时间发送一条信息，那个线程将检查各个service的健康状况，而看门狗等待检查结果，如果第二次没有返回结果，将会杀掉systemserver Watchdog.getInstance().addMonitor()，如果要支持看门狗的检查，就需要让service实现monitor接口（比如ActivityManagerService,PowerManagerService,WindowManagerService） Example: 当一个函数占着锁，长时间没有返回（原因是这个函数需要和硬件交互，而硬件没有及时返回），导致系统服务死锁被watchdog检查到。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"Android init进程","slug":"2019/190909_android_init_service","date":"2019-09-09T13:52:00.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/09/2019/190909_android_init_service/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/09/2019/190909_android_init_service/","excerpt":"概述 init是Linux系统中用户空间的第一个进程。通过adb shell ps -rf查看我的一加手机进程信息。 12UID PID PPID C STIME TTY TIME CMDroot 1 0 0 12:43:34 ? 00:00:10 init init进程负责创建系统中的几个关键进程，例如zygote init提供了一个property service（属性服务）来管理Android系统的众多属性","text":"概述 init是Linux系统中用户空间的第一个进程。通过adb shell ps -rf查看我的一加手机进程信息。 12UID PID PPID C STIME TTY TIME CMDroot 1 0 0 12:43:34 ? 00:00:10 init init进程负责创建系统中的几个关键进程，例如zygote init提供了一个property service（属性服务）来管理Android系统的众多属性 init分析 使用android-10.0.0_r2 AOSP最新源码（http://192.99.106.107:8080/xref/android-10.0.0_r2/） init进程的入口函数从/system/core/init/main.cpp的main函数开始： system/core/init/main.cpp123456789101112131415161718192021222324252627int main(int argc, char** argv) &#123;#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#endif if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; if (!strcmp(argv[1], \"subcontext\")) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap function_map; return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], \"selinux_setup\")) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], \"second_stage\")) &#123; return SecondStageMain(argc, argv); //此处调用init.cpp的函数入口 &#125; &#125; re 在Android Q之前，此处一直都是直接调用入口函数： system/core/init/main.cpp123int main(int argc, char** argv) &#123; android::init::main(argc, argv);&#125; 然后会调用到init.cpp中的SecondStageMain函数。init的工作流程精简为以下四点： 解析配置文件 执行各个阶段的动作（创建zygote的工作就是此时完成） 调用Property_init初始化属性相关的资源 init进入一个无线循环，等待一些事情的发生（init处理来自socket和来自属性服务器的相关事情） 解析系统配置文件init.rc 在入口函数调用LoadBootScripts(am, sm); 然后调用parser.ParseConfig(bootscript); 调用system/core/init/parser.cpp的parseConfig函数 调用Parser::ParseConfigFile函数，读取配置文件并解析 1234567891011121314bool Parser::ParseConfigFile(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing file \" &lt;&lt; path &lt;&lt; \"...\"; android::base::Timer t; auto config_contents = ReadFile(path); //读取init.rc配置文件 if (!config_contents) &#123; LOG(INFO) &lt;&lt; \"Unable to read config file '\" &lt;&lt; path &lt;&lt; \"': \" &lt;&lt; config_contents.error(); return false; &#125; ParseData(path, &amp;config_contents.value()); LOG(VERBOSE) &lt;&lt; \"(Parsing \" &lt;&lt; path &lt;&lt; \" took \" &lt;&lt; t &lt;&lt; \".)\"; return true;&#125; init.rc解析service 查看/system/core/rootdir/init.rc 123456789101112131415161718192021222324252627282930313233343536373839404142on init //on关键字表示一个section，对应的名字时init sysclktz 0 # Mix device-specific information into the entropy pool copy /proc/cmdline /dev/urandom copy /system/etc/prop.default /dev/urandom symlink /proc/self/fd/0 /dev/stdin...# It is recommended to put unnecessary data/ initialization from post-fs-data# to start-zygote in device's init.rc to unblock zygote start.on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon zygote-start &amp;&amp; property:ro.crypto.state=unsupported # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon boot //新的section，名为boot # basic network init ifup lo //一个command hostname localhost domainname localdomain # IPsec SA default expiration length write /proc/sys/net/core/xfrm_acq_expires 3600... init.rc中：class_start，标识一个COMMAND，对应的处理函数是do_class_start，位于boot section范围内。 属性服务 注册标可以存储一些类似ket/value的键值对，一般系统或某些应用程序会吧自己的一些属性存储在注册表中，即使重启，还是能够根据之前在注册表中设置的属性，进行相应的初始化工作。Android平台也提供了一个类似的机制，称为属性服务（property service） property的初始化在init.cpp的主函数里面： 123456789101112131415161718property_init();...... // Make the time that init started available for bootstat to log. property_set(\"ro.boottime.init\", getenv(\"INIT_STARTED_AT\")); property_set(\"ro.boottime.init.selinux\", getenv(\"INIT_SELINUX_TOOK\")); // Set libavb version for Framework-only OTA match in Treble build. const char* avb_version = getenv(\"INIT_AVB_VERSION\"); if (avb_version) property_set(\"ro.boot.avb_version\", avb_version);... property_load_boot_defaults(load_debug_prop); UmountDebugRamdisk(); fs_mgr_vendor_overlay_mount_all(); export_oem_lock_status(); StartPropertyService(&amp;epoll); MountHandler mount_handler(&amp;epoll); set_usb_controller();......","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/tags/android/"}]},{"title":"C++对象和类","slug":"2019/190904_cpp_class_object","date":"2019-09-04T14:52:00.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/04/2019/190904_cpp_class_object/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/04/2019/190904_cpp_class_object/","excerpt":"类型指定基本类型完成了三项工作： 决定数据对象需要的内存数量 决定如何解释内存中的位（long和float所占位数相同，但是将他们转换成数值的方法不同） 决定可使用数据对象执行的操作和方法","text":"类型指定基本类型完成了三项工作： 决定数据对象需要的内存数量 决定如何解释内存中的位（long和float所占位数相同，但是将他们转换成数值的方法不同） 决定可使用数据对象执行的操作和方法 类class 类规范由两部分组成： 类声明：以数据成员的方式描述数据部分，以成员函数（方法）的方式描述公有接口 类方法定义：描述如何实现类成员函数 即类声明提供类的蓝图，方法定义则提供了细节。 类声明举例： stock00.h12345678910111213141516171819#ifndef STOCKOO_H_#define STOCKOO_H_#include&lt;string&gt;class Stock &#123; private: //只能通过公共成员（或友元函数）访问的类成员，例如要修改shares，只能通过Stock的成员函数 std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125; public: void acquire(const std::String &amp;co, long n); //函数原型 protected: ...&#125; 实现类成员函数 为由类声明中的函数原型表示的成员函数提供代码。成员函数定义和常规函数相似，有函数头和函数体、返回类型和参数，但是有两个特征： 定义成员函数时，使用作用域解析运算符::来标识函数所属的类 void Stock::update(double price) {...} 此处的update即是Stock的成员函数，这就意味着可以将另一个类的成员函数也命名为update。 类方法可以访问类的private组件 构造函数 函数声明对象时，将自动调用构造函数。构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能和类成员相同，否则会导致混乱。 使用构造函数： 显示调用构造函数：Stock food = Stock(&quot;World cabbage&quot;, 250, 1.25); 隐式调用构造函数：Stock garment(&quot;Furry&quot;, 50, 2.6); 创建类对象：Stock *pstock = new Stock(&quot;ABC&quot;, 18, 19.0); Notes: 如果没有提供任何构造函数，则自动提供默认构造函数。比如：Sotck::stock() {...} 如果定义了构造函数，就必须提供默认构造函数，否则会报错。定义的方式有两种： 给已有构造函数的所有参数提供默认值，Stock(const string&amp;co = &quot;Error&quot;, int n =0;) 通过函数重载来定义另一个没有参数的构造函数，Stock() 而只能拥有一个默认构造函数，所以不要同时使用这两个方式。而用户定义的默认构造函数通常给所有成员提供了隐式初始值。例如： 123456Stock::Stock() &#123; company = \"no name\"; share = 0; share_val = 0.0; total_val = 0.0;&#125; 隐式的调用默认构造函数时，不用使用圆括号。Stock stock1; 析构函数 如果构造函数使用new发根配内存，则析构函数将使用delete释放内存。而析构函数的名称是在函数名前加上~，例如~Stock()。Stock的析构函数不承担任何重要的工作，因此直接编写不执行任何操作的函数： 123Stock::~Stock() &#123;&#125; 编译器决定调用析构函数的时机 如果创建的是静态存储对象，则其析构函数就爱你挂在程序结束时自动调用 如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用 如果对象通过new创建的，则将驻留在栈内存或者自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用 程序可以创建临时对象来完成特定的操作，此时程序将在结束对该对象使用时自动调用其析构函数 this指针 this指针指向用来调用成员函数的对象（this被称为隐藏参数传递给方法）每个成员函数（包含构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法想要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。然而要返回的不是this，因为this是对象的地址，*this是指向的值。 123456const Stock &amp; Stock::topval(const Stock &amp; s) const &#123; if (s.total_val &gt; total_val) return s; else return *this;&#125; 对象数组创建同一个类的多个对象，创建对象数组比独立对象变量更合适。 Stock mystuff[4]; 123456789101112mystuff[0].update();mystuff[3].show();const Stock * tops = mystuff[2].topval(mystuff[1]);//使用构造函数初始化数组元素，此时必须为没够元素调用构造函数const int STKS = 4;Stock stocks[STKS] = &#123; Stock(\"A\", 12.5, 20), Stock(\"B\", 11.5, 530), Stock(\"C\", 13.5, 120), Stock(\"D\", 14.5, 30),&#125;; 类作用域 在类中定义的名称（如类数据称源和类成员函数名）的作用域都为整个类。在类声明或成员函数定义中，可以使用未修饰的成员名称（未限定的名称）。构造函数名称被调用时，才能被识别，因为他的名称和类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（.），间接成员运算符（-&gt;）或者作用域解析运算符（::） 作用域于为类的常量声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，没有用于存储值的空间（C++11提供了成员初始化，但不适用于数组声明）。因此以下的方式初始化不正确： 12345class Bck &#123; private:- const int Months = 12; //fail- double costs[Months];&#125; 可以使用以下方式,在类中声明一个枚举，枚举的作用域是整个类。 12345class Bck &#123; private:+ enum &#123;Months= 12&#125;;+ double costs[Months];&#125; 可以在类中定义常量的方式，使用关键字static。这将常量和其他静态变量存储在一起，而不是存储在对象中。因此只有一个Months常量，被所有的Bck类对象共享。 12345class Bck &#123; private:+ static const int Months= 12;+ double costs[Months];&#125; C++11作用域内枚举传统的枚举容易出现冲突，例如在一个类中定义： 12enum egg &#123;Small. Large, Medium&#125;;enum t_shirt &#123;Small. Large, Medium&#125;; C++11提供一种新枚举，其枚举量的作用域是类，如下： 12345678enum class egg &#123;Small. Large, Medium&#125;;enum class t_shirt &#123;Small. Large, Medium&#125;;//或者使用struct关键字代替classenum struct egg &#123;Small. Large, Medium&#125;;enum struct t_shirt &#123;Small. Large, Medium&#125;;egg choic = egg::Large;t_shirt Floyd = t_shirt::Large; //此时将不再发生冲突 抽象数据类型 C++使用栈来管理自动变量，当新的自动变量被生成后，他们被添加到栈顶；消亡时，从栈中删除他们。 栈的特征栈存储了多个数据项（该特征使得栈成为一个容器，一种通用的抽象），其次，栈由可对他执行的操作来描述。 可创建空栈 可将数据项添加到栈顶（压入） 可从栈顶删除数据项（弹出） 可查看栈是否填满 可查看栈是否为空 如果将上述描述转换为一个类声明，其中公有成员函数提供了栈操作的接口，而私有数据成员负责存储栈数据。私有部分必须表明数据存储的方式，例如可以使用常规数组、动态分配数组或者更高级的数据结构。 小结 通常将类声明分成两部分，类声明（包含函数原型表示的方法）应该放在头文件中。定义成员函数的源代码放在方法文件中。 使用OOP方法的第一步是根据他和程序之间的接口描述数据，从而指定如何使用数据。然后设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称作方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏。 类是用户定义的类型，而对象是类的实例。也可以说对象是这种类型的变量，例如由new按类描述分配的内存。 如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显示的引用调用他的对象，则可以使用this指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别名。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++头文件、作用域、内存模型和名称空间","slug":"2019/190901_cpp_namespace","date":"2019-09-01T13:52:00.000Z","updated":"2020-03-08T10:14:08.790Z","comments":true,"path":"2019/09/01/2019/190901_cpp_namespace/","link":"","permalink":"https://alonealive.github.io/Blog/2019/09/01/2019/190901_cpp_namespace/","excerpt":"单独编译C++提供#include语法，因而可以将程序划分，大致可以分成三部分： 头文件a.h：包含结构声明和使用这些结构的函数原型 源代码文件a.cpp：包含与结构相关的函数的代码 源代码文件b.cpp：包含调用与结构相关的函数的代码","text":"单独编译C++提供#include语法，因而可以将程序划分，大致可以分成三部分： 头文件a.h：包含结构声明和使用这些结构的函数原型 源代码文件a.cpp：包含与结构相关的函数的代码 源代码文件b.cpp：包含调用与结构相关的函数的代码 头文件内容和引用 头文件常包含的内容： 函数原型 使用#define或者const定义的符号常量 结构声明struct 类声明class 模板声明template 内联函数inline 头文件引用时，使用#include &quot;coordin.h&quot;，而不是#include &lt;coordin.h&gt;因为尖括号的文件名，C++编译器将在存储标准头文件的主机系统的文件系统中查找；而双引号的头文件，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，取决于编译器） 头文件管理在同一个文件中只能将同一个头文件包含一次。有时候会存在包含了另一个头文件的头文件。因而有一种方法基于预处理器编译指令#ifndef即if not defined可以忽略第一次包含之外的所有内容，但是这种方法不能防止编译器将文件包含两次。。 12345//仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#inndef和#endif之间的语句#ifndef COORDIN_H_#define COORDIN_H_ //完成该名称的定义...#endif 作用域scope 作用域描述名称在文件的多大范围可见。C++变量的作用域有多种。 局部变量只在定义他的代码块中可用。 作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。 自动变量的作用域为局部 静态变量的作用域是全局还是局部取决于它如何被定义 在函数原型作用域中使用的名称只包含参数列表的括号内可用 在类中声明的成员的作用域为整个类 在名称空间中声明的变量的作用域是整个名称空间 C++函数的作用域可以是整个类或者命名空间，但不能是局部的，不能只对自己可见，这样会导致不能被其他函数调用 不同的C++存储方式是通过存储持续性（数据内存存储方式）、作用域和链接性来描述的。 数据内存的存储方式（存储持续性） C++使用三种方案存储数据，见文章《C++内存分配方式和模板类vector,array》C++11新增了线程存储持续性 线程存储持续性在多核处理器很常见，这些CPU可以同时处理多个执行任务（可以使用SDK的systrace工具抓取一份trace查看）。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期和所属的线程一样长。 自动存储持续性 默认情况下，在函数中声明的函数参数和变量的存储持续性是自动，作用域是局部，没有链接性。当函数结束时，这些变量将小时（执行到代码块时，将为变量分配内存，但是其作用域的起点是其声明位置） 如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。 通常存储在栈stack中，先进后出。之所以被称为栈，是由于新数据被象征性的放在原有数据的上面（相邻的内存单元），当程序使用完后，将其从栈中删除（栈的默认长度取决于实现，编译器通常提供改变栈长度的选项）。程序使用两个指针跟踪栈，一个指向栈底（开始位置），一个指向栈顶（下一个可用内存单元）。当函数被调用时，其自动变量被加入栈中，栈顶指针指向变量后的下一个可用内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。 有些自动变量存储在寄存器中，关键字register最初由C语言引入，C++11之前，它建议编译器使用CPU寄存器存储自动变量。这旨在提高访问变量的速度。register int count_fast; 在C++11中，失去了这种提示作用，关键字register只是显式的指出变量是自动的。鉴于它只能用于原本就是自动的变量，使用他的唯一原因是指出这个变量的名称可能与外部变量相同，避免使用了该关键字的现有代码非法。 静态持续变量C++未静态存储持续性变量提供三种链接性： 外部链接性（可在其他文件中访问） 内部链接性（只能在当前文件中访问） 无链接性（只能在当前函数或者代码块中访问） 123456789101112...int global = 1000; //外部链接，作用域是整个文件static int one_file = 50; //内部链接，作用域是整个文件int main()&#123; ...&#125;void fun1(int n) &#123; static int count = 0; //无链接 int ma = 0; //自动变量，两者区别在于静态无链接变量在函数没有被执行时，也会在内存中 ...&#125; 存储描述 持续性 作用域 链接性 声明方法 自动 自动 代码块 无 代码块中 寄存器 自动 代码块 无 代码块中，使用关键字register 静态，无链接性 静态 代码块 无 使用关键字’static’ 静态，外部链接性 静态 文件 外部 不再任何函数内 静态，内部链接性 静态 文件 内部 不再任何函数内，使用关键字static 所有静态持续变量的初始化特征：未被出的初始化的静态变量的所在位都被设置为0，这种变量被称为零初始化的 零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在编译后初始化。 12int x; //零初始化int y = 5; //y先被零初始化，然后编译器计算常量表达式，初始化成5 静态持续性、外部链接性链接性为外部的变量通常简称为外部变量，存储持续性是静态，作用域是整个文件。在函数外部定义，因此对所有函数都是外部的。例如可以在main()前面或者头文件中定义他们。可以在文件中位于外部变量定义后面的任何函数中使用它，因此也被称为全局变量（相对于局部的自动变量） C++有“单定义规则”，每个变量只能有一次定义。因而C++提供两种变量声明，一种是定义声明，分配存储空间；另一种是引用声明，不给变量分配存储空间，引用已有的变量。 引用声明使用关键字extern，则不进行初始化。 123double up; //零初始化extern int blem;; //引用声明，不进行初始化（此处可以引用其他文件已经声明的外部变量）extern char gr = 'z'; //已经初始化了，所以导致分配存储空间 静态持续性、内部链接性不同于外部变量，将static限定符用于作用域为整个文件的变量时，该变量的链接性是内部的。两者区别是 内部链接的变量只能在所属的文件中使用，外部变量具有外部链接性，可以在其他文件中使用。 静态持续性、无链接性将static限定符用于在代码块中定义的变量，导致局部变量的存储持续性是静态的。这意味着虽然只能在该代码块使用，但是在该代码块不处于活动状态时仍然存在。因此在两次调用该函数时，静态局部变量的值将保持不变。此外如果初始化了静态局部变量，则程序只在启动时进行一次初始化，再次调用时不会初始化，即值保持上次的值 限定符和说明符存储说明符 auto(在C++11不再是说明符) register static extern thread_local mutable 同一个声明中不能使用多个说明符（除了thread_local可以和static或者extern结合使用） C++11之前auto指出变量是自动变量，但是在C++11中，auto用于自动类型推断 register用于在声明中指示寄存器存储，在C++11中只是显式的指出变量是自动的 static被用在作用域是整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性是静态的 extern表明是引用声明，即声明引用在其他地方定义的变量 thread_local指出变量的持续性和所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。 mutable的含义根据const来解释（查看下一小节） cv-限定符(const和volatile) const volatile const表示内存被初始化后，程序不能再对其进行修改 volatile表明即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，如果编译器发现程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到既存区中。（这种优化假设变量的值在两次使用之间不发生变化）将变量声明为volatile，则编译器不会进行这种优化；否则将进行这种优化。 可以使用mutable指出，即使结构（或者类）变量为const，其某个成员也可以被修改。 123456789struct data &#123; char name[30]; mutable int accesses; ...&#125;;const data veep = &#123;\"peter\", 0, ...&#125;;+ strcpy(veep.name, \"nancy\"); //not allowed,因为const- veep.accesses++; //allow veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符可以使的access不受这种限制。 名称空间 声明区域是可以在其中进行声明的区域。例如函数外面声明全局变量，其声明区域为所在的文件；函数中声明变量，声明区域为所在代码块； 潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明作用域小，这是由于变量必须定义后才能使用。 关键字namespace通过定义一种新的声明区域来创建命名的空间，如此不会和另一个名称空间发生同名冲突。 1234567891011namespace Javk &#123; double pail; int pal; ...&#125;namespace Jil &#123; double pail; int pal; ...&#125; 作用域解析运算符::双冒号123Jil::pal = 3; //限定的名称int pal = 10; //未限定的名称Javk::pail = 23.4; using声明恶化using编译指令 using声明使得特定的标识符可用，using编译指令使得整个命名空间可用。 12345678namespace Jil &#123; ...&#125;int main() &#123; using Jil::pail; //using声明 double a;&#125; using编译指令由名称空间和关键字using namespace组成。 12using namespace Jil;using namespace std; 建议 不要在头文件使用using编译指令，如果非要使用，应将其放在所有的预处理编译指令#include后面 导入名称时，首选使用作用域解析运算符或者using声明的方法 对于using声明，首选将其作用域设置为局部而不是全局","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Android JNI理解","slug":"2019/190829_android_JNI","date":"2019-08-29T15:41:06.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/29/2019/190829_android_JNI/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/29/2019/190829_android_JNI/","excerpt":"概述 JNI,即Java Native Interface，Java本地调用。通过JNI可以实现： Java程序函数可以调用Natvie语言（C/C++）写的函数 Natvie程序函数可以调用Java层的函数","text":"概述 JNI,即Java Native Interface，Java本地调用。通过JNI可以实现： Java程序函数可以调用Natvie语言（C/C++）写的函数 Natvie程序函数可以调用Java层的函数 MediaScanner示例 使用Android Xref提供的 Android 9.0.0_r3的源码 Java层的MediaScanner完成两件事： 加载JNI库 Java的native函数 frameworks/base/media/java/android/media/MediaScanner.java12345678910111213141516public class MediaScanner implements AutoCloseable &#123; static &#123; System.loadLibrary(\"media_jni\"); //加载对应的JNI库，media_jni是库名，在实际加载动态库的时候会拓展成libmedia_jni.so native_init(); //调用函数 &#125; private final static String TAG = \"MediaScanner\";... private native void processDirectory(String path, MediaScannerClient client); private native boolean processFile(String path, String mimeType, MediaScannerClient client); private native void setLocale(String locale); public native byte[] extractAlbumArt(FileDescriptor fd); private static native final void native_init(); private native final void native_setup(); private native final void native_finalize(); 动态库是运行时加载的库。如果Java要调用native函数，必须通过一个位于JNI层的动态库实现。通常是在类的static语句中加载，调用System.loadLibrary方法就可以加载。 函数名前有Java的关键字native的函数表示将由JNI层实现。 因而Java层只需要两项工作：加载对应的JNI库，和声明由关键字native修饰的函数 JNI层的MediaScannerJNI对应的文件是frameworks/base/media/jni/android_media_MediaScanner.cpp frameworks/base/media/jni/android_media_MediaScanner.cpp123456789101112131415161718// This function gets a field ID, which in turn causes class initialization.// It is called from a static block in MediaScanner, which won't run until the// first time an instance of this class is used.static voidandroid_media_MediaScanner_native_init(JNIEnv *env)&#123; ALOGV(\"native_init\"); jclass clazz = env-&gt;FindClass(kClassMediaScanner); if (clazz == NULL) &#123; return; &#125; fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); if (fields.context == NULL) &#123; return; &#125;&#125;... java层的native_init函数对应android_media_MediaScanner_native_init。通过文件路径来命名，观察两个文件的路径： frameworks/base/media/java/android/media/MediaScanner.java frameworks/base/media/jni/android_media_MediaScanner.cpp 注册JNI函数java层的MediaScanner.java函数native_init位于android.media包中，全路径名是：android/media/MediaScanner.java，对应JNI层函数的名字。JNI层将Java函数名称（包含包名）中的.转换成_，通过这种方式，native_init对应JNI的函数。 JNI函数注册的意思是将java层的native函数和JNI层对应的实现函数关联起来。注册有两种方式：静态方法和动态注册 静态注册 根据函数名来找对应的JNI函数。 （1） 编写Java代码，编译生成.class文件 （2） 使用Java的工具命令javah -o output packagename.classname，生成一个output.h的JNI头文件，里面声明了对应的JNI函数，只要实现里面的函数即可。 动态注册 因为Java native函数和JNI函数是一一对应的，所以存在一种JNINativeMethod的结构记录这种一一对应的关系。 例如frameworks/base/media/jni/android_media_MediaScanner.cpp文件中： 1234567891011121314151617181920212223...static const JNINativeMethod gMethods[] = &#123; ...... &#123; \"native_setup\", \"()V\", (void *)android_media_MediaScanner_native_setup &#125;, &#123; \"native_finalize\", \"()V\", (void *)android_media_MediaScanner_native_finalize &#125;,&#125;;//注册上面的数组// This function only registers the native methods, and is called from// JNI_OnLoad in android_media_MediaPlayer.cppint register_android_media_MediaScanner(JNIEnv *env)&#123; return AndroidRuntime::registerNativeMethods(env, kClassMediaScanner, gMethods, NELEM(gMethods));&#125; 当Java层通过System.loadLibrary加载完JNI动态库后，会查找该库中JNI_OnLoad函数，然后调用他，之后完成动态注册。 12345678910111213141516171819202122232425262728293031323334jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)&#123; JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; ALOGE(\"ERROR: GetEnv failed\\n\"); goto bail; &#125; assert(env != NULL);...... if (register_android_media_MediaRecorder(env) &lt; 0) &#123; ALOGE(\"ERROR: MediaRecorder native registration failed\\n\"); goto bail; &#125; if (register_android_media_MediaScanner(env) &lt; 0) &#123; //此处开始动态注册 ALOGE(\"ERROR: MediaScanner native registration failed\\n\"); goto bail; &#125; if (register_android_media_MediaMetadataRetriever(env) &lt; 0) &#123; ALOGE(\"ERROR: MediaMetadataRetriever native registration failed\\n\"); goto bail; &#125;...... /* success -- return valid version number */ result = JNI_VERSION_1_4;bail: return result;&#125;","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"JNI","slug":"JNI","permalink":"https://alonealive.github.io/Blog/tags/JNI/"}]},{"title":"ubuntu输入法无法选择候选文字","slug":"2019/190829_linux_ibus","date":"2019-08-29T14:28:00.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/29/2019/190829_linux_ibus/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/29/2019/190829_linux_ibus/","excerpt":"解决方法1234#删除配置文件rm -rf ~/.cache/ibus/libpinyinibus-daemon -drxibus-daemon -drx","text":"解决方法1234#删除配置文件rm -rf ~/.cache/ibus/libpinyinibus-daemon -drxibus-daemon -drx","categories":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/tags/linux/"}]},{"title":"C++双冒号、点号、箭头的区别","slug":"2019/190829_cpp_maohao","date":"2019-08-29T13:52:00.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/29/2019/190829_cpp_maohao/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/29/2019/190829_cpp_maohao/","excerpt":"箭头-&gt;和点号.声明一个结构： 123struct mystruct &#123; int age;&#125;;","text":"箭头-&gt;和点号.声明一个结构： 123struct mystruct &#123; int age;&#125;; 如果有个结构变量a，访问成员元素的方法：a.age = 1; 如果采用指针方法访问，则必须用箭头访问元素，比如: 12mystruct *ps;ps-&gt;age = 1; 指针对象当定义类对象是指针对象的时候，需要用到-&gt;指向类中的成员；当定义一般对象的时候，使用:单冒号指向类中的成员。 12345678910class A &#123; public: play();&#125;A *p;p-&gt;play(); //左边是结构指针A pr;pr.play(); //左边是结构变量 双冒号::双冒号只用在类成员函数和类成员变量中。比如： 1234567891011class CA &#123; public: int ca_var; int add(int a, int b);&#125;//函数实现int CA::add(int a, int b) &#123; int c = ::ca_var; //访问当前类实例中的变量 return a+b;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Android中的makefile（Android.mk）","slug":"2019/190828_android_makefile","date":"2019-08-28T13:52:00.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/28/2019/190828_android_makefile/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/28/2019/190828_android_makefile/","excerpt":"makefile是和make命令一起使用，在Android中，可以使用mm、mmm、mma进行编译。Makefile可以组织项目中各种库和代码之间的依赖，构建项目，和maven、gradle一样属于构建工具。常用于大型项目。","text":"makefile是和make命令一起使用，在Android中，可以使用mm、mmm、mma进行编译。Makefile可以组织项目中各种库和代码之间的依赖，构建项目，和maven、gradle一样属于构建工具。常用于大型项目。 基本语法变量定义=或者:=123OBJS &#x3D; programA.o&#x2F;&#x2F;或者OBJS :&#x3D; programA.o 两者区别在于:=只能使用前面定义好的变量，=可以使用后面定义的变量。 变量值追加+=12SRCS :&#x3D; programB.cSRCS +&#x3D; programC.c makefile在Android中的运用 name note LOCAL_PATH = $(call my-dir) 调用my-dir函数，返回Android.mk文件所在的目录，放在第一行，地址是当前目录 include file Makefile 引入其他的makefile文件 include $(CLEAR_VARS) 编译模块时清空LOCAL_MODULE等参数 LOCAL_MODULE 模块名称 LOCAL_SRC_FILES 编译需要的源文件 LOCAL_C_INCLUDES 需要的头文件 LOCAL_SHARED_LIBRARIES 编译需要的动态库 LOCAL_LDLIBS 链接库 引入aidl文件12345LOCAL_SRC_FILES :&#x3D; $(call all-laidl-files-under, src&#x2F;com&#x2F;srm&#x2F;aidl)或者直接如下，但是最后要加上 \\ 符号，并且符号之后要回车：LOCAL_SRC_FILES +&#x3D; $(call all-java-files-under, src) \\src&#x2F;com&#x2F;srm&#x2F;aidl&#x2F;test.aidl \\ 添加jar包（libs和mk同目录）：12345678LOCAL_STATIC_JAVA_LIBRARIES :&#x3D; testjar&#x2F;&#x2F;需要用CLEAR_VARS分割include $(CLEAR_VARS)LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :&#x3D; testjar:libs&#x2F;testjar.jar&#x2F;&#x2F;需要添加include $(BUILD_MULTI_PREBUILT)","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"https://alonealive.github.io/Blog/tags/makefile/"}]},{"title":"C++内联函数、引用变量、函数重载、函数模板","slug":"2019/190826_cpp_inline","date":"2019-08-26T14:23:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/26/2019/190826_cpp_inline/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/26/2019/190826_cpp_inline/","excerpt":"内联函数 常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束后返回。来回跳跃并记录跳跃位置意味着一定的开销。内联函数使得编译器将相应的函数代码替换函数调用。程序无需跳到另一个位置处执行代码，再调回来。因而，内联函数运行速度比常规函数快，但是代价是需要占用更多的内存。如果程序在10个不同的地方调用调用同一个内联函数，则该程序将包含该函数代码的10个副本。","text":"内联函数 常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束后返回。来回跳跃并记录跳跃位置意味着一定的开销。内联函数使得编译器将相应的函数代码替换函数调用。程序无需跳到另一个位置处执行代码，再调回来。因而，内联函数运行速度比常规函数快，但是代价是需要占用更多的内存。如果程序在10个不同的地方调用调用同一个内联函数，则该程序将包含该函数代码的10个副本。 使用内联函数： 在函数声明前加上关键字inline 在函数定义前加上关键字inline 通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。 示例代码： inline.cpp 1234567891011121314#include&lt;iostream&gt;using namespace std;inline double square(double x) &#123;return x * x;&#125;int main() &#123; double a, b; a = square(5.0); b = square(4.5 + 7.5); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt;endl; return 0;&#125; 执行结果： a = 25, b = 144 NOTE：C语言使用预处理语句**#define提供宏（内联代码的原始实现），比如：#define SQUARE(X) X*X这是通过文本替换来实现的。 引用变量标识符&amp; 引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是副本。这样除了指针以外，引用也为函数处理大型结构提供了方便的途径。 创建引用变量12int rats;int &amp; rodents = rats; //此处的&amp;不是地址运算符，而是类型标识符的一部分。int&amp;是指向int的引用。 上述的引用声明允许将rats和rodents互换，他们指向相同的值和内存单元。示例代码： firstref.cpp 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int rats = 101; int &amp; rodents = rats; //必须在声明引用时初始化，不可以分成两句 //上一句等价于 int * const pr = &amp;rats; cout &lt;&lt; \"rats = \" &lt;&lt; rats &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt;endl; rodents++; cout &lt;&lt; \"After rodents++, rats = \" &lt;&lt; rats &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; \"Address &amp;rats = \" &lt;&lt; &amp;rats &lt;&lt; \", &amp;rodents = \" &lt;&lt; &amp;rodents &lt;&lt;endl; return 0;&#125; 执行结果： 123rats = 101, rodents = 101After rodents++, rats = 102, rodents = 102Address &amp;rats = 0x7ffe8c156f1c, &amp;rodents = 0x7ffe8c156f1c //相同的地址和值 将引用用作函数参数12345678910111213141516171819202122&#x2F;&#x2F;按值传递void lazy(int x);int main() &#123; int times &#x3D; 20; lazy(times); return 0;&#125;void lazy(int x) &#123; ...&#125;&#x2F;&#x2F;按引用传递void work(int &amp;x);int main() &#123; int times &#x3D; 20; work(times);&#125;void work(int &amp;x) &#123; ...&#125; 如果让函数使用传递给她的信息，而不对信息进行修改，同时又箱使用引用，则应使用常量引用，即使用const。 double refcube(const double &amp;ra); 将引用参数声明为常量数据的引用的理由三个： 使用const可以避免无意中修改数据的编程错误 使用const使函数能够处理const和非const实参，否则将只能接受非cosnt数据 使用const引用使函数能够正确生成并使用临时变量 C++11新增了另一种引用 – 右值引用，这种引用可以指向右值，是使用&amp;&amp;声明的。目的用来实现移动语义。而’&amp;’引用是左值引用。 123double &amp;&amp; rref = std::sqrt(36.00); //6double j = 15.0;douvle &amp;&amp; jref = 2.0 * j + 18.5; //48.5 合适使用引用参数使用引用参数的主要原因有两个： 能够修改调用函数中的数据对象 通过传递引用而不是整个数据对象，提高程序运行速度 对于使用传递的值而不做修改的函数： 如果数据对象很小，如内置数据类型或小型数据。则按值传递 如果数据对象是数组，则使用指针，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或const引用，提高效率，节省复制结构所需的时间和空间 如果数据对象是类对象，则使用const引用，传递类对象参数的标准方式是按引用传递 对于修改函数中数据的函数： 如果数据对象是内置数据类型，则使用指针。例如调用fixit(&amp;x)这样的函数，则很明显要修改x 如果数据对象是数组，则只能使用指针 如果数据对象是结构，则使用引用或者指针 如果数据对象是类对象，则使用引用 默认参数 默认参数指的是当函数调用中省略了实参时自动调用的一个值。例如将void wow(int n)设置成n有默认值是1，则函数调用wow()就等价于wow(1) 通过函数原型设置默认值：char * left(const char *str, int n = 1); 函数重载 同名的函数使用不同的参数列表。因而关键是参数列表，也称作函数特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序相同，则他们的特征标相同。返回类型可以不同，但是特征标也必须不同 1234567891011void print(const char *str, int width);void print(double d, int width);void print(long l, int width);void print(int i, int width);void print(const char *str);//返回类型不同long gronk(int n, float m);double gronk(int n, float); //互斥，不允许重载double gronk(float n, float m); //可以重载 因而在使用print()函数时，编译器根据采取的用法使用有相应特征标的函数原型。 123print(1999.0, 10);print(1999L, 15);print(\"pen\", 12); 当函数基本上执行相同的人物，但使用不同形式的数据时，才应采用函数重载。 名称修饰（或名称矫正）根据函数原型中指定的形参类型对每个函数名进行加密。long MyFun(int, float);编译器将其转化为内部表示来描述接口：?MyFun@@YAXH 函数模板 函数模板是通用的函数描述，使用泛型来定义函数，其中泛型可以用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可以使编译器生成该类型的函数由于模板允许以泛型的方式编写程序，因此也称作通用编程由于类型是用参数表示的，因此模板特性有时也称作参数化类型 函数模板允许以任意类型的方式来定义函数。例如，可以建立一个交换模板： 123456789template &lt;typename AnyType&gt;//template &lt;class T&gt;void swap(AnyType &amp;a, AnyType &amp;b) &#123; AnyType temp; temp = a; a = b; b = temp;&#125; 第一行建立一个模板，将类型命名为AnyType，关键字template和typename是必需的，除非使用另一个关键字class代替typename(这两个关键字等价的)。另外，必须使用尖括号。类型名可以任意选择（此处是AnyType），常用T 如果需要多个将同一个算法用于不同类型的函数，请使用函数模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不使用class。 Example: funtemp.cpp 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt; //or class Tvoid Swap(T &amp;a, T &amp;b); //函数原型、函数模板使用、引用变量//函数模板定义template &lt;typename T&gt; //or class Tvoid Swap(T &amp;a, T &amp;b) &#123; T temp; temp = a; a = b; b = temp;&#125;int main()&#123; int i = 10; int j = 20; cout &lt;&lt; \"Before swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; Swap(i, j); cout &lt;&lt; \"After swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; double x = 24.45; double y = 45.2; cout &lt;&lt; \"Before swap, x = \" &lt;&lt; x &lt;&lt; \",y = \" &lt;&lt; y &lt;&lt;endl; Swap(x, y); cout &lt;&lt; \"After swap, x = \" &lt;&lt; x &lt;&lt; \",y = \" &lt;&lt; y &lt;&lt;endl; return 0;&#125; Result: 1234Before swap, i = 10,j = 20 //当接收两个int参数，则会用int代替TAfter swap, i = 20,j = 10Before swap, x = 24.45,y = 45.2After swap, x = 45.2,y = 24.45 Note:函数模板不能缩短可执行程序，最终仍将由独立的函数定义，最终的代码不包含任何函数模板，而只包含了为程序生成的实际函数。 使用函数模板的好处是使得多个函数定义更简单可靠。 重载的函数模板 可以像重载常规函数定义一样重载函数模板定义。保证被重载的函数模板特征标必须不同 12345678910111213141516template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b);template &lt;typename T&gt;void Swap(T *a, T *b, int n);//实现第二个template &lt;typename T&gt;void Swap(T a[], T b[], int n) &#123; T temp; for (int i = 0; i &lt; n; i++) &#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125; 局限性 模板函数可能无法处理某些类型。例如数组、指针、结构的某些运算。一种解决方案是C++允许你重载运算符+，以便能够将其用于特定的结构或类；另一种是为特定类型提供具体化的模板定义。 显示具体化C++98标准选择了以下的方法实现第三代具体化： 对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数、以及他们的重载版本 显示具体化的原型和定义应该以template &lt;&gt;开头，并通过名称指出类型 优先级： 非模板函数 &gt; 显示具体化模板函数 &gt; 常规模板函数 123456789101112131415struct job &#123; char name[40]; double salary; int floor;&#125;;//非模板函数(首先调用)void Swap(job &amp;, job &amp;);//显示具体化模板函数（其次调用）template &lt;&gt; void Swap&lt;job&gt;(job &amp; ,job &amp;);//常规模板函数template &lt;typename T&gt;void Swap(T &amp;, T &amp;); Swap&lt;job&gt;的&lt;job&gt;是可选的，因为函数的参数类型声明，这是job的一个具体化。因此，该原型也可以写作：template &lt;&gt; void Swap(job &amp;, job &amp;); Example: twoswap.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b);struct job&#123; char name[40]; double salary; int floor;&#125;;template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2);void Show(job &amp;j);template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b) &#123; T temp; temp = a; a = b; b = temp;&#125;template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2) &#123; double t1; int t2; t1 = j1.salary; j1.salary = j2.salary; j2.salary = t1; t2 = j1.floor; j1.floor = j2.floor; j2.floor = t2; &#125;void Show(job &amp;j) &#123; cout &lt;&lt; j.name &lt;&lt; \" : $\" &lt;&lt; j.salary &lt;&lt; \" on floor \" &lt;&lt; j.floor &lt;&lt;endl;&#125;int main()&#123; cout.precision(2); cout.setf(ios::fixed, ios::floatfield); int i = 10, j = 20; cout &lt;&lt; \"Before swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; Swap(i, j); cout &lt;&lt; \"After swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; job sue = &#123;\"Susan\", 7300.60, 7&#125;; job sidney = &#123;\"Sidney Taffee\", 78060.72, 9&#125;; cout &lt;&lt; \"Before job swap,\\n\"; Show(sue); Show(sidney); Swap(sue, sidney); cout &lt;&lt; \"After job swap,\\n\"; Show(sue); Show(sidney); return 0;&#125; Results: 12345678Before swap, i = 10,j = 20After swap, i = 20,j = 10Before job swap,Susan : $7300.60 on floor 7Sidney Taffee : $78060.72 on floor 9After job swap,Susan : $78060.72 on floor 9Sidney Taffee : $7300.60 on floor 7 关键字decltype(c++11)123456template &lt;class T1, class T2&gt;void ft(T1 x, T2 y) &#123; ... ?type? xpy = x + y; ...&#125; 此处的xpy不知道如何确定类型，在C++11中提供关键字decltype，使用方法： 12345678910111213141516171819int x;decltype(x) y;decltype(x+y) xpy;xpy = x + y;//或者合并成一句decltype(x+y) xpy = x + y;//举例decltype(auto) a;//完善上述的模板函数template &lt;class T1, class T2&gt;void ft(T1 x, T2 y) &#123; ... decltype(x+y) xpy = x + y; ...&#125; C++11后置返回类型声明语法1234template&lt;class T1, class T2&gt;?type? gt(T1 x, T2 y) &#123; return x + y;&#125; 此处无法确定返回的类型，因为未声明参数x和y，所以他们不再作用域呢，无法使用decltype关键字（必须声明参数后使用）。C++11新增了一种语法： double h(int x, float y);使用新增的语法后可以这样编写： auto h(int x, float y) -&gt; double; 这样将返回类型已到了参数声明之后，-&gt;double被称为后置返回类型。 因而使用这种方法声明模板函数： 1234template&lt;class T1, class T2&gt;auto gt(T1 x, T2 y) -&gt; decltype(x+y) &#123; return x + y;&#125;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++函数模块（函数指针、递归）","slug":"2019/190821_cpp_function","date":"2019-08-21T14:23:05.000Z","updated":"2020-10-14T12:23:37.634Z","comments":true,"path":"2019/08/21/2019/190821_cpp_function/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/21/2019/190821_cpp_function/","excerpt":"本章节主要是围绕函数为圆心，涉及到字符串、指针、C++11特性auto、typedef。由于接触android源码、opengl，需将C++学习一遍，之前只是用过java、c、c#这些。涉及到android源码，例如frameworks/native的surfaceflinger,gui,ui, 以及vender,hardware都是需要仔细的阅读C++代码才能够理解。再如graphics的测量、绘制渲染、硬件加速、合成显示，私以为学习一些图形学是有必要的。人生在勤，不索何获。","text":"本章节主要是围绕函数为圆心，涉及到字符串、指针、C++11特性auto、typedef。由于接触android源码、opengl，需将C++学习一遍，之前只是用过java、c、c#这些。涉及到android源码，例如frameworks/native的surfaceflinger,gui,ui, 以及vender,hardware都是需要仔细的阅读C++代码才能够理解。再如graphics的测量、绘制渲染、硬件加速、合成显示，私以为学习一些图形学是有必要的。人生在勤，不索何获。 函数function 是否有返回值（void） main()函数 函数原型，diybke vikyne = cube(side);，函数原型是一条语句，必须以分号结束。一般可以放在头文件中（.h）。函数原型可以确保以下几点： 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确 传递给函数的参数类型和数量（形参） 可以有多个参数，通过逗号分隔 参数的变量名可以和函数原型的不同，而且原型的变量名可以省略void n_chars(char, int); 示例代码： twoarg.cpp 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;void n_chars(char, int); //函数原型int main()&#123; int times; char ch; cout &lt;&lt; \"Enter a character: \"; cin &gt;&gt; ch; while (ch != 'q') &#123; cout &lt;&lt; \"Enter an integer: \"; cin &gt;&gt; times; n_chars(ch, times); //调用函数 cout &lt;&lt; \"\\nEnter another character or press the 'q' to quit: \"; cin &gt;&gt; ch; &#125; cout &lt;&lt; \"The value of times is \" &lt;&lt; times &lt;&lt;endl; return 0;&#125;void n_chars(char c, int n) &#123; while (n-- &gt; 0) cout &lt;&lt; c;&#125; 执行结果： 12345678Enter a character: aEnter an integer: 3aaaEnter another character or press the 'q' to quit: bEnter an integer: 5bbbbbEnter another character or press the 'q' to quit: qThe value of times is 5 函数使用指针处理数组 C++将数组名解释为其第一个元素的地址:cookies == &amp;cookies[0]数组声明使用数组名来标记存储位置对数组名使用sizeof将得到数组的长度（以字节为单位）将地址运算符&amp;用于数组名，将得到整个数组的地址在C++中，只有用于函数头或者函数原型中，int *arr才等价于int arr[] 例如函数原型： int sum_arr(int *arr, int n) 指针和const 让指针指向一个常量对象，这样可以防止使用该指针修改所指向的值 将指针本身声明为常量，可以防止改变指针指向的位置 12int age = 39;const int *pt = &amp;age; //并不意味着指向的值是常量，而是对于pt而言，这个值是常量。即可以通过age改变age的值，但是不能通过pt指针改变它 建议将指针参数声明为指向常量数据的指针有两条理由： 可以避免由于无意间修改数据而导致的编程错误 使用const使得函数能够处理const和非const的实参，否则将只能接收非cosnt数据 1234int sloth = 3;const int * ps = &amp;sloth; //不允许ps来修改sloth的值，但是允许将ps指向另一个位置，即ps不是const，*ps是constint * const finger = &amp;sloth; //允许*finger来修改sloth的值，但是finger只能指向sloth，即finger是const，但是*finger不是constconst int * const strick = &amp;sloth; //strick和*strick都是const 函数和字符串C-风格字符串的表示方式有三种： char数组 用引号括起的字符串常量（也称作字符串字面值） 被设置为字符串的地址的char指针 12345char ghost[15] = \"galloping\";char * str = \"galumphing\";int n1 = strlen(ghost); //ghost是&amp;ghost[0]int n2 = strlen(str); //指向charint n3 = strelan(\"gambolling\"); //字符串string地址 示例代码： strgfun.cpp 12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;unsigned int c_in_str(const char * str, char ch); //只针对非负数int main() &#123; char mmm[15] = \"minimum\"; char *wail = \"ululate\"; unsigned int ms = c_in_str(mmm, 'm'); unsigned int us = c_in_str(wail, 'u'); cout &lt;&lt; ms &lt;&lt; \" m characters in \" &lt;&lt; mmm &lt;&lt;endl; cout &lt;&lt; us &lt;&lt; \" u characters in \" &lt;&lt; wail &lt;&lt;endl; return 0;&#125;unsigned int c_in_str(const char * str, char ch) &#123; unsigned int count = 0; while (*str) &#123; if (*str == ch) count++; str++; &#125; return count;&#125; 执行结果： 123 m characters in minimum2 u characters in ululate 返回字符串的函数 函数无法返回一个字符串，但是可以返回字符串的地址，并且效率更高 示例代码： strgback.cpp 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;char * buildstr(char c, int n);int main() &#123; int times; char ch; cout &lt;&lt; \"Enter a character: \"; cin &gt;&gt; ch; cout &lt;&lt; \"Enter an integer: \"; cin &gt;&gt; times; char *ps = buildstr(ch, times); cout &lt;&lt; \"Result is \" &lt;&lt; ps &lt;&lt;endl; delete []ps; return 0;&#125;char* buildstr(char c, int n) &#123; char * pstr = new char[n+1]; pstr[n] = '\\0'; while (n-- &gt; 0) pstr[n] = c; return pstr;&#125; 执行结果： 123Enter a character: sEnter an integer: 10Result is ssssssssss 函数和结构最直接的方式是像处理基本类型那样处理结构，将结构作为函数传递，并在需要时将结构作返回值使用。 示例代码： travel.cpp 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;struct travel_time &#123; int hours; int mins;&#125;;const int Mins_per_hr = 60;travel_time sum(travel_time tl, travel_time t2);void show_time(travel_time t);travel_time sum(travel_time t1, travel_time t2) &#123; travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total;&#125;void show_time(travel_time t) &#123; cout &lt;&lt; t.hours &lt;&lt; \" hours, \" &lt;&lt; t.mins &lt;&lt; \" minutes\\n\"; &#125;int main() &#123; travel_time day1 = &#123;5, 45&#125;; travel_time day2 = &#123;4, 55&#125;; travel_time trip= sum(day1, day2); show_time(trip); return 0;&#125; 执行结果 10 hours, 40 minutes 函数和string对象代码示例： topfive.cpp 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int SIZE = 5;void display(const string sa[], int n);void display(const string sa[], int n) &#123; for (int i =0; i &lt; n; i++) cout &lt;&lt; i+1 &lt;&lt; \" : \" &lt;&lt; sa[i] &lt;&lt; endl;&#125;int main()&#123; string list[SIZE]; cout &lt;&lt; \"Enter your \" &lt;&lt; SIZE &lt;&lt; \" favorite astronomical sights: \\n\"; for (int i =0; i &lt; SIZE;i++) &#123; cout &lt;&lt; i+1 &lt;&lt; \" : \"; getline(cin, list[i]); &#125; cout &lt;&lt; \"Your list : \\n\"; display(list, SIZE); return 0;&#125; 执行结果： 123456789101112Enter your 5 favorite astronomical sights: 1 : Peter2 : Nancy3 : Good4 : Wizzie5 : JackYour list :1 : Peter2 : Nancy3 : Good4 : Wizzie5 : Jack 函数和array对象要使用数组模板类array，需要包含头文件array，#include&lt;array&gt;，而arrat位于命名空间std中。array不仅可以存储基本数据类型，还可以存储类对象。 12void show(std::array&lt;double, 4&gt; da);void fill(std::array&lt;double, 4&gt; *pa); 示例代码： arrobj.cpp 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;array&gt;#include&lt;string&gt;using namespace std;const int Seasons = 4;const array&lt;string, Seasons&gt; snames = &#123;\"spring\", \"summer\", \"fall\", \"winter\"&#125;;void fill(array&lt;double, Seasons&gt; *pa);void show(array&lt;double, Seasons&gt; da);void fill(array&lt;double, Seasons&gt; *pa) &#123; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; \"Enter \" &lt;&lt; snames[i] &lt;&lt; \" expenses: \"; cin &gt;&gt; (*pa)[i]; &#125;&#125;void show(array&lt;double, Seasons&gt; da) &#123; double total = 0.0; cout &lt;&lt; \"\\nExpenses\\n\"; for (int i =0; i&lt;Seasons; i++) &#123; cout &lt;&lt; snames[i] &lt;&lt; \" : $\" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; \"Total Expenses : $\" &lt;&lt; total &lt;&lt;endl;&#125;int main() &#123; array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); return 0;&#125; 执行结果： 因为array模板类是C++11新增，所以编译命令： g++-5 arrobj.cpp -std=c++11 1234567891011Enter spring expenses: 212Enter summer expenses: 256Enter fall expenses: 208Enter winter expenses: 244Expensesspring : $212summer : $256fall : $208winter : $244Total Expenses : $920 递归 C++函数可以调用自己，和C不同的是，不允许main()调用自己 123456void resurs(argumentlist) &#123; statements1 if (test) recurs(arguments) statements2&#125; 示例代码： 头文件： recur.h 1void countdown(int n); CPP文件： recur.cpp 1234567891011121314151617#include&lt;iostream&gt;#include \"recur.h\"using namespace std;//void countdown(int n);int main() &#123; countdown(10); return 0;&#125;void countdown(int n) &#123; cout &lt;&lt; \"Counting down ...\" &lt;&lt; n &lt;&lt;endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; \" : Kaboom!\\n\";&#125; 执行结果： 12345678910111213141516171819202122Counting down ...10Counting down ...9Counting down ...8Counting down ...7Counting down ...6Counting down ...5Counting down ...4Counting down ...3Counting down ...2Counting down ...1Counting down ...00 : Kaboom!1 : Kaboom!2 : Kaboom!3 : Kaboom!4 : Kaboom!5 : Kaboom!6 : Kaboom!7 : Kaboom!8 : Kaboom!9 : Kaboom!10 : Kaboom! 函数指针 函数也存在地址，函数的地址是存储其机器语言代码的内存的开始地址。例如，可以编写将另一个函数的地址作为参数的函数，这样第一个函数将能够找到第二个函数并运行它。 释义函数指针必要工作： 获取函数的地址 只需使用函数名（后面不用跟参数）。比如think()函数的地址是think。要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值 12process(think); //传递地址thought(think()); //传递返回值 声明函数指针 声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，必须指定指针指向的函数类型。即声明应该像函数原型那样指出有关函数的信息。 通常要声明指向特定类型的函数的指针，可以首先编写如下的函数原型，然后用(*pf)替换函数名。如此，pf就是这个函数的指针。 1234567double pam(int); //函数原型double (*pf)(int); //如果(*pf)是函数，pf就是函数指针double *pf(int); //返回double指针pf = pam; //pf指向pam函数，但是要注意参数类型必须相同 使用指针来调用函数 123456789doubld pam(int);double (*pf)(int);pt = pam; //pf指向pam()函数double x = pam(4);double y = (*pf)(5); //（1） 等价，调用pam(5)double y = pf(5); //（2） 也可以调用函数指针指向的pam函数，但是没有第一种易懂 代码示例： fun_ptr.cpp 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;double betsy(int);double pam(int);void estimate(int lines, double (*pf)(int));using namespace std;double betsy(int lns) &#123; return 0.05 * lns;&#125;double pam(int lns) &#123; return 0.03 * lns + 0.0004 * lns * lns;&#125;void estimate(int lines, double (*pf)(int)) &#123; //函数指针 cout &lt;&lt; lines &lt;&lt; \" lines will take\"; cout &lt;&lt; (*pf)(lines) &lt;&lt; \" hours\\n\";&#125;int main() &#123; int code; cout &lt;&lt; \"How many lines of code do you need?\"&lt;&lt;endl; cin &gt;&gt; code; cout &lt;&lt; \"Here is Betsy's estimate:\\n\"; estimate(code, betsy); //入参函数名 cout &lt;&lt; \"Here is Pam's estimage:\\n\"; estimate(code, pam); return 0;&#125; 执行结果： 123456How many lines of code do you need?6Here is Betsy's estimate:6 lines will take0.3 hoursHere is Pam's estimage:6 lines will take0.1944 hours 案例12345678910const double * f0(const double ar[], int);const double * f1(const double [], int);const double * f2(const double * , int); //这三种表达方式相同//声明一个指针指向这三个函数之一，假设指针名是pa，则只需将目标函数原型中的函数名代替为(*pa)const double * (*pa)(const double *, int);//可以在声明的同时初始化const double * (*pa)(const double *, int) = f1;//简洁的使用autoauto p2 = f2; //也是函数指针 示例代码： arfupt.cpp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const double * f1 (const double ar[], int n);const double * f2 (const double [], int);const double * f3 (const double *, int);const double * f1(const double * ar, int n) &#123; return ar;&#125;const double * f2(const double ar[], int n) &#123; return ar+1;&#125;const double * f3(const double ar[], int n) &#123; return ar+2;&#125;int main() &#123; double av[3] = &#123;1.2, 2.3, 3.4&#125;; const double *(*p1)(const double *, int ) = f1; auto p2 = f2; cout &lt;&lt; \"Using pointers to functions:\\n\"; cout &lt;&lt; \"Address Vaule\\n\"; cout &lt;&lt; (*p1)(av, 3) &lt;&lt; \" : \" &lt;&lt; *(*p1)(av, 3) &lt;&lt;endl; cout &lt;&lt; p2(av, 3) &lt;&lt; \" : \" &lt;&lt; *p2(av, 3) &lt;&lt;endl; const double *(*pa[3])(const double *, int) = &#123;f1, f2, f3&#125;; auto pb = pa; cout &lt;&lt; \"\\nUsing pointers to functions:\\n\"; cout &lt;&lt; \"Address Value\\n\"; for (int i = 0; i&lt;3; i++) cout &lt;&lt; pa[i](av, 3) &lt;&lt; \" : \" &lt;&lt; *pa[i](av,3) &lt;&lt;endl; cout &lt;&lt; \"\\nUsing pointers to functions:\\n\"; cout &lt;&lt; \"Address Value\\n\"; for (int i = 0; i&lt;3; i++) cout &lt;&lt; pb[i](av, 3) &lt;&lt; \" : \" &lt;&lt; *pb[i](av,3) &lt;&lt;endl; auto pc = &amp;pa; cout &lt;&lt; (*pc)[0](av,3) &lt;&lt; \" : \" &lt;&lt; *(*pc)[0](av,3) &lt;&lt;endl; return 0;&#125; 执行结果： 1234567891011121314151617Using pointers to functions:Address Vaule0x7ffef6915240 : 1.20x7ffef6915248 : 2.3Using pointers to functions:Address Value0x7ffef6915240 : 1.20x7ffef6915248 : 2.30x7ffef6915250 : 3.4Using pointers to functions:Address Value0x7ffef6915240 : 1.20x7ffef6915248 : 2.30x7ffef6915250 : 3.40x7ffef6915240 : 1.2 typedef关键字简化除了auto，C++11提供了typedef穿件类型别名，typedef double real; 12345typedef const double *(*p_fun)(const douvle *, int); //p_fun现在是一个类型名称（别名）p_fun p1 = f1; //p1指向f1()函数p_fun pa[3] = &#123;f1, f2 ,f3&#125;; //pa是一个指向三个函数的函数指针p_fun (*pd)[3] = &amp;pa; //pd指向一个包含三个函数指针的数组 小结 函数必须提供定义和原型，并且调用该函数 函数原型描述了函数的接口：入参的数目和类型、返回类型 默认情况，C++函数按值传递参数，意味着函数定义中的形参是新的变量，被初始化为函数调用所提供的值。因此通过使用拷贝保护了原始数据的完整性 C++将数组名参数视为数组第一个元素的地址，typename arr[]和typename * arr是等价的 C++提供三种表示C风格字符串的方法：字符数组、字符串常量、字符串指针，类型都是char* C++提供string类，用于表示字符串，使用size()用于判断存储的字符串的长度 处理结构的方式和基本类型完全相同，可以按值传递结构，并将其用作函数返回类型。如果结构非常大，则传递结构指针，同时函数能够使用原始数据 支持递归 函数名和函数地址的作用相同。通过函数指针作为参数，可以传递要调用的函数的名称","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"ubuntu搭建opengl环境","slug":"2019/190820_opengl_setup","date":"2019-08-20T14:23:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/20/2019/190820_opengl_setup/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/20/2019/190820_opengl_setup/","excerpt":"安装1234sudo apt-get install build-essentialsudo apt-get install libgl1-mesa-devsudo apt-get install libglu1-mesa-devsudo apt-get install freeglut3-dev","text":"安装1234sudo apt-get install build-essentialsudo apt-get install libgl1-mesa-devsudo apt-get install libglu1-mesa-devsudo apt-get install freeglut3-dev 安装完成后，库文件： 123456789wizzie@wizzie:&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu|⇒ ls -tl lib[gG][lL]*.solrwxrwxrwx 1 root root 22 5月 10 20:17 libGLdispatch.so -&gt; libGLdispatch.so.0.0.0lrwxrwxrwx 1 root root 15 5月 10 20:17 libGLX.so -&gt; libGLX.so.0.0.0lrwxrwxrwx 1 root root 17 2月 14 2019 libGLESv1_CM.so -&gt; libGLESv1_CM.so.1lrwxrwxrwx 1 root root 14 2月 14 2019 libGLESv2.so -&gt; libGLESv2.so.2lrwxrwxrwx 1 root root 10 2月 14 2019 libGL.so -&gt; libGL.so.1lrwxrwxrwx 1 root root 16 8月 24 2016 libglut.so -&gt; libglut.so.3.9.0lrwxrwxrwx 1 root root 15 5月 22 2016 libGLU.so -&gt; libGLU.so.1.3.1 测试测试C代码test.c12345678910111213141516171819202122232425262728293031323334353637#include &lt;GL/glut.h&gt;void init(void)&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glMatrixMode(GL_PROJECTION); glOrtho(-5, 5, -5, 5, 5, 15); glMatrixMode(GL_MODELVIEW); gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0); return;&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0, 0, 0); glutWireTeapot(3); glFlush(); return;&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(0, 0); glutInitWindowSize(300, 300); glutCreateWindow(\"OpenGL 3D View\"); init(); glutDisplayFunc(display); glutMainLoop(); return 0;&#125; 编译12$ gcc -o test test.c -lGL -lGLU -lglut$ .&#x2F;test 编译结束后执行，会出现一个红色的小茶壶，表示配置完成。 测试C++代码test1.cpp 123456789101112131415161718192021// File Name: example.cpp #include &lt;GL/glut.h&gt; void draw()&#123; glClearColor(1, 0, 0, 1); glClear(GL_COLOR_BUFFER_BIT); glFlush();&#125; int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); glutInitWindowPosition(100, 100); glutInitWindowSize(300, 300); glutCreateWindow(\"My First OpenGL Program\"); glutDisplayFunc(draw); glutMainLoop(); return 0;&#125; 编译12gcc -o test1 test1.cpp -lGL -lGLU -lglut.&#x2F;test1 编译结束后执行，会出现一个红色的窗口，表示配置完成。","categories":[{"name":"opengl","slug":"opengl","permalink":"https://alonealive.github.io/Blog/categories/opengl/"}],"tags":[{"name":"opengl","slug":"opengl","permalink":"https://alonealive.github.io/Blog/tags/opengl/"}]},{"title":"C++分支语句、逻辑表达式、字符函数库、switch、文本I/O","slug":"2019/190815_cpp_ifelse","date":"2019-08-15T14:23:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/15/2019/190815_cpp_ifelse/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/15/2019/190815_cpp_ifelse/","excerpt":"if语句 两种格式： if和if else","text":"if语句 两种格式： if和if else if.cpp 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; char ch; int spaces = 0; int total = 0; cin.get(ch); while (ch != '.') &#123; if (ch == ' ') ++spaces; ++total; cin.get(ch); &#125; cout &lt;&lt; spaces &lt;&lt; \" spaces, total is \" &lt;&lt; total &lt;&lt;endl; return 0;&#125; 执行结果： 123456789101112abc //space //space.2 spaces, total is 10 //总数为10是因为包含换行符或者如下结果：dwdadw .3 spaces, total is 9 嵌套ifelse123456789if (ch == 'A') a++;else if (ch =='B') b++; else if (ch == 'C') c++; else x++; 逻辑表达式 三种：逻辑or||， 逻辑and&amp;&amp;，逻辑NOT! 例如： 12345675 &gt; 3 || 5 &gt; 10 //如果左侧为true，就不会判断右侧等同于(2 &lt; 3) || (5 &gt; 10) //说明逻辑运算符优先级低于关系运算符5 &gt; 8 &amp;&amp; 5 &lt; 10 //优先判断左侧，如果左侧为false，就不会判断右侧!(x &gt; 5) //取反 使用保留字表达 逻辑运算符 另一种表达方式 &amp;&amp; and 或 or ! not 字符函数库cctype 使用isalpha()来检查字符是否为字母字符使用isdigit()来测试字符是否是数字字符使用isspace()来测试字符是否是空白（如换行符、空格、制表符）使用ispunct()来测试字符是否是标点符号 函数名 入参 返回值 isalnum() 字母或数字 true isalpha() 字母 true iscntrl() 控制字符 true isdigit() 数字（0～9） true isgraph() 除空格外的打印字符 true islower() 小写字符 true isprint() 打印字符，包含空格 true ispunct() 标点符号 true isspace() 标准空白字符，如空格、换行、回车、水平制表符、垂直制表符 true isupper() 大写字母 true isxdigit() 十六进制数字，即0～9、a~f、A～F 返回true tolower() 大写字符 返回其小写，否则返回参数 toupper() 小写字符 返回大写，否则返回参数 三目条件运算符（?:）5 &gt; 3 ? 10 : 12，如果true，则返回10，false返回12 switch switch中的每个case标签必须是一个单独的值。这个值必须是整数（含char）。因此switch无法处理浮点测试。另外case标签必须是常量。break和continue都呢该构跳过代码。不同之处前者跳出整个循环，后者跳出本次循环。 switchtest.cpp 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int main() &#123; char choice; cin &gt;&gt; choice; while (choice != 'Q' &amp;&amp; choice != 'q') &#123; switch(choice) &#123; case 'a': case 'A': cout &lt;&lt; \"result is a/A\\n\"; break; case 'b': case 'B': cout &lt;&lt; \"result is b/B\\n\"; break; case 'd': case 'D': cout &lt;&lt; \"result is d/D\\n\"; break; case 'c': case 'C': cout &lt;&lt; \"result is c/C\\n\"; break; default: cout &lt;&lt; \"Not abcd\" &lt;&lt;endl; break; &#125; cin &gt;&gt; choice; &#125; return 0;&#125; 执行结果： 1234567891011aresult is a/ABresult is b/Bcresult is c/CD result is d/DFNot abcdq 文件输入输出I/O写入1234567char ch;std::cin &gt;&gt; ch;std::cout &lt;&lt; \"Result is \" &lt;&lt; ch &lt;&lt;std::endl;char word[50];cin &gt;&gt; word; //不断读取，直到遇到空白字符cin.getline(word, 50); //不断读取，直到遇到换行符 写入到文本文件outfile.cpp1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; char automobile[50]; int year; double a_price; double b_price; ofstream outFile; outFile.open(\"carinfo.txt\"); cout &lt;&lt; \"Enter the make and model of automobile: \\n\"; cin.getline(automobile, 50); cout &lt;&lt; \"Enter the model year: \\n\"; cin &gt;&gt; year; cout &lt;&lt; \"Enter the original asking price: \\n\"; cin &gt;&gt; a_price; b_price = 0.913 * a_price; outFile &lt;&lt; fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile &lt;&lt; \"Make and model: \" &lt;&lt; automobile &lt;&lt;endl; outFile &lt;&lt; \"Year : \" &lt;&lt; year &lt;&lt;endl; outFile &lt;&lt; \"Was asking $\" &lt;&lt; a_price &lt;&lt;endl; outFile &lt;&lt; \"Now asking $\" &lt;&lt; b_price &lt;&lt;endl; outFile.close(); return 0;&#125; 执行结束后生成的文件： carinfo.txt 1234Make and model: Flitz PerkyYear : 2009Was asking $13500.00Now asking $12325.50 读取文本读取文件： readfile_test.txt 12312 31.2 32123 23.21 3123 31 代码： readfile.cpp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;const int SIZE = 60;int main() &#123; using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; \"Enter file name: \\n\"; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; \"Could not open file \" &lt;&lt; filename &lt;&lt;endl; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; //读取的数量 inFile &gt;&gt; value; //获取第一个alue while (inFile.good()) &#123; ++count; //读取数量+1 sum += value; //极端总和 inFile &gt;&gt; value; //获取下一个value &#125; if (inFile.eof()) cout &lt;&lt; \"End of file reached.\\n\"; else if (inFile.fail()) cout &lt;&lt; \"Input terminated by data mismatch.\\n\"; else cout &lt;&lt; \"Input terminated for unknown reason.\\n\"; if (count == 0) cout &lt;&lt; \"No data processed.\\n\"; else &#123; cout &lt;&lt; \"Item read : \" &lt;&lt; count &lt;&lt;endl; cout &lt;&lt; \"Sum : \" &lt;&lt; sum &lt;&lt;endl; &#125; inFile.close(); return 0;&#125; 执行结果： 12345Enter file name: readfile_test.txtEnd of file reached.Item read : 8Sum : 495.41","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++循环语句for, while, do-while","slug":"2019/190814_cpp_for","date":"2019-08-14T14:23:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/14/2019/190814_cpp_for/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/14/2019/190814_cpp_for/","excerpt":"for循环12for (int i = 5; i &lt; 0; i--) cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt;endl;","text":"for循环12for (int i = 5; i &lt; 0; i--) cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt;endl; 阶乘运算： formore.cpp 12345678910111213141516#include&lt;iostream&gt;using namespace std;const int SIZE = 16;int main() &#123; long long factorials[SIZE]; factorials[1] = factorials[0] = 1LL; for (int i = 2; i &lt; SIZE; i++) factorials[i] = i * factorials[i-1]; for (int i = 0; i &lt; SIZE; i++) cout &lt;&lt; i &lt;&lt; \"! = \" &lt;&lt; factorials[i] &lt;&lt;endl; return 0;&#125; 执行结果： 123456789101112131415160! &#x3D; 11! &#x3D; 12! &#x3D; 23! &#x3D; 64! &#x3D; 245! &#x3D; 1206! &#x3D; 7207! &#x3D; 50408! &#x3D; 403209! &#x3D; 36288010! &#x3D; 362880011! &#x3D; 3991680012! &#x3D; 47900160013! &#x3D; 622702080014! &#x3D; 8717829120015! &#x3D; 1307674368000 while循环while循环是没有初始化和更新部分的for循环，只有测试条件和循环体。循环的指导原则： 指定循环终止的条件 在首次测试之前初始化条件 在条件被再次测试之前更新条件 示例代码： while.cpp 123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int SIZE = 20;int main() &#123; char name[SIZE]; cout &lt;&lt; \"Enter your name: \"; cin &gt;&gt; name; int i = 0; while(name[i] != '\\0') &#123; cout &lt;&lt; name[i] &lt;&lt; \" : \" &lt;&lt; int(name[i]) &lt;&lt;endl; i++; &#125; return 0;&#125; 执行结果： 1234567Enter your name: wizziew : 119i : 105z : 122z : 122i : 105e : 101 类型别名 使用预处理器#define BYTE char 使用关键字typedef，例如typedef char * byte_pointer; do while循环不同于前两种循环，他是出口条件循环。首先执行循环体，然后判断测试表达式。 基于范围的for循环（C++11新增）对数组或者容器类（例如vector， array）的每个元素执行相同的操作。For example: 123double prices[3] = &#123;2.33, 4122.2, 321.33&#125;;for (double x : prices) std::cout &lt;&lt; x &lt;&lt;std::endl; 嵌套循环12345for (int row = 0; row &lt; 4; row++) &#123; for (int col = 0; col &lt; 5; ++col) cout &lt;&lt; maxtemps[row][col] &lt;&lt; \"\\t\"; cout &lt;&lt; endl;&#125; 二维数组123456int btus[3][2] =&#123; &#123;23, 31&#125;, &#123;23, 532&#125;, &#123;31243, 4231&#125;&#125;;","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++内存分配方式和模板类vector, array","slug":"2019/190813_cpp_typeTemplete","date":"2019-08-13T15:31:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/13/2019/190813_cpp_typeTemplete/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/13/2019/190813_cpp_typeTemplete/","excerpt":"使用new创建动态结构 在运行时创建数组优于编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，可以使用new完成。动态意味着内存是在运行时，而不是编译时分配的。例如inflatable *ps = new inflatable;其中inflatable是一个结构类型。这句代码将把存储结构inflatable的一块可用内存的地址赋值给ps。箭头成员运算符-&gt;，可用于指向结构的指针。例如ps指向一个inflatable结构的成员price，即ps-&gt;price","text":"使用new创建动态结构 在运行时创建数组优于编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，可以使用new完成。动态意味着内存是在运行时，而不是编译时分配的。例如inflatable *ps = new inflatable;其中inflatable是一个结构类型。这句代码将把存储结构inflatable的一块可用内存的地址赋值给ps。箭头成员运算符-&gt;，可用于指向结构的指针。例如ps指向一个inflatable结构的成员price，即ps-&gt;price Note： 如果结构标识符是结构名，则使用句点运算符 如果标识符是指向结构的指针，则使用箭头运算符 示例代码： newstruct.cpp 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;struct inflatable &#123; char name[20]; float volume; double price;&#125;;int main() &#123; inflatable *ps = new inflatable; cout &lt;&lt; \"Enter name: \"; cin.get(ps-&gt;name, 20); cout &lt;&lt; \"Enter volume:\"; cin &gt;&gt; (*ps).volume; cout &lt;&lt; \"Enter price: $\"; cin &gt;&gt; ps-&gt;price; cout &lt;&lt; \"Result: Name=\" &lt;&lt; (*ps).name &lt;&lt;endl; cout &lt;&lt; \"Volume=\" &lt;&lt; ps-&gt;volume &lt;&lt;endl; cout &lt;&lt; \"Price=\" &lt;&lt; ps-&gt;price &lt;&lt;endl; delete ps; //删除new创建的对象 return 0;&#125; 执行结果： 123456Enter name: PeterEnter volume:27.99Enter price: $23.54Result: Name&#x3D;PeterVolume&#x3D;27.99Price&#x3D;23.54 示例代码： delete.cpp 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char * getname(void); //一般可以放在头文件int main()&#123; char * name; name = getname(); cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int*)name &lt;&lt;endl; delete []name; name = getname(); cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int*)name &lt;&lt;endl; delete []name; return 0;&#125;char * getname() &#123; char temp[80]; //暂时内存 cout &lt;&lt; \"Enter name: \"; cin &gt;&gt; temp; char * pn = new char[strlen(temp)+1]; //+1包含空字符 strcpy(pn, temp); return pn; //返回指针&#125; 执行结果： 1234Enter name: peterpeter at 0x21ee440Enter name: nancynancy at 0x21ee440 管理数据内存的四种方式 根据用于分配内存的方法，C++有三种管理数据内存的方式：自动存储、静态存储、动态存储（有时候也叫做自由存储空间或堆）C++11增加了第四种类型：线程存储 自动存储(stack)在函数内部定义的常规变量使用自动存储空间，被称为自动变量。这意味着他们所属的函数被调用时自动产生，函数结束时消亡。实际上，自动变量是一个局部变量，其作用域是包含他的代码块。（代码块是被包含在花括号中的一段代码）自动变量通常存储在栈中，这意味着执行代码时，其中的变量将依次加入到栈中，而在离开代码块时，按照相反的顺序释放这些变量（先进后出LIFO）。因此，在程序执行过程中，栈将不断地的增大和缩小。 静态存储静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种： 在函数外面定义它 在声明变量时使用关键字static (例如static double fee = 56.30;) 自动存储和静态存储的关键在于： 这些方法严格的限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也有可能只在特定函数被执行时存在（自动变量） 动态存储(heap or free store)new和delete提供了一种比前两者更加灵活的方法。他们管理了一个内存池，这个在C++中被称为自由存储空间free store或者堆heap该内存池同用于静态变量和自动变量的内存是分开的。new和delete能够让你在一个函数中分配内存，而在另一个函数中释放它。 有关栈、堆和内存泄漏 如果使用new在堆（或者自由存储空间）上创建变量后，没有调用delete。将会发生什么情况呢？ 如果没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因被释放，在堆上动态分配的变量或者结构还是会继续存在。实际上，将会无法方位堆中的结构，因为指向这些内存的指针无效。这将会导致内存泄漏memory leak。被泄漏的内存在程序的整个生命周期都不能使用，这些内存被分配出去，但是无法收回。 极端情况下，内存泄漏可能会非常严重，以致于应用程序的可用内存被耗尽，导致程序崩溃crash。因此为比描内存泄漏，同时使用new和delete运算符 类型组合123456789101112131415161718192021222324struct yearinfo&#123; int year;&#125;;yearinfo s1, s2, s3; //都是结构s0.year = 1996; //使用句点运算符访问成员yearinfo *pa = &amp;s0; //创建指向这个结构变量的指针（地址运算符）pa-&gt;year = 1999; //使用指针的箭头运算符访问成员yearinfo info[3]; //创建结构数组info[0].year = 2019; (info+1)-&gt;year = 2004; //地址加一（一个类型的字节数） ， 同info[1].yearconst yearinfo * arp[3] = &#123;&amp;s0, &amp;s1, &amp;s2&#125;;arp[1]-&gt;year //访问成员const yearinfo ** ppa = arp; //建立上述指针的指针auto ppb = arp; //C++11版本的auto能够正确的推断ppb的类型(*ppa)-&gt;year(*(ppb+1))-&gt;year 数组的替代品vector模板类vector类似于string类，也是一种动态数组。基本使用： 必须包含头文件vector 包含在命名空间std中 模板使用不同的语法来指出它存储的数据类型 使用不同的语法来指定元素数 示例代码： 1234567#include&lt;vector&gt;...using namespace std;vector&lt;int&gt; vi;int n;cin &gt;&gt; n;vector&lt;double&gt; vd(n); //创建数组包含n个double元素 缺点：效率相比数组稍低；而数组长度固定，不方便和安全。 C++11新增模板类array位于命名空间std中，并且长度固定，也是使用栈（静态内存分配），因此效率和数组相同。创建需要包含头文件array。 12345#include&lt;array&gt;...using namespace std;array&lt;int, 5&gt; ai; //创建长度是5，类型是int的array模板array&lt;double, 4&gt; ad = &#123;1.2, 32.2, 31.2, 3.2&#125;; 复杂类型的小结结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符(.)访问成员。 共同体可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。 指针是被设计用来存储地址的变量。指针声明指出了指针指向的对象的类型。指针指向了它存储的地址。对指针应用接触引用运算符，将得到指针指向的位置中的值。 字符串以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在char数组中，可以用被初始化为指向字符串的char指针表示字符串。 函数strlen()返回字符串长度，但是不包含空字符。 函数strcpy()将字符串从一个位置复制到另一个位置。需要加入头文件cstring或者string.h new运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋值给一个指针，程序将只能使用该指针来访问这块内存。 如果是简单变量，使用解除引用运算符*来获取值； 如果数据对象是数组，则可以使用数组名那样使用指针来访问元素； 如果数据对象是结构，使用-&gt;访问成员 指针和数组紧密相关，如果ar是数组名，则表达式ar[i]被解释为*(ar+i)，其中数组名被解释为数组第一个元素的地址。这样，数组名的作用同指针。反之，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++复合类型之枚举、指针","slug":"2019/190812_cpp_complex2","date":"2019-08-12T14:21:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/12/2019/190812_cpp_complex2/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/12/2019/190812_cpp_complex2/","excerpt":"枚举enum C++的enum工具提供了另一种创建符号常量的方式，可以代替const。它还允许定义新的类型，但是必须严格按照格式。使用enum语法格式和结构相似，例如","text":"枚举enum C++的enum工具提供了另一种创建符号常量的方式，可以代替const。它还允许定义新的类型，但是必须严格按照格式。使用enum语法格式和结构相似，例如 enum colorInfo{red, blue, orange}; colorInfo是新类型的名称；colorInfo被成为枚举 red,blue,orange是符号常量，对应整型树脂0,1,2，这些常量叫做枚举量 默认情况下，将整型数值赋给枚举量，从0开始以此类推 声明 使用枚举名来声明这种枚举的变量：colorInfo band; 赋值 只能使用定义枚举量赋值给枚举的变量： 1234567891011+ band = red; //将定义枚举中的red值赋给band变量- band = black; //在枚举中不存在double *pn;char *pa;double *pc;double bu = 4.2;pn = &amp;bu;pa = new char;pc = new double[10]; 设置枚举的值 使用赋值运算符显式设置枚举的值： enum bits {one=1, two=2}; 显式定义部分元素（其他的元素以前一个元素作为参照依次+1） enum bytes {a, b=100, c} //此时a=0,b=100,c=101 创建多个值相同的枚举量 enum {zero, null=0, one, numero_uno=1}; //其中zero和null都是0，后面两个都是1，这是合法的 枚举的取值范围 枚举的最大值的最小的2的次幂，将其减去1，得到取值范围的上限。 例如最大值是101，则最小的2的次幂是128，减去1，所以取值的上限是127 如果枚举量的最小值&gt;=0，则取值范围的下限是0；否则同上，取2的最小次幂，减一，加上负号。 例如最小值是-6，则取最小2次幂减一是7，加上负号，所以取值下限是-7 指针 计算机在存储数据的时候必须跟踪的三种基本属性： 信息存储的位置 存储的值 存储的类型 指针是一个变量，其存储的值是值的地址 地址运算符&amp;地址运算符&amp;可以获取一个常规变量的地址，例如home是变量，&amp;home即是他的地址 address1.cpp 1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; int dog = 6; double food = 4.5; cout &lt;&lt; \"dog = \" &lt;&lt; dog &lt;&lt; \", food = \" &lt;&lt; food &lt;&lt;endl; cout &lt;&lt; \"dog address = \" &lt;&lt; &amp;dog &lt;&lt; \", food address = \" &lt;&lt; &amp;food &lt;&lt;endl; return 0;&#125; 打印结果： 12dog = 6, food = 4.5dog address = 0x7fff81decc1c, food address = 0x7fff81decc20 Notes: 常用十六进制描述地址（也存在十进制表示法）。 使用常规变量时，值是指定的量，而地址是派生量 面向对象OOP和面向过程的编程区别在于，OOP强调的是在运行阶段（非编译阶段）进行决策。运行阶段指的是程序正在运行，编译阶段指的是编译器将程序组合起来时。 运行阶段决策提供了灵活性，可以根据实时情况进行调整。例如声明数组的时候定义长度。 指针用于存储值的地址。指针名表示的是地址，*运算符被称为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。 例如：假设manly是一个指针，则manly表示的是一个地址，而*manly表示存储在该处的值。*manly和常规int变量等效。 例如下列代码： pointer.cpp123456789101112131415#include&lt;iostream&gt;using namespace std;int main() &#123; int updates = 6; //变量 int * p_updates; //指针 p_updates = &amp;updates; //指针存储了变量的地址 cout &lt;&lt; \"value updates = \" &lt;&lt; updates &lt;&lt; \", p_updates = \" &lt;&lt; p_updates &lt;&lt; \", &amp;updates = \" &lt;&lt; &amp;updates &lt;&lt;endl; *p_updates = *p_updates + 1; cout &lt;&lt; \"Now updates = \"&lt;&lt; updates &lt;&lt; \", *p_updates = \"&lt;&lt; *p_updates &lt;&lt; \", p_updates = \" &lt;&lt; p_updates &lt;&lt;endl; return 0;&#125; 执行结果： 12value updates = 6, p_updates = 0x7ffcf520fbcc, &amp;updates = 0x7ffcf520fbccNow updates = 7, *p_updates = 7, p_updates = 0x7ffcf520fbcc 声明和初始化 指针声明必须指定指针指向的数据的类型 int * p_updates;*p_updates的类型是int，由于*被用于指针，因此p_updates变量本身必须是指针，即p_updates指向int类型，或者是指向int的指针，或int*p_updates是指针（地址）；*p_updates是int，而不是指针。 Notes: (1) *两边的空格是可选的。int *ptr; 强调*ptr是int类型的变量。int* ptr; 强调int*是一种指向int的指针。（在C++中，int*是复合类型，是指向int的指针） (2) 在C++中创建指针时，计算机将分配内存用来存储地址的内存，但是不会分配用来存储指针所指向的数据的内存。例如： long *fellow;*fellow = 2333; //ERROR此处没有给2333赋地址。 指针和数字 整数可以加减乘除，而指针表示地址，描述的是位置，将两个地址相乘没有意义。 1234567//ERROR 不可以直接赋值，编译器会有错误消息：通用类型不匹配int* ptr;ptr = 0xB8000000;//Right 转换int* ptr;ptr = (int*) 0xB8000000; 使用new分配内存 在C++中，除了可以使用C语言的方法malloc()函数分配内存，还可以使用new运算符例如：(1) int *ptr = new int;new int告诉程序需要合适存储int的内存。new运算符根据类型确定需要多少字节的内存，然后找到这样的内存并返回地址。接着将地址赋给ptr，ptr是被声明为指向int的指针。 (2) int hig;int *pn = &amp;hig;这种方法是使用hig名称来访问int 为一个数据对象（可以是结构，或者基本类型等）获得并指定分配内存的通用格式：typename * poniter_name = new typename; 代码示例： use_new.cpp 1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int nights = 1001; int *pt = new int; //分配内存 *pt = 1001; //赋值 cout &lt;&lt; \"nights = \" &lt;&lt; nights &lt;&lt; \", its' address = \" &lt;&lt; &amp;nights &lt;&lt;endl; cout &lt;&lt; \"*pt = \" &lt;&lt; *pt &lt;&lt; \", its' address = \" &lt;&lt; pt &lt;&lt;endl; double *pd = new double; *pd = 10000001.0; cout &lt;&lt; \"*pd = \" &lt;&lt; *pd &lt;&lt; \", address of pointer *pd = \" &lt;&lt; &amp;pd &lt;&lt;endl; cout &lt;&lt; \"size of pt = \" &lt;&lt; sizeof(pt); cout &lt;&lt; \" : size of *pt = \" &lt;&lt; sizeof(*pt) &lt;&lt;endl; cout &lt;&lt; \"size of pd = \" &lt;&lt; sizeof(pd); cout &lt;&lt; \" : size of *pd = \" &lt;&lt; sizeof(*pd) &lt;&lt;endl; return 0;&#125; 执行结果： 12345nights = 1001, its' address = 0x7fff3426f484*pt = 1001, its' address = 0x150bc20*pd = 1e+07, address of pointer *pd = 0x7fff3426f488size of pt = 8 : size of *pt = 4size of pd = 8 : size of *pd = 8 Note: 变量nights和pd的值都存储在栈stack的内存区域；而new从堆heap或者自由存储区free store的内存区域分配内存。 使用delete释放内存 使用delete时，后面要加上指向内存块的指针（这些内存块最初是由new分配的） 123int *ps = new int;...delete ps; 这将会释放ps指向的内存，但是不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。 一定要配对的使用new和delete，否则会发生内存泄漏 memory leak。 只能用delete来释放使用new分配的内存（对空指针使用delete是安全的） 使用delete的关键是，将他用于new分配的内存，这并不意味者要使用用于new的指针，而是用于new的地址。 例如： 1234567891011int *ps = new int;delete ps; //okdelete ps; //not okint jugs = 6;int *pi = &amp;jugs; //okdelete pi; //not allowedint *pk = new int; //分配内存int *pq = pk; //声明第二个指针delete pq; //delete第二个指针，并不会影响pk的值（但是pk的值必须要new分配内存） 使用new创建动态数组例如下面的语句创建指针，它指向包含十个int值的内存块中的第一个元素：int *psome = new int[10]; 不能修改数组名的值，但是可以修改指针变量。 将指针变量加一后，增加的量等于它指向类型的字节数（例如int数组一个变量四个字节） 代码： arraytnew.cpp 123456789101112131415161718192021#include&lt;iostream&gt;int main() &#123; using namespace std; double *p3 = new double[3]; p3[0] = 0.2; p3[1] = 0.5; p3[2] = 0.8; cout &lt;&lt; \"p3[1] = \"&lt;&lt; p3[1] &lt;&lt;endl; p3+=1; cout &lt;&lt; \"Now p3[0] = \"&lt;&lt; p3[0] &lt;&lt;endl; cout &lt;&lt; \"Now p3[1] = \"&lt;&lt; p3[1] &lt;&lt;endl; p3-=1; delete []p3; //free memory return 0;&#125; 结果： 123p3[1] = 0.5Now p3[0] = 0.5Now p3[1] = 0.8 //+1之后的数组第一个元素就变成了第二个元素 指针小结 对数组使用sizeof得到的是数组的长度（int4个字节乘以元素数量，单位是字节），而对指针使用sizeof得到的是指针的长度，即指针指向的是一个数组（元素数量）。 1234567int *pt = new int[10];*pt = 5; //pt[0]=5 or pt=5pt[0] = 6; //resetpt[9] = 44;int coats[10];*(coats + 4) = 12; //coats[4] = 12 数组名被解释为其第一个元素的地址arrayname，而对数组名应用地址运算符&amp;时，即&amp;arrayname，得到的是整个数组的地址。例如： 123short tell[10];tell //display &amp;tell[0]，一个2字节内存块的地址&amp;tell //display address of whole array，一个20字节内存块的地址 对指针接触引用意味着获取指针指向的值，例如*pn，另一种接触引用的方法是使用数组表示法，例如pn[0]。 区别指针和指针指向的值，int *pt = new int; *pt = 5;其中pt是指向int的指针，而*pt是完全等同于一个int类型的变量。 数组的静态联编是使用数组声明来创建数组时，数组的长度在编译时设置int tacos[10]; 数组的动态联编是使用new[]创建数组，在运行时为数组分配空间，其长度在运行时者之。使用完这种数组后，应该使用delete[]释放占用的内存。 ptrstr.cpp 1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; char animal[20] = \"bear\"; const char *bird = \"wren\"; char *ps; cout &lt;&lt; animal &lt;&lt; \" and \" &lt;&lt; bird &lt;&lt;endl; //cout &lt;&lt; ps &lt;&lt;endl; //may crash, may garbage, may skip, print nothing ps = animal; cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; (int *)animal &lt;&lt; \" and \" &lt;&lt; (int *)ps &lt;&lt;endl; ps = new char(strlen(animal) + 1); //get new storage返回字符串的长度 strcpy(ps, animal); //copy string to new storage将字符串从一个位置复制到另一个位置 cout &lt;&lt; \"After using strcpy, animal \" &lt;&lt; animal &lt;&lt; \" at \"&lt;&lt; (int*)animal &lt;&lt;endl; cout &lt;&lt; ps &lt;&lt; \" at \" &lt;&lt; (int*)ps &lt;&lt;endl; delete []ps; return 0;&#125; 执行结果： 12345bear and wrenbear0x7ffde23d00b0 and 0x7ffde23d00b0After using strcpy, animal bear at 0x7ffde23d00b0bear at 0x1b2b030","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"C++复合类型之数组、字符串、结构、共用体","slug":"2019/190801_cpp_complex","date":"2019-08-01T13:41:05.000Z","updated":"2020-03-08T10:11:22.924Z","comments":true,"path":"2019/08/01/2019/190801_cpp_complex/","link":"","permalink":"https://alonealive.github.io/Blog/2019/08/01/2019/190801_cpp_complex/","excerpt":"题外话： 在我眼里，我实习的第一家公司教会了我两件事，一是让自己忙起来，二是代码规范整洁。有时候有所悟会很晚，但终究不迟。序： C++提供了基于整型和浮点类型创建的复合类型。影响最深远的复合类型是类。然而，C++还支持几种普通的复合类型。例如，数组 可以存储多个同类型的值。结构 可以存储多个不同类型的值。指针 则是一种将数据所处位置告诉计算机的类型。","text":"题外话： 在我眼里，我实习的第一家公司教会了我两件事，一是让自己忙起来，二是代码规范整洁。有时候有所悟会很晚，但终究不迟。序： C++提供了基于整型和浮点类型创建的复合类型。影响最深远的复合类型是类。然而，C++还支持几种普通的复合类型。例如，数组 可以存储多个同类型的值。结构 可以存储多个不同类型的值。指针 则是一种将数据所处位置告诉计算机的类型。 数组array 数组声明应指出以下三点： 存储每个元素中的值的类型 数组名 数组的元素数量 格式： short months[12]; typename arrayname[size]; size 必须是整型常数或const值，也可以是常量表达式。他不能是变量。 C++11新增初始化的功能 初始化数组可以省略等于号=，例如double ear {1.2e2, 1.6e3, 2.3e4,3.5e10}; 可以不在大括号内包含任何东西，意味着所有元素是0 列表初始化禁止缩窄转换 123long plifs[] = &#123;23,12,3.0&#125;; //浮点数转换成长整型是缩窄操作，不能编译通过char slifs[] = &#123;'g',1123456,'\\o'&#125;; //1123456超过char变量的取值范围，不能编译通过char tlifs[] = &#123;'h',112,'o'&#125;; //OK 数组的替代品 – 模板类vector 在C++标准模板库STL提供了vector，以及C++11增加了模板类array。 字符串 C++处理字符串的方式有两种，一种来自C语言，常称为C-风格字符串，另一种基于string类库的方法。 C-风格字符串(字符数组) C-风格字符串以空字符 \\0 结尾，其ASCII码是0。 char dog[3] = {&#39;d&#39;,&#39;o&#39;,&#39;g&#39;}; //not a string char dog[3] = {&#39;d&#39;,&#39;o&#39;,&#39;g&#39;, &#39;\\0&#39;}; //is a string 字符串常量或者称字符串字面值 使用双引号表示字符串常量，而字符是单引号 char bird[11] = &quot;Mr. cheeps&quot;; //the \\0 is hideen,隐式包含结尾的空字符 char fish[] = &quot;buddles&quot;; //left the complier count sizeof()指出整个数组长度，而strlen返回的是存储在数组中字符串的长度，而不是数组本省的长度。strlen()只计算可见的字符，不计算空字符\\0在内。(只针对char数组，并且需要加入头文件 #include&lt;cstring&gt;) 读取一行字符串输入 istream中的类（例如cin）提供了一些面向行的成员函数：getline()和get()这两个函数都读取一行输入，直到到达换行符随后，getline将丢弃换行符，get()将换行符保留在输入序列。 （1）cin.getline(name,20); 将一行数据读入到一个包含20个元素的name数组。如果这行包含的字符不超过19个（\\0） instr2.cpp12345678910111213141516 #include&lt;iostream&gt; int main() &#123;using namespace std;const int size = 20;char name[size];char group[size];cout &lt;&lt; \"Enter your name : \\n\";cin.getline(name, size); //read info inlinecout &lt;&lt; \"Enter group: \\n\";cin.getline(group, size);cout &lt;&lt; \"name is \"&lt;&lt; name &lt;&lt;endl;cout &lt;&lt; \"groupf is \" &lt;&lt; group &lt;&lt;endl;return 0; &#125; 结果： 123456Enter your name : abcEnter group: defname is abcgroupf is def （2）cin.get(name,size)不会换行，而是将换行符读入到下一行开始。可以通过以下两种方式换行： 123456//firstcin.get(name,size);cin.get();cin.get(group,size);//secondcin.get(name.size).get(); (3) 读取空行 当get()或者getline()读取空行后将设置失效位 failbit。这意味接下来的输入将被阻断。恢复输入方法： cin.clear(); (4) 输入字符串比分配的空间（数组size）长，则getline()和get()将把余下的字符留在输入队列中，getline()还会设置失效位，并关闭后续的输入。 string类 string类需要头文件string。并且string位于命名空间std中。 代码示例： strtype1.cpp 123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1; string str2 = \"cat\"; cout &lt;&lt; \"Enter string data:\\n\"; cin &gt;&gt; str1; cout &lt;&lt; \"str1=\" &lt;&lt; str1 &lt;&lt;\", str2 = \"&lt;&lt; str2 &lt;&lt; \", str2[2] = \"&lt;&lt; str2[2] &lt;&lt;endl; return 0;&#125; 结果： 123Enter string data:dogstr1=dog, str2 = cat, str2[2] = t Note: 类设计让程序能够自动处理string的大小。例如str1声明的时候长度为0，读取到输入后长度是3。 C++11新增的字符串初始化： 12345char char1[] = &#123;\"hello boy\"&#125;;char char2[] &#123;\"hello girl\"&#125;;string str1 = &#123;\"good boy\"&#125;;string str2 &#123;\"good girl\"&#125;; 字符串拼接合并 123string str3;str3 = str1 + str2;str1 += str2; cstring头文件的字符数组char[]复制和附加操作 12strcpy(char1, char2); //将char2数组赋值到char1strcat(char1, char2); //将char2数组附加到char1末尾 对比来说，字符串string的拼接和附加操作更加简单。 两种字符串书写方式的I/O和字符串长度代码： strtype2.cpp 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; char ch[10]; string str; cout &lt;&lt; \"length of ch[10] = \" &lt;&lt; strlen(ch) &lt;&lt;endl; cout &lt;&lt; \"length of str = \" &lt;&lt; str.size() &lt;&lt;endl; cout &lt;&lt; \"Enter a line for ch[10]: \\n\"; cin.getline(ch,10); cout &lt;&lt; \"Enter a line for str:\\n\"; getline(cin, str); //这个getline()不是类方法，他将cin作为参数，指出到哪里去查找输入 cout &lt;&lt; \"Now length of ch[10] = \" &lt;&lt; strlen(ch) &lt;&lt;endl; cout &lt;&lt; \"Now length of str = \" &lt;&lt; str.size() &lt;&lt;endl; return 0;&#125; 结果： 12345678length of ch[10] = 0length of str = 0Enter a line for ch[10]:cat dogEnter a line for str:cat dog2Now length of ch[10] = 7Now length of str = 8 wchar_t, char16_t, char32_t的初始化123wchar_t title[] = L\"Paper\"; //Lchar16_t name[] = u\"Nancy\"; //uchar32_t subject[] = U\"math\"; //U C++11新增的原始字符串raw，以R为前缀cout &lt;&lt; R&quot;(&quot;king&quot; \\n and queue)&quot; 结果： &quot;king&quot; \\n and queue 原始字符串使用&quot;(和)&quot;作为限定符，换行符\\n也只打印两个单独的符号。或者使用&quot;+*(和)*+&quot;作为限定符 结构 结构可以存储多种类型的数据。 结构是用户定义的类型而结构声明定义了这种类型的数据属性定义了类型之后，便可以创建这种类型的变量 创建结构包含两步： 定义结构描述（它描述并且标记能够存储在结构中的各种数据的类型） 按照描述创建变量（结构数据变量） 例如以下结构描述 123456struct inflatable //结构的关键字`struct`，标识符`inflatable`是这种数据格式的名称&#123; char name[20]; float volume; double price;&#125;; 创建这种类型的变量： 12inflatable hat; //允许省略关键字`struct`，因为结构声明定义了一种新的数据格式inflatable mainframe; 因为hat是数据结构类型，所以允许使用hat.name来访问成员。 示例代码： strucetype1.cpp 1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;struct inflatable //结构的关键字`struct`，标识符`inflatable`是这种数据格式的名称&#123; char name[20]; float volume; double price;&#125;;int main()&#123; using namespace std; inflatable hat = &#123; \"pen\", 1.88, 29.99 &#125;; inflatable pal = &#123; \"pencil\", 3.13, 32.99 &#125;; cout &lt;&lt; \"List name : \" &lt;&lt; hat.name &lt;&lt; \" ,and \" &lt;&lt; pal.name &lt;&lt;endl; cout &lt;&lt; \"List volume: \" &lt;&lt; hat.volume &lt;&lt; \",and \" &lt;&lt; pal.volume &lt;&lt;endl; cout &lt;&lt; \"Total price : \" &lt;&lt; hat.price + pal.price &lt;&lt;endl; return 0;&#125; 执行结果： 123List name : pen ,and pencilList volume: 1.88,and 3.13Total price : 62.98 结构声明的位置 结构声明的位置很重要，可以将声明放在main函数中，紧跟在开始括号的后面也可以选择将声明放在main函数前面 位于函数外面的声明被成为外部声明，如果类包含两个或更多的函数，外部声明可以被后面的函数使用而内部声明只能当前函数使用 C++11的初始化 同字符串和数组，结构也支持列表初始化，即在初始化的时候=等于号是可选的。 `inflatable duck {&quot;Dada&quot;, 0.12, 9.98};`同时定义结构和和创建变量1234567891011121314151617181920struct perks &#123; int keynum; char car[10];&#125; mr_smith,ms_jones; //定义的两个结构体变量//或者同时进行初始化struct perks &#123; int keynum; char car[10];&#125; mr_smith &#123; 7, \"Peak\"&#125;;//声明一次性没有名称的结构，此时直接使用`position.x`进行访问struct //没有结构体名称&#123; int x, int y&#125; position; 结构数组 可以创建结构数组，例如inflatable gifts[100];，此时访问成员元素使用gifts[0].name此时的gifts不是结构，而是数组‘gifts[0]’是结构 结构中的位字段 C++允许指定占用特定位数的结构成员。这使得创建与某个硬件的寄存器对应的数据结构非常方便。字段的类型应为整型或者枚举，接下来是冒号，冒号后面是数字，它指定了使用的位数每个成员都被称为位字段位字段常用于低级编程中 12345struct torgle &#123; unsigned int SN : 4; //4位给SN变量 unsigned int : 4; //不指定的4位 bool googin : 1; //非法输入&#125; 共用体union union能够存储不同类型的数据，但是只能同时存储其中的一种类型。 例如： 12345union one4all &#123; int val; long val2; double val3;&#125; 可以使用one4all存储不同的类型，存储int，long，或者double 123456one4all pail;pail.val = 10;cout &lt;&lt; pail.val; //10pail.val3 = 1.35;cout &lt;&lt; pail.val3; //1.35 因此，pail有时候是int类型，有时候也可以使long，double成员名称标识了变量的容量共同体每次只能存储一个值，因此必须有足够的空间来存储里面最大的成员，所以共同体的长度为其最大成员变量的长度共同体的用途之一是： 当数据项使用两种或者更多的格式，但是不会同时使用时，可以节省时间。 例如一些商品的ID是整数，而另一些的ID是字符，则可以定义： 123456789struce thing &#123; char name[20]; union id &#123; long id_num; //整型的ID char id_char[20]; //字符型的ID &#125; id_val; //id_val是声明在结构体中，可以使用`结构体.id_val.id_num`初始化&#125;; 匿名共用体 匿名共用体没有名称，其成员将成为位于相同地址的变量。每次只有一个成员是当前的成员。 123456789101112131415161718struce thing &#123; char name[20]; int type; union &#123; //匿名 long id_num; //整型的ID char id_char[20]; //字符型的ID &#125;;&#125;;......thing prize;if (type == 1) &#123; cin &gt;&gt; prize.id_num;&#125; else &#123; cin &gt;&gt; prize.id_char; //此时直接调用匿名共用体的成员&#125; 因为是匿名共用体，所以id_num和id_char被视为结构体thing的成员，他们的地址相同（相对于结构体来理解），因而不需要中间标识符id_val（即共用体的变量声明）。 共用体常用于节省内存（例如操作系统数据结构或硬件数据结构）","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"linux配置zsh终端","slug":"2019/190727-linux-zsh-md","date":"2019-07-27T09:41:06.000Z","updated":"2020-03-08T10:04:18.971Z","comments":true,"path":"2019/07/27/2019/190727-linux-zsh-md/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/27/2019/190727-linux-zsh-md/","excerpt":"从echo $SHELL可以查看当前使用的终端是/bin/bash。zsh是Ubuntu的一种终端工具，虽然听说功能很强很给力，事实上我只是被他的众多主题迷住了。具体查看文档","text":"从echo $SHELL可以查看当前使用的终端是/bin/bash。zsh是Ubuntu的一种终端工具，虽然听说功能很强很给力，事实上我只是被他的众多主题迷住了。具体查看文档 安装zsh 下载zsh sudo apt-get install zsh Note: 生成配置文件/home/wizzie/.zshrc,对应默认的文件.bashrc 下载 oh-my-zsh 项目配置 zsh wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh Note: 生成文件夹wizzie@wizzie:~/.oh-my-zsh,包含所有的zsh主题 切换zsh模式 123456chsh -s /bin/zsh//如果想切换会bash可以使用命令：chsh -s /bin/bash//重启电脑reboot 修改主题 修改.zshrc的ZSH_THEME=&quot;pygmalion&quot; #&quot;robbyrussell&quot; 主题的文件预览样式 主题文件从/home/wizzie/.oh-my-zsh/themes移动到/home/wizzie/.oh-my-zsh/custom/themes 打开一个新的终端窗口，会发现主题修改成功 例如我修改的pygmalion主题：","categories":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/tags/linux/"}]},{"title":"hexo文章中使用iframe插件插入网易云音乐","slug":"2019/190726-next-addmusic","date":"2019-07-26T17:12:19.000Z","updated":"2020-03-08T10:02:35.538Z","comments":true,"path":"2019/07/27/2019/190726-next-addmusic/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/27/2019/190726-next-addmusic/","excerpt":"为了收藏一些喜欢的音乐分享在博客上，使用iframe插件生成网易云音乐的控件。","text":"为了收藏一些喜欢的音乐分享在博客上，使用iframe插件生成网易云音乐的控件。 获取链接 简单的可以直接获取到，点击音乐进入播放界面，然后点击生成外链播放器 例如此处的音乐《约定》的iframe插件代码是： 1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=187911&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt; Note: 其中的id就是和网址的id相同（重点就是这个id） 此时只需要将代码拷贝到md博客文章中，发布博客后就可以查看到音乐。 有些音乐没有获取外链的版权 如下图： 此时只需要注意这首歌的网址里面的id即可，然后替换上面的那个代码里面的id，之后就可以播放了～","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"},{"name":"music","slug":"music","permalink":"https://alonealive.github.io/Blog/tags/music/"}]},{"title":"Ubuntu安装后的环境配置注意点","slug":"2019/190725_linux_linuxEnv","date":"2019-07-26T13:31:37.000Z","updated":"2020-03-08T10:02:27.766Z","comments":true,"path":"2019/07/26/2019/190725_linux_linuxEnv/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/26/2019/190725_linux_linuxEnv/","excerpt":"Ubuntu系统刚安装完成后，工作还只是进行了一小半，还有一大堆的环境需要配置搭建。比如说JDK, nodejs, python, vs code编译器 …","text":"Ubuntu系统刚安装完成后，工作还只是进行了一小半，还有一大堆的环境需要配置搭建。比如说JDK, nodejs, python, vs code编译器 … apt查询包的版本 apt-cache madison &lt;&lt;package name&gt;&gt; git配置 安装： sudo apt-get install git config配置：git config --global user.name &quot;username&quot;git config --global user.email &quot;username@example.com&quot; ssh公钥生成：ssh-keygen 或者 ssh-keygen -t rsa -C ****@**.com 然后会生成.ssh/id_rsa.pub文件 将其拷贝到需要的地方即可（github） vscode下载1234567sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt-get updatesudo apt-get install ubuntu-makeumake ide visual-studio-codereboot //如果安装完成没有vscode，就重启电脑 gnome主题切换类似以下的方法： pop命令安装 1234567sudo add-apt-repository ppa:system76&#x2F;popsudo apt updatesudo apt install pop-theme&#x2F;&#x2F;重启alt+f2输入r或者reboot 在gnome主题网站下载安装 下载后的压缩包解压到用户目录.local/themes或者.local/icons/目录下，之后使用gnome tweaks tool修改即可 npm install一直卡住输入： npm config set registry http://registry.cnpmjs.org 截图工具sudo apt-get install shutter java环境sudo apt install default-jdk sudo apt install default-jre _测试结果： java --version javac","categories":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/tags/linux/"}]},{"title":"C++浮点常量表示、算术运算符、类型转换","slug":"2019/190725_cpp_operator","date":"2019-07-25T14:01:37.000Z","updated":"2020-03-08T10:02:21.770Z","comments":true,"path":"2019/07/25/2019/190725_cpp_operator/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/25/2019/190725_cpp_operator/","excerpt":"浮点常量 默认情况下，8.27和3.4E5这类浮点常量都属于double类型。如果希望常量是float类型，使用f或者F后缀对于long double的类型，使用l和L的后缀 例如： 12341.234f //float2.2L //long double2.34F //float23.231E24 //double (defalut)","text":"浮点常量 默认情况下，8.27和3.4E5这类浮点常量都属于double类型。如果希望常量是float类型，使用f或者F后缀对于long double的类型，使用l和L的后缀 例如： 12341.234f //float2.2L //long double2.34F //float23.231E24 //double (defalut) 算术运算符五种C++基本运算符 operation note example + 加法 3+43=46 - 减法 20-5=15 * 乘以 3*5=15 / 除以 10/3=3（整型相除，小数部分丢弃） % 取余 10%3=1 例如： arith.cpp123456789101112131415#include&lt;iostream&gt;using namespace std;int main() &#123; float a = 50.25f; float b = 11.17f; cout&lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt; \"a+b=\"&lt;&lt; a+b &lt;&lt;endl; cout&lt;&lt; \"a-b=\"&lt;&lt; a-b &lt;&lt;endl; cout&lt;&lt; \"a*b=\"&lt;&lt; a*b &lt;&lt;endl; cout&lt;&lt; \"a/b=\"&lt;&lt; a/b &lt;&lt;endl; return 0;&#125; 结果： Result12345a=50.25,b=11.17a+b=61.42a-b=39.08a*b=561.292a/b=4.49866 除法 如果两个整数相除，结果的小数部分将被丢弃，只保留整数部分 如果其中一个（或者两个）是浮点数，则结果也会保留小数部分，类型是浮点数 类型转换 C++自动执行的类型转换： 将一个算数类型的值赋给另一种算数类型的变量时，C++会对值转换 表达式包含不同的类型时，C++会对值转换 将参数传递给函数时，C++会对值转换 类型转换的潜在问题 转换 潜在问题 将较大的浮点类型转换成较小的浮点类型，例如double转换成float 精度（有效位数降低），值可能超出目标类型的取值范围 将浮点类型转换成整型 小数部分丢失 将较大的整型转换成较小的整型，例如long转换成short 值可能超出目标类型的取值范围，通常只复制右边的字节 将0赋值给bool类型，被转换成true非零的则是false 以{}方式初始化时进行的转换（C++11） C++11将使用{}的初始化称为列表初始化因为这种初始化常用于给复杂的数据类型提供值列表列表初始化不允许缩窄，即可能无法赋值。例如浮点型不允许转换成整型 12345678910const int code = 66; //整型常量int x = 66; //整型变量- char c1 &#123;31366&#125;; //类型缩窄，非法+ char c2 = &#123;66&#125;; //合法+ char c3 &#123;code&#125;; //合法- char c4 = &#123;x&#125;; //非法，x是一个变量，对于编译器而言，这个值可能很大。所以编译器不会跟踪执行以下阶段：从x被初始化，到被用来初始化c4x = 31355;+ char c5 = x; //合法，因为x已经被初始化 表达式中的自动转换 C++在表达式会执行两种自动转换： 类型出现时就自动转换 类型和其他类型同时出现在表达式中，将被转换 整型提升在计算表达式时，C++将 bool,char,unsigned char,signed char,short 转换成int其中true -&gt; 1, false -&gt; 0 123short a =20;short b =30;short c = a+b; //在进行计算的时候，会先将a,b转换成int，然后将结果转换成short Note: 因为int是计算机最自然的类型，计算机使用这种类型时，运算速度可能最快。 如果short比int短，则unsigned short会被转换成int；如果两个长度相同，unsigned short会被转换成unsigned int；这种规则保证unsigned short进行整型提升的时候不会损失数据 C++11校验后，编译器在进行算术运算时，依次如下查阅： 如果有一个操作类型是long double, 则另一个转换成long double否则，有一个是double， 另一个转换成double否则，有一个是float， 另一个转换成float否则，说明操作数都是整型，执行整型提升 在这种情况下，如果两个操作数都是有符号或者无符号的，且级别不同，则转换成级别高的类型 如果一个操作数有符号，另一个没有符号，且无符号操作数的级别比有操作符的高，则将有符号操作数转换成无符号操作数（还是转向级别高的类型） 否则，有符号类型可以表示无符号类型的所有可能取值，则将无符号操作数转换成有符号操作数的类型 否则，将两个操作数都转换成有符号类型的无符号版本 传递参数的时候转换类型 传递参数时的类型转换 通常由C++函数原型控制C++将对char和short类型应用整型提升（int） 强制类型转换 强制转换不会修改原变量本身，而是创建一个新的、指定类型的值 通用格式如下： 123456(typename) value //C的方式typename (value) //C++的方式例如将变量a的int值转换成long类型：(long) along (a) 强制类型转换符 1234static_cast&lt;typename&gt; (value)例如：static_cast&lt;long&gt; (a) C++11的auto声明 auto是C++的关键字使用auto，而不指定变量类型，编译器将把变量的类型设置成和初始值相同 1234567891011121314auto n = 10; //intauto x = 1.5; //doubleauto y = 1.3e12L //long doubleauto a = 0; //int，自动类型判断不会判断double类型auto b = 0.0; //doubledouble c = 0; //double，显示声明不会出现问题//标准模块库(STL)的自动类型判断（复杂类型）std::vector&lt;double&gt; scores;//(1)std::vector&lt;double&gt;::iterator pv = scores.begin();//(2)auto pv = scores.begin(); 小结 C++的基本类型分为两组： 一组存储整数的类型一组存储浮点数的类型 整型由小到大依次是： bool, char, signed char, unsigned char, short, signed char, unsigned char, int, signed int, unsigned int, long, unsinged long, long long, unsigned long long 还有在一种wchar_t类型，取决于实现C++11新增的char16_t和char32_t，分别存储16和32位的字符编码short 至少16位int 至少和short一样长long 至少32位","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Ubuntu18系统安装（无需制作启动盘）","slug":"2019/190724_ubuntu_install","date":"2019-07-25T13:31:37.000Z","updated":"2020-03-08T10:02:13.950Z","comments":true,"path":"2019/07/25/2019/190724_ubuntu_install/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/25/2019/190724_ubuntu_install/","excerpt":"数据备份准备工具 Ubuntu系统（官网选择版本下载ISO文件） U盘（之前有一个U盘是做了window10的启动盘） 安装步骤 移除备份好的机械硬盘 制作一个启动盘(win10系统不需要用软碟通UltraISO作启动盘)","text":"数据备份准备工具 Ubuntu系统（官网选择版本下载ISO文件） U盘（之前有一个U盘是做了window10的启动盘） 安装步骤 移除备份好的机械硬盘 制作一个启动盘(win10系统不需要用软碟通UltraISO作启动盘) 123456789（1）U盘最好是16g，USB3.0（2）清空U盘（格式化）（3）将ISO文件双击然后选中所有的文件将其复制到U盘（win10好像是不需要启动装置软件）（4）U盘保持插到电脑上（5）win10关闭快速启动选项，“电源选项”-》“选择电源按钮的功能”-》点击“更改当前不可用的设置”-》取消“启动快速启动”选项 修改启动项（保持U盘插到电脑上！） 1234567（1） 重启电脑，一直按F2（或者F1），进入BIOS（2） 点击方向箭头移动到Security，再向下移动到Secure Boot点击回车键，选择Disable（3） 点击方向箭头移动到boot,查看USB Boot是否是Enalbed（有的电脑没有USB Boot，在Devices模块的USB Setup选项修改）（4） 按F10保存退出 安装 123456789（1）上一个步骤保存后还是会进入windows，再重启一遍（U盘不要拔出来，如果光驱位有机械硬盘记得拔出来）（2）重启一直按F12，进入Boot Option Menu开机选择界面（3）选择U盘（USB3.0&#x2F;2.0这种标识）（4）等待一会进入启动选项，先选择&quot;try ubuntu without install&quot;,查看ubuntu是否可以安装在电脑上。（5）然后会进入Ubuntu桌面，如果觉得正常，可以安装，就点击左上角的&quot;install ubuntu 18.04LTS&quot;（版本选择最新的稳定版本） 安装Ubuntu预配置 12345678910111213141516171819202122（1）选择语言（建议中文或者英文，进入系统后可以切换语言）（2）键盘布局（建议选择汉语）（3）无线选项，暂时不连接wifi（4）更新和其他软件选项，选择“最小安装”（避免系统自动安装多余软件，加快速度）（5）安装类型选项，此处会选择是否删除之前的系统和硬盘所有的文件！ --- 如果避免出现问题，可以选择“其他选项”； --- 如果需要全新的安装，就选择删除之前的系统的选项；（我选择的这一项，然后系统会默认分区，就不需要之后两步）（6）开始分区，重新分区或者分一块空闲盘的内存（建议不少于20G） --- EFI分区，存放系统引导文件的引导分区（可以默认选择，或者512MB） --- 交换分区swap，逻辑分区，建议和电脑内存大小相同（例如我的是8G） --- 根分区“&#x2F;”，存放apt-get安装的软件，这个大小自己分配（建议内存大一点，以便安装软件有足够的空间） --- &quot;&#x2F;home&quot;分区，存放个人文件，剩余的磁盘空间可以都给它 （这样分区的话，如果重装Linux系统只需要格式化根分区，而保留“&#x2F;home”分区）（7）接着在安装类型选项界面下侧，有一个“安装启动引导器的设备”，选择刚刚分配好的EFI分区（8）选择“安装” 安装进行时 12（1）选择时区（2）设置用户名、密码 安装后善后 12345678910111213（1）如果安装后无法关机，直接长按电源键强制关机，然后再次重启，查看是否正常；（2）开机一直按F12进入开机选择界面选择Ubuntu&#x2F;或者一直按F2进入启动项修改第一启动项为Ubuntu（3）如果内存大于等于8G，交换分区swap分不分配也没有问题（4）显卡驱动不生效：开机按F2进入启动项，进入BIOS中关闭，再重启，显卡驱动就会生效了（这个应该是内核或者驱动和电脑的安全模式启动冲突了）（5）如果安装的时候一直卡在语言包下载，则点击右侧的skip跳过（6）如果vi编辑器输入错乱，编辑&#x2F;etc&#x2F;vim&#x2F;vimrc.tiny,将&#39;compatiable&#39;修改成&#39;nocompatiable&#39;,然后加入一行&#39;set backspace&#x3D;2&#39;,保存退出（可以sudo使用vim编辑，或者root权限使用gedit编辑） Ubuntu桌面主题修改Gnome桌面环境查看12345在登录界面的右上角查看小图标，选择GNOME图标或者安装：** sudo apt-get install gnome-shell （窗口管理程序）** sudo apt-get install gnome-tweak-tool 修改主题(只在当前的登录用户)123456789（1）打开文件目录tweek tool，查看到Extensions（2）查看插件选项是否有User themes插件 --- 如果没有tweek tool, 执行sudo apt-get install gnome-tweek-tool --- 如果没有use themes, 执行sudo apt-get gnome-shell-extensions（3）登录GNOME主题官网(https:&#x2F;&#x2F;www.gnome-look.org)，选择主题下载（4）下载后解压放到“~&#x2F;.themes”目录，如果没有，自己创建（5）重新启动tweak tool（可能是重启窗口），然后在Appearance中选择“Shell theme”，修改即可（6）按”alt+F12“弹出命令窗口，输入“r”，重启Gnome桌面环境，查看修改后的主题 图标和指针的主题123修改方式和上面一样，但是下载解压后的文件夹放置位置不同。图标： &#x2F;usr&#x2F;share&#x2F;icons&#x2F; （全局修改）指针： ~&#x2F;.icons&#x2F; （只限当前用户，即&#x2F;home&#x2F;account&#x2F;） ibus输入法有些软件不能输入中文12345ibus-daemon -drx此时终端不能编辑，重启终端之后就可以输入中文。 终端主题zsh修改12345678910111213141. 查看当前shell主题echo $SHELL2. 查看shell列表cat &#x2F;etc&#x2F;shell3. 安装zsh再次查看列表会有zsh的存在4. 切换shellchsh -s &#x2F;bin&#x2F;shells5. 重启服务器 添加开机启动程序的自定义命令12345vi /etc/rc.local例如ibus输入中文： ibus-daemonibus-daemon -dxr 重启ibus 查看CPU使用情况 cat /proc/cpuinfo 查看磁盘内存使用情况12345df -hdf -i 检查inode使用情况sudo du / -h --max-depth=1","categories":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://alonealive.github.io/Blog/tags/linux/"}]},{"title":"C++多字节char、bool、字符常量、浮点数","slug":"2019/190723_cpp_float","date":"2019-07-23T14:01:37.000Z","updated":"2020-03-08T10:01:44.193Z","comments":true,"path":"2019/07/23/2019/190723_cpp_float/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/23/2019/190723_cpp_float/","excerpt":"wchar_t 程序需要处理的字符集可能无法用一个8位的字节表示，比如日文、汉字等此时有两种处理方法： 编译器厂商将char定义16位的字节或者更长 char表示8位的字节，另一种wchar_t表示宽字符类型，可以扩展字符集","text":"wchar_t 程序需要处理的字符集可能无法用一个8位的字节表示，比如日文、汉字等此时有两种处理方法： 编译器厂商将char定义16位的字节或者更长 char表示8位的字节，另一种wchar_t表示宽字符类型，可以扩展字符集 wchar_t类型是一种整数类型，因此可以有足够的空间表示系统使用的最大扩展字符集。 iostream使用wcin和wcout表示宽字符的输入输出。 C++11新增的char16_t和char32_t Unicode提供了一种表示各种字符集的解决方案。ASCII码是Unicode的子集。Unicode给每个字符指定一个编号 – 码点码点通常类似: U-222B (其中U表示这是一个Unicode字符，222B表示该字符的16进制编号)另一种针对多语言文本的编码标准是ISO 10646 char16_t使用前缀u表示字符常量或者字符串常量； char32_t使用前缀U表示字符常量或者字符串常量； 例如： 12char16_t = u'q';char32_t = U'\\U0000222B'; bool布尔类型 C++将非零值解释为true，0是false此处bool表示真和假如果需要打印这个类型的值，可以直接使用%d打印判断是否为0 1234bool is_ready = false;bool start = -100; //truebool stop = 0; //false 常量的符号名称 – const限定符 符号名称指出了常量表示的内容（即使用符号来表示一个常量）符号常量的两种定义方式： #define A 10 (预处理处理) const int B = 10; (C++编译器处理，提供类型检查和作用域检查) 例如： const int Months = 12; //首字母大写或者全部大写，表示常量（非通用约定） 常量Months被初始化后，其值就被固定了，编译器不允许修改这个常量的值。 如果强制修改，g++将指出程序试图给一个只读变量赋值。 关键词const叫做限定符，因为它限定了声明的含义。 创建常量 如果在声明中没有提供具体值，则常量的值是不确定的，且无法修改。 const_test.cpp12345const int pink = 10; //建议在声明中对常量初始化//TODO 不建议- const int toes;- toes = 10; const和define比较 const相比#define定义常量来说， 优势： 能够明确指定类型 可以使用C++的作用域规则将其定义限制在特定的函数或者类文件中 可以用于复杂的类型，例如数组、结构 浮点数书写方式 常用的小数点表示法 12312.340.23192.023 E表示法 例如23.3E3表示23.3的三次方。 E可以形容很大或者很小的数。E后面是负数，表示除以N*10d.ddE+n表示小数点向右移动n位d.ddE-n表示小数点向左移动n位之所以称为浮点数，就是因为小数点的移动 12344E334E-1031.23e1212.5e-5 浮点类型float,double,long double 这三个类型是按他们可以表示的有效数位和允许的指数最小范围来描述的。有效位表示数字当中有效的位数。比如14000的有效位数是2，因为可以精确到千位，其余三位只不过是占位符。有效位数不依赖小数点的位置。比如12.23的有效位数是4。 C++和C对float的有效位数至少32位。double至少48位，且不少于float。long double至少和double一样多。可以从头文件cfloat和float.h找到系统的限制！ floatnum.cpp 12345678910111213141516#include&lt;iostream&gt;int main() &#123; using namespace std; cout.setf(ios_base::fixed, ios_base::floatfield); //fixed-point,将E转换成小数点显示 float tub = 10.0/3.0; double mint = 10.0/3.0; const float million = 1.0E6; cout &lt;&lt; \"float tub = \" &lt;&lt; tub &lt;&lt;endl; cout &lt;&lt; \"double mint = \" &lt;&lt; mint &lt;&lt;\"\\n\"; cout &lt;&lt; \"const float million = \" &lt;&lt; million &lt;&lt;endl; cout &lt;&lt; \"tub * million = \" &lt;&lt; tub*million &lt;&lt;endl; cout &lt;&lt; \"mint * million = \" &lt;&lt; mint*million&lt;&lt;endl; return 0;&#125; g++ floatnum.cpp编译 生成a.out 执行./a.out 运行结果： 12345float tub = 3.333333double mint = 3.333333const float million = 1000000.000000tub * million = 3333333.250000mint * million = 3333333.333333 说明: cout会将3333333.250000直接打印成3333333.25 ，而cout.setf将覆盖这种行为； cout打印6位小数，他是iostream的一个类成员函数，能够精确的控制输出格式、字段宽度、小数位数、采用小数格式还是E格式显示；","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"hexo文章加密方法","slug":"2019/190722-hexo-article-pass","date":"2019-07-22T14:31:16.000Z","updated":"2020-03-08T10:00:29.904Z","comments":true,"path":"2019/07/22/2019/190722-hexo-article-pass/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/22/2019/190722-hexo-article-pass/","excerpt":"直接修改JS 存在问题：可能被破解。如果你的博客源码是存放在GitHub这样的开源库的话，那么恭喜你。别有用心之人可以通过查看你的GitHub仓库对应文章的md文件找到这个密码。","text":"直接修改JS 存在问题：可能被破解。如果你的博客源码是存放在GitHub这样的开源库的话，那么恭喜你。别有用心之人可以通过查看你的GitHub仓库对应文章的md文件找到这个密码。 themes/next/layout/custom/head.swig1234567891011#JavaScript&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; Hexo插件安装 npm install --save hexo-blog-encrypt 站点配置文件启用该插件_config.yml12encrypt: enable: true 文章的头部添加上对应的字段，如 password, abstract, message123password: 是该博客加密使用的密码abstract: 是该博客的摘要，会显示在博客的列表页message: 这个是博客查看时，密码输入框上面的描述性文字 123456789101112---title: 文章加密date: 2019-01-04T22:20:13.000Zcategory: 教程tags: - 博客 - Hexokeywords: 博客文章密码password: passabstract: 密码：passmessage: 输入密码，查看文章---","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"git stash储藏命令","slug":"2019/190722-git-stashing","date":"2019-07-22T03:12:33.000Z","updated":"2020-03-08T10:00:21.940Z","comments":true,"path":"2019/07/22/2019/190722-git-stashing/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/22/2019/190722-git-stashing/","excerpt":"储藏（stashing）可以获取工作目录的中间状态，即被修改过的被追踪的文件和暂存的变更。 并将它保存在一个未完结变更的堆栈中，随时可以重新应用。","text":"储藏（stashing）可以获取工作目录的中间状态，即被修改过的被追踪的文件和暂存的变更。 并将它保存在一个未完结变更的堆栈中，随时可以重新应用。 储藏暂时未完成的工作 如果你想在当前目录切换分支或者暂停正在进行的工作，而去先做另一件事。你就需要先储藏这些变更。为了向堆栈推送一个新的储藏，只需要执行：git stash git status 可以查看到干净的工作目录； git stash list 可以查看储藏的列表; git stash show stash@{0} 可以查看某个储藏的修改信息 如果工作目录不干净，包含已修改、未提交的文件，此时进行apply会给出归并冲突。 git stash apply stash@{0} 可以请求某个储藏（如果不指定某个，会默认最近的储藏） 对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。需要告诉命令重新应用被暂存（commit）的变更。 git stash apply --index 告诉命令重新应用被暂存的变更 git stash drop stash@{0} 移除某个储藏 取消储藏 如果已经apply某个储藏，但是在修改一些代码后需要取消这个储藏，此时使用:git stash show -p stash@{0} | git apply -R可以达到取消该储藏的补丁效果。 git stash branch &lt;name&gt; 这条命令会根据最近的stash创建一个新的分支，然后删除最近的stash可以指定某个stash， 在后面加上 stash@{0}","categories":[{"name":"git","slug":"git","permalink":"https://alonealive.github.io/Blog/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://alonealive.github.io/Blog/tags/git/"}]},{"title":"C++变量","slug":"2019/190721-cpp-variable","date":"2019-07-21T13:11:47.000Z","updated":"2020-03-08T10:00:13.500Z","comments":true,"path":"2019/07/21/2019/190721-cpp-variable/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/21/2019/190721-cpp-variable/","excerpt":"C++变量命名规则 只能使用字母、数字、下划线 第一个字符不能是数字 区分大小写 不能使用关键字 以两个下划线或下划线和大写字母打头的名称保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符 C++对命名的长度没有限制，但是有些平台会限制长度","text":"C++变量命名规则 只能使用字母、数字、下划线 第一个字符不能是数字 区分大小写 不能使用关键字 以两个下划线或下划线和大写字母打头的名称保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符 C++对命名的长度没有限制，但是有些平台会限制长度 常用描述类型或者变量的命名方式，比如： str或者sz（表示以空字符结束的字符串）、b（表示布尔值）、p（表示指针）、c（表示单个字符） 整型1C++的基本整型按照宽度递增（width,用于描述存储整型时候使用的内存量。内存越多，则越宽）的排序顺序分别是：char、short、int、long和C++11新增的long long。 short、int、long、long long123456789101112计算机内存的基本单元是bit位。关表示0，开表示1.8位的内存内存块可以设置256种不同的组合（2的八次方）。因此，8位单元可以表示0-255或者-128到127。字节byte通常表示8位的内存单元。从这个意义来说，字节指的是描述计算机内存量的度量单位。1KB&#x3D;1024byte1MB&#x3D;1024KB在美国，基本字符集通常是ASCII和EBCDIC字符集，他们可以用8位表示一个字节。但是在国际编程中可能需要使用更大的字符集，如Unicode，因此有些实现可能使用16位甚至32位的字节。 当前很多系统都使用最小长度，即short是16位。这为int提供了多种选择，可以是16位、24位、32位。甚至64位。因为long和long long至少长64位。 short是short int的简称。long是long int的简称。 short、int、long、long long都是符号类型。这意味着每种类型的取值范围，负值和正值几乎相同。 示例代码： limits.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;climits&gt; //use limits.h for older systemint main() &#123; using namespace std; int n_int = INT_MAX; short n_short = SHRT_MAX; //symbols defined in climts file long n_long = LONG_MAX; long long n_llong = LLONG_MAX; cout &lt;&lt; \"int is\"&lt;&lt; sizeof(n_int) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"short is\"&lt;&lt; sizeof(n_short) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"long is\"&lt;&lt; sizeof(n_long) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"long long is\"&lt;&lt; sizeof(n_llong) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"Maximum value:\"&lt;&lt; endl; cout &lt;&lt; \"int : \" &lt;&lt; n_int &lt;&lt; endl; cout &lt;&lt; \"short : \" &lt;&lt; n_short &lt;&lt; endl; cout &lt;&lt; \"long : \" &lt;&lt; n_long &lt;&lt; endl; cout &lt;&lt; \"long long : \" &lt;&lt; n_llong &lt;&lt; endl; cout &lt;&lt; \"Minimum int value = \"&lt;&lt;INT_MIN&lt;&lt;endl; cout &lt;&lt; \"BNits per bytr = \"&lt;&lt; CHAR_BIT &lt;&lt;endl; return 0;&#125; 执行结果： Results123456789101112int is 4 bytesshort is 2 byteslong is 8 byteslong long is 8 bytesMaximum value:int : 2147483647short : 32767long : 9223372036854775807long long : 9223372036854775807Minimum int value = -2147483648BNits per bytr = 8 climits文件的符号常量 符号常量 极值意义 CHAR_INT char的位数 CHAR_MAX char的最大值 CHAR_INT char的最小值 SCHAR_MAX signed char的最大值 UCHAR_MAX unsigned char的最大值 SHRT_MAX short的最大值 USHRT_MAX unsigned short的最大值 INT_MAX int的最大值 LONG_MAX long的最大值 LLONG_MAX long long的最大值 初始化12345678910111213int n_int = INT_MAX; short year; year = 1492; //C++11的初始化方式int hamburgers = &#123;24&#125;; //set hanmburgers to 24int emus&#123;7&#125;; //设置emus为7int rheas = &#123;12&#125;; //设置rheas为12int rocs = &#123;&#125;; //设置为0int rocs&#123;&#125;; 无符号类型123例如：short的unsigned无符号的表示范围是0-65535short的表示范围是-32768到+32767 C++如何确定常量的类型12345678910111213例如：&#96;cout &lt;&lt; &quot;year&quot; &lt;&lt; 2019 &lt;&lt; endl;&#96;程序会把2019存储为int类型。整型后面的l或者L后缀表示为long；u或者U表示unsigned int常量；ul或者UL表示unsigned long；C++11还提供了ull, ULL, uLL和Ull。 char字符型 char是专门存储字符（字母或者数字）的类型。 testChar123char ch = 'M';cout.put(ch); char的字面值123456ASCII系统中对应的数值编码：&#39;A&#39; &#x3D; 65&#39;a&#39; &#x3D; 97&#39;5&#39; &#x3D; 53&#39;&#39; &#x3D; 32 &#x2F;&#x2F;空格字&#39;!&#39; &#x3D; 33","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Hexo Next主题优化（二）","slug":"2019/190718-nextdebug-md","date":"2019-07-18T14:41:47.000Z","updated":"2020-03-08T10:00:02.380Z","comments":true,"path":"2019/07/18/2019/190718-nextdebug-md/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/18/2019/190718-nextdebug-md/","excerpt":"样式页脚foot优化爱心跳动 在Next主题根目录的配置文件修改","text":"样式页脚foot优化爱心跳动 在Next主题根目录的配置文件修改 12345678910111213footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heartbeat # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: \"#ff0000\" 代码框样式代码框样式（复制按钮） 在Next主题根目录的配置文件修改 主题根目录_config.yml12345678910codeblock: # Manual define the border radius in codeblock, leave it blank for the default value: 1 border_radius: 10 //代码框边缘圆角 # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true # Style: only 'flat' is currently available, leave it blank if you prefer default theme style: flat //复制按钮 代码高亮主题主题根目录_config.yml1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normal diff样式12- printf(\"Hello World!\");+ printf(\"Hello_World!\"); 改变显示字体的颜色 主要是侧边栏和文章主题内容（不包含标题） source/custom/custom.styl123456789101112131415161718//主页的阅读全文、主内容字体，不包含标题.main-inner &#123; p,span,a &#123;color: #ffb6c1;&#125; background-color: rgba(255,255,255,0.5);&#125;//上侧边栏.header-inner &#123; p,span,a &#123;color: #ffb6c1;&#125; background-color: rgba(255,255,255,0.5);&#125;// 下侧边栏字体颜色#sidebar &#123; p,span,a &#123;color: #ffb6c1;&#125; //改变颜色&#125;*/ 自动更换背景图片source/custom/custom.styl123456789101112131415161718body &#123; //以下是自动更换背景图片 background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: 100% 100%;&#125;//更换侧边标题栏图片.site-meta &#123; //background: #BABABA //#5CADAD; //颜色 background-image:url(/images/subtitle1.jpg); //背景图片 background-position:50% 50%; background-size: 100% 100%; opacity: 0.9; //虚化 //p,span,a &#123;color: #3D3D3D;&#125; //字体颜色&#125; 背景虚化（解决搜索框被虚化的问题） 修改左侧栏菜单带搜索框的UI的背景颜色RGB值其余的使用透明度如此搜索框的就不会被虚化 source/custom/custom.styl12345678910111213141516171819202122//主页的阅读全文、主内容字体，不包含标题.main-inner &#123; //background-color: rgba(255,255,255.0.8); opacity: 0.8;&#125;//上侧边栏.header-inner &#123; background-color: rgba(255,255,255,0.8); //只修改此处的背景颜色，以便搜索框不会被覆盖 //opacity: 0.75; //透明度，会覆盖到搜索框&#125;//上侧边栏的标题栏.site-meta &#123; background: #5CADAD; //颜色 //background-image:url(/images/huojinsi.jpg); //背景图片&#125;// 下侧边栏#sidebar &#123; //opacity: 0.8; //透明度&#125; note 便签 主题配置文件搜索 note, 可设置风格和图标是否显示。存在部分样式无效的问题。 主题根目录_config.yml123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple //默认样式 icons: true //图标 border_radius: 10 //圆角 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 示例： 1&#123;% note default %&#125;default是类型还有以下几种&#123;% endnote %&#125; 123456789101112131415&#123;% note default %&#125;default&#123;% endnote %&#125;&#123;% note primary %&#125;primary&#123;% endnote %&#125;&#123;% note success %&#125;success&#123;% endnote %&#125;&#123;% note info %&#125;info&#123;% endnote %&#125;&#123;% note warning %&#125;warning&#123;% endnote %&#125;&#123;% note danger %&#125;danger&#123;% endnote %&#125;&#123;% note %&#125;空样式&#123;% endnote %&#125;&#123;% note danger no-icon %&#125;danger no-icon&#123;% endnote %&#125; 另一种写法： 1&lt;div class=\"note danger\"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; &lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt; 文章编辑选项卡 “tab” 为选项卡的名称，可以自定义，数字是几表示从第几个选项卡开始。非必须，若数值为 - 1 则隐藏选项卡内容。下载插件： npm i hexo-ruby-marks 1234567891011&#123;% tabs tab,2 %&#125;&lt;!-- tab --&gt;this is tab1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab3&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 结果： 1234567891011&#123;% tabs tab,2 %&#125;&lt;!-- tab --&gt;this is tab1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab3&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 引用（文章居中）123&#123;% cq %&#125;**there are test words**&#123;% endcq %&#125; 123&#123;% cq %&#125;**there are test words in center**&#123;% endcq %&#125; 在文章中插入 iframe1&#123;% iframe url [width] [height] %&#125;","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"Use ADB","slug":"2019/190717_debug_adb_commonds","date":"2019-07-17T14:04:14.000Z","updated":"2020-03-08T09:59:45.028Z","comments":true,"path":"2019/07/17/2019/190717_debug_adb_commonds/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/17/2019/190717_debug_adb_commonds/","excerpt":"ADB是连接手机设备和电脑设备的调试桥。这种工具命令用于Android调试是基础而且重要的。 Overview Install: sudo apt-get install adb Function:123456通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级、运行shell命令等。手机启动USB调试模式，设备连接电脑。注：我的手机一加6的USB调试模式打开方式如下： （1）在手机设置的关于手机找到版本号，双击七次打开开发者模式; （2）在开发者选项中打开USB调试选项; （3）设备连接","text":"ADB是连接手机设备和电脑设备的调试桥。这种工具命令用于Android调试是基础而且重要的。 Overview Install: sudo apt-get install adb Function:123456通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级、运行shell命令等。手机启动USB调试模式，设备连接电脑。注：我的手机一加6的USB调试模式打开方式如下： （1）在手机设置的关于手机找到版本号，双击七次打开开发者模式; （2）在开发者选项中打开USB调试选项; （3）设备连接 Commonds基础命令 如果设备连接&gt;1，可使用adb -s DevicesID + 其余部分命令 Commond Explain adb devices 查看设备连接情况 adb version 查看版本 adb help 查看帮助 adb shell 进入adb sehll命令 adb shell top 查看手机当前进程占用手机内存情况 adb shell kill -3 pid 杀掉进程 adb logcat -v process &#124; grep 8607 8607是进程 PID adb shell reboot -p 关机 adb reboot 重启 adb shutdown 关机 adb root root adb remount 获取读写权限 adb kill-server 关闭adb服务 adb start-server 启动adb服务 adb shell stop 关闭设备请求 adb shell start 启动设备请求 adb shell su root setenforce 0 关闭seLinux模式 网络相关设置 Commond Explain adb shell ifconfig 查看手机IP adb tcpip 5555 设置手机tcpip adb connect IP 连接IP 屏幕display信息 Commond Explain adb shell wm size 查看分辨率 adb shell set wm size 设置分辨率 软件操作命令 安装软件:123adb install adb install &lt;apk文件路径&gt; :这个命令将指定的apk文件安装到设备上adb install -r -d APK 卸载软件12adb uninstall &lt;软件名&gt;adb uninstall -k &lt;软件名&gt; 如果加 -k 参数,为卸载软件但是保留配置和缓存文件 文件操作命令： 从电脑上发送文件到设备,用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)1adb push &lt;本地路径&gt; &lt;远程路径&gt; 从设备上下载文件到电脑,用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑1adb pull &lt;远程路径&gt; &lt;本地路径&gt; 录制视频12adb shell screenrecord sdcard&#x2F;test.mp4adb pull sdcard&#x2F;test.mp4 . 日志操作命令 常用日志命令 Commond Explain adb logcat &#124; tee log1 保存日志到本地并且打印到控制台 adb logcat -v threadtime 按照线程时间打印日志 adb logcat -s System.out 设置标签（某个字符串），过滤显示日志 adb logcat -c 清理已存在的日志 adb logcat -g 打印日志缓冲区的大小 adb logcat &gt; home/mylog.txt 日志保存到电脑某路径 adb logcat -d -f /sdcard/mylog.txt 保存到手机上指定位置（-d 日志显示在控制台） adb logcat -f /scard/log.txt 输出到手机指定位置 查看日志 12345678910adb logcat日志等级（由上往下级别递增）：V verbase，级别最低，琐碎、不重要的日志信息D debug，调试信息I info，重要信息W warning，警告信息E error，错误信息F fatal，严重错误信息S slient，无记载 查看帮助信息，获取该命令可配置的参数选项 1adb logcat --help 加载一个可使用的日志缓冲区供查看 123456789adb logcat -b &lt;buffer&gt; buffer选项可以填为：radio 通信系统system 系统组件event event事件模块main java层kernel linux内核all 所有 指定标签，指定级别过滤显示日志 12adb logcat [tag:level]例如：adb logcat Test:I 设置日志输入格式控制输出字段 123456789101112adb logcat -v &lt;format&gt;format选项可以填为：brief 显示优先级&#x2F;标记和原始进程的PID（默认） process 只显示进程PIDtag 只显示优先级&#x2F;标记thread 只显示进程、线程、优先级&#x2F;标记rawtimelong例如：adb logcat -v process APK包相关命令adb shell pm命令 123456adb shell pm -l 列出包列表adb shell pm list packages 查看包名(同上)adb shell pm path &quot;PackageName&quot; 获取包的路径(可以通过dump SF获取当前的活动包名)adb shell pm list packages -f 查看包名对应的apk路径及名称adb shell dumpsys 列出手机所有apk的详细信息 按名称检查正在运行的进程12adb shell pidof ”mediaserver“ &#x2F;&#x2F;查找正在运行的服务名的pidadb shell pidof com.android.phone &#x2F;&#x2F;获取进程号(如果找到此类进程，则返回PID，否则返回空字符串) 获取当前ACTIVITY1adb shell dumpsys activity top|grep ACTIVITY 命令启动指定Activity1adb shell am start -n com.android.systemui&#x2F;com.android.systemui.recents.RecentActivity 模拟点击事件（点击屏幕） 打开开发者选项的指针位置选项，点击屏幕即可获得XY坐标。 1adb shell input tap x y 获取设备信息参数12345678910adb shell getprop &quot;name&quot;例如：adb shellgetprop 查看机器的全部信息参数getprop ro.serialno 查看机器的序列号getprop ro.carrier 查看机器的CID号getprop ro.hardware 查看机器板子代号getprop ro.bootloader 查看SPL(Hboot)版本号setprop &lt;参数名&gt; &lt;参数值&gt; 设置某个参数 输入命令input input后可以跟很多参数， text相当于输入内容，keyevent相当于手机物理或是屏幕按键，tap相当于touch事件，swipe相当于滑动。 模拟的是滑动事件 12345678910111213141516input swipe模拟的是滑动事件，需要将起始的坐标传进去,可以传入滑动时长adb shell input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)例如：向左滑动：input swipe 600 800 300 800向右滑动：input swipe 300 800 600 800滑动：adb shell input swipe 100 100 200 200 300 &#x2F;&#x2F;从 100 100 经历300毫秒滑动到 200 200 长按：adb shell input swipe 100 100 100 100 1000 &#x2F;&#x2F;在 100 100 位置长按 1000毫秒 输入文本内容 1adb shell input &quot;text&quot; 输入文本内容 adb shell am instrument …instrument为am命令的一个子命令。用于启动一个Instrumentation测试。各项参数： 12345678910111213-r: 以原始形式输出测试结果；该选项通常是在性能测试时与[-e perf true]一起使用。-e name value: 提供了以键值对形式存在的过滤器和参数。例如：-e testFile &lt;filePath&gt;（运行文件中指定的用例）；-e package &lt;packageName&gt;（运行这个包中的所有用例）…… 有十几种。 -p file: 将分析数据写入 file。-w: 测试运行器需要使用此选项。例如:-w &lt;test_package_name&gt;&#x2F;&lt;runner_class&gt; ：&lt;test_package_name&gt;和&lt;runner_class&gt;在测试工程的AndroidManifest.xml中查找，作用是保持adb shell打开直至测试完成。--no-window-animation: 运行时关闭窗口动画。--user user_id | current: 指定仪器在哪个用户中运行；如果未指定，则在当前用户中运行。 例如运行一个类中的所有用例： 1adb shell am instrument -w -r -e class com.letv.leview.setproxy com.le.tcauto.uitest.test&#x2F;android.support.test.runner.AndroidJUnitRunner Dumpsys信息服务列表信息 adb shell 进入shell dumpsys -l 查看所有正在运行的服务名 service list 查看这些服务名称调用了哪个服务 常见服务信息列表 服务名 类名 功能 gfxinfo GraphicsBinder 图像 SurfaceFlinger 图像相关 activity ActivityManagerService AMS相关信息 package PackageManagerService PMS相关信息 window WindowManagerService WMS相关信息 input InputManagerService IMS相关信息 power PowerManagerService PMS相关信息 batterystats BatterystatsService 电池统计信息 battery BatteryService 电池信息 alarm AlarmManagerService 闹钟信息 dropbox DropboxManagerService 调试相关 procstats ProcessStatsService 进程统计 cpuinfo CpuBinder CPU meminfo MemBinder 内存 dbinfo DbBinder 数据库 appops app使用情况 permission 权限 processinfo 进程服务 batteryproperties 电池相关 audio 查看声音信息 netstats 查看网络统计信息 diskstats 查看空间free状态 jobscheduler 查看任务计划 wifi wifi信息 diskstats 磁盘情况 usagestats 用户使用情况 devicestoragemonitor 设备信息 dump方法1234567dumpsys &lt;service&gt; 打印具体某一项服务（service就是前面表格中的服务名）例如： （adb shell）dumpsys cpuinfo &#x2F;&#x2F;打印一段时间进程的CPU使用百分比排行榜dumpsys meminfo -h &#x2F;&#x2F;查看dump内存的帮助信息dumpsys package &lt;packagename&gt; &#x2F;&#x2F;查看指定包的信息dumpsys SurfaceFLinger &#x2F;&#x2F;查看SF服务 dump窗口信息12adb shell dumpsys window windowsadb shell dumpsys window windows |grep Current &#x2F;&#x2F;当前窗口信息 dump SurfaceFlinger信息 方式： 12345678910adb shell dumpsys SurfaceFlinger一般包含：1、layer的信息，layer一般对应于一个surface;2、opengl的信息。一般是跟gpu比较相关的参数，opengl是标准的接口;3、display。安卓支持三种类型的display，可以导出display当前的显示状态，也就是各个surface(layer)在各个display的显示属性;4、surfaceflinger管理graphis buffer的信息。主要是layer申请的帧数据内存;5、hwcomopser的如果实现dump接口也能知道hwcomposer的一些参数;6、gralloc的内存分配信息。如果gralloc有实现dump接口的话;7、合成方式、BufferLayer的树形结构信息 连接DP 然后继续dump SurfaceFlinger信息 123连接之前启动: adb shell dumpsys SurfaceFlinger --file --no-limit 断开后再次执行 adb shell dumpsys SurfaceFlinger --file --no-limit 并pull出来 adb pull &#x2F;data&#x2F;misc&#x2F;wmtrace&#x2F;dumpsys.txt GPU帧渲染数据1234567adb shell dumpsys gfxinfo 例如查看camera功能的渲染一帧所经过的各个阶段的耗时情况（单位毫秒）dumpsys gfxinfo **.camera 带上 framestats 参数可以获取最近的 120 帧数据：adb shell dumpsys gfxinfo **.camera framestats fastboot模式进入fastboot（设备需要解锁） adb reboot bootloaderfastboot devices 检查设备 刷机 fastboot erase boot/system 清除区 fastboot -w fastboot boot/system NewImg 烧录 fastboot reboot","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"ADB","slug":"ADB","permalink":"https://alonealive.github.io/Blog/tags/ADB/"}]},{"title":"在Android源码调试函数的堆栈","slug":"2019/190716_debug_ancdoid_callstack","date":"2019-07-16T12:04:14.000Z","updated":"2020-03-08T09:59:34.368Z","comments":true,"path":"2019/07/16/2019/190716_debug_ancdoid_callstack/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/16/2019/190716_debug_ancdoid_callstack/","excerpt":"在Android代码中可以通过了解函数的CallStack加速调试和分析过程，本文说明如何在Android运行时加入CallStack及Android P上的注意点。 Java12import android.util.Log; Log.d(\"yourTag\", Log.getStackTraceString(new Exception()));","text":"在Android代码中可以通过了解函数的CallStack加速调试和分析过程，本文说明如何在Android运行时加入CallStack及Android P上的注意点。 Java12import android.util.Log; Log.d(\"yourTag\", Log.getStackTraceString(new Exception())); C++Android 9以前CallStack call是被build进libutils, framework大部分service都是link了该lib，因此可以直接使用Callstack。Android 9开始后CallStack被build进libutilscallstack，因此直接使用Callstack会报undefined reference to ‘android::CallStack::CallStack 在Android.bp或Android.mk中加入”libutilscallstack” 即可. 12345678910#include &lt;utils/CallStack.h&gt;ALOGD(\"dump callstack\");android::CallStack stack; stack.update(); stack.dump(\"yourTag\");// stack.log(\"yourTag\"); //callstack LOG_TAGMethods:adb logcat | grep yourTag","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"android debug","slug":"android-debug","permalink":"https://alonealive.github.io/Blog/tags/android-debug/"}]},{"title":"Next Gemini主题优化","slug":"2019/190715_genminiChange-md","date":"2019-07-15T14:16:31.000Z","updated":"2020-03-08T09:58:29.455Z","comments":true,"path":"2019/07/15/2019/190715_genminiChange-md/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/15/2019/190715_genminiChange-md/","excerpt":"圆角设计主题修改成Gemini 不同于Pisces, Gemini主题是卡片式布局 _config.xml12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini","text":"圆角设计主题修改成Gemini 不同于Pisces, Gemini主题是卡片式布局 _config.xml12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 修改UIthemes/hexo-theme-next/source/css/_variables/Gemini.styl123// 修改主题页面布局为圆角$border-radius-inner = 15px 15px 15px 15px;$border-radius = 15px; 背景动态效果下载依赖库12cd themes&#x2F;next git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source&#x2F;lib&#x2F;canvas-nest 修改配置文件_config.xml123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: \"0,0,255\" # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"Use CTS","slug":"2019/190715_debug_CTS","date":"2019-07-15T14:04:14.000Z","updated":"2020-03-08T09:48:56.623Z","comments":true,"path":"2019/07/15/2019/190715_debug_CTS/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/15/2019/190715_debug_CTS/","excerpt":"OverviewCTS就是兼容性测试为了确保Android应用能够在所有兼容Android的设备上正确运行，并且保持相似的用户体验，在每个版本发布之时，Android提供了一套兼容性测试用例集合（Compatibility Test Suite, CTS）来认证运行Android系统的设备是否完全兼容Android规范，并附带有相关的兼容性标准文档（Compatibility Definition Document, CDD）。 从 http://source.android.com/compatibility/downloads.html（ 网络需要能进google）处下载最新的兼容性测试用例集合，并解压。大部分是基于Junit和仪表盘技术编写的。还扩展了自动化测试过程，可以自动执行用例，自动收集和汇总测试结果。CTS采用XML配置文件的方式将这些测试用例分组成多个测试计划（plan）,第三方也可以创建自己的plan。","text":"OverviewCTS就是兼容性测试为了确保Android应用能够在所有兼容Android的设备上正确运行，并且保持相似的用户体验，在每个版本发布之时，Android提供了一套兼容性测试用例集合（Compatibility Test Suite, CTS）来认证运行Android系统的设备是否完全兼容Android规范，并附带有相关的兼容性标准文档（Compatibility Definition Document, CDD）。 从 http://source.android.com/compatibility/downloads.html（ 网络需要能进google）处下载最新的兼容性测试用例集合，并解压。大部分是基于Junit和仪表盘技术编写的。还扩展了自动化测试过程，可以自动执行用例，自动收集和汇总测试结果。CTS采用XML配置文件的方式将这些测试用例分组成多个测试计划（plan）,第三方也可以创建自己的plan。 Achieve CTS Package google官方下载Link: http://source.android.com/compatibility/downloads.html 编译源码 1234CTS的代码在Android源码CTS目录下。 make cts -j4 编译好cts后生成的文件位置： &#x2F;out&#x2F;host&#x2F;linux-x86&#x2F; 在该目录下包含tools和rtestcases两个目录。 环境配置 Android 调试桥 (adb) 手机不能休眠123设置-&gt;开发人员选项：打开Settings-&gt;Accessibility-&gt;Developer options-&gt;USB debugging(USB 调试)打开Settings-&gt;Accessibility-&gt;Developer options-&gt;Stay Awake（保持唤醒） 系统语言最好保证英语1设置手机语言为英语：Setting-&gt;Language&amp;input-&gt;language-&gt;English(United States)。 测试命令 在CTS/tools目录下执行 ./cts-tradefed 进入cts-tf,进入的打印信息会提示连接到手机设备！ 123run cts --help 查看帮助help listhelp run 测试模块 run cts -s DeviceID -m CtsMediaTestCases （在testcases目录下找apk）测试模块下的一小模块： cts-tf &gt; run cts -m CtsMediaTestCases -a armeabi-v7a 测试模块某个testcase run cts -s DeviceID -m &lt;模块名&gt; -t &lt;具体fail项&gt; 123456789101112131415161718192021run cts -兼容性（compatibility）选项：--include-filter 请求包含的模块过滤器--exclude-filter 请求排出的模块过滤器（默认一大堆）--subplan 运行子计划--serial&#x2F;-s &lt;deviceID&gt; 在特定设备上运行 CTS-d&#x2F;--device &lt;devicedID&gt; 设备-r &#x2F;--retry 重新尝试当前的session--skip-system-status-check + ...Check 跳过系统状态检查-–skip-preconditions&#x2F;-o 跳过一些预置条件的检查，可以减少测试的时间–-skip-device-info 跳过手机信息的收集，可以减少测试的时间--continue-session &lt;sessionId&gt; 继续被中断的任务 查看测试结果 l r 查看等待执行的任务 l c 查看所有执行的任务 l i 12345678l -d 设备r 结果c 当前被等待执行的命令p 所有可获得的planm 所有可获得的modulei 所有调用的线程（查看任务是否结束）config 所有可知的配置 全局测试 run cts –plan CTS 继续被中断的测试 l rrun cts –continue-session sessionID 重新跑测某个任务的失败项（节约时间） l rrun cts retry -s DeviceID –retry sessionID 测试结果测试结束后在/results文件夹中，会看到以日期和时间命名的文件夹用于保存执行过的测试结果。还有一个同名的zip文件保存同样的内容。 测试过程中的自动录log，测试结束后log自动保存在/logs里边以日期和时间命名的文件夹中。 在测试结果文件夹中，所有的测试结果是以XML的形式保存的。通常测试结果网页分成“Device Information”、“Test Summary”、“Test Summary by Package”、“Test Failures(xx)”和“Detailed Test Report”等四个区域。","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"CTS","slug":"CTS","permalink":"https://alonealive.github.io/Blog/tags/CTS/"}]},{"title":"VS code常用插件","slug":"2019/190715_vscode_plugins","date":"2019-07-15T14:04:14.000Z","updated":"2020-03-08T09:59:07.399Z","comments":true,"path":"2019/07/15/2019/190715_vscode_plugins/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/15/2019/190715_vscode_plugins/","excerpt":"markdown相关插件markdown PDF 可以转换md文件成pdf, html, png, jpg文件 markdownlint 可以提示markdown语法规范","text":"markdown相关插件markdown PDF 可以转换md文件成pdf, html, png, jpg文件 markdownlint 可以提示markdown语法规范 markdown toc 可以生成md文件的目录 markdown preview enhanced 实时预览，但是在vscode自带预览markdown文件效果，必要性不大。 UML建模插件plantUML 使用一种便捷的设计语言plantUML， 参考http://plantuml.com/ 基本使用方法参考：https://www.jianshu.com/p/30f6a9c06083","categories":[{"name":"tools","slug":"tools","permalink":"https://alonealive.github.io/Blog/categories/tools/"}],"tags":[{"name":"vs code","slug":"vs-code","permalink":"https://alonealive.github.io/Blog/tags/vs-code/"}]},{"title":"Use VTS","slug":"2019/190715_debug_VTS","date":"2019-07-15T14:04:14.000Z","updated":"2020-03-08T09:55:25.440Z","comments":true,"path":"2019/07/15/2019/190715_debug_VTS/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/15/2019/190715_debug_VTS/","excerpt":"Overview来源为了能更快的将设备升级到新的Android版本，Android O 开始新引入了 Project Treble，Project Treble 适用于搭载 Android O 及后续版本的所有新设备。","text":"Overview来源为了能更快的将设备升级到新的Android版本，Android O 开始新引入了 Project Treble，Project Treble 适用于搭载 Android O 及后续版本的所有新设备。 (1) Android 7.x 及更早版本中没有正式的Vendor层接口，因此每次更新系统都相对耗时和困难： (2) Android O 之后，Treble 提供了稳定的Vendor层接口，供设备制造商访问 Android 代码中特定于硬件的部分，这样就可以只更新框架层，减少升级系统带来的成本和困难： 作用为了确保Vendor层实现的前向兼容性，新的Vendor层接口会由供应商测试套件 (VTS) 进行验证，该套件类似于兼容性测试套件 (CTS)。 通过 CTS 测试，确保了 APP 与 Android Framework 之间有一致的调用接口（API），这使得 APP 开发者编写的同一款程序可以运行在不同系统版本（向前兼容）、不同硬件平台、不同厂商制造的不同设备上。 VTS 类似 CTS，通过对 Vendor Interface 进行测试，确保同一个版本的 Android Framework 可以运行在不同 HAL 上，或不同 Android Framework 可以运行在 同一个 HAL 上。 通过这样的 Framework / HAL 分离设计和接口一致性保证，也使得 8.0 版本之后的 Android 系统在进行升级时，可以直接对 Framework 进行升级而不用考虑 HAL 层的改动，从而缩短了用户手上设备得到系统升级 OTA 推送的时间。 环境搭建12345678910111213141） 安装 Python 开发包$ sudo apt-get install python-dev2） 安装 Protocol Buffer 工具（协议缓冲区工具）$ sudo apt-get install python-protobuf$ sudo apt-get install protobuf-compiler3） 安装 Python 虚拟环境相关工具$ sudo apt-get install python-virtualenv$ sudo apt-get install python-pip4） 在设备上启用开发者模式并打开 USB 调试功能 5） 测试的时候需要网络 测试前提GSIGSI介绍GSI是Google AOSP System Image的简称，在进行VTS测试之前，要使用user版本关闭verified boot后刷入GSI，VTS测试用的GSI由谷歌释放。 如VTS r6版本的GSI镜像： GSI方法1234567GSI方法（先adb remount）：1）adb reboot bootloader 进入fastboot（或者音量键+电源键）2）fastboot devices 查看识别设备 3）fastboot erase system_a 擦除分区（需要userDebug版本）4）fastboot -w 擦除用户数据分区和缓存分区5）fastboot flash system_a xxx.img 刷入img6）fastboot reboot 重启 123PS：在开发者选项查看oem unlocking选项是否已经解锁，如果未解锁可能是因为：（1）不是userDebugg版本； （2）可以通过执行fastboot flashing unlock和fastboot oem unlock，执行命令后需要选择音量 + 来确认unlock； 测试命令（同CTS相似） 启动vts(测试包从源码编译或者Google Android Developer官网查找) ./vts-tradefed 测试（跑测需要网络稳定） 1234567891011全局测： run vts模块测试： run vts -m 模块名某个测试项： run vts -m &lt;模块名&gt; -t &lt;测试项名&gt;可用选项:run vts -s &lt;device_id&gt; --logcat-on-failure --screenshot-on-failure --shard-count &lt;shards&gt;&#39;-s &lt;device_id&gt;&#39;：可指定运行测试的设备&#39;--logcat-on-failure&#39;：当测试失败时捕获logcat&#39;--screenshot-on-failure&#39;：当测试失败时截取屏幕截图&#39;--shard-count &lt;shards&gt;&#39;：用多个设备上同时跑测，可节省时间 查看list命令 123查看设备信息： l d查看命令信息： l c查看跑测结果： l r","categories":[{"name":"android","slug":"android","permalink":"https://alonealive.github.io/Blog/categories/android/"}],"tags":[{"name":"VTS","slug":"VTS","permalink":"https://alonealive.github.io/Blog/tags/VTS/"}]},{"title":"Hexo Next主题优化","slug":"2019/190713_hexo-improve","date":"2019-07-13T14:04:14.000Z","updated":"2020-03-08T09:56:53.890Z","comments":true,"path":"2019/07/13/2019/190713_hexo-improve/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/13/2019/190713_hexo-improve/","excerpt":"首页预览加入图片 在根目录下的images文件夹加入图片 12345678---title: Hexo Next主题优化categories: Webtags: - Hexophotos: - /images/background.jpg---","text":"首页预览加入图片 在根目录下的images文件夹加入图片 12345678---title: Hexo Next主题优化categories: Webtags: - Hexophotos: - /images/background.jpg--- Hexo-lazyload-image图片懒加载下载插件 npm install hexo-lazyload-image –save 修改_config.xml_config.xml1234lazyload: enable: true onlypost: false loadingImg: # eg. ./images/loading.png 文章插入图片 1. 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true 在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件 等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹; 最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](图片名.jpg) 例如![loading](background.jpg) result： Next主题图片浏览放大功能fancybox1234567891011Step1:cd next&#x2F;source&#x2F;libgit clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancyboxps:注意fancybox和next&#x2F;_config.uml里面的名字保持一致step2：更改next&#x2F;_config.uml文件fancybox： true Hexo NexT主题添加点击爱心效果创建js文件 在/themes/next/source/js/src下新建文件 clicklove.js ，接着把该链接下的代码拷贝粘贴到 clicklove.js 文件中。代码如下： 1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 修改_layout.swig 在\\themes\\next\\layout_layout.swig文件末尾添加： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/clicklove.js\"&gt;&lt;/script&gt; Next网站标题栏颜色 打开themes/next/source/css/_custom/custom.styl，在里面新增如下代码： 123.site-meta &#123; background: $blue; //天空的颜色，和我的眼镜是绝配&#125; 博客背景图片 打开上述相同文件 1234567body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: 100% 100%;&#125; 背景虚化12345678910&#x2F;&#x2F; 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.85;&#125;&#x2F;&#x2F; 修改菜单栏透明度.header-inner &#123; opacity: 0.85;&#125; 添加资源链接菜单(1) hexo new page &quot;resources&quot; (2) 编辑resources文件夹下的md页面,将类型设置为resources，主题将自动为这个页面显示所有分类。 1234567title: resourcesdate: 2019-07-14 13:05:38type: &quot;resources&quot;comments: false---(3) 在菜单中添加链接,编辑主题的_config.yml，在menu中的添加如下: menu: resources: /resources || download 123456789101112131415(4) 新添加的菜单需要翻译对应的中文,打开hexo&gt;theme&gt;next&gt;languages&gt;zh-Hans.yml，在menu下添加：&#96;&#96;&#96;cssmenu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 resources: 资源 阅读全文设置 在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。 解决 要解决这个问题有两个方法：一是修改 _config.yml 文件设置，而是直接在你的 md 中加一句代码即可。 第一种方法 用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码： Automatically Excerpt. Not recommend.Please use in the post to control excerpt accurately.123456auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。修改后重启 hexo 就ok了。 第二种方法 在你写 md 文章的时候，可以在内容中加上 ，这样首页和列表页展示的文章内容就是 之前的文字，而之后的就不会显示了。 效果 上面两种方式展示出来的效果是不一样的。 第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 … 标签云 位置：\\blog\\themes\\next\\layout\\page.swig原来： 1&#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125; 修改成:(else) 12345&#123;% if not theme.tagcloud %&#125; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125;&#123;% else %&#125; &#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125;&#123;% endif %&#125; 与主题样式一致的 404 页面new page12cd &lt;blog-path&gt; #定位到 Hexo 博客目录hexo new page &quot;404&quot; index.md12345---title: 404 Not Foundcomments: falsepermalink: &#x2F;404--- 使用hexo-neat插件压缩页面以提高响应速度安装hexo-neat插件 npm install hexo-neat --save 在站点配置文件中添加配置 下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义那些文件需要压缩,主要是有些js可能压缩后会失效。 123456789101112131415161718192021222324# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js' //此处忽略压缩点击桃心的特效# 压缩博文配置结束 菜单上显示数目 在next的主题配置文件中找到下面内容，设置为true即可 123menu_settings: icons: true badges: true # 显示文章数开关 Next主题代码块加入复制功能 在Next主题的配置文件，将copy_button打开 _congig.xml 12345678910codeblock: # Manual define the border radius in codeblock, leave it blank for the default value: 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true # Style: only 'flat' is currently available, leave it blank if you prefer default theme style: 修改侧边栏宽度1234# Manual define the sidebar width. If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300 Hexo博客NexT主题下添加文章边框阴影效果themes/next/source/css/_custom/custom.styl123456789101112.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;.main-inner &#123; background: #fff; opacity: 0.85;&#125; 保留上次阅读时候的位置_config.xml12# Automatically saving scroll position on each post / page in cookies.save_scroll: true 界面对齐方式_confi.xml12345# Set the text alignment in the posts.text_align: # Available values: start | end | left | right | center | justify | justify-all | match-parent desktop: justify mobile: justify","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"Hexo Next主题集成gitalk评论系统","slug":"2019/190713_use_gitalk","date":"2019-07-13T14:04:14.000Z","updated":"2020-03-08T09:48:46.194Z","comments":true,"path":"2019/07/13/2019/190713_use_gitalk/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/13/2019/190713_use_gitalk/","excerpt":"在我的Github+hexo搭建的网站中，使用github的gitalk评论系统。gitalk官方示例、官方文档","text":"在我的Github+hexo搭建的网站中，使用github的gitalk评论系统。gitalk官方示例、官方文档 register app in github在Github注册一个application，点击创建参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://wizzie.top/Application description # 描述，随意Authorization callback URL：# 网站URL，https://wizzie.top/ 创建完成后记录好Clien信息Client ID、Client Secret 配置_config.yml在主题配置文件next/_config.yml中添加如下内容： 12345678gitalk: enable: true githubID: github帐号 # 例：asdfv1929 repo: 仓库名称 # 例：asdfv1929.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true 提交hexo cleanhexo ghexo deploy 以下在最新的Next代码库都已经添加，无需修改。 修改gitalk.swig文件（最新的Next版本已有）修改/layout/_third-party/comments/gitalk.swig文件，添加（最新的Next版本已有，无需修改）： 12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt; &lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.githubID &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: location.pathname, distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125; comments.swig（最新的Next版本已有）修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=\"gitalk-container\"&gt;&lt;/div&gt; 修改index.swig（最新的Next版本已有）修改layout/_third-party/comments/index.swig，在最后一行添加内容： 1&#123;% include 'gitalk.swig' %&#125; 修改gitalk.styl（最新的Next版本已有）新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; third-party.styl（最新的Next版本已有）修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 1@import \"gitalk\"; 常见问题GET https://api.github.com/user 401 (Unauthorized)未找到相关的 Issues 进行评论未找到解决办法https://github.com/gitalk/gitalk/issues/183","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"C++ 编译和概述","slug":"2019/190711_cpp-basic","date":"2019-07-11T13:01:33.000Z","updated":"2020-03-08T06:57:20.984Z","comments":true,"path":"2019/07/11/2019/190711_cpp-basic/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/11/2019/190711_cpp-basic/","excerpt":"g++编译工具linux编译的四个阶段在Linux下编译程序分为以下4个阶段： 预处理：编译处理宏定义等宏命令（eg:#define）——生成后缀为“.i”的文件 编译：将预处理后的文件转换成汇编语言——生成后缀为“.s”的文件 汇编：由汇编生成的文件翻译为二进制目标文件——生成后缀为“.o”的文件 连接：多个目标文件（二进制）结合库函数等综合成的能直接独立执行的执行文件——生成后缀为“.out”的文件","text":"g++编译工具linux编译的四个阶段在Linux下编译程序分为以下4个阶段： 预处理：编译处理宏定义等宏命令（eg:#define）——生成后缀为“.i”的文件 编译：将预处理后的文件转换成汇编语言——生成后缀为“.s”的文件 汇编：由汇编生成的文件翻译为二进制目标文件——生成后缀为“.o”的文件 连接：多个目标文件（二进制）结合库函数等综合成的能直接独立执行的执行文件——生成后缀为“.out”的文件 Linux下执行gcc与g++编译C++文件的差别 后缀为.c的，gcc把它当作是C程序（cc/cpp才判定为C++源程序），而g++当作是c++程序 gcc无法进行库文件的连接，即无法编译完成步骤4；而g++则能完整编译出可执行文件。（实质上，g++从步骤1-步骤3均是调用gcc完成，步骤4连接则由自己完成），如以下： 1234567 gcc -E 执行到步骤1，只处理宏命令，需要用重定向生成文件 gcc -S 执行到步骤2，生成文件.s gcc -c 执行到步骤3，生成文件.o g++ 分别编译于连接 .cc文件与.o文件 Tips 后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。 编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。 安装使用g++ 除了code blocks, Vs code，可以更简单的使用gcc g++编译c和c++语言。安装：sudo apt-get install g++ 编译：g++ getinfo.cpp 生成a.out,使用./a.out执行或者g++ getinfo.cpp -o getinfo 生成getinfo，使用./getinfo执行 input and output12345678910111213141516171819//getinfo .cpp -- input and output#include&lt;iostream&gt;int main() &#123; using namespace std; int carrots; cout &lt;&lt; \"How many carrots do you have?\" &lt;&lt; endl; cin &gt;&gt; carrots; cout &lt;&lt; \"Here are two more.\"; carrots = carrots + 2; cin.get(); cin.get(); //添加两句，第一句按enter键位输入数字，第二条让程序暂停 //FIXME the next line concatenates output cout &lt;&lt; \"Now you have\" &lt;&lt; carrots &lt;&lt; \" carrots.\" &lt;&lt; endl; return 0;&#125; cin &gt;&gt; carrots;从键盘输入数值赋给变量carrots cout &lt;&lt; &quot;Now you have&quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; endl;使用cout拼接，endl换行。 类class 类是c++种面向对象编程OOP的核心概念之一 类是用户定义的一种数据类型 定义类，需要描述它能够表达什么信息和可对数据执行那哪些操作 类定义描述的是数据格式及其用法，而杜希昂是根据数据格式规范创建的实体 例如cout是一个ostream类对象，cin是一个istream类对象，都是在iostream中定义的。 函数 函数创建C++程序的模块，分为两种：有返回值的和无返回值的。例如： 1234#include&lt;cmath&gt;double x;x = sqrt(6.25);","categories":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/categories/cpp/"}],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://alonealive.github.io/Blog/tags/cpp/"}]},{"title":"Hexo Next主题集成Valine评论系统","slug":"2019/190709_use_valine","date":"2019-07-09T14:04:14.000Z","updated":"2020-03-08T09:48:41.274Z","comments":true,"path":"2019/07/09/2019/190709_use_valine/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/09/2019/190709_use_valine/","excerpt":"注册leanCloud官网账号 为了避免混乱，可以和github使用同样的账号信息。 注册app邮箱验证后，注册一个APP应用：alonealive.github.com_appAPP设置的安全中心选上数据存储，以及添加绑定的web域名。","text":"注册leanCloud官网账号 为了避免混乱，可以和github使用同样的账号信息。 注册app邮箱验证后，注册一个APP应用：alonealive.github.com_appAPP设置的安全中心选上数据存储，以及添加绑定的web域名。 配置_config.yml12345678910111213valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: vh******sz # your leancloud application appid appkey: Cf***2xz # your leancloud application appkey notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: wavatar # gravatar style 评论头像 guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size language: zh-cn # language, available values: en, zh-cn visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page 评论头像，点解链接查看 添加邮件提醒 参考：Valine评论系统中的邮件提醒设置 在邮件模板中，将重置密码的模板修改一下，邮件内容修改成： 12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=\"你的网址首页链接\" style=\"display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;\"&gt;马上查看&lt;/a&gt;&lt;/p&gt; 保存后，提交代码发布网站测试。 去除标签页和类别页的分类在他们的suource目录下的md文件添加：comments: false 例如分类页面： 123456---title: categoriesdate: 2019-05-08 22:40:04type: \"categories\"comments: false---","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"hexo的admin后台搭建","slug":"2019/190708_hexo的admin后台搭建","date":"2019-07-08T14:04:14.000Z","updated":"2020-03-08T06:55:58.910Z","comments":true,"path":"2019/07/08/2019/190708_hexo的admin后台搭建/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/08/2019/190708_hexo%E7%9A%84admin%E5%90%8E%E5%8F%B0%E6%90%AD%E5%BB%BA/","excerpt":"hexo-admin配置后台 查看github源项目： https://github.com/jaredly/hexo-admin 部署步骤123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/","text":"hexo-admin配置后台 查看github源项目： https://github.com/jaredly/hexo-admin 部署步骤123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ hexo的_config.xml配置123456admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 secret: hey hexo deployCommand: './admin_script/hexo-generate.sh' # expire: 60*1 hexo-myadmin 查看文档： https://www.npmjs.com/package/hexo-myadmin 使用方法12345678910# install hexo-myadmin npm i hexo-myadmin --save # start server with global hexo-cli hexo server # or with pm2 as deamon pm2 start node_modules&#x2F;.bin&#x2F;hexo -- server # visit localhost:4000&#x2F;admin 优点 使用轻量级的插件，而且简化了界面，编辑书写方便，功能便捷 待完善 关于图片的功能不够完善，需要输入地址，这对于同一个内网不通的机器不方便。 hexo-local-admin 文档： https://www.npmjs.com/package/hexo-local-admin 使用方法：123451. installnpm install -g hexo-local-admin2. use commandhexo-admin -h hexo-hey https://github.com/nihgwu/hexo-hey 使用方法npm install hexo-hey –save 优点可以粘贴图片 缺点部分文章没有编辑的UI，原因待查","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]},{"title":"Use hexo and github to build website","slug":"2019/190705_use_hexo","date":"2019-07-05T14:04:14.000Z","updated":"2020-03-08T07:08:11.739Z","comments":true,"path":"2019/07/05/2019/190705_use_hexo/","link":"","permalink":"https://alonealive.github.io/Blog/2019/07/05/2019/190705_use_hexo/","excerpt":"这篇文章主要是讲述如何结合hexo和github建站。使用hexo+github建站，相对减少开发时间和成本。相关Link： hexo官方文档、github建站Issue、我的网站","text":"这篇文章主要是讲述如何结合hexo和github建站。使用hexo+github建站，相对减少开发时间和成本。相关Link： hexo官方文档、github建站Issue、我的网站 1. 安装node.js 2. 配置hexonpm install -g hexo-cli 3. 初始化hexo工作目录1. mkdir hexo //新建文件夹2. hexo init hexo //初始化hexo工作目录 note: 可能需要安装一些依赖，按照log的指示配置。 12生成目录文件夹：TODO 4. 编译运行登录1. hexo g //build2. hexo s //生成服务端 使用http://localhost:4000/ 即可查看结果。 本地测试也可以使用127.0.0.1:4000访问，或者内网IP:4000 方式访问（ipconfig查看）note: 如果有修改，可以使用hexo clean清除public等文件，再重新编译运行。结果文件是public文件夹。 5. 发布到github1. 在根目录的_config.yml（非theme主题文件下的配置文件）修改1234deploy: type: git repository: git@github.com:***&#x2F;***.github.com.git branch: master 2. 安装插件 npm install hexo-deployer-git –save 3. 发布到githubhexo deploy4. 查看结果，例如我的网站wizzie.top note: 需要在你购买域名的万网进行域名绑定解析到github，please google by yourseflf。 6. 修改配置_config.yml1. 修改主题 推荐主题： 官方主题、Next套装主题（不需要安装基础依赖插件，简单配置使用） 例如下载Next主题仓库，然后在_config.yml中修改，编译后查看结果即可： 12345# Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;## theme: landscapetheme: next 2. 修改博主信息12345678# Sitetitle: 博客 &#x2F;&#x2F;标题subtitle: &#x2F;&#x2F;子标题description:keywords:author: wizzie &#x2F;&#x2F;作者language: zh-CN &#x2F;&#x2F;网站语言，可在theme目录的language查看timezone: 3. hexo文件夹结构123456789# Directorysource_dir: source &#x2F;&#x2F;资源文件夹public_dir: public &#x2F;&#x2F;网站构建生成tag_dir: tags &#x2F;&#x2F;标签archive_dir: archives &#x2F;&#x2F;日期归档category_dir: categories &#x2F;&#x2F;分类（使用hexo page &quot;categories&quot;生成）code_dir: downloads&#x2F;code &#x2F;&#x2F;下载i18n_dir: :lang &#x2F;&#x2F;语言skip_render: README.md &#x2F;&#x2F;可以避免该文件构造成html 4. 主页配置（分页大小、排序规则）12345678# Home page setting# path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)# per_page: Posts displayed per page. (0 &#x3D; disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#39;&#39; per_page: 10 order_by: -date 5. 网站日期格式123456# Date &#x2F; Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;date_format: YYYY-MM-DDtime_format: HH:mm:ss 7. 修改theme的_config.yml(Next主题)1. 主题选择12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini 2. 菜单配置1234567891011121314menu: home: &#x2F; || home archives: &#x2F;archives&#x2F; || archive categories: &#x2F;categories&#x2F; || th tags: &#x2F;tags&#x2F; || tags about: &#x2F;about&#x2F; || user #schedule: &#x2F;schedule&#x2F; || calendar #sitemap: &#x2F;sitemap.xml || sitemap #commonweal: &#x2F;404&#x2F; || heartbeat# Enable &#x2F; Disable menu icons &#x2F; item badges.menu_settings: icons: true badges: false 3. LOGO修改1234567favicon: small: &#x2F;images&#x2F;favicon-16x16-next.png medium: &#x2F;images&#x2F;favicon-32x32-next.png apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png safari_pinned_tab: &#x2F;images&#x2F;logo.svg #android_manifest: &#x2F;images&#x2F;manifest.json #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml 4. 页脚配置12345678910111213141516171819202122232425262728293031323334footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https:&#x2F;&#x2F;fontawesome.com&#x2F;v4.7.0&#x2F;icons&#x2F; # &#96;heart&#96; is recommended with animation in red (#ff0000). name: user &#x2F;&#x2F;图标可以到提供的网站修改 # If you want to animate the icon, set it to true. animated: false &#x2F;&#x2F;动画效果 # Change the color of icon, using Hex Code. color: &quot;#808080&quot; &#x2F;&#x2F;图标颜色 # If not defined, &#96;author&#96; from Hexo main config will be used. copyright: powered: # Hexo link (Powered by Hexo). &#x2F;&#x2F;关闭hexo强力驱动显示 enable: false # Version info of Hexo after Hexo link (vX.X.X). version: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). &#x2F;&#x2F;关闭next主题显示 enable: false # Version info of NexT after scheme info (vX.X.X). version: false # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http:&#x2F;&#x2F;www.beian.miit.gov.cn beian: enable: false icp: 5. 主页阅读全文设置12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true &#x2F;&#x2F;修改成true length: 150 &#x2F;&#x2F;显示字数 6. 评论系统配置文件提供了一些畅言、Valine(要指定next版本)、gitment、gitalk等，选择其中一个进行配置，配置方法见另一篇文章。 12345678910111213141516171819# ---------------------------------------------------------------# Comments and Widgets# See: https:&#x2F;&#x2F;theme-next.org&#x2F;docs&#x2F;third-party-services&#x2F;comments-and-widgets# ---------------------------------------------------------------.......# Gitalk# Demo: https:&#x2F;&#x2F;gitalk.github.iogitalk: enable: true github_id: # Github repo owner repo: # Repository name to store issues client_id: # Github Application Client ID client_secret: # Github Application Client Secret admin_user: # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode # Gitalk&#39;s display language depends on user&#39;s browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en, es-ES, fr, ru, zh-CN, zh-TW language: 7. 右上角github12345# &#96;Follow me on GitHub&#96; banner in the top-right corner.github_banner: enable: false &#x2F;&#x2F;修改成true permalink: https:&#x2F;&#x2F;github.com&#x2F;yourname title: Follow me on GitHub 8. 创建page(menu标签) 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：12$ cd your-hexo-site$ hexo new page categories categories目录index.md修改date: 2019-05-08 22:40:04type: “categories” 编辑刚新建的页面,设置分类title: 分类date: 2019-06-01 12:39:04categories: Testing #分类名type: “categories” 9. 创建文章和草稿12$ cd you-site$ hexo new post(或者draft) &quot;you title&quot; 10. 头像显示123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/user.jpg //使用本地图片 # If true, the avatar would be dispalyed in circle. rounded: true //是否圆形显示 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 //透明度 # If true, the avatar would be rotated with the cursor. rotated: true //是否旋转 11. 浏览进度按钮123456back2top: enable: true //是否启用 # Back to top in sidebar. sidebar: false //是否显示在左侧栏下方 # Scroll percent label in b2t button. scrollpercent: true //是否显示阅读进度 12. 侧边栏社交图标12345678910# Social Links# Usage: `Key: permalink || icon`social: #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibosocial_icons: enable: true icons_only: false //是否只显示图标 transition: true 13. 侧边栏其余外部链接12345678# Blog rollslinks_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: 移动平台资源整理: https://mobdevgroup.com/ Android Developer: https://developer.android.com/docs 14. 修改底部user文字12# If not defined, `author` from Hexo main config will be used. copyright: 'wizzie.top' 15. 修改加载进度条12345pace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom......pace_theme: pace-theme-barber-shop 16. 打开本地搜索123456789local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: -1 # Unescape html strings to the readable one. unescape: false 17. 文章顶部显示时间信息12345678# Post meta display settingspost_meta: item_text: true // created_at: true //创建文章时间 updated_at: enable: true //显示更新时间 another_day: true //其他天显示 categories: true //分类显示 18. 文章阅读量统计12345678910# Show Views / Visitors of the website / page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye 8. 修改主题背景custom.styl修改source/_custom/custon.styl文件，详情可以查询其他博客案例。 9. 修改文章底部标签#在theme/layout/_macro/post.swig修改标签： 12//将原有的#替换成&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt;&lt;a href=\"&#123;&#123; url_for(tag.path) &#125;&#125;\" rel=\"tag\"&gt;&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt;&#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 10. 修改文章链接样式在theme/next/source/css/custom/custom.styl添加以下内容： 1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 效果图： note：注意此处的image是放在hexo/source/img/目录下，但是构建之后在public目录下img是一级目录。所以引用的时候不用加上souce/ hexo-admin配置后台 查看github源项目： https://github.com/jaredly/hexo-admin 部署步骤123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/ hexo的_config.xml配置123456admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 secret: hey hexo deployCommand: './admin_script/hexo-generate.sh' # expire: 60*1","categories":[{"name":"web","slug":"web","permalink":"https://alonealive.github.io/Blog/categories/web/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alonealive.github.io/Blog/tags/hexo/"}]}]}