<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->






    <link rel="dns-prefetch" href="//cdn1.lncld.net">


<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>Android Q SurfaceFlinger合成（二） | sunwengang blog</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/Blog/img/favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/Blog/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #8E354A;
    }

    a:active, a:focus, a:hover {
        color: #8E354A;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #8E354A;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #8E354A;
    }

    .navbar-link:hover {
        color: #8E354A;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/Blog/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/Blog/css/highlight/arduino-light.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/Blog/css/highlight/arduino-light.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/Blog/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="sunwengang blog"><meta name="msapplication-starturl" content="https://alonealive.github.io/Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sunwengang blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="Android Q SurfaceFlinger合成（二） | sunwengang blog"><meta property="og:site_name" content="sunwengang blog"><meta property="og:type" content="article"><meta property="og:url" content="https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/"><meta property="og:locale" content="zh-CN"><meta name="description" content="继上篇《Android　Ｑ SurfaceFlinger合成（一）》中SF对INVALIDATE信息处理，针对Layer属性变化、显示设备变化等情况处理，将mCurrentState提交到mDrawingState。然后遍历mDrawingState的Layer，将新的Buffer内容更新绑定到Layer纹理对象。经过这些流程，决定是否需要SF进行合成刷新，如果需要则调用handleMessage - sunwengang - sunwengang blog"><meta name="keywords" content="android, graphics, display"><meta property="article:published_time" content="2020-10-31T10:42:00.000Z"><meta property="article:modified_time" content="2020-11-04T13:45:14.666Z"><meta property="og:updated_time" content="2020-11-04T13:45:14.666Z"><meta property="article:author" content="sunwengang"><meta property="article:tag" content="android, graphics, display"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/">

    <meta name="generator" content="Hexo 4.2.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/",
    "@type": "BlogPosting",
    "logo": "https://alonealive.github.io/Blog/img/favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/"
    },
    "headline": "Android Q SurfaceFlinger合成（二） | sunwengang blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://alonealive.github.io/Blog/img/favicon.ico"
    },
    
    "datePublished": "2020-10-31T10:42:00.000Z",
    "dateModified": "2020-11-04T13:45:14.666Z",
    "author": {
        "@type": "Person",
        "name": "sunwengang",
        "image": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/head.jpg"
        },
        "description": "developer | android display/graphics"
    },
    "publisher": {
        "@type": "Organization",
        "name": "sunwengang blog",
        "logo": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://alonealive.github.io/Blog/Blog/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "android, graphics, display",
    "description": "继上篇《Android　Ｑ SurfaceFlinger合成（一）》中SF对INVALIDATE信息处理，针对Layer属性变化、显示设备变化等情况处理，将mCurrentState提交到mDrawingState。然后遍历mDrawingState的Layer，将新的Buffer内容更新绑定到Layer纹理对象。经过这些流程，决定是否需要SF进行合成刷新，如果需要则调用handleMessage - sunwengang - sunwengang blog"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/Blog/">sunwengang blog</a></h1>

    <p class="text-center header-slogan">
        
            
                developer | android display/graphics
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/Blog/" class="navbar-link">首页</a>
    
    
        <a href="/Blog/archives/" class="navbar-link">归档</a>
    
    
        <a href="/Blog/search" class="navbar-link">搜索</a>
    
    
        <a href="/Blog/tags" class="navbar-link">标签</a>
    
        <a href="/Blog/html/nav.html" class="navbar-link">导航</a>
    
        <a href="/Blog/links" class="navbar-link">友链</a>
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=sunwengang blog&url=https://alonealive.github.io/Blog&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=sunwengang blog&url=https://alonealive.github.io/Blog&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog&title=Android Q SurfaceFlinger合成（二）" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=Android Q SurfaceFlinger合成（二）&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog&text=Android Q SurfaceFlinger合成（二）" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACN0lEQVR42u3b0U7sMAxF0f7/T8PrqEp8tssghnj3BTG3tKuoCc5x7vX1D45LpEiRIj8AeRXH6zmrc9PPv56TrrW8r8ixyOVLe/t8BV8hyoEAfkakyNWLfP98eYHNv98fpnrI6r4iRVLk/XyKEynynUjy+erBdg8kUiRB7v7Qp0J2B90Nnk5hI3IukiyifuPr21aLIo9CdhZPu0FFit7dtd6Sqok8CpkmbbqYKiflzYPG+4kciaSFbRWedooI+gsQORdZTci7l7oKWFOQRRdkIuci08v8k7A1TeLVfUTORaYJnC70041Towo1QEWOQHYWUdX3KRBNgwStFkWOQ1bFLIHTgIo0oUTORZLNRtUE/rh4ANcUKTI1MxMqNfBTuNAaOCKPRZImZneRVYX6qVEQUzWRI5ApaE9BKilmO5uWRYokm9jTACPFLC1cRIqk4T558WmYXxUWImcj0cn0os3AChcYIschSUDQLUiqBdmPAyuRRyPTC5wCgxTCpgcrF4AiRyPJRNyBPdkogroPIo9HVmF7CgJI2E+ap9tfiEiRF/vPEyQ8paFU+dAiRyNTSPoEs90AIlIkRNINI1UjkzSaSMEhci4yHbSIII321DRFq0WRxyPTC02DfjJwyAIMp2oij0Z2wyvSQCKI1sAROQ6ZmpVkYHWKilRgixRJG+h0U2g1SEgxLVIkQT4J6tOEXTZDRY5G0qbSk1CBnB93DogcheyE+CQwoEVJbKKKHIn85EOkSJEi//D4BsaWOAat5U7jAAAAAElFTkSuQmCC" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">Android Q SurfaceFlinger合成（二）</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/Blog/img/head.jpg" src="/Blog/img/suka-lazyload.gif" alt="sunwengang's Avatar">
        <span>2020-10-31</span>
        
            <span class="suka-devide-dot"></span>
            <a class="category-link" href="/Blog/categories/android/">android</a>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=Android Q SurfaceFlinger合成（二）&url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=Android Q SurfaceFlinger合成（二）&url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/&title=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=sunwengang blog&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/&text=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACN0lEQVR42u3b0U7sMAxF0f7/T8PrqEp8tssghnj3BTG3tKuoCc5x7vX1D45LpEiRIj8AeRXH6zmrc9PPv56TrrW8r8ixyOVLe/t8BV8hyoEAfkakyNWLfP98eYHNv98fpnrI6r4iRVLk/XyKEynynUjy+erBdg8kUiRB7v7Qp0J2B90Nnk5hI3IukiyifuPr21aLIo9CdhZPu0FFit7dtd6Sqok8CpkmbbqYKiflzYPG+4kciaSFbRWedooI+gsQORdZTci7l7oKWFOQRRdkIuci08v8k7A1TeLVfUTORaYJnC70041Towo1QEWOQHYWUdX3KRBNgwStFkWOQ1bFLIHTgIo0oUTORZLNRtUE/rh4ANcUKTI1MxMqNfBTuNAaOCKPRZImZneRVYX6qVEQUzWRI5ApaE9BKilmO5uWRYokm9jTACPFLC1cRIqk4T558WmYXxUWImcj0cn0os3AChcYIschSUDQLUiqBdmPAyuRRyPTC5wCgxTCpgcrF4AiRyPJRNyBPdkogroPIo9HVmF7CgJI2E+ap9tfiEiRF/vPEyQ8paFU+dAiRyNTSPoEs90AIlIkRNINI1UjkzSaSMEhci4yHbSIII321DRFq0WRxyPTC02DfjJwyAIMp2oij0Z2wyvSQCKI1sAROQ6ZmpVkYHWKilRgixRJG+h0U2g1SEgxLVIkQT4J6tOEXTZDRY5G0qbSk1CBnB93DogcheyE+CQwoEVJbKKKHIn85EOkSJEi//D4BsaWOAat5U7jAAAAAElFTkSuQmCC" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#signalRefresh"><span class="post-toc-number">1.</span> <span class="post-toc-text">signalRefresh</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MessageQueue分发refresh"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">MessageQueue分发refresh</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#handleMessageRefresh刷新总流程"><span class="post-toc-number">2.</span> <span class="post-toc-text">handleMessageRefresh刷新总流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#preComposition合成前预处理"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">preComposition合成前预处理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#rebuildLayerStacks重构Layer栈"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">rebuildLayerStacks重构Layer栈</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#computeVisibleRegions计算可见区域"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">computeVisibleRegions计算可见区域</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#calculateWorkingSet"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">calculateWorkingSet</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#writeStateToHWC设置Layer几何尺寸"><span class="post-toc-number">2.3.1.</span> <span class="post-toc-text">writeStateToHWC设置Layer几何尺寸</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setPerFrameData设置每一层Layer显示数据"><span class="post-toc-number">2.3.2.</span> <span class="post-toc-text">setPerFrameData设置每一层Layer显示数据</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#beginFrame"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">beginFrame</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#prepareFrame准备数据"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">prepareFrame准备数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#doDebugFlashRegions"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">doDebugFlashRegions</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#doComposition合成处理"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">doComposition合成处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#getDirtyRegion获取脏区域"><span class="post-toc-number">2.7.1.</span> <span class="post-toc-text">getDirtyRegion获取脏区域</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#doDisplayComposition合成"><span class="post-toc-number">2.7.2.</span> <span class="post-toc-text">doDisplayComposition合成</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#doComposeSurfaces"><span class="post-toc-number">2.7.2.1.</span> <span class="post-toc-text">*doComposeSurfaces</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#postFramebuffer"><span class="post-toc-number">2.7.3.</span> <span class="post-toc-text">postFramebuffer</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#postComposition"><span class="post-toc-number">2.8.</span> <span class="post-toc-text">postComposition</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#advanceFrame"><span class="post-toc-number">2.8.1.</span> <span class="post-toc-text">advanceFrame</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#GPU合成模块概述"><span class="post-toc-number">3.</span> <span class="post-toc-text">GPU合成模块概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建RenderEngine"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">创建RenderEngine</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建Surface-FBTarget"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">创建Surface FBTarget</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#创建Texture纹理"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">创建Texture纹理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#绑定Texture纹理"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">绑定Texture纹理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Layer合成"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">Layer合成</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文章"><span class="post-toc-number">4.</span> <span class="post-toc-text">参考文章</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <blockquote>
<p>继上篇《Android　Ｑ SurfaceFlinger合成（一）》中SF对INVALIDATE信息处理，针对Layer属性变化、显示设备变化等情况处理，将mCurrentState提交到mDrawingState。然后遍历mDrawingState的Layer，将新的Buffer内容更新绑定到Layer纹理对象。经过这些流程，决定是否需要SF进行合成刷新，如果需要则调用<code>handleMessageRefresh</code>开始合成处理。</p>
</blockquote>
<a id="more"></a>

<h2 id="signalRefresh"><a href="#signalRefresh" class="headerlink" title="signalRefresh"></a>signalRefresh</h2><p>在onMessageReceivedINVALIDATE信息处理完成后，如果需要刷新，则会触发刷新：</p>
<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            ......</span><br><span class="line">            refreshNeeded |= mRepaintEverything;</span><br><span class="line">            <span class="comment">//在BootStage:：BOOTLOADER中时不要调用signalRefresh，不想用一个空白屏幕代替bootloader引导加载程序启动。</span></span><br><span class="line">            <span class="comment">//这样可以节省HWC不必要的工作</span></span><br><span class="line">            <span class="keyword">if</span> (refreshNeeded &amp;&amp; CC_LIKELY(mBootStage != BootStage::BOOTLOADER)) &#123;</span><br><span class="line">                <span class="comment">//如果事务修改了窗口状态，新的Buffer被获取到，或者HWC已经请求一个新的repaint，则发出刷新信号</span></span><br><span class="line">                signalRefresh();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::signalRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRefreshPending = <span class="literal">true</span>;</span><br><span class="line">    mEventQueue.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要刷新的情况：</strong></p>
<ol>
<li>有新的Transaction处理</li>
<li>PageFlip时，有Buffer更新</li>
<li>有重新合成请求时mRepaintEverything，这是响应HWC的请求时触发的。</li>
</ol>
<h3 id="MessageQueue分发refresh"><a href="#MessageQueue分发refresh" class="headerlink" title="MessageQueue分发refresh"></a>MessageQueue分发refresh</h3><figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MessageQueue::refresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler-&gt;dispatchRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchRefresh() &#123;</span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskRefresh, &amp;mEventMask) &amp; eventMaskRefresh) == <span class="number">0</span>) &#123;</span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::REFRESH));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终回调handleMessage，处理REFRESH的message</span></span><br><span class="line"><span class="comment">//这过程中不用去等Vsync的，INVALIDATE时，是需要等Vsync的</span></span><br><span class="line"><span class="comment">//即INVALIDATE和REFRESH是在同一个Vsync周期内完成的</span></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="handleMessageRefresh刷新总流程"><a href="#handleMessageRefresh刷新总流程" class="headerlink" title="handleMessageRefresh刷新总流程"></a>handleMessageRefresh刷新总流程</h2><p>handleMessageRefresh函数包含了刷新（合成）一帧显示数据的所有流程。</p>
<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onMessageReceived</span><span class="params">(<span class="keyword">int32_t</span> what)</span> NO_THREAD_SAFETY_ANALYSIS </span>&#123;</span><br><span class="line">    ATRACE_CALL();d</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">            handleMessageRefresh();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleMessageRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = mRepaintEverything.exchange(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//合成前预处理工作</span></span><br><span class="line">    preComposition();</span><br><span class="line">    <span class="comment">//计算和存储每个Layer的脏区域</span></span><br><span class="line">    rebuildLayerStacks();</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    calculateWorkingSet();<span class="comment">//和P不同</span></span><br><span class="line">    <span class="comment">//遍历Display</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, display] : mDisplays) &#123;</span><br><span class="line">        beginFrame(display);<span class="comment">//和P不同</span></span><br><span class="line">        prepareFrame(display); <span class="comment">//和P不同</span></span><br><span class="line">        doDebugFlashRegions(display, repaintEverything);</span><br><span class="line">        <span class="comment">//先进行GL合成，将合成后的的图像放在HWC任务列表的最后为止</span></span><br><span class="line">        <span class="comment">//然后由HWC进行合成并输出到屏幕</span></span><br><span class="line">        doComposition(display, repaintEverything);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logLayerStats();</span><br><span class="line"></span><br><span class="line">    postFrame();</span><br><span class="line">    <span class="comment">//合成善后工作</span></span><br><span class="line">    postComposition();</span><br><span class="line"></span><br><span class="line">    mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line">    mHadDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">        mHadClientComposition =</span><br><span class="line">                mHadClientComposition || getHwComposer().hasClientComposition(displayId);</span><br><span class="line">        mHadDeviceComposition =</span><br><span class="line">                mHadDeviceComposition || getHwComposer().hasDeviceComposition(displayId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mVsyncModulator.onRefreshed(mHadClientComposition);</span><br><span class="line">    mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="preComposition合成前预处理"><a href="#preComposition合成前预处理" class="headerlink" title="preComposition合成前预处理"></a>preComposition合成前预处理</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::preComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"preComposition"</span>);</span><br><span class="line"></span><br><span class="line">    mRefreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//遍历所有需要进行合成的Layer（mDrawingState）</span></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">//调用onPreComposition，但绘制</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;onPreComposition(mRefreshStartTime)) &#123;</span><br><span class="line">            needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//通过上述函数的返回值来判断是否需要再次触发SurfaceFlinger接受Vsync合成</span></span><br><span class="line">    <span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">        signalLayerUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>onPreComposition</code>函数的返回值针对不同Layer：</p>
<ul>
<li>ColorLayer和ContainLayer固定返回false</li>
<li>BufferLayer如下：</li>
</ul>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/BufferLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::onPreComposition</span><span class="params">(<span class="keyword">nsecs_t</span> refreshStartTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mBufferLatched) &#123;</span><br><span class="line">        <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mFrameEventHistoryMutex)</span></span>;</span><br><span class="line">        <span class="comment">//mFrameEventHistory记录PreComposition事件</span></span><br><span class="line">        mFrameEventHistory.addPreComposition(mCurrentFrameNumber, refreshStartTime);</span><br><span class="line">    &#125;</span><br><span class="line">    mRefreshPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> hasReadyFrame();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::hasReadyFrame</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasFrameUpdate() || getSidebandStreamChanged() || getAutoRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//****** BufferQueueLayer.cpp **********</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferQueueLayer::hasFrameUpdate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//之前在acquireBuffer的时候已经做了-1操作，而此处是现在BufferQueue中还有Buffer</span></span><br><span class="line">    <span class="comment">//（即仍有待处理的Buffer，就需要下次Vsync到来的时候再次执行合成）</span></span><br><span class="line">    <span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferQueueLayer::getSidebandStreamChanged</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//SidebandStream改变</span></span><br><span class="line">    <span class="keyword">return</span> mSidebandStreamChanged;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferQueueLayer::getAutoRefresh</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自动刷新模式</span></span><br><span class="line">    <span class="keyword">return</span> mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="rebuildLayerStacks重构Layer栈"><a href="#rebuildLayerStacks重构Layer栈" class="headerlink" title="rebuildLayerStacks重构Layer栈"></a>rebuildLayerStacks重构Layer栈</h3><p>执行该函数，将完成创建Layer栈。</p>
<p>此时需要进行合成显示的数据已经被更新到每个Display各自的<code>layersSortedByZ</code>中。</p>
<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::invalidateHwcGeometry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mGeometryInvalid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::rebuildLayerStacks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"rebuildLayerStacks"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line">    <span class="comment">// 前提是存在脏区域，即mVisibleRegionsDirty为true</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">"rebuildLayerStacks VR Dirty"</span>);</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//重置mGeometryInvalid标记</span></span><br><span class="line">        invalidateHwcGeometry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个屏幕，因为每个Display是分开合成的</span></span><br><span class="line">        <span class="comment">//根据显示屏的特性，分别进行合成，合成后的数据也送给各自的显示屏</span></span><br><span class="line">        <span class="comment">//mDisplays是当前系统中的显示屏</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : mDisplays) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">                <span class="comment">//计算屏幕的脏区域、每个Layer的可见区域、被覆盖的区域、可见非透明区域（见下面一小节）</span></span><br><span class="line">                computeVisibleRegions(displayDevice, dirtyRegion, opaqueRegion);</span><br><span class="line">                <span class="comment">//正序遍历mDrawingState合成列表的layer</span></span><br><span class="line">                <span class="comment">//和当前的显示设备进行比较，Layer的脏区域是否在显示设备的显示区域内</span></span><br><span class="line">                <span class="comment">//如果在显示区域内的话说明该layer是需要更新的，则更新到显示设备的`VisibleLayersSortedByZ`列表中，等待被合成</span></span><br><span class="line">                mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="keyword">auto</span> compositionLayer = layer-&gt;getCompositionLayer();</span><br><span class="line">                    <span class="keyword">if</span> (compositionLayer == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = displayDevice-&gt;getId();</span><br><span class="line">                    sp&lt;compositionengine::LayerFE&gt; layerFE = compositionLayer-&gt;getLayerFE();</span><br><span class="line">                    LOG_ALWAYS_FATAL_IF(layerFE.get() == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">bool</span> needsOutputLayer = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">//计算Layer需要绘制的区域drawRegion</span></span><br><span class="line">                    <span class="keyword">if</span> (display-&gt;belongsInOutput(layer-&gt;getLayerStack(),</span><br><span class="line">                                                 layer-&gt;getPrimaryDisplayOnly())) &#123;</span><br><span class="line">                        Region drawRegion(tr.transform(</span><br><span class="line">                                layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                        <span class="comment">//将Layer的可见区域和Display大小做交集</span></span><br><span class="line">                        drawRegion.andSelf(bounds);</span><br><span class="line">                        <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                            needsOutputLayer = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//drawRegion不为空，将该Layer加到当前Display的Layer列表中</span></span><br><span class="line">                    <span class="keyword">if</span> (needsOutputLayer) &#123;</span><br><span class="line">                        layersSortedByZ.emplace_back(</span><br><span class="line">                                display-&gt;getOrCreateOutputLayer(displayId, compositionLayer,</span><br><span class="line">                                                                layerFE));</span><br><span class="line">                        deprecated_layersSortedByZ.add(layer);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">auto</span>&amp; outputLayerState = layersSortedByZ.back()-&gt;editState();</span><br><span class="line">                        outputLayerState.visibleRegion =</span><br><span class="line">                                tr.transform(layer-&gt;visibleRegion.intersect(displayState.viewport));</span><br><span class="line">                    <span class="comment">//之前Layer可见，现在不可见，将销毁掉HWC Layer</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">                        <span class="comment">//对于正在从HWC Display中移除的和已经排队的帧的那些Layer，将他们添加到一个发布的Layer列表中，以便可以设置一个fence</span></span><br><span class="line">                        <span class="keyword">bool</span> hasExistingOutputLayer =</span><br><span class="line">                                display-&gt;getOutputLayerForLayer(compositionLayer.get()) != <span class="literal">nullptr</span>;</span><br><span class="line">                        <span class="keyword">bool</span> hasQueuedFrames = <span class="built_in">std</span>::find(mLayersWithQueuedFrames.cbegin(),</span><br><span class="line">                                                         mLayersWithQueuedFrames.cend(),</span><br><span class="line">                                                         layer) != mLayersWithQueuedFrames.cend();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (hasExistingOutputLayer &amp;&amp; hasQueuedFrames) &#123;</span><br><span class="line">                            <span class="comment">//销毁掉的Layer放置到layersNeedingFences中</span></span><br><span class="line">                            <span class="comment">//虽然不需要releaseFence，但是还是需要fence去释放旧的Buffer</span></span><br><span class="line">                            layersNeedingFences.add(layer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;); <span class="comment">//遍历Layer结束</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后将数据更新到DisplayDevice中</span></span><br><span class="line">            display-&gt;setOutputLayersOrderedByZ(<span class="built_in">std</span>::move(layersSortedByZ));</span><br><span class="line"></span><br><span class="line">            displayDevice-&gt;setVisibleLayersSortedByZ(deprecated_layersSortedByZ);</span><br><span class="line">            displayDevice-&gt;setLayersNeedingFences(layersNeedingFences);</span><br><span class="line"></span><br><span class="line">            Region undefinedRegion&#123;bounds&#125;;</span><br><span class="line">            undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line"></span><br><span class="line">            display-&gt;editState().undefinedRegion = undefinedRegion;</span><br><span class="line">            display-&gt;editState().dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">        &#125;<span class="comment">//遍历Display结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="computeVisibleRegions计算可见区域"><a href="#computeVisibleRegions计算可见区域" class="headerlink" title="computeVisibleRegions计算可见区域"></a>computeVisibleRegions计算可见区域</h4><p>代码包含注解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outOpaqueRegion是屏幕的非透明区域</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::computeVisibleRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Region&amp; outDirtyRegion, Region&amp; outOpaqueRegion)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"computeVisibleRegions"</span>);</span><br><span class="line">    <span class="comment">//获取当前合成显示屏的display</span></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="comment">//针对当前整个Display！</span></span><br><span class="line">    <span class="comment">//当前Layer上层所有Layer不透明区域的累加</span></span><br><span class="line">    Region aboveOpaqueLayers;</span><br><span class="line">    <span class="comment">//当前Layer上层所有Layer可见区域的累加</span></span><br><span class="line">    Region aboveCoveredLayers;</span><br><span class="line">    <span class="comment">//脏区域</span></span><br><span class="line">    Region dirty;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清空屏幕脏区域（每个Layer脏区域的和），将计算好的区域值设置到Layer中</span></span><br><span class="line">    outDirtyRegion.clear();</span><br><span class="line">    <span class="comment">//反序号遍历，即从最上面layer层开始遍历</span></span><br><span class="line">    mDrawingState.traverseInReverseZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="comment">// start with the whole surface at its current location</span></span><br><span class="line">        <span class="keyword">const</span> Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">        <span class="comment">// layerStackId必须匹配</span></span><br><span class="line">        <span class="keyword">if</span> (!display-&gt;belongsInOutput(layer-&gt;getLayerStack(), layer-&gt;getPrimaryDisplayOnly())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//针对每个Layer！</span></span><br><span class="line">        <span class="comment">//完全不透明区域</span></span><br><span class="line">        Region opaqueRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可见区域（屏幕上可见的Surface区域，而且是不完全透明）</span></span><br><span class="line">        <span class="comment">//包含半透明区域：半透明Surface覆盖的区域被视为可见</span></span><br><span class="line">        Region visibleRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//覆盖区域：被全部覆盖的Surface区域（包括被透明区域覆盖的区域）</span></span><br><span class="line">        Region coveredRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完全透明区域：Surface完全透明的部分，如果没有可见的非透明区域，这个Layer就可以从Layer列表中删除</span></span><br><span class="line">        <span class="comment">//并且不会影响该Layer本身或其下方layer的可见区域大小</span></span><br><span class="line">        <span class="comment">//这个区域可能不太准，因为有的APP不遵守SurfaceView的限制</span></span><br><span class="line">        Region transparentRegion;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过将可见区域设置为空来处理隐藏的Surface</span></span><br><span class="line">        <span class="keyword">if</span> (CC_LIKELY(layer-&gt;isVisible())) &#123;</span><br><span class="line">            <span class="comment">//isOpaque表示Lyaer是非透明的Layer（上层应用层设置）</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> translucent = !layer-&gt;isOpaque(s);</span><br><span class="line">            <span class="comment">//获取Layer在屏幕上的大小</span></span><br><span class="line">            <span class="comment">//注：activeWidth和activeHeight是Layer本身的大小,用win表示</span></span><br><span class="line">            <span class="comment">//crop是Layer的源剪截区域，由上层设置，表示该Layer只截取crop的区域进行合成显示。可能比win大也可能小，需要取交集，截取重复的部分</span></span><br><span class="line">            Rect bounds(layer-&gt;getScreenBounds());</span><br><span class="line">            <span class="comment">//即上面返回Layer大小设置为可见区域，但是后续还会被裁剪</span></span><br><span class="line">            visibleRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">            <span class="comment">//Layer的变换矩阵，例如旋转，适配显示屏幕</span></span><br><span class="line">            ui::Transform tr = layer-&gt;getTransform();</span><br><span class="line">            <span class="comment">//可见区域不为空（一般情况下，如果layer是非透明的，非透明区域就是可见区域）</span></span><br><span class="line">            <span class="keyword">if</span> (!visibleRegion.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 从可见区域移除完全透明区域</span></span><br><span class="line">                <span class="keyword">if</span> (translucent) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tr.preserveRects()) &#123;</span><br><span class="line">                        <span class="comment">// transform the transparent region</span></span><br><span class="line">                        transparentRegion = tr.transform(layer-&gt;getActiveTransparentRegion(s));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//转型太复杂，不能做到透明区域优化</span></span><br><span class="line">                        transparentRegion.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算不透明区域</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int32_t</span> layerOrientation = tr.getOrientation();</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;getAlpha() == <span class="number">1.0f</span> &amp;&amp; !translucent &amp;&amp;</span><br><span class="line">                        layer-&gt;getRoundedCornerState().radius == <span class="number">0.0f</span> &amp;&amp;</span><br><span class="line">                        ((layerOrientation &amp; ui::Transform::ROT_INVALID) == <span class="literal">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// the opaque region is the layer's footprint</span></span><br><span class="line">                    opaqueRegion = visibleRegion;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 将覆盖区域剪辑到可见区域</span></span><br><span class="line">        <span class="comment">//遍历时，第一层时，aboveCoveredLayers为空，coveredRegion也是为空，最上面一层是没有被覆盖的，当然为空</span></span><br><span class="line">        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为下一个（底）layer更新aboveCoveredLayers</span></span><br><span class="line">        <span class="comment">//更新aboveCoveredLayers，该层之下的Layer都被该层Layer覆盖，所以这里和可见区域做一个或操纵，最下面的区域被覆盖的越大</span></span><br><span class="line">        aboveCoveredLayers.orSelf(visibleRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//减去在我aboveOpaqueLayers覆盖的不透明区域</span></span><br><span class="line">        <span class="comment">//可见区域要减掉该层之上的非透明区域</span></span><br><span class="line">        visibleRegion.subtractSelf(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算Layer的脏区域</span></span><br><span class="line">        <span class="comment">// contentDirty表示包含脏区域内容，即Layer的可见区域被修改了</span></span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;contentDirty) &#123;</span><br><span class="line">            <span class="comment">//需要使整个地区无效</span></span><br><span class="line">            dirty = visibleRegion;</span><br><span class="line">            <span class="comment">//以及旧的可见区域</span></span><br><span class="line">            dirty.orSelf(layer-&gt;visibleRegion);</span><br><span class="line">            layer-&gt;contentDirty = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//计算暴露出来的区域 exposedRegion</span></span><br><span class="line">            <span class="comment">//包含两部分：1.之前被覆盖的区域，现在可见了；2.现在暴露的比之前的少</span></span><br><span class="line">            <span class="comment">//注：1是从整体的可见区域开始，但是只保留以前被覆盖的区域（现在暴露了）；2是处理那种因为重新调整了大小从而暴露出来的区域</span></span><br><span class="line">            <span class="keyword">const</span> Region newExposed = visibleRegion - coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldVisibleRegion = layer-&gt;visibleRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldCoveredRegion = layer-&gt;coveredRegion;</span><br><span class="line">            <span class="keyword">const</span> Region oldExposed = oldVisibleRegion - oldCoveredRegion;</span><br><span class="line">            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);</span><br><span class="line">        &#125;</span><br><span class="line">        dirty.subtractSelf(aboveOpaqueLayers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//累计到屏幕脏区域</span></span><br><span class="line">        outDirtyRegion.orSelf(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新opaqueRegion到aboveOpaqueLayers，为下面（底）的Layer做准备</span></span><br><span class="line">        aboveOpaqueLayers.orSelf(opaqueRegion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在屏幕空间保存可见区域</span></span><br><span class="line">        <span class="comment">//设置可见区域</span></span><br><span class="line">        layer-&gt;setVisibleRegion(visibleRegion);</span><br><span class="line">        <span class="comment">//设置被覆盖的区域</span></span><br><span class="line">        layer-&gt;setCoveredRegion(coveredRegion);</span><br><span class="line">        <span class="comment">//设置可见的非透明区域（=可见区域-透明区域）</span></span><br><span class="line">        layer-&gt;setVisibleNonTransparentRegion(</span><br><span class="line">                visibleRegion.subtract(transparentRegion));</span><br><span class="line">    &#125;);  <span class="comment">//遍历结束</span></span><br><span class="line">    <span class="comment">//屏幕的非透明区域</span></span><br><span class="line">    outOpaqueRegion = aboveOpaqueLayers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="calculateWorkingSet"><a href="#calculateWorkingSet" class="headerlink" title="calculateWorkingSet"></a>calculateWorkingSet</h3><p>在Android P中是用的<code>setUpHWComposer</code>函数，Q升级后将其分成几个单独的函数。以下是第一个：</p>
<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::calculateWorkingSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(__FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建H/W工作列表（判断变量在rebuildLayerStacks中变动）</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mGeometryInvalid)) &#123;</span><br><span class="line">        <span class="comment">//重置</span></span><br><span class="line">        mGeometryInvalid = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历Display</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">            <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> zOrder = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历Layer</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123;</span><br><span class="line">                <span class="comment">//**调用CompositionEngine/src/OutputLayer.cpp返回mState</span></span><br><span class="line">                <span class="keyword">auto</span>&amp; compositionState = layer-&gt;editState();</span><br><span class="line">                <span class="comment">//forceClientComposition指强制GPU合成（Client）</span></span><br><span class="line">                <span class="comment">//mDebugDisableHWC指开发者选项的“停用HWC叠加层”，mDebugRegion指调试Region</span></span><br><span class="line">                compositionState.forceClientComposition = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!compositionState.hwc || mDebugDisableHWC || mDebugRegion) &#123;</span><br><span class="line">                    compositionState.forceClientComposition = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出的z顺序值是一个简单的计数器设置</span></span><br><span class="line">                compositionState.z = zOrder++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新Display自己的合成状态</span></span><br><span class="line">                layer-&gt;getLayerFE().latchCompositionState(layer-&gt;getLayer().editState().frontEnd,</span><br><span class="line">                                                          <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//重新计算输出output layer的合成状态</span></span><br><span class="line">                layer-&gt;updateCompositionState(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//写入到HWC，该函数会设置Layer的几何尺寸（见下一小节该函数释义）</span></span><br><span class="line">                layer-&gt;writeStateToHWC(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置每层Layer的frame帧数据</span></span><br><span class="line">    <span class="comment">//遍历Display</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line">        <span class="keyword">if</span> (!displayId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span>* profile = display-&gt;getDisplayColorProfile();</span><br><span class="line">        <span class="comment">//设置颜色矩阵</span></span><br><span class="line">        <span class="keyword">if</span> (mDrawingState.colorMatrixChanged) &#123;</span><br><span class="line">            display-&gt;setColorTransform(mDrawingState.colorMatrix);</span><br><span class="line">        &#125;</span><br><span class="line">        Dataspace targetDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="keyword">if</span> (useColorManagement) &#123;</span><br><span class="line">            ColorMode colorMode;</span><br><span class="line">            RenderIntent renderIntent;</span><br><span class="line">            pickColorMode(displayDevice, &amp;colorMode, &amp;targetDataspace, &amp;renderIntent);</span><br><span class="line">            <span class="comment">//设置色彩模式</span></span><br><span class="line">            display-&gt;setColorMode(colorMode, targetDataspace, renderIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可见layer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="comment">//根据layer的数据空间dataSpace（通过dump SurfaceFlinger可以查看到）来设置layer的合成方式</span></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;isHdrY410()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(displayDevice);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((layer-&gt;getDataSpace() == Dataspace::BT2020_PQ ||</span><br><span class="line">                        layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_PQ) &amp;&amp;</span><br><span class="line">                       !profile-&gt;hasHDR10Support()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(displayDevice);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((layer-&gt;getDataSpace() == Dataspace::BT2020_HLG ||</span><br><span class="line">                        layer-&gt;getDataSpace() == Dataspace::BT2020_ITU_HLG) &amp;&amp;</span><br><span class="line">                       !profile-&gt;hasHLGSupport()) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(displayDevice);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getRoundedCornerState().radius &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                layer-&gt;forceClientComposition(displayDevice);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getForceClientComposition(displayDevice)) &#123;</span><br><span class="line">                ALOGV(<span class="string">"[%s] Requesting Client composition"</span>, layer-&gt;getName().<span class="built_in">string</span>());</span><br><span class="line">                <span class="comment">//设置合成方式GPU合成</span></span><br><span class="line">                layer-&gt;setCompositionType(displayDevice,</span><br><span class="line">                                          Hwc2::IComposerClient::Composition::CLIENT);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置每一层Layer的显示数据</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">            layer-&gt;setPerFrameData(displayDevice, displayState.transform, displayState.viewport,</span><br><span class="line">                                   displayDevice-&gt;getSupportedPerFrameMetadata(),</span><br><span class="line">                                   isHdrColorMode(displayState.colorMode) ? Dataspace::UNKNOWN</span><br><span class="line">                                                                          : targetDataspace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrawingState.colorMatrixChanged = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [token, displayDevice] : mDisplays) &#123;</span><br><span class="line">        <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; layerState = layer-&gt;getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line">            layerState.compositionType = <span class="keyword">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(</span><br><span class="line">                    layer-&gt;getCompositionType(displayDevice));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>颜色矩阵如下，可以在开发这选项中设置，有<code>模拟颜色空间</code>选项。其支持的transform主要有：</strong></p>
<figure class="highlight cpp"><figcaption><span>system/core/libsystem/include/system/graphics-base-v1.0.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    HAL_COLOR_TRANSFORM_IDENTITY = <span class="number">0</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_ARBITRARY_MATRIX = <span class="number">1</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_VALUE_INVERSE = <span class="number">2</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_GRAYSCALE = <span class="number">3</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_PROTANOPIA = <span class="number">4</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_DEUTERANOPIA = <span class="number">5</span>,</span><br><span class="line">    HAL_COLOR_TRANSFORM_CORRECT_TRITANOPIA = <span class="number">6</span>,</span><br><span class="line">&#125; <span class="keyword">android_color_transform_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="writeStateToHWC设置Layer几何尺寸"><a href="#writeStateToHWC设置Layer几何尺寸" class="headerlink" title="writeStateToHWC设置Layer几何尺寸"></a>writeStateToHWC设置Layer几何尺寸</h4><p>OutputLayer.cpp是Android新分离出来的文件，writeStateToHWC函数也是分离成一个单独的函数，以供SurfaceFlinger的calculateWorkingSet函数调用。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/src/OutputLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputLayer::writeStateToHWC</span><span class="params">(<span class="keyword">bool</span> includeGeometry)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Skip doing this if there is no HWC interface</span></span><br><span class="line">    <span class="comment">//此处的State数据是来源于DrawingState</span></span><br><span class="line">    <span class="keyword">if</span> (!mState.hwc) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = (*mState.hwc).hwcLayer;</span><br><span class="line">    <span class="keyword">if</span> (!hwcLayer) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] failed to write composition state to HWC -- no hwcLayer for output %s"</span>,</span><br><span class="line">              mLayerFE-&gt;getDebugName(), mOutput.getName().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (includeGeometry) &#123;</span><br><span class="line">        <span class="comment">//输出依赖状态 Output dependent state</span></span><br><span class="line">        <span class="comment">//计算DisplayFrame</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;setDisplayFrame(mState.displayFrame);</span><br><span class="line">            error != HWC2::Error::None) &#123;... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算SourceCrop</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;setSourceCrop(mState.sourceCrop); error != HWC2::Error::None) &#123;</span><br><span class="line">            ... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置zOrder</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;setZOrder(mState.z); error != HWC2::Error::None) &#123;</span><br><span class="line">            ... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置transform旋转</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error =</span><br><span class="line">                    hwcLayer-&gt;setTransform(<span class="keyword">static_cast</span>&lt;HWC2::Transform&gt;(mState.bufferTransform));</span><br><span class="line">            error != HWC2::Error::None) &#123;</span><br><span class="line">            ... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出独立状态 Output independent state</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>&amp; outputIndependentState = mLayer-&gt;getState().frontEnd;</span><br><span class="line">        <span class="comment">//设置图层混合模式（见https://developer.android.google.cn/reference/android/graphics/BlendMode）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;setBlendMode(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;HWC2::BlendMode&gt;(outputIndependentState.blendMode));</span><br><span class="line">            error != HWC2::Error::None) &#123;</span><br><span class="line">            ... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置Alpha透明度</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error = hwcLayer-&gt;setPlaneAlpha(outputIndependentState.alpha);</span><br><span class="line">            error != HWC2::Error::None) &#123;</span><br><span class="line">            ... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置Layer信息</span></span><br><span class="line">        <span class="comment">//type和appId是Android Framework层创建SurfaceControl时设置的</span></span><br><span class="line">        <span class="comment">//其中type包含ScreenshotSurface、Background等</span></span><br><span class="line">        <span class="comment">//appId是应用进程号</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> error =</span><br><span class="line">                    hwcLayer-&gt;setInfo(outputIndependentState.type, outputIndependentState.appId);</span><br><span class="line">            error != HWC2::Error::None) &#123;</span><br><span class="line">            A... <span class="comment">//log打印</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>setBlendModes</code>设置混合模式（两个Layer直接的混合方式），主要有以下几种：</p>
<figure class="highlight cpp"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Blend modes, settable per layer */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    HWC2_BLEND_MODE_INVALID = <span class="number">0</span>, </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc */</span></span><br><span class="line">    HWC2_BLEND_MODE_NONE = <span class="number">1</span>,  <span class="comment">//不混合，源和输出不变</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc + colorDst * (1 - alphaSrc) */</span></span><br><span class="line">    HWC2_BLEND_MODE_PREMULTIPLIED = <span class="number">2</span>,  <span class="comment">//预乘，Dst需要做Alpha的处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* colorOut = colorSrc * alphaSrc + colorDst * (1 - alphaSrc) */</span></span><br><span class="line">    HWC2_BLEND_MODE_COVERAGE = <span class="number">3</span>, <span class="comment">//覆盖方式，源和Dst都需要做Alpha透明度的处理</span></span><br><span class="line">&#125; <span class="keyword">hwc2_blend_mode_t</span>;</span><br></pre></td></tr></table></figure>

<h4 id="setPerFrameData设置每一层Layer显示数据"><a href="#setPerFrameData设置每一层Layer显示数据" class="headerlink" title="setPerFrameData设置每一层Layer显示数据"></a>setPerFrameData设置每一层Layer显示数据</h4><ol>
<li><code>ColorLayer::setPerFrameData</code></li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/ColorLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ColorLayer::setPerFrameData</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; display,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> ui::Transform&amp; transform, <span class="keyword">const</span> Rect&amp; viewport,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int32_t</span> <span class="comment">/* supportedPerFrameMetadata */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> ui::Dataspace targetDataspace)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//设置可见区域，之前已经计算好，但是此处需要确保可见区域在Display的窗口内</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setVisibleRegion(visible);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//设置数据空间</span></span><br><span class="line">    error = hwcLayer-&gt;setDataspace(dataspace);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line">    layerCompositionState.dataspace = mCurrentDataSpace;</span><br><span class="line">    <span class="comment">//设置RGB颜色，Alpha默认255（全透明）</span></span><br><span class="line">    half4 color = getColor();</span><br><span class="line">    error = hwcLayer-&gt;setColor(&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.r)),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.g)),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.b)), <span class="number">255</span>&#125;);</span><br><span class="line">    ...</span><br><span class="line">    layerCompositionState.color = &#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.r)),</span><br><span class="line">                                   <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.g)),</span><br><span class="line">                                   <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(<span class="built_in">std</span>::round(<span class="number">255.0f</span> * color.b)), <span class="number">255</span>&#125;;</span><br><span class="line">    <span class="comment">//色彩ColorLayer不需要变换矩阵，清除掉</span></span><br><span class="line">    error = hwcLayer-&gt;setTransform(HWC2::Transform::None);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] Failed to clear transform: %s (%d)"</span>, mName.<span class="built_in">string</span>(), to_string(error).c_str(),</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    error = hwcLayer-&gt;setColorTransform(getColorTransform());</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] Failed to setColorTransform: %s (%d)"</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line">    layerCompositionState.colorTransform = getColorTransform();</span><br><span class="line"></span><br><span class="line">    error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion);</span><br><span class="line">    <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] Failed to set surface damage: %s (%d)"</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">              to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        surfaceDamageRegion.dump(LOG_TAG);</span><br><span class="line">    &#125;</span><br><span class="line">    layerCompositionState.surfaceDamage = surfaceDamageRegion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>BufferLayer::setPerFrameData</code></li>
</ol>
<p>BufferLayer的处理比ColorLayer多，Sideband，Cursor和其他的UI图层都属于BufferLayer，每种类型Layer处理都不同。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/BufferLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BufferLayer::setPerFrameData</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> ui::Transform&amp; transform, <span class="keyword">const</span> Rect&amp; viewport,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int32_t</span> supportedPerFrameMetadata,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> ui::Dataspace targetDataspace)</span> </span>&#123;</span><br><span class="line">    RETURN_IF_NO_HWC_LAYER(displayDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在给HWC HAL层前，设置Display的投影的viewport给可见区域</span></span><br><span class="line">    Region visible = transform.transform(visibleRegion.intersect(viewport));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> outputLayer = findOutputLayerForDisplay(displayDevice);</span><br><span class="line">    LOG_FATAL_IF(!outputLayer || !outputLayer-&gt;getState().hwc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = (*outputLayer-&gt;getState().hwc).hwcLayer;</span><br><span class="line">    <span class="comment">//设置可见区域</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcLayer-&gt;setVisibleRegion(visible);</span><br><span class="line">    outputLayer-&gt;editState().visibleRegion = visible;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; layerCompositionState = getCompositionLayer()-&gt;editState().frontEnd;</span><br><span class="line">    <span class="comment">//设置Damage区域</span></span><br><span class="line">    error = hwcLayer-&gt;setSurfaceDamage(surfaceDamageRegion);</span><br><span class="line">    layerCompositionState.surfaceDamage = surfaceDamageRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sideband layers处理，默认为SIDEBAND合成</span></span><br><span class="line">    <span class="keyword">if</span> (layerCompositionState.sidebandStream.get()) &#123;</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::SIDEBAND);</span><br><span class="line">        ALOGV(<span class="string">"[%s] Requesting Sideband composition"</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        error = hwcLayer-&gt;setSidebandStream(layerCompositionState.sidebandStream-&gt;handle());</span><br><span class="line">        layerCompositionState.compositionType = Hwc2::IComposerClient::Composition::SIDEBAND;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Device or Cursor layers</span></span><br><span class="line">    <span class="comment">//如果是Cursor Layer，则合成方式为CURSOR，其他为DEVICE合成</span></span><br><span class="line">    <span class="keyword">if</span> (mPotentialCursor) &#123;</span><br><span class="line">        ALOGV(<span class="string">"[%s] Requesting Cursor composition"</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CURSOR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGV(<span class="string">"[%s] Requesting Device composition"</span>, mName.<span class="built_in">string</span>());</span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::DEVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ui::Dataspace dataspace = isColorSpaceAgnostic() &amp;&amp; targetDataspace != ui::Dataspace::UNKNOWN</span><br><span class="line">            ? targetDataspace</span><br><span class="line">            : mCurrentDataSpace;</span><br><span class="line">    <span class="comment">//设置数据空间</span></span><br><span class="line">    error = hwcLayer-&gt;setDataspace(dataspace);</span><br><span class="line">    <span class="comment">//HDR</span></span><br><span class="line">    <span class="keyword">const</span> HdrMetadata&amp; metadata = getDrawingHdrMetadata();</span><br><span class="line">    error = hwcLayer-&gt;setPerFrameMetadata(supportedPerFrameMetadata, metadata);</span><br><span class="line">    <span class="comment">//设置色彩矩阵</span></span><br><span class="line">    error = hwcLayer-&gt;setColorTransform(getColorTransform());</span><br><span class="line">    <span class="keyword">if</span> (error == HWC2::Error::Unsupported) &#123;</span><br><span class="line">        <span class="comment">//如果每个layer的色彩矩阵都不支持，则使用GPU合成（CLIENT）</span></span><br><span class="line">        setCompositionType(displayDevice, Hwc2::IComposerClient::Composition::CLIENT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error != HWC2::Error::None) &#123;</span><br><span class="line">        ALOGE(<span class="string">"[%s] Failed to setColorTransform: %s (%d)"</span>, mName.<span class="built_in">string</span>(),</span><br><span class="line">                to_string(error).c_str(), <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">    &#125;</span><br><span class="line">    layerCompositionState.dataspace = mCurrentDataSpace;</span><br><span class="line">    layerCompositionState.colorTransform = getColorTransform();</span><br><span class="line">    layerCompositionState.hdrMetadata = metadata;</span><br><span class="line"></span><br><span class="line">    setHwcLayerBuffer(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="beginFrame"><a href="#beginFrame" class="headerlink" title="beginFrame"></a>beginFrame</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::beginFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> dirty = !display-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = displayDevice-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !displayState.lastCompositionHadVisibleLayers;</span><br><span class="line">    <span class="comment">//判断是否需要重新合成：</span></span><br><span class="line">    <span class="comment">//如果没有变化（即没有脏区域），不需要重新合成；</span></span><br><span class="line">    <span class="comment">//如果有一些变化，但是当前没有任何可见的Layers，并且最近一次的合成也没有，则跳过这次合成；</span></span><br><span class="line">    <span class="comment">//第二条判断做了以下两件事：</span></span><br><span class="line">    <span class="comment">//1.当所有layers从该Display被移除，我们将发射一个黑色（无内容）的帧，然后没有其他任何东西，直到我们获取到新的layers；</span></span><br><span class="line">    <span class="comment">//2.当一个Display被创建，包含了一个单独的空layer栈，我们将不会发射任何黑色的帧，知道一个Layers被添加到这个layer栈</span></span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//主显、外显：fsurfaceflinger/DisplayHardware/FramebufferSurface.h的beginFrame</span></span><br><span class="line">    <span class="comment">//虚拟显示：surfaceflinger/DisplayHardware/VirtualDisplaySurface.h的beginFrame</span></span><br><span class="line">    display-&gt;getRenderSurface()-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        display-&gt;editState().lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="prepareFrame准备数据"><a href="#prepareFrame准备数据" class="headerlink" title="prepareFrame准备数据"></a>prepareFrame准备数据</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::prepareFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!displayState.isEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = display-&gt;getRenderSurface()-&gt;prepareFrame();</span><br><span class="line">    ALOGE_IF(result != NO_ERROR, <span class="string">"prepareFrame failed for %s: %d (%s)"</span>,</span><br><span class="line">             displayDevice-&gt;getDebugName().c_str(), result, strerror(-result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/src/RenderSurface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">RenderSurface::prepareFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwc = mCompositionEngine.getHwComposer();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> id = mDisplay.getId();</span><br><span class="line">    <span class="keyword">if</span> (id) &#123;</span><br><span class="line">        <span class="comment">//查看HWC是否支持之前SurfaceFlinger决定的合成方式</span></span><br><span class="line">        <span class="keyword">status_t</span> error = hwc.prepare(*id, mDisplay);</span><br><span class="line">        <span class="keyword">if</span> (error != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合成方式</span></span><br><span class="line">    DisplaySurface::CompositionType compositionType;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasClient = hwc.hasClientComposition(id);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasDevice = hwc.hasDeviceComposition(id);</span><br><span class="line">    <span class="keyword">if</span> (hasClient &amp;&amp; hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_MIXED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasClient) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_GLES;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasDevice) &#123;</span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Nothing to do -- when turning the screen off we get a frame like</span></span><br><span class="line">        <span class="comment">// this. Call it a HWC frame since we won't be doing any GLES work but</span></span><br><span class="line">        <span class="comment">// will do a prepare/set cycle.</span></span><br><span class="line">        compositionType = DisplaySurface::COMPOSITION_HWC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mDisplaySurface-&gt;prepareFrame(compositionType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重要函数：</strong></p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::prepare</span><span class="params">(DisplayId displayId, <span class="keyword">const</span> compositionengine::Output&amp; output)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    displayData.validateWasSkipped = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//SurfaceFlinger没有指定得有Client端合成，即false</span></span><br><span class="line">    <span class="keyword">if</span> (!displayData.hasClientComposition) &#123;</span><br><span class="line">        sp&lt;Fence&gt; outPresentFence;</span><br><span class="line">        <span class="keyword">uint32_t</span> state = UINT32_MAX;</span><br><span class="line">        <span class="comment">//调用函数尝试直接present，如果HWC不能直接显示，再执行validate操纵</span></span><br><span class="line">        error = hwcDisplay-&gt;presentOrValidate(&amp;numTypes, &amp;numRequests, &amp;outPresentFence , &amp;state);</span><br><span class="line">        <span class="keyword">if</span> (error != HWC2::Error::HasChanges) &#123;</span><br><span class="line">            RETURN_IF_HWC_ERROR_FOR(<span class="string">"presentOrValidate"</span>, error, displayId, UNKNOWN_ERROR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果成功，数据显示，则不再执行后续流程</span></span><br><span class="line">        <span class="keyword">if</span> (state == <span class="number">1</span>) &#123; <span class="comment">//Present Succeeded.</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">            error = hwcDisplay-&gt;getReleaseFences(&amp;releaseFences);</span><br><span class="line">            displayData.releaseFences = <span class="built_in">std</span>::move(releaseFences);</span><br><span class="line">            displayData.lastPresentFence = outPresentFence;</span><br><span class="line">            displayData.validateWasSkipped = <span class="literal">true</span>;</span><br><span class="line">            displayData.presentError = error;</span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Present failed but Validate ran.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//调用validate</span></span><br><span class="line">        error = hwcDisplay-&gt;validate(&amp;numTypes, &amp;numRequests);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, HWC2::Composition&gt; changedTypes;</span><br><span class="line">    changedTypes.reserve(numTypes);</span><br><span class="line">    <span class="comment">//通过getChangedCompositionTypes函数获取到HWC对合成方式的修改，保存在changedTypes中</span></span><br><span class="line">    error = hwcDisplay-&gt;getChangedCompositionTypes(&amp;changedTypes);</span><br><span class="line">    RETURN_IF_HWC_ERROR_FOR(<span class="string">"getChangedCompositionTypes"</span>, error, displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    displayData.displayRequests = <span class="keyword">static_cast</span>&lt;HWC2::DisplayRequest&gt;(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, HWC2::LayerRequest&gt; layerRequests;</span><br><span class="line">    layerRequests.reserve(numRequests);</span><br><span class="line">    <span class="comment">//获取LayerRequest，保存在layerRequests中</span></span><br><span class="line">    error = hwcDisplay-&gt;getRequests(&amp;displayData.displayRequests,</span><br><span class="line">            &amp;layerRequests);</span><br><span class="line">    RETURN_IF_HWC_ERROR_FOR(<span class="string">"getRequests"</span>, error, displayId, BAD_INDEX);</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">//合成方式初始化为false</span></span><br><span class="line">    displayData.hasClientComposition = <span class="literal">false</span>;</span><br><span class="line">    displayData.hasDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//遍历Layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; outputLayer : output.getOutputLayersOrderedByZ()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; state = outputLayer-&gt;editState();</span><br><span class="line">        LOG_FATAL_IF(!state.hwc.);</span><br><span class="line">        <span class="keyword">auto</span> hwcLayer = (*state.hwc).hwcLayer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = changedTypes.find(hwcLayer.get()); it != changedTypes.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> newCompositionType = it-&gt;second;</span><br><span class="line">            validateChange(<span class="keyword">static_cast</span>&lt;HWC2::Composition&gt;((*state.hwc).hwcCompositionType),</span><br><span class="line">                           newCompositionType);</span><br><span class="line">            (*state.hwc).hwcCompositionType =</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;Hwc2::IComposerClient::Composition&gt;(newCompositionType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ((*state.hwc).hwcCompositionType) &#123;</span><br><span class="line">            <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT:</span><br><span class="line">                displayData.hasClientComposition = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Hwc2::IComposerClient::Composition::DEVICE:</span><br><span class="line">            <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SOLID_COLOR:</span><br><span class="line">            <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CURSOR:</span><br><span class="line">            <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SIDEBAND:</span><br><span class="line">                displayData.hasDeviceComposition = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//响应layerRequests</span></span><br><span class="line">        state.clearClientTarget = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> it = layerRequests.find(hwcLayer.get()); it != layerRequests.end()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> request = it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span> (request == HWC2::LayerRequest::ClearClientTarget) &#123;</span><br><span class="line">                state.clearClientTarget = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                LOG_DISPLAY_ERROR(displayId,</span><br><span class="line">                                  (<span class="string">"Unknown layer request "</span> + to_string(request)).c_str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后，通过HWC，SurfaceFlinger接受修改</span></span><br><span class="line">    error = hwcDisplay-&gt;acceptChanges();</span><br><span class="line">    RETURN_IF_HWC_ERROR_FOR(<span class="string">"acceptChanges"</span>, error, displayId, BAD_INDEX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>validate刷新：</strong></p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Display::validate</span><span class="params">(<span class="keyword">uint32_t</span>* outNumTypes, <span class="keyword">uint32_t</span>* outNumRequests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> numTypes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> numRequests = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//调用Composer::validateDisplay</span></span><br><span class="line">    <span class="keyword">auto</span> intError = mComposer.validateDisplay(mId, &amp;numTypes, &amp;numRequests);</span><br><span class="line">    <span class="keyword">auto</span> error = <span class="keyword">static_cast</span>&lt;Error&gt;(intError);</span><br><span class="line">    <span class="keyword">if</span> (error != Error::None &amp;&amp; error != Error::HasChanges) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *outNumTypes = numTypes;</span><br><span class="line">    *outNumRequests = numRequests;</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>validateDisplay</code>是通过CommandWriter写Buffer的方式调用到HWC中的，但是多了一个<code>execute</code>函数：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/ComposerHal.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">Composer::validateDisplay</span><span class="params">(Display display, <span class="keyword">uint32_t</span>* outNumTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span>* outNumRequests)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mWriter.selectDisplay(display);</span><br><span class="line">    <span class="comment">//Buffer命令的调用，只是将命令写到Buffer中</span></span><br><span class="line">    mWriter.validateDisplay();</span><br><span class="line">    <span class="comment">//真正的将触发HWC服务端解析Buffer命令，再分别取调HWC对应的实现函数</span></span><br><span class="line">    Error error = execute();</span><br><span class="line">    <span class="keyword">if</span> (error != Error::NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    mReader.hasChanges(display, outNumTypes, outNumRequests);</span><br><span class="line">    <span class="keyword">return</span> Error::NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="doDebugFlashRegions"><a href="#doDebugFlashRegions" class="headerlink" title="doDebugFlashRegions"></a>doDebugFlashRegions</h3><p>doDebugFlashRegions只是一个debug功能，受<code>mDebugRegion</code>控制（开发者选项）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDebugFlashRegions</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is debugging enabled</span></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(!mDebugRegion))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen's coordinate space</span></span><br><span class="line">        <span class="keyword">const</span> Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything);</span><br><span class="line">        <span class="keyword">if</span> (!dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            base::unique_fd readyFence;</span><br><span class="line">            <span class="comment">// redraw the whole screen</span></span><br><span class="line">            doComposeSurfaces(displayDevice, dirtyRegion, &amp;readyFence);</span><br><span class="line">            display-&gt;getRenderSurface()-&gt;queueBuffer(<span class="built_in">std</span>::move(readyFence));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postFramebuffer(displayDevice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDebugRegion &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        usleep(mDebugRegion * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prepareFrame(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="doComposition合成处理"><a href="#doComposition合成处理" class="headerlink" title="doComposition合成处理"></a>doComposition合成处理</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice, <span class="keyword">bool</span> repaintEverything)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"doComposition"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="comment">//获取rebuildLayerStacks时计算的当前显示设备的脏区域DirtyRegion</span></span><br><span class="line">        <span class="comment">//如果是强制重画，mRepaintEverything为true，那么脏区域就是整个屏幕的大小</span></span><br><span class="line">        <span class="comment">//1. 获取脏区域</span></span><br><span class="line">        <span class="keyword">const</span> Region dirtyRegion = display-&gt;getDirtyRegion(repaintEverything);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        <span class="comment">//2. 主要是对当前的显示设备上的所有不支持硬件合成Layer进行OpenGL合成处理</span></span><br><span class="line">        doDisplayComposition(displayDevice, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        display-&gt;editState().dirtyRegion.clear();</span><br><span class="line">        display-&gt;getRenderSurface()-&gt;flip();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统一交由HWC，由HWC硬件合成并输出到显示屏</span></span><br><span class="line">    postFramebuffer(displayDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>合成方式：</strong></p>
<ul>
<li><p>Client合成<br>Client合成方式是相对与硬件合成来说的，其合成方式是，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件。这个暂存缓冲区，我们称为FBTarget，每个Display设备有各自的FBTarget。Client合成，之前称为GLES合成，我们也可以称之为GPU合成。Client合成，采用RenderEngine进行合成。</p>
</li>
<li><p>Device合成<br>就是用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Devicehec的抽象。</p>
</li>
</ul>
<hr>
<h4 id="getDirtyRegion获取脏区域"><a href="#getDirtyRegion获取脏区域" class="headerlink" title="getDirtyRegion获取脏区域"></a>getDirtyRegion获取脏区域</h4><p>前面在<code>rebuildLayerStacks</code>重构Layer的时候，Display的脏区域DirtyRegion已经计算出来。如果重画，则mRepaintEverything为true，此时脏区域就是整个屏幕的大小。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/src/Output.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Region <span class="title">Output::getDirtyRegion</span><span class="params">(<span class="keyword">bool</span> repaintEverything)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="function">Region <span class="title">dirty</span><span class="params">(mState.viewport)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!repaintEverything) &#123;</span><br><span class="line">        dirty.andSelf(mState.dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dirty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="doDisplayComposition合成"><a href="#doDisplayComposition合成" class="headerlink" title="doDisplayComposition合成"></a>doDisplayComposition合成</h4><p>合成方式主要就两种，一种Client客户端用GPU合成；另外一种，Device端HWC硬件合成。<code>doComposeSurfaces</code>主要是处理Client端合成，通过<code>RenderEngine</code>用GPU来进行合成。</p>
<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::doDisplayComposition</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> Region&amp; inDirtyRegion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="comment">// 只有在以下情况下才去真正合成这个Display的图像:</span></span><br><span class="line">    <span class="comment">// 1) 需要HWC硬件合成</span></span><br><span class="line">    <span class="comment">// 2) 脏区域不为空</span></span><br><span class="line">    <span class="keyword">if</span> (!displayDevice-&gt;getId() &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"Skipping display composition"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"doDisplayComposition"</span>);</span><br><span class="line">    base::unique_fd readyFence;</span><br><span class="line">    <span class="comment">//调用doComposeSurfaces进行合成</span></span><br><span class="line">    <span class="keyword">if</span> (!doComposeSurfaces(displayDevice, Region::INVALID_REGION, &amp;readyFence)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将合成后的Buffer提交给该显示设备的BufferQueue,最终有FrameBufferSurface进行处理</span></span><br><span class="line">    <span class="comment">//swap buffers (presentation)</span></span><br><span class="line">    <span class="comment">//代码路径：frameworks/native/libs/gui/Surface.cpp</span></span><br><span class="line">    display-&gt;getRenderSurface()-&gt;queueBuffer(<span class="built_in">std</span>::move(readyFence));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="doComposeSurfaces"><a href="#doComposeSurfaces" class="headerlink" title="*doComposeSurfaces"></a>*doComposeSurfaces</h5><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doComposeSurfaces</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SurfaceFlinger::doComposeSurfaces</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> Region&amp; debugRegion, base::unique_fd* readyFence)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="comment">//RenderEngine初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Region <span class="title">bounds</span><span class="params">(displayState.bounds)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> DisplayRenderArea <span class="title">renderArea</span><span class="params">(displayDevice)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasClientComposition = getHwComposer().hasClientComposition(displayId);</span><br><span class="line">    ATRACE_INT(<span class="string">"hasClientComposition"</span>, hasClientComposition);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> applyColorMatrix = <span class="literal">false</span>;</span><br><span class="line">    renderengine::DisplaySettings clientCompositionDisplay;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;renderengine::LayerSettings&gt; clientCompositionLayers;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    base::unique_fd fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasClientComposition) &#123;</span><br><span class="line">        ALOGV(<span class="string">"hasClientComposition"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (displayDevice-&gt;isPrimary() &amp;&amp; supportProtectedContent) &#123;</span><br><span class="line">            <span class="keyword">bool</span> needsProtected = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//遍历layer</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">                <span class="comment">//如果layer受保护，则进行标记</span></span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isProtected()) &#123;</span><br><span class="line">                    needsProtected = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needsProtected != renderEngine.isProtected()) &#123;</span><br><span class="line">                renderEngine.useProtectedContext(needsProtected);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needsProtected != display-&gt;getRenderSurface()-&gt;isProtected() &amp;&amp;</span><br><span class="line">                needsProtected == renderEngine.isProtected()) &#123;</span><br><span class="line">                display-&gt;getRenderSurface()-&gt;setProtected(needsProtected);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Client合成Display的属性赋值</span></span><br><span class="line">        clientCompositionDisplay.physicalDisplay = displayState.scissor; <span class="comment">//主屏剪切区</span></span><br><span class="line">        clientCompositionDisplay.clip = displayState.scissor;</span><br><span class="line">        <span class="keyword">const</span> ui::Transform&amp; displayTransform = displayState.transform;</span><br><span class="line">        clientCompositionDisplay.globalTransform = displayTransform.asMatrix4();</span><br><span class="line">        clientCompositionDisplay.orientation = displayState.orientation;  <span class="comment">//屏幕转向</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span>* profile = display-&gt;getDisplayColorProfile();</span><br><span class="line">        Dataspace outputDataspace = Dataspace::UNKNOWN;</span><br><span class="line">        <span class="comment">//是否用WideColor，设置数据空间</span></span><br><span class="line">        <span class="keyword">if</span> (profile-&gt;hasWideColorGamut()) &#123;</span><br><span class="line">            outputDataspace = displayState.dataspace;</span><br><span class="line">        &#125;</span><br><span class="line">        clientCompositionDisplay.outputDataspace = outputDataspace;</span><br><span class="line">        clientCompositionDisplay.maxLuminance =</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (applyColorMatrix) &#123;</span><br><span class="line">            clientCompositionDisplay.colorTransform = displayState.colorTransformMat;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Client端Layer渲染到FrameBuffer（即FBTarget）</span></span><br><span class="line">    ALOGV(<span class="string">"Rendering client layers"</span>);</span><br><span class="line">    <span class="keyword">bool</span> firstLayer = <span class="literal">true</span>;</span><br><span class="line">    Region clearRegion = Region::INVALID_REGION;</span><br><span class="line">    <span class="comment">//遍历layer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getVisibleLayersSortedByZ()) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">viewportRegion</span><span class="params">(displayState.viewport)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">const</span> Region <span class="title">clip</span><span class="params">(viewportRegion.intersect(layer-&gt;visibleRegion))</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!clip.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (layer-&gt;getCompositionType(displayDevice)) &#123;</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CURSOR:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::DEVICE:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SIDEBAND:</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::SOLID_COLOR: &#123;</span><br><span class="line">                    LOG_ALWAYS_FATAL_IF(!displayId);</span><br><span class="line">                    <span class="function"><span class="keyword">const</span> Layer::State&amp; <span class="title">state</span><span class="params">(layer-&gt;getDrawingState())</span></span>;</span><br><span class="line">                    <span class="keyword">if</span> (layer-&gt;getClearClientTarget(displayDevice) &amp;&amp; !firstLayer &amp;&amp;</span><br><span class="line">                        layer-&gt;isOpaque(state) &amp;&amp; (layer-&gt;getAlpha() == <span class="number">1.0f</span>) &amp;&amp;</span><br><span class="line">                        layer-&gt;getRoundedCornerState().radius == <span class="number">0.0f</span> &amp;&amp; hasClientComposition) &#123;</span><br><span class="line">                        <span class="comment">//千万不要清除第一层，因为我们保证FB已经清除了</span></span><br><span class="line">                        renderengine::LayerSettings layerSettings;</span><br><span class="line">                        Region dummyRegion;</span><br><span class="line">                        <span class="comment">//调用该函数，此处有对受保护secure layer的处理（如果有数字保护协议，则会显示black layer）</span></span><br><span class="line">                        <span class="comment">//然后会将layer的clip区域绘制到FBTarget上</span></span><br><span class="line">                        <span class="keyword">bool</span> prepared =</span><br><span class="line">                                layer-&gt;prepareClientLayer(renderArea, clip, dummyRegion,</span><br><span class="line">                                                          supportProtectedContent, layerSettings);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                            layerSettings.source.buffer.buffer = <span class="literal">nullptr</span>;</span><br><span class="line">                            layerSettings.source.solidColor = half3(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">                            layerSettings.alpha = half(<span class="number">0.0</span>);</span><br><span class="line">                            layerSettings.disableBlending = <span class="literal">true</span>;</span><br><span class="line">                            clientCompositionLayers.push_back(layerSettings);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> Hwc2::IComposerClient::Composition::CLIENT: &#123;</span><br><span class="line">                    renderengine::LayerSettings layerSettings;</span><br><span class="line">                    <span class="comment">//同上</span></span><br><span class="line">                    <span class="keyword">bool</span> prepared =</span><br><span class="line">                            layer-&gt;prepareClientLayer(renderArea, clip, clearRegion,</span><br><span class="line">                                                      supportProtectedContent, layerSettings);</span><br><span class="line">                    <span class="keyword">if</span> (prepared) &#123;</span><br><span class="line">                        clientCompositionLayers.push_back(layerSettings);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"  Skipping for empty clip"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        firstLayer = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="postFramebuffer"><a href="#postFramebuffer" class="headerlink" title="postFramebuffer"></a>postFramebuffer</h4><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postFramebuffer</span><span class="params">(<span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"postFramebuffer"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> display = displayDevice-&gt;getCompositionDisplay();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; displayState = display-&gt;getState();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> displayId = display-&gt;getId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (displayState.isEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">            <span class="comment">//调用该函数获取releaseFence</span></span><br><span class="line">            getHwComposer().presentAndGetReleaseFences(*displayId);</span><br><span class="line">        &#125;</span><br><span class="line">        display-&gt;getRenderSurface()-&gt;onPresentDisplayCompleted();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : display-&gt;getOutputLayersOrderedByZ()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; releaseFence = Fence::NO_FENCE;</span><br><span class="line">            <span class="keyword">bool</span> usedClientComposition = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在这一帧的fence发出信号的时候，上一帧的layer buffer被HWC释放</span></span><br><span class="line">            <span class="comment">//始终先从HWC处获取释放fence</span></span><br><span class="line">            <span class="keyword">if</span> (layer-&gt;getState().hwc) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span>&amp; hwcState = *layer-&gt;getState().hwc;</span><br><span class="line">                releaseFence =</span><br><span class="line">                        getHwComposer().getLayerReleaseFence(*displayId, hwcState.hwcLayer.get());</span><br><span class="line">                usedClientComposition =</span><br><span class="line">                        hwcState.hwcCompositionType == Hwc2::IComposerClient::Composition::CLIENT;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果层在上一帧中是Client客户端合成的，则需要与前一个Client客户端获取的fence合并。</span></span><br><span class="line">            <span class="comment">//因为我们不跟踪它，所以当它可用时，总是与当前客户端Fence合并，即使这是子选项</span></span><br><span class="line">            <span class="keyword">if</span> (usedClientComposition) &#123;</span><br><span class="line">                releaseFence =</span><br><span class="line">                        Fence::merge(<span class="string">"LayerRelease"</span>, releaseFence,</span><br><span class="line">                                     display-&gt;getRenderSurface()-&gt;getClientTargetAcquireFence());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            layer-&gt;getLayerFE().onLayerDisplayed(releaseFence);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们有一列需要fence的layer，它们与display-&gt;getVisibleLayersSortedByZ不相交。</span></span><br><span class="line">        <span class="comment">//我们能做的最好的就是给他们提供现有的fence</span></span><br><span class="line">        <span class="keyword">if</span> (!displayDevice-&gt;getLayersNeedingFences().isEmpty()) &#123;</span><br><span class="line">            sp&lt;Fence&gt; presentFence =</span><br><span class="line">                    displayId ? getHwComposer().getPresentFence(*displayId) : Fence::NO_FENCE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : displayDevice-&gt;getLayersNeedingFences()) &#123;</span><br><span class="line">                layer-&gt;getCompositionLayer()-&gt;getLayerFE()-&gt;onLayerDisplayed(presentFence);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (displayId) &#123;</span><br><span class="line">            <span class="comment">//清除</span></span><br><span class="line">            getHwComposer().clearReleaseFences(*displayId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="postComposition"><a href="#postComposition" class="headerlink" title="postComposition"></a>postComposition</h3><figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::postComposition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"postComposition"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用Layer的onPostComposition， 处理Layer中刚刚绘制的Buffer的Fence</span></span><br><span class="line">    <span class="comment">//此时才会真正释放掉一个Buffer</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> dequeueReadyTime = systemTime();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">        <span class="comment">//这一帧合成完成后，将会被替代的Buffer释放掉</span></span><br><span class="line">        layer-&gt;releasePendingBuffer(dequeueReadyTime);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//记录Buffer状态</span></span><br><span class="line">    mDrawingState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameLatched =</span><br><span class="line">                layer-&gt;onPostComposition(displayDevice-&gt;getId(), glCompositionDoneFenceTime,</span><br><span class="line">                                         presentFenceTime, compositorTiming);</span><br><span class="line">        <span class="keyword">if</span> (frameLatched) &#123;</span><br><span class="line">            recordBufferingStats(layer-&gt;getName().<span class="built_in">string</span>(),</span><br><span class="line">                    layer-&gt;getOccupancyHistory(<span class="literal">false</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//VSYNC是由mScheduler分发出来的，并不是每一次都是从底层硬件上报的</span></span><br><span class="line">    <span class="comment">//所以mScheduler需要和底层硬件Vsync保持同步</span></span><br><span class="line">    <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">        mScheduler-&gt;addPresentFence(presentFenceTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Vsync同步</span></span><br><span class="line">    <span class="keyword">if</span> (!hasSyncFramework) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId()) &amp;&amp;</span><br><span class="line">            displayDevice-&gt;isPoweredOn()) &#123;</span><br><span class="line">            mScheduler-&gt;enableHardwareVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动画合成处理</span></span><br><span class="line">    <span class="keyword">if</span> (mAnimCompositionPending) &#123;</span><br><span class="line">        mAnimCompositionPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (presentFenceTime-&gt;isValid()) &#123;</span><br><span class="line">            mAnimFrameTracker.setActualPresentFence(</span><br><span class="line">                    <span class="built_in">std</span>::move(presentFenceTime));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displayDevice &amp;&amp; getHwComposer().isConnected(*displayDevice-&gt;getId())) &#123;</span><br><span class="line">            <span class="comment">// The HWC doesn't support present fences, so use the refresh</span></span><br><span class="line">            <span class="comment">// timestamp instead.</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">nsecs_t</span> presentTime =</span><br><span class="line">                    getHwComposer().getRefreshTimestamp(*displayDevice-&gt;getId());</span><br><span class="line">            mAnimFrameTracker.setActualPresentTime(presentTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//advanceFrame处理FBTarget</span></span><br><span class="line">        mAnimFrameTracker.advanceFrame();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//处理时间的记录</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，REFRESH处理完成。之后等到下一个Vsync周期，开始下一次合成。</p>
<h4 id="advanceFrame"><a href="#advanceFrame" class="headerlink" title="advanceFrame"></a>advanceFrame</h4><p>其中调用advanceFrame方法，虚显用的<code>VirtualDisplaySurface</code>，非虚显用的<code>FramebufferSurface</code>。advanceFrame获取FBTarget的数据：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::advanceFrame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> slot = <span class="number">0</span>;</span><br><span class="line">    sp&lt;GraphicBuffer&gt; buf;</span><br><span class="line">    <span class="function">sp&lt;Fence&gt; <span class="title">acquireFence</span><span class="params">(Fence::NO_FENCE)</span></span>;</span><br><span class="line">    Dataspace dataspace = Dataspace::UNKNOWN;</span><br><span class="line">    <span class="keyword">status_t</span> result = nextBuffer(slot, buf, acquireFence, dataspace);</span><br><span class="line">    mDataSpace = dataspace;</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error latching next FramebufferSurface buffer: %s (%d)"</span>,</span><br><span class="line">                strerror(-result), result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">FramebufferSurface::nextBuffer</span><span class="params">(<span class="keyword">uint32_t</span>&amp; outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;GraphicBuffer&gt;&amp; outBuffer, sp&lt;Fence&gt;&amp; outFence,</span></span></span><br><span class="line"><span class="function"><span class="params">        Dataspace&amp; outDataspace)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    BufferItem item;</span><br><span class="line">    <span class="comment">//1.获取一个Buffer（在上面doComposition - doDisplayComposition函数最后调用queueBuffer，会放到FrameBufferSurface的BufferQueue中）</span></span><br><span class="line">    <span class="comment">//此处的函数将从这个BufferQueue中获取一个Buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> err = acquireBufferLocked(&amp;item, <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//2.当前Buffer序号mCurrentBufferSlot，当前Buffer是mCurrentBuffer，对应的Fence是mCurrentFence</span></span><br><span class="line">    <span class="comment">//如果上面获取到的Buffer不一样，则将Current置为Previous上一个buffer，否则没有变化</span></span><br><span class="line">    <span class="keyword">if</span> (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &amp;&amp;</span><br><span class="line">        item.mSlot != mCurrentBufferSlot) &#123;</span><br><span class="line">        mHasPendingRelease = <span class="literal">true</span>;</span><br><span class="line">        mPreviousBufferSlot = mCurrentBufferSlot;</span><br><span class="line">        mPreviousBuffer = mCurrentBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.将获取到的Buffer置为当前的Current</span></span><br><span class="line">    mCurrentBufferSlot = item.mSlot;</span><br><span class="line">    mCurrentBuffer = mSlots[mCurrentBufferSlot].mGraphicBuffer;</span><br><span class="line">    mCurrentFence = item.mFence;</span><br><span class="line"></span><br><span class="line">    outFence = item.mFence;</span><br><span class="line">    mHwcBufferCache.getHwcBuffer(mCurrentBufferSlot, mCurrentBuffer, &amp;outSlot, &amp;outBuffer);</span><br><span class="line">    outDataspace = <span class="keyword">static_cast</span>&lt;Dataspace&gt;(item.mDataSpace);</span><br><span class="line">    <span class="comment">//4.将FBTarget设置给HWC  （头文件HWComposer&amp; mHwc;）</span></span><br><span class="line">    <span class="keyword">status_t</span> result = mHwc.setClientTarget(mDisplayId, outSlot, outFence, outBuffer, outDataspace);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        ALOGE(<span class="string">"error posting framebuffer: %d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setClientTarget函数：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HWComposer::setClientTarget</span><span class="params">(DisplayId displayId, <span class="keyword">uint32_t</span> slot,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> sp&lt;Fence&gt;&amp; acquireFence, <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; target,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     ui::Dataspace dataspace)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头文件：std::unordered_map&lt;DisplayId, DisplayData&gt; mDisplayData;</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcDisplay = mDisplayData[displayId].hwcDisplay;</span><br><span class="line">    <span class="comment">//FBTarget是通过Command Buffer的方式传到HWC中的</span></span><br><span class="line">    <span class="keyword">auto</span> error = hwcDisplay-&gt;setClientTarget(slot, target, acquireFence, dataspace);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HWComposer头文件，hwcDisplay在HWC2命名空间内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisplayData</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isVirtual = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasClientComposition = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> hasDeviceComposition = <span class="literal">false</span>;</span><br><span class="line">    HWC2::Display* hwcDisplay = <span class="literal">nullptr</span>;</span><br><span class="line">    HWC2::DisplayRequest displayRequests;</span><br><span class="line">    sp&lt;Fence&gt; lastPresentFence = Fence::NO_FENCE; <span class="comment">// signals when the last set op retires</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;HWC2::Layer*, sp&lt;Fence&gt;&gt; releaseFences;</span><br><span class="line">    <span class="keyword">buffer_handle_t</span> outbufHandle = <span class="literal">nullptr</span>;</span><br><span class="line">    sp&lt;Fence&gt; outbufAcquireFence = Fence::NO_FENCE;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int32_t</span>,</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> HWC2::Display::Config&gt;&gt; configMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> validateWasSkipped;</span><br><span class="line">    HWC2::Error presentError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vsyncTraceToggle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::mutex vsyncEnabledLock;</span><br><span class="line">    <span class="function">HWC2::Vsync vsyncEnabled <span class="title">GUARDED_BY</span><span class="params">(vsyncEnabledLock)</span> </span>= HWC2::Vsync::Disable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex lastHwVsyncLock;</span><br><span class="line">    <span class="function"><span class="keyword">nsecs_t</span> lastHwVsync <span class="title">GUARDED_BY</span><span class="params">(lastHwVsyncLock)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="GPU合成模块概述"><a href="#GPU合成模块概述" class="headerlink" title="GPU合成模块概述"></a>GPU合成模块概述</h2><p>硬件HWC合成是由Vendor实现。而各个厂商在这部分的实现不同。</p>
<p>GPU合成（Client）是Android原生自带的，本质是采用GPU进程合成，SurfaceFlinger模块封装了RenderEngine进行具体的实现。</p>
<p>看一下这个模块的文件目录：</p>
<figure class="highlight plain"><figcaption><span>frameworks/native/libs/renderengine</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">├── Android.bp</span><br><span class="line">├── Description.cpp</span><br><span class="line">├── gl</span><br><span class="line">│   ├── GLESRenderEngine.cpp</span><br><span class="line">│   ├── GLESRenderEngine.h</span><br><span class="line">│   ├── GLExtensions.cpp</span><br><span class="line">│   ├── GLExtensions.h</span><br><span class="line">│   ├── GLFramebuffer.cpp</span><br><span class="line">│   ├── GLFramebuffer.h</span><br><span class="line">│   ├── GLImage.cpp</span><br><span class="line">│   ├── GLImage.h</span><br><span class="line">│   ├── ProgramCache.cpp</span><br><span class="line">│   ├── ProgramCache.h</span><br><span class="line">│   ├── Program.cpp</span><br><span class="line">│   └── Program.h</span><br><span class="line">├── include</span><br><span class="line">│   └── renderengine</span><br><span class="line">│       ├── DisplaySettings.h</span><br><span class="line">│       ├── Framebuffer.h</span><br><span class="line">│       ├── Image.h</span><br><span class="line">│       ├── LayerSettings.h</span><br><span class="line">│       ├── Mesh.h</span><br><span class="line">│       ├── mock</span><br><span class="line">│       │   ├── Framebuffer.h</span><br><span class="line">│       │   ├── Image.h</span><br><span class="line">│       │   └── RenderEngine.h</span><br><span class="line">│       ├── private</span><br><span class="line">│       │   └── Description.h</span><br><span class="line">│       ├── RenderEngine.h</span><br><span class="line">│       └── Texture.h</span><br><span class="line">├── Mesh.cpp</span><br><span class="line">├── mock</span><br><span class="line">│   ├── Framebuffer.cpp</span><br><span class="line">│   ├── Image.cpp</span><br><span class="line">│   └── RenderEngine.cpp</span><br><span class="line">├── OWNERS</span><br><span class="line">├── RenderEngine.cpp</span><br><span class="line">├── TEST_MAPPING</span><br><span class="line">├── tests</span><br><span class="line">│   ├── Android.bp</span><br><span class="line">│   └── RenderEngineTest.cpp</span><br><span class="line">└── Texture.cpp</span><br></pre></td></tr></table></figure>

<h3 id="创建RenderEngine"><a href="#创建RenderEngine" class="headerlink" title="创建RenderEngine"></a>创建RenderEngine</h3><p>在SF.cpp初始化函数init中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// TODO(b/77156734): We need to stop casting and use HAL types when possible.</span></span><br><span class="line">    <span class="comment">// Sending maxFrameBufferAcquiredBuffers as the cache size is tightly tuned to single-display.</span></span><br><span class="line">    mCompositionEngine-&gt;setRenderEngine(</span><br><span class="line">            renderengine::RenderEngine::create(<span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(defaultCompositionPixelFormat),</span><br><span class="line">                                               renderEngineFeature, maxFrameBufferAcquiredBuffers));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>create调用RenderEngine.cpp中的对应函数：（在Q版本该模块已经独立出来，该模块是对GPU渲染的封装）</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/libs/renderengine/RenderEngine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;impl::RenderEngine&gt; <span class="title">RenderEngine::create</span><span class="params">(<span class="keyword">int</span> hwcFormat, <span class="keyword">uint32_t</span> featureFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                         <span class="keyword">uint32_t</span> imageCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">    property_get(PROPERTY_DEBUG_RENDERENGINE_BACKEND, prop, <span class="string">"gles"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(prop, <span class="string">"gles"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGD(<span class="string">"RenderEngine GLES Backend"</span>);</span><br><span class="line">        <span class="keyword">return</span> renderengine::gl::GLESRenderEngine::create(hwcFormat, featureFlags, imageCacheSize);</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">"UNKNOWN BackendType: %s, create GLES RenderEngine."</span>, prop);</span><br><span class="line">    <span class="keyword">return</span> renderengine::gl::GLESRenderEngine::create(hwcFormat, featureFlags, imageCacheSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;GLESRenderEngine&gt; <span class="title">GLESRenderEngine::create</span><span class="params">(<span class="keyword">int</span> hwcFormat, <span class="keyword">uint32_t</span> featureFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                           <span class="keyword">uint32_t</span> imageCacheSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建EGLDisplay</span></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">//初始化EGLDisplay</span></span><br><span class="line">    <span class="keyword">if</span> (!eglInitialize(display, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"failed to initialize EGL"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//选择EGLConfig</span></span><br><span class="line">    EGLConfig config = EGL_NO_CONFIG;</span><br><span class="line">    <span class="keyword">if</span> (!extensions.hasNoConfigContext()) &#123;</span><br><span class="line">        config = chooseEglConfig(display, hwcFormat, <span class="comment">/*logConfig*/</span> <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建EGLContext</span></span><br><span class="line">    <span class="comment">//在该函数中:</span></span><br><span class="line">    <span class="comment">//1.调用eglGetConfigAttrib获取renderableType、</span></span><br><span class="line">    <span class="comment">//2.初始化Context属性contextAttributes、</span></span><br><span class="line">    <span class="comment">//3.调用eglCreateContext创建EGLContext</span></span><br><span class="line">    <span class="keyword">if</span> ((featureFlags &amp; RenderEngine::ENABLE_PROTECTED_CONTEXT) &amp;&amp;</span><br><span class="line">        extensions.hasProtectedContent()) &#123;</span><br><span class="line">        protectedContext = createEglContext(display, config, <span class="literal">nullptr</span>, useContextPriority,</span><br><span class="line">                                            Protection::PROTECTED);</span><br><span class="line">        ALOGE_IF(protectedContext == EGL_NO_CONTEXT, <span class="string">"Can't create protected context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLContext ctxt = createEglContext(display, config, protectedContext, useContextPriority,</span><br><span class="line">                                       Protection::UNPROTECTED);</span><br><span class="line">    ...</span><br><span class="line">    EGLSurface dummy = EGL_NO_SURFACE;</span><br><span class="line">    <span class="keyword">if</span> (!extensions.hasSurfacelessContext()) &#123;</span><br><span class="line">        <span class="comment">//创建PBuffer</span></span><br><span class="line">        dummy = createDummyEglPbufferSurface(display, config, hwcFormat, Protection::UNPROTECTED);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//查看可以获取到什么版本的GL</span></span><br><span class="line">    GlesVersion version = parseGlesVersion(extensions.getVersion());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化当前GL的渲染器RenderEngine</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;GLESRenderEngine&gt; engine;</span><br><span class="line">    <span class="keyword">switch</span> (version) &#123;</span><br><span class="line">        <span class="keyword">case</span> GLES_VERSION_1_0:</span><br><span class="line">        <span class="keyword">case</span> GLES_VERSION_1_1:</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"SurfaceFlinger requires OpenGL ES 2.0 minimum to run."</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> GLES_VERSION_2_0:</span><br><span class="line">        <span class="keyword">case</span> GLES_VERSION_3_0:</span><br><span class="line">            engine = <span class="built_in">std</span>::make_unique&lt;GLESRenderEngine&gt;(featureFlags, display, config, ctxt, dummy,</span><br><span class="line">                                                        protectedContext, protectedDummy,</span><br><span class="line">                                                        imageCacheSize);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Surface-FBTarget"><a href="#创建Surface-FBTarget" class="headerlink" title="创建Surface FBTarget"></a>创建Surface FBTarget</h3><p>RenderEngine创建时始化的EGLDisplaym，EGLConfig，EGLContext等，都是所有Display共用的。</p>
<p>而Surface每个Display的是自己的，在创建DisplayDevice时，创建对应的Surface。</p>
<p>从BufferQueue中dequeue Buffer进行渲染，swapBuffer时，也queue到Bufferqueu中。这里的ANativeWindow，本质就是FBTarget。</p>
<h3 id="创建Texture纹理"><a href="#创建Texture纹理" class="headerlink" title="创建Texture纹理"></a>创建Texture纹理</h3><p>在BufferLayer创建的构造函数中创建Texture：</p>
<figure class="highlight cpp"><figcaption><span>BufferLayer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferLayer::BufferLayer(<span class="keyword">const</span> LayerCreationArgs&amp; args)</span><br><span class="line">      : Layer(args),</span><br><span class="line">      <span class="comment">//调用SurfaceFlinger的getNewTexture创建</span></span><br><span class="line">      <span class="comment">//在创建BufferLayerConsumer时，传到了Consumer中，对应的值为mTexName</span></span><br><span class="line">        mTextureName(args.flinger-&gt;getNewTexture()),</span><br><span class="line">        mCompositionLayer&#123;mFlinger-&gt;getCompositionEngine().createLayer(</span><br><span class="line">                compositionengine::LayerCreationArgs&#123;<span class="keyword">this</span>&#125;)&#125; &#123;</span><br><span class="line">                    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span>SF.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">SurfaceFlinger::getNewTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// The pool was empty, so we need to get a new texture name directly using a</span></span><br><span class="line">    <span class="comment">// blocking call to the main thread</span></span><br><span class="line">    <span class="keyword">uint32_t</span> name = <span class="number">0</span>;</span><br><span class="line">    postMessageSync(<span class="keyword">new</span> LambdaMessage([&amp;]() &#123; getRenderEngine().genTextures(<span class="number">1</span>, &amp;name); &#125;));</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用genTextures：</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GLESRenderEngine::genTextures</span><span class="params">(<span class="keyword">size_t</span> count, <span class="keyword">uint32_t</span>* names)</span> </span>&#123;</span><br><span class="line">    glGenTextures(count, names);  <span class="comment">//生成Texture，在BufferLayer中保存在mTexture中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="绑定Texture纹理"><a href="#绑定Texture纹理" class="headerlink" title="绑定Texture纹理"></a>绑定Texture纹理</h3><p>在<code>BufferLayerConsumer::updateTexImage</code>函数中调用<code>bindTextureImageLocked</code>绑定新的buffer到GL Texture纹理。</p>
<p>而该函数是在SurfaceFlinger调用latchBuffer从BufferQueue申请获取渲染好的buffer的时候会调用到。</p>
<h3 id="Layer合成"><a href="#Layer合成" class="headerlink" title="Layer合成"></a>Layer合成</h3><p>在Q版本之前是调用的<code>onDraw</code>函数，而在Q上函数名变成<code>prepareClientLayer</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BufferLayer::prepareClientLayer</span><span class="params">(<span class="keyword">const</span> RenderArea&amp; renderArea, <span class="keyword">const</span> Region&amp; clip,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">bool</span> useIdentityTransform, Region&amp; clearRegion,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> <span class="keyword">bool</span> supportProtectedContent,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     renderengine::LayerSettings&amp; layer)</span> </span>&#123;</span><br><span class="line">                                        ...</span><br><span class="line">    <span class="comment">//DRM处理，是否阻塞当前Layer                                        </span></span><br><span class="line">    <span class="keyword">bool</span> blackOutLayer =</span><br><span class="line">            (isProtected() &amp;&amp; !supportProtectedContent) || (isSecure() &amp;&amp; !renderArea.isSecure());</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>SurfaceFlinger::doComposeSurfaces</code>函数中，调用完prepareClientLayer后，末尾最后调用<code>renderEngine.drawLayers</code>函数。</p>
<p>最终调用到GPU合成模块<code>frameworks/native/libs/renderengine/gl/GLESRenderEngine.cpp</code>的<code>GLESRenderEngine::drawLayers</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">GLESRenderEngine::drawLayers</span><span class="params">(<span class="keyword">const</span> DisplaySettings&amp; display,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LayerSettings&gt;&amp; layers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ANativeWindowBuffer* <span class="keyword">const</span> buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">const</span> <span class="keyword">bool</span> useFramebufferCache, base::unique_fd&amp;&amp; bufferFence,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      base::unique_fd* drawFence)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//Texture坐标顶点</span></span><br><span class="line">            renderengine::<span class="function">Mesh::VertexArray&lt;vec2&gt; <span class="title">texCoords</span><span class="params">(mesh.getTexCoordArray&lt;vec2&gt;())</span></span>;</span><br><span class="line">            texCoords[<span class="number">0</span>] = vec2(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            texCoords[<span class="number">1</span>] = vec2(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            texCoords[<span class="number">2</span>] = vec2(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">            texCoords[<span class="number">3</span>] = vec2(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// Buffer sources will have a black solid color ignored in the shader,</span></span><br><span class="line">            <span class="comment">// so in that scenario the solid color passed here is arbitrary.</span></span><br><span class="line">            <span class="comment">//处理Alpha的Blend</span></span><br><span class="line">            setupLayerBlending(usePremultipliedAlpha, isOpaque, disableTexture, color,</span><br><span class="line">                               layer.geometry.roundedCornersRadius);</span><br><span class="line">                                      &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// We only want to do a special handling for rounded corners when having rounded corners</span></span><br><span class="line">            <span class="comment">// is the only reason it needs to turn on blending, otherwise, we handle it like the</span></span><br><span class="line">            <span class="comment">// usual way since it needs to turn on blending anyway.</span></span><br><span class="line">            <span class="keyword">if</span> (layer.geometry.roundedCornersRadius &gt; <span class="number">0.0</span> &amp;&amp; color.a &gt;= <span class="number">1.0f</span> &amp;&amp; isOpaque) &#123;</span><br><span class="line">                handleRoundedCorners(display, layer, mesh);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//绘制（合成）内容</span></span><br><span class="line">                <span class="comment">//该函数中使用glDrawArrays函数进行绘制（合成）</span></span><br><span class="line">                drawMesh(mesh);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://developer.android.google.cn/reference/android/graphics/BlendMode" target="_blank" rel="noopener">Google Developers - BlendMode</a></li>
<li><a href="https://www.jianshu.com/p/fa115146949f" target="_blank" rel="noopener">SurfaceFlinger合成流程(一)</a></li>
<li><a href="https://www.jianshu.com/p/fd16dcb4dfb6" target="_blank" rel="noopener">SurfaceFlinger合成流程(二)</a></li>
<li><a href="https://wizzie.top/Blog/2019/09/22/2019/190922-android-handler-cpp/#SurfaceFlinger%E7%9A%84%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">Android Handler消息循环处理机制</a></li>
<li><a href="https://wizzie.top/Blog/2020/07/30/2020/200730_android_GraphicsFramework/" target="_blank" rel="noopener">Android 图形显示框架</a></li>
<li><a href="https://blog.csdn.net/u013686019/article/details/51614774" target="_blank" rel="noopener">Android BitTube</a></li>
<li><a href="https://blog.csdn.net/dabenxiong666/article/details/80629316" target="_blank" rel="noopener">Android之BitTube</a></li>
<li><a href="https://blog.csdn.net/weixin_41054077/article/details/105735639" target="_blank" rel="noopener">基于Android Q分析SurfaceFlinger启动过程</a></li>
<li><a href="https://wizzie.top/Blog/2019/12/22/2019/191222_android_HWC2/#mCurrentState%E5%92%8CmDrawingState" target="_blank" rel="noopener">Android SurfaceFlinger和HWC2概述 - mCurrentState和mDrawingState</a></li>
<li><a href="https://www.jianshu.com/p/b0928eaaeb1c" target="_blank" rel="noopener">SurfaceFlinger图像合成[1]</a></li>
</ul>

                    </article>
                    
    <blockquote class="post-license">
        <p>
            <strong>本文作者&nbsp;:&nbsp;sunwengang</strong>
            <br>
            <strong>
            
                本文使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)</a> 协议
            </strong>
            <br>
            <strong>本文链接&nbsp;:&nbsp;</strong><a href="https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/">https://alonealive.github.io/Blog/2020/10/31/2020/201031_android_SurfaceFlinger2/</a>
        </p>
    </blockquote>



    <blockquote id="date-expire-notification" class="post-expired-notify">本文最后更新于 <span id="date-expire-num"></span> 天前，文中所描述的信息可能已发生改变</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2020-11-04");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2020-10-31T10:42:00.000Z" itemprop="datePublished">2020-10-31</time>

    , 最后修改于&nbsp;<time datetime="2020-11-04T13:45:14.666Z" itemprop="dateModified">2020-11-04</time>

</p>
<p class="post-footer-info mb-0 pt-2">

<span class="post-categories-list mt-2">

<a class="post-categories-list-item" href='/Blog/categories/android/'>android</a>

</span>



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/Blog/tags/android/" rel="tag">#&nbsp;android</a>

<a class="post-tags-list-item" href="/Blog/tags/graphics/" rel="tag">#&nbsp;graphics</a>

<a class="post-tags-list-item" href="/Blog/tags/display/" rel="tag">#&nbsp;display</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/Blog/2020/10/15/2020/201015_android_SurfaceFlinger1/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android Q SurfaceFlinger合成（一）</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                        <div class="card-footer post-comment">
                            <div id="vcomments"></div>

<script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' === 'true';
    var verify = '' === 'true';
    new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        appId: "vhY87VAxwU991O4b7vDREoC7-gzGzoHsz",
        appKey: "CftrDkclI3ylGGjiQeD8C2xz",
        placeholder: "Just go go",
        meta: guest_info,
        pageSize:'10',
        avatar:'identicon',
        lang:'zh-cn',
        guest_info: guest_info,
        visitor: false
    });
</script>

                        </div>
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="https://alonealive.github.io/Blog">sunwengang blog</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};

(function() {
    var copyrightNow = new Date().getFullYear();
    var copyrightContent = document.getElementById('copyright-year');
    var copyrightSince = 2019;
    if (copyrightSince === copyrightNow) {
        copyrightContent.textContent = copyrightNow;
    } else {
        copyrightContent.textContent = copyrightSince + ' - ' + copyrightNow;
    }
})();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/Blog/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->

    
        
    


<!-- ### Custom Footer ### -->

    </body>

</html>