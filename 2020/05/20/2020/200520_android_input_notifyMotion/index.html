<!DOCTYPE html>

<html lang="zh-CN">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->






    <link rel="dns-prefetch" href="//cdn1.lncld.net">


<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>Android InputDispatcher获取点击事件 | sunwengang blog</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/Blog/img/favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/Blog/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #8E354A;
    }

    a:active, a:focus, a:hover {
        color: #8E354A;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #8E354A;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #8E354A;
    }

    .navbar-link:hover {
        color: #8E354A;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/Blog/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/Blog/css/highlight/arduino-light.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/Blog/css/highlight/arduino-light.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/Blog/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="sunwengang blog"><meta name="msapplication-starturl" content="https://alonealive.github.io/Blog"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="sunwengang blog"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="Android InputDispatcher获取点击事件 | sunwengang blog"><meta property="og:site_name" content="sunwengang blog"><meta property="og:type" content="article"><meta property="og:url" content="https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/"><meta property="og:locale" content="zh-CN"><meta name="description" content="Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。参考上一篇《Android 触控事件分析》   Input down&#x2F;up事件查看在开发者选项打开“显示点按操作反馈”和“指针位置”，通过adb shell getevent -lrt命令，然后点击屏幕可以查看到控制台的 - sunwengang - sunwengang blog"><meta name="keywords" content="display, input"><meta property="article:published_time" content="2020-05-20T15:52:00.000Z"><meta property="article:modified_time" content="2021-05-31T12:52:52.107Z"><meta property="og:updated_time" content="2021-05-31T12:52:52.107Z"><meta property="article:author" content="sunwengang"><meta property="article:tag" content="display, input"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/">

    <meta name="generator" content="Hexo 4.2.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/",
    "@type": "BlogPosting",
    "logo": "https://alonealive.github.io/Blog/img/favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/"
    },
    "headline": "Android InputDispatcher获取点击事件 | sunwengang blog",
    
    "image": {
        "@type": "ImageObject",
        "url": "https://alonealive.github.io/Blog/img/favicon.ico"
    },
    
    "datePublished": "2020-05-20T15:52:00.000Z",
    "dateModified": "2021-05-31T12:52:52.107Z",
    "author": {
        "@type": "Person",
        "name": "sunwengang",
        "image": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/head.jpg"
        },
        "description": "developer | android display/graphics"
    },
    "publisher": {
        "@type": "Organization",
        "name": "sunwengang blog",
        "logo": {
            "@type": "ImageObject",
            "url": "https://alonealive.github.io/Blog/img/favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "https://alonealive.github.io/Blog/Blog/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "display, input",
    "description": "Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。参考上一篇《Android 触控事件分析》   Input down/up事件查看在开发者选项打开“显示点按操作反馈”和“指针位置”，通过adb shell getevent -lrt命令，然后点击屏幕可以查看到控制台的 - sunwengang - sunwengang blog"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/Blog/">sunwengang blog</a></h1>

    <p class="text-center header-slogan">
        
            
                developer | android display/graphics
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/Blog/" class="navbar-link">首页</a>
    
    
        <a href="/Blog/archives/" class="navbar-link">归档</a>
    
    
        <a href="/Blog/search" class="navbar-link">搜索</a>
    
    
        <a href="/Blog/tags" class="navbar-link">标签</a>
    
        <a href="/Blog/html/nav.html" class="navbar-link">导航</a>
    
        <a href="/Blog/links" class="navbar-link">友链</a>
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">分享</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=sunwengang blog&url=https://alonealive.github.io/Blog&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=sunwengang blog&url=https://alonealive.github.io/Blog&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog&title=Android InputDispatcher获取点击事件" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=Android InputDispatcher获取点击事件&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog&text=Android InputDispatcher获取点击事件" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACLUlEQVR42u3a204DMQxF0fn/n4YnJCQmPttpK9p4zwuolJkVqU59yfX1AdclUqRIkW+AvIrr5++/37f6vz8PKN5PnityNvL2QwteXy0k4fD9RY5Grm5WYVLwkfuXzxUpsviAV2gSYCJFPhtJkobVYu7+X6TI3QSjumm1gFhkPTMLEnkckiYIz/75kmpR5Mcj6Qd8lWCQKwXLw101kUch75IAummvEghS0JGFiJyLvGtuVolutTjaME1YkbOR3YKs2pxTIysVayJFpmI/NUnTpk6TGBQ4IkchyYaeNuU0GK2CEw1ARY5AdpvyK1gq4lJQtqtFkcci6YGO3d9pUx9l5iLHIHeGR7TQqhKJ6gtE5Fwk2XirRgDd/FNTthyAihyHTAMh2thKh+hIcr0MHJFjkJ3Dcd1Elizy4aRX5HHIneEnCRr6JYGSXpHjkNVNq0K+M5SnxZ5IkZ3klgTW7oAfJxgij0cSAP3wkyR6q2ElchSyM9B8NGnoFHoiZyPpASMynEpfBK1hgMjRyGoguUxKG69Xw6bW4SWRxyPJ8Cg9jBZ1pLEqUmR3w01JbhxqwiaYyLnIlNDS5ANv0LDBJXIukjYJ6GZeBQcZ6LenDyKPQ3Yb8qnIJ4PQtBCRIlPA0IN2BEAO2YkUWb15pynaOUTSOngsUiQs+EkgdRsPIkV2DmZ2kt+dYbxIkSTBIAFAg48sRORsZCrEaOOqCsSU6OKTAyKPR77zJVKkSJH/eH0D0qmXpjak1HgAAAAASUVORK5CYII=" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">Android InputDispatcher获取点击事件</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/Blog/img/head.jpg" src="/Blog/img/suka-lazyload.gif" alt="sunwengang's Avatar">
        <span>2020-05-20</span>
        
            <span class="suka-devide-dot"></span>
            <a class="category-link" href="/Blog/categories/android/">android</a>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">分享本文</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=Android InputDispatcher获取点击事件&url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/&pic=https://alonealive.github.io/Blog/img/favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">分享到微博</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=Android InputDispatcher获取点击事件&url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/&via=sunwengang" target="_blank" rel="external noopener noreferrer nofollow">分享到 Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/" target="_blank" rel="external noopener noreferrer nofollow">分享到 Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/&title=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=sunwengang blog&title=sunwengang blog&summary=&pics=https://alonealive.github.io/Blog/img/favicon.ico&url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/" target="_blank" rel="external noopener noreferrer nofollow"> 分享到 QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/&text=sunwengang blog" target="_blank" rel="external noopener noreferrer nofollow">分享到 Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKQAAACkCAAAAAA83tqdAAACLUlEQVR42u3a204DMQxF0fn/n4YnJCQmPttpK9p4zwuolJkVqU59yfX1AdclUqRIkW+AvIrr5++/37f6vz8PKN5PnityNvL2QwteXy0k4fD9RY5Grm5WYVLwkfuXzxUpsviAV2gSYCJFPhtJkobVYu7+X6TI3QSjumm1gFhkPTMLEnkckiYIz/75kmpR5Mcj6Qd8lWCQKwXLw101kUch75IAummvEghS0JGFiJyLvGtuVolutTjaME1YkbOR3YKs2pxTIysVayJFpmI/NUnTpk6TGBQ4IkchyYaeNuU0GK2CEw1ARY5AdpvyK1gq4lJQtqtFkcci6YGO3d9pUx9l5iLHIHeGR7TQqhKJ6gtE5Fwk2XirRgDd/FNTthyAihyHTAMh2thKh+hIcr0MHJFjkJ3Dcd1Elizy4aRX5HHIneEnCRr6JYGSXpHjkNVNq0K+M5SnxZ5IkZ3klgTW7oAfJxgij0cSAP3wkyR6q2ElchSyM9B8NGnoFHoiZyPpASMynEpfBK1hgMjRyGoguUxKG69Xw6bW4SWRxyPJ8Cg9jBZ1pLEqUmR3w01JbhxqwiaYyLnIlNDS5ANv0LDBJXIukjYJ6GZeBQcZ6LenDyKPQ3Yb8qnIJ4PQtBCRIlPA0IN2BEAO2YkUWb15pynaOUTSOngsUiQs+EkgdRsPIkV2DmZ2kt+dYbxIkSTBIAFAg48sRORsZCrEaOOqCsSU6OKTAyKPR77zJVKkSJH/eH0D0qmXpjak1HgAAAAASUVORK5CYII=" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Input-down-up事件查看"><span class="post-toc-number">1.</span> <span class="post-toc-text">Input down&#x2F;up事件查看</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#systrace分析"><span class="post-toc-number">2.</span> <span class="post-toc-text">systrace分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#input-debug开关打开抓取日志分析"><span class="post-toc-number">3.</span> <span class="post-toc-text">input debug开关打开抓取日志分析</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#日志打印分析代码流程"><span class="post-toc-number">4.</span> <span class="post-toc-text">日志打印分析代码流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#inputReader通过QueuedInputListener"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">inputReader通过QueuedInputListener</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InputDispatcher获取数据"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">InputDispatcher获取数据</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InputDispatcherThread分发线程被唤醒"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">InputDispatcherThread分发线程被唤醒</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#InputDispatcher事件处理"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">InputDispatcher事件处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#InputTarget结构体"><span class="post-toc-number">4.4.1.</span> <span class="post-toc-text">InputTarget结构体</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#处理点击事件findTouchedWindowTargetsLocked"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">处理点击事件findTouchedWindowTargetsLocked</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#dispatchEventLocked向目标窗口发送事件"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">dispatchEventLocked向目标窗口发送事件</span></a></li></ol></li></ol></div>
                        
                    
                    <article id="post-content">
                        <blockquote>
<p>Input点击事件从InputReader会传到InputDispatcher进行处理。针对一些点击调试方式和日志打印，来分析InputDispatcher获取点击事件的部分流程。<br>参考上一篇<a href="http://wizzie.top/Blog/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">《Android 触控事件分析》</a></p>
</blockquote>
<!--mode-->
<h2 id="Input-down-up事件查看"><a href="#Input-down-up事件查看" class="headerlink" title="Input down/up事件查看"></a>Input down/up事件查看</h2><p>在开发者选项打开“显示点按操作反馈”和“指针位置”，通过<code>adb shell getevent -lrt</code>命令，然后点击屏幕可以查看到控制台的打印。</p>
<p>查看帮助：<code>adb shell getevent -h</code></p>
<p>打印结果包含Input的down/up事件，以及点击点的坐标（十六进制）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   0000003b            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_X    0000017e            &#x2F;&#x2F;横坐标X&#x3D;382  十六进制转成十进制&#x3D;》 1*16*16+7*16+14*1&#x3D;382</span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_POSITION_Y    0000032d            &#x2F;&#x2F;纵坐标Y&#x3D;813  十六进制转成十进制&#x3D;》 3*16*16+2*16+13*1&#x3D;813  </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   0000000a            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      000003e8            </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            DOWN                </span><br><span class="line">[    1423.973137] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TOUCH_MAJOR   00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_PRESSURE      00000000            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_ABS       ABS_MT_TRACKING_ID   ffffffff            </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_KEY       BTN_TOUCH            UP                  </span><br><span class="line">[    1436.084174] &#x2F;dev&#x2F;input&#x2F;event2: EV_SYN       SYN_REPORT           00000000             rate 0</span><br></pre></td></tr></table></figure>

<h2 id="systrace分析"><a href="#systrace分析" class="headerlink" title="systrace分析"></a>systrace分析</h2><p>抓取Systrace可以查看到触屏的整个事件，从InputReader开始，然后到deliverInputEvent触发APP绘制。关于报点可以重点关注inputflinger模块的log打印，会打印input的坐标。<br>(参考：<a href="http://wizzie.top/Blog/2020/03/17/2020/200317_adnroid_touchEvent/" target="_blank" rel="noopener">《Android 触控事件分析》</a>)</p>
<h2 id="input-debug开关打开抓取日志分析"><a href="#input-debug开关打开抓取日志分析" class="headerlink" title="input debug开关打开抓取日志分析"></a>input debug开关打开抓取日志分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb shell setprop sys.input.TouchFilterEnable true</span><br><span class="line">adb shell setprop sys.input.TouchFilterLogEnable true</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_FOCUS</span><br><span class="line">adb shell dumpsys window -d enable DEBUG_INPUT</span><br><span class="line">adb shell setprop sys.inputlog.enabled true</span><br><span class="line">adb shell dumpsys input</span><br></pre></td></tr></table></figure>

<p>然后抓取log可以看到类似<code>InputDispatcher: notifyMotion</code>、<code>dispatchMotion</code>这些日志打印。</p>
<h2 id="日志打印分析代码流程"><a href="#日志打印分析代码流程" class="headerlink" title="日志打印分析代码流程"></a>日志打印分析代码流程</h2><h3 id="inputReader通过QueuedInputListener"><a href="#inputReader通过QueuedInputListener" class="headerlink" title="inputReader通过QueuedInputListener"></a>inputReader通过QueuedInputListener</h3><p>负责读取触摸事件交给 InputDispatcher 进行事件派发。</p>
<ol>
<li>首先在构造函数中new一个QueueListener对象：</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputReader.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">InputReader::InputReader(<span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; policy,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) :</span><br><span class="line">        mContext(<span class="keyword">this</span>), mEventHub(eventHub), mPolicy(policy),</span><br><span class="line">        mNextSequenceNum(<span class="number">1</span>), mGlobalMetaState(<span class="number">0</span>), mGeneration(<span class="number">1</span>),</span><br><span class="line">        mDisableVirtualKeysTimeout(LLONG_MIN), mNextTimeout(LLONG_MAX),</span><br><span class="line">        mConfigurationChangesToRefresh(<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/// M: for nwk @&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *func;</span><br><span class="line">    <span class="comment">/// @&#125;</span></span><br><span class="line">    mQueuedListener = <span class="keyword">new</span> QueuedInputListener(listener);</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>InputReader::loopOnce()</code>循环等待消息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputReader::loopOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> oldGeneration;</span><br><span class="line">    <span class="keyword">int32_t</span> timeoutMillis;</span><br><span class="line">    <span class="keyword">bool</span> inputDevicesChanged = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputDeviceInfo&gt; inputDevices;</span><br><span class="line">    ...</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>flush刷新将遍历QueuedInputListener中<code>mArgsQueue</code>的数组元素，触发每一个元素NotifyArgs的<code>notify</code>方法，交给内部InputDispatcher，清空数组。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueuedInputListener::flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">        args-&gt;notify(mInnerListener);</span><br><span class="line">        <span class="keyword">delete</span> args;</span><br><span class="line">    &#125;</span><br><span class="line">    mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>结构体NotifyMotionArgs/NotifySwitchArgs/NotifyDeviceResetArgs继承自NotifyArgs，所以执行NotifyArgs的<code>notify</code>函数。调用派发者InputDispatcher的通知notifyMotion，将自己交给派发者。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputListener.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NotifyMotionArgs::notify</span><span class="params">(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    listener-&gt;notifyMotion(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="InputDispatcher获取数据"><a href="#InputDispatcher获取数据" class="headerlink" title="InputDispatcher获取数据"></a>InputDispatcher获取数据</h3><ol>
<li>触发InputDispatcher.cpp的<code>notifyMotion</code>函数，读取线程InputReaderThread在处理事务，notifyMotion方法之后会唤醒分发线程，接下来的任务就由分发线程处理。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::notifyMotion</span><span class="params">(<span class="keyword">const</span> NotifyMotionArgs* args)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_INBOUND_EVENT_DETAILS   <span class="comment">//打开了input debug log后会打印以下log</span></span></span><br><span class="line">    ALOGD(<span class="string">"notifyMotion - eventTime=%"</span> PRId64 <span class="string">", deviceId=%d, source=0x%x, displayId=%"</span> PRId32</span><br><span class="line">            <span class="string">", policyFlags=0x%x, "</span></span><br><span class="line">            <span class="string">"action=0x%x, actionButton=0x%x, flags=0x%x, metaState=0x%x, buttonState=0x%x,"</span></span><br><span class="line">            <span class="string">"edgeFlags=0x%x, xPrecision=%f, yPrecision=%f, downTime=%"</span> PRId64,</span><br><span class="line">            args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, args-&gt;displayId, args-&gt;policyFlags,</span><br><span class="line">            args-&gt;action, args-&gt;actionButton, args-&gt;flags, args-&gt;metaState, args-&gt;buttonState,</span><br><span class="line">            args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; args-&gt;pointerCount; i++) &#123;</span><br><span class="line">        ALOGD(<span class="string">"  Pointer %d: id=%d, toolType=%d, "</span></span><br><span class="line">                <span class="string">"x=%f, y=%f, pressure=%f, size=%f, "</span></span><br><span class="line">                <span class="string">"touchMajor=%f, touchMinor=%f, toolMajor=%f, toolMinor=%f, "</span></span><br><span class="line">                <span class="string">"orientation=%f"</span>,</span><br><span class="line">                i, args-&gt;pointerProperties[i].id,</span><br><span class="line">                args-&gt;pointerProperties[i].toolType,</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_X),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_Y),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_PRESSURE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_SIZE),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOUCH_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MAJOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_TOOL_MINOR),</span><br><span class="line">                args-&gt;pointerCoords[i].getAxisValue(AMOTION_EVENT_AXIS_ORIENTATION));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">        <span class="comment">// Just enqueue a new motion event. //将NotifyMotionArgs的数据封装为MotionEntry</span></span><br><span class="line">        MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;sequenceNum, args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags,</span><br><span class="line">                args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">                args-&gt;metaState, args-&gt;buttonState, args-&gt;classification,</span><br><span class="line">                args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">                args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//插入InputDispatcher的mInboundQueue队列中</span></span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">        mLock.unlock();</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;   <span class="comment">//需要唤醒分发线程</span></span><br><span class="line">        mLooper-&gt;wake();  <span class="comment">//TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note：</strong>注意：mLooper属于InputDispatcher，InputManager创建InputDispatcher时，在其构造方法同时创建mLooper，创建的线程是服务线程，并非读取或分发线程<br>这里只是借用了Looper提供的epoll唤醒与休眠机制，在分发线程中InputDispatcherThread中使用mLooper休眠，读取线程负责唤醒。</p>
<ol start="2">
<li>数据封装成MotionEntry，然后作为enqueueInboundEventLocked函数的入参，插入到mInboundQueue队列尾部。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::enqueueInboundEventLocked</span><span class="params">(EventEntry* entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br></pre></td></tr></table></figure>

<h3 id="InputDispatcherThread分发线程被唤醒"><a href="#InputDispatcherThread分发线程被唤醒" class="headerlink" title="InputDispatcherThread分发线程被唤醒"></a>InputDispatcherThread分发线程被唤醒</h3><blockquote>
<p>参考：<a href="http://wizzie.top/2020/05/10/2020/200510_android_inputANR/" target="_blank" rel="noopener">http://wizzie.top/2020/05/10/2020/200510_android_inputANR/</a></p>
</blockquote>
<ol>
<li>在InputDispatcherThread线程threadLoop循环中，触发InputDispatcher的dispatchOnce方法。然后调用dispatchOnce方法。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcherThread::threadLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher-&gt;dispatchOnce();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//下次唤醒事件，设置无限大</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        <span class="built_in">std</span>::scoped_lock _l(mLock);</span><br><span class="line">        mDispatcherIsAlive.notify_all();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//mCommandQueue为空时，触发dispatchOnceInnerLocked</span></span><br><span class="line">        <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">            dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">        <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">        <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;         <span class="comment">//mCommandQueue为空时是false</span></span><br><span class="line">            nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    <span class="comment">//计算下一次唤醒时间，比当前时间大</span></span><br><span class="line">    <span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用Looper在epoll_wait处进入休眠，休眠timeoutMillis时间仍无事件，threadLoop会一直循环，继续dispatchOnce。<br>当被唤醒时，执行switch循环进入dispatchOnceInnerLocked取出队列中的事件。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchOnceInnerLocked</span><span class="params">(<span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    ...</span><br><span class="line">        <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            traceInboundQueueLengthLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poke user activity for this event.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingEvent-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            pokeUserActivityLocked(mPendingEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get ready to dispatch the event.</span></span><br><span class="line">        resetANRTimeoutsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mPendingEvent的type做区分处理，此处对motion事件分析</span></span><br><span class="line">    ALOG_ASSERT(mPendingEvent != <span class="literal">nullptr</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">        MotionEntry* typedEntry = <span class="keyword">static_cast</span>&lt;MotionEntry*&gt;(mPendingEvent);</span><br><span class="line">        <span class="comment">//如果没有及时响应窗口切换操作</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; isAppSwitchDue) &#123;</span><br><span class="line">            dropReason = DROP_REASON_APP_SWITCH;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//事件过期</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED</span><br><span class="line">                &amp;&amp; isStaleEvent(currentTime, typedEntry)) &#123;</span><br><span class="line">            dropReason = DROP_REASON_STALE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻碍其他窗口获取事件</span></span><br><span class="line">        <span class="keyword">if</span> (dropReason == DROP_REASON_NOT_DROPPED &amp;&amp; mNextUnblockedEvent) &#123;</span><br><span class="line">            dropReason = DROP_REASON_BLOCKED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处执行事件</span></span><br><span class="line">        done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p><strong>Notes:</strong>Looper借助epoll机制实现线程休眠，它本身内部有套接字mWakeEventFd，在rebuildEpollLocked建立时，注册到epoll_ctl监听。因此wake方法就是向mWakeEventFd套接字发送一段字符，促使epoll_wait处的线程能监听到，从而InputDispatcherThread线程被唤醒。</p>
<h3 id="InputDispatcher事件处理"><a href="#InputDispatcher事件处理" class="headerlink" title="InputDispatcher事件处理"></a>InputDispatcher事件处理</h3><ol>
<li>InputDispatcher#dispatchMotionLocked处理MotionEntry。此处函数开头会有类似<code>InputDispatcher: dispatchMotion - eventTime= ...</code>的日志打印。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入参：dropReason代表了事件丢弃的原因，它的默认值为DROP_REASON_NOT_DROPPED，代表事件不被丢弃</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InputDispatcher::dispatchMotionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">nsecs_t</span> currentTime, MotionEntry* entry, DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();   <span class="comment">//systrace抓取</span></span><br><span class="line">    <span class="comment">//*************1**************//</span></span><br><span class="line">    <span class="comment">// Preprocessing. 即标记当前已经进入分发的过程</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;dispatchInProgress) &#123;</span><br><span class="line">        entry-&gt;dispatchInProgress = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        logOutboundMotionDetails(<span class="string">"dispatchMotion - "</span>, entry);    <span class="comment">//log打印</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*************2**************//</span></span><br><span class="line">   <span class="comment">// Clean up if dropping the event. 如果事件是需要丢弃的，则返回true，不会去为该事件寻找合适的窗口</span></span><br><span class="line">    <span class="keyword">if</span> (*dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">        setInjectionResult(entry, *dropReason == DROP_REASON_POLICY</span><br><span class="line">                ? INPUT_EVENT_INJECTION_SUCCEEDED : INPUT_EVENT_INJECTION_FAILED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">//此时就是事件被丢弃了，分发任务就没有完成！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************3*************//</span></span><br><span class="line">    <span class="keyword">bool</span> isPointerEvent = entry-&gt;source &amp; AINPUT_SOURCE_CLASS_POINTER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标窗口信息列表会存储在inputTargets中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt; inputTargets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> conflictingPointerActions = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult;</span><br><span class="line">    <span class="comment">//事件处理的结果交由injectionResult</span></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="comment">//1. 处理点击形式的事件，比如触摸屏幕</span></span><br><span class="line">        injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//2. 处理非触摸形式的事件，比如轨迹球</span></span><br><span class="line">        injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">                entry, inputTargets, nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//**************4*************//</span></span><br><span class="line">    <span class="comment">//1. 如果injectionResult的值为INPUT_EVENT_INJECTION_PENDING，这说明找到了窗口并且窗口无响应输入事件被挂起，这时就会返回false</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult == INPUT_EVENT_INJECTION_PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setInjectionResult(entry, injectionResult);</span><br><span class="line">    <span class="comment">//2. 如果injectionResult的值不为INPUT_EVENT_INJECTION_SUCCEEDED，这说明没有找到合适的窗口，输入事件没有分发成功，这时就会返回true</span></span><br><span class="line">    <span class="comment">//输入事件被挂起，说明找到了窗口并且窗口无响应</span></span><br><span class="line">    <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_SUCCEEDED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (injectionResult != INPUT_EVENT_INJECTION_PERMISSION_DENIED) &#123;</span><br><span class="line">            <span class="function">CancelationOptions::Mode <span class="title">mode</span><span class="params">(isPointerEvent ?</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_POINTER_EVENTS :</span></span></span><br><span class="line"><span class="function"><span class="params">                    CancelationOptions::CANCEL_NON_POINTER_EVENTS)</span></span>;</span><br><span class="line">            <span class="function">CancelationOptions <span class="title">options</span><span class="params">(mode, <span class="string">"input event injection failed"</span>)</span></span>;</span><br><span class="line">            synthesizeCancelationEventsForMonitorsLocked(options);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**************5*************//</span></span><br><span class="line">    <span class="comment">//分发目标添加到inputTargets列表中    // Add monitor channels from event's or focused display.</span></span><br><span class="line">    addGlobalMonitoringTargetsLocked(inputTargets, getTargetDisplayId(entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPointerEvent) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> stateIndex = mTouchStatesByDisplay.indexOfKey(entry-&gt;displayId);</span><br><span class="line">        <span class="keyword">if</span> (stateIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> TouchState&amp; state = mTouchStatesByDisplay.valueAt(stateIndex);</span><br><span class="line">            <span class="keyword">if</span> (!state.portalWindows.empty()) &#123;</span><br><span class="line">                <span class="comment">// The event has gone through these portal windows, so we add monitoring targets of</span></span><br><span class="line">                <span class="comment">// the corresponding displays as well.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; state.portalWindows.size(); i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> InputWindowInfo* windowInfo = state.portalWindows[i]-&gt;getInfo();</span><br><span class="line">                    addGlobalMonitoringTargetsLocked(inputTargets, windowInfo-&gt;portalToDisplayId,</span><br><span class="line">                            -windowInfo-&gt;frameLeft, -windowInfo-&gt;frameTop);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the motion.</span></span><br><span class="line">    <span class="keyword">if</span> (conflictingPointerActions) &#123;</span><br><span class="line">        <span class="function">CancelationOptions <span class="title">options</span><span class="params">(CancelationOptions::CANCEL_POINTER_EVENTS,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="string">"conflicting pointer actions"</span>)</span></span>;</span><br><span class="line">        synthesizeCancelationEventsForAllConnectionsLocked(options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将事件分发给inputTargets列表中的目标</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h4 id="InputTarget结构体"><a href="#InputTarget结构体" class="headerlink" title="InputTarget结构体"></a>InputTarget结构体</h4><p>InputTarget结构体可以说是inputDispatcher与目标窗口的转换器。<br>其分为两大部分：</p>
<ol>
<li>一个是枚举中存储的inputDispatcher与目标窗口交互的标记，</li>
<li>另一部分是inputDispatcher与目标窗口交互参数，比如：</li>
</ol>
<ul>
<li><code>inputChannel</code>，它实际上是一个SocketPair，SocketPair用于进程间双向通信，这非常适合inputDispatcher与目标窗口之间的通信，因为inputDispatcher不仅要将事件分发到目标窗口，同时inputDispatcher也需要得到目标窗口对事件的响应。</li>
<li><code>xOffset和yOffset</code>，屏幕坐标系相对于目标窗口坐标系的偏移量，MotionEntry(MotionEvent)中的存储的坐标是屏幕坐标系，因此就需要注释2和注释3处的参数，来将屏幕坐标系转换为目标窗口的坐标系。</li>
</ul>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputTarget</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">//此标记表示事件正在交付给前台应用程序</span></span><br><span class="line">    FLAG_FOREGROUND = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line">    <span class="comment">//此标记指示MotionEvent位于目标区域内</span></span><br><span class="line">    FLAG_WINDOW_IS_OBSCURED = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    ...</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//inputDispatcher与目标窗口的通信管道</span></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel;<span class="comment">//1</span></span><br><span class="line">    <span class="comment">//事件派发的标记</span></span><br><span class="line">    <span class="keyword">int32_t</span> flags;</span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的偏移量</span></span><br><span class="line">    <span class="keyword">float</span> xOffset, yOffset;<span class="comment">//2</span></span><br><span class="line">    <span class="comment">//屏幕坐标系相对于目标窗口坐标系的缩放系数</span></span><br><span class="line">    <span class="keyword">float</span> scaleFactor;<span class="comment">//3</span></span><br><span class="line">    BitSet32 pointerIds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="处理点击事件findTouchedWindowTargetsLocked"><a href="#处理点击事件findTouchedWindowTargetsLocked" class="headerlink" title="处理点击事件findTouchedWindowTargetsLocked"></a>处理点击事件findTouchedWindowTargetsLocked</h3><blockquote>
<p>参考：<a href="https://www.codercto.com/a/52484.html" target="_blank" rel="noopener">https://www.codercto.com/a/52484.html</a><br>在函数dispatchMotionLocked中，会分别对Motion事件中的点击形式事件和非触摸形式事件做了处理。其中点击事件调用函数<code>findTouchedWindowTargetsLocked</code>。</p>
</blockquote>
<p>函数末尾会打印类似日志<code>InputDispatcher: findTouchedWindow finished: injectionResult=0, injectionPermission=1, timeSpentWaitingForApplication=0.0ms</code>，injectionResult=0是succeed，injectionPermission=1是允许。</p>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int32_t</span> <span class="title">InputDispatcher::findTouchedWindowTargetsLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> MotionEntry* entry, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets, <span class="keyword">nsecs_t</span>* nextWakeupTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span>* outConflictingPointerActions)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL(); <span class="comment">//systrace</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (newGesture || (isSplit &amp;&amp; maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) &#123;</span><br><span class="line">        <span class="comment">/* Case 1: New splittable pointer going down, or need target for hover or scroll. */</span></span><br><span class="line">        <span class="comment">//从MotionEntry中获取坐标点</span></span><br><span class="line">        <span class="keyword">int32_t</span> pointerIndex = getMotionEventActionPointerIndex(action);</span><br><span class="line">        <span class="keyword">int32_t</span> x = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_X));</span><br><span class="line">        <span class="keyword">int32_t</span> y = <span class="keyword">int32_t</span>(entry-&gt;pointerCoords[pointerIndex].</span><br><span class="line">                getAxisValue(AMOTION_EVENT_AXIS_Y));</span><br><span class="line">        <span class="keyword">bool</span> isDown = maskedAction == AMOTION_EVENT_ACTION_DOWN;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//将符合条件的窗口放入TempTouchState中，以便后续处理</span></span><br><span class="line">        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);</span><br><span class="line">        &#125;</span><br><span class="line">        mTempTouchState.addGestureMonitors(newGestureMonitors);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Case 2: Pointer move, up, cancel or non-splittable pointer down. */</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处说明窗口已经查找成功</span></span><br><span class="line">    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;</span><br><span class="line">    <span class="comment">//为每个mTempTouchState中的窗口生成InputTargets</span></span><br><span class="line">    addWindowTargetLocked(focusedWindowHandle,</span><br><span class="line">            InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS, BitSet32(<span class="number">0</span>),</span><br><span class="line">            inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Done.</span></span><br><span class="line">        Unresponsive:</span><br><span class="line">    <span class="comment">// Reset temporary touch state to ensure we release unnecessary references to input channels.</span></span><br><span class="line">    <span class="comment">//重置TempTouchState</span></span><br><span class="line">    mTempTouchState.reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);</span><br><span class="line">    updateDispatchStatistics(currentTime, entry, injectionResult, timeSpentWaitingForApplication);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_FOCUS</span></span><br><span class="line">    <span class="comment">//日志打印输出</span></span><br><span class="line">    ALOGD(<span class="string">"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, "</span></span><br><span class="line">            <span class="string">"timeSpentWaitingForApplication=%0.1fms"</span>,</span><br><span class="line">            injectionResult, injectionPermission, timeSpentWaitingForApplication / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> injectionResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dispatchEventLocked向目标窗口发送事件"><a href="#dispatchEventLocked向目标窗口发送事件" class="headerlink" title="dispatchEventLocked向目标窗口发送事件"></a>dispatchEventLocked向目标窗口发送事件</h3><ol>
<li>上面函数dispatchMotionLocked的末尾，会执行<code>dispatchEventLocked</code>函数，将事件分发给inputTargets列表中的分发目标（目标窗口）。</li>
</ol>
<figure class="highlight cpp"><figcaption><span>frameworks/native/services/inputflinger/InputDispatcher.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::dispatchEventLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        EventEntry* eventEntry, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;InputTarget&gt;&amp; inputTargets)</span> </span>&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE</span></span><br><span class="line">    ALOGD(<span class="string">"dispatchEventToCurrentInputTargets"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    ALOG_ASSERT(eventEntry-&gt;dispatchInProgress); <span class="comment">// should already have been set to true</span></span><br><span class="line"></span><br><span class="line">    pokeUserActivityLocked(eventEntry);</span><br><span class="line">    <span class="comment">//遍历inputTargets列表，获取每一个inputTarget</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> InputTarget&amp; inputTarget : inputTargets) &#123;</span><br><span class="line">        <span class="comment">//1. 根据inputTarget内部的inputChannel来获取Connection的索引</span></span><br><span class="line">        <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">        <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//2. 根据索引，获取保存在mConnectionsByFd容器中的Connection（可以理解为InputDispatcher和目标窗口的连接，其内部包含了连接的状态、InputChannel、InputWindowHandle和事件队列等）</span></span><br><span class="line">            sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">            <span class="comment">//3. 根据inputTarget，开始事件发送循环</span></span><br><span class="line">            prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">#<span class="keyword">if</span> DEBUG_FOCUS</span><br><span class="line">            ALOGD(<span class="string">"Dropping event delivery to target with channel '%s' because it "</span></span><br><span class="line">                    <span class="string">"is no longer registered with the input dispatcher."</span>,</span><br><span class="line">                    inputTarget.inputChannel-&gt;getName().c_str());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>开始事件发送，最终会通过inputTarget中的inputChannel和窗口进行<code>进程间通信</code>，最终将Motion事件发送给目标窗口。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::prepareDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(</span><br><span class="line">                <span class="string">"prepareDispatchCycleLocked(inputChannel=%s, sequenceNum=%"</span> PRIu32 <span class="string">")"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str(), eventEntry-&gt;sequenceNum);</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ prepareDispatchCycle - flags=0x%08x, "</span></span><br><span class="line">            <span class="string">"xOffset=%f, yOffset=%f, globalScaleFactor=%f, "</span></span><br><span class="line">            <span class="string">"windowScaleFactor=(%f, %f), pointerIds=0x%x"</span>,</span><br><span class="line">            connection-&gt;getInputChannelName().c_str(), inputTarget-&gt;flags,</span><br><span class="line">            inputTarget-&gt;xOffset, inputTarget-&gt;yOffset,</span><br><span class="line">            inputTarget-&gt;globalScaleFactor,</span><br><span class="line">            inputTarget-&gt;windowXScale, inputTarget-&gt;windowYScale,</span><br><span class="line">            inputTarget-&gt;pointerIds.value);</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后调用startDispatchCycleLocked（在函数dispatchMotionLocked末尾处），最终调用两种事件的<code>connection-&gt;inputPublisher...</code>函数，至此，InputDisapatcher结束。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InputDispatcher::startDispatchCycleLocked</span><span class="params">(<span class="keyword">nsecs_t</span> currentTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ATRACE_ENABLED()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> message = StringPrintf(<span class="string">"startDispatchCycleLocked(inputChannel=%s)"</span>,</span><br><span class="line">                connection-&gt;getInputChannelName().c_str());</span><br><span class="line">        ATRACE_NAME(message.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG_DISPATCH_CYCLE   <span class="comment">//日志打印！</span></span></span><br><span class="line">    ALOGD(<span class="string">"channel '%s' ~ startDispatchCycle"</span>,</span><br><span class="line">    ...</span><br><span class="line">      <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source, keyEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_MOTION: &#123;</span><br><span class="line">    <span class="comment">// Publish the motion event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishMotionEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    motionEntry-&gt;deviceId, motionEntry-&gt;source, motionEntry-&gt;displayId,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, motionEntry-&gt;actionButton,</span><br><span class="line">                    dispatchEntry-&gt;resolvedFlags, motionEntry-&gt;edgeFlags,</span><br><span class="line">                    motionEntry-&gt;metaState, motionEntry-&gt;buttonState, motionEntry-&gt;classification,</span><br><span class="line">                    xOffset, yOffset, motionEntry-&gt;xPrecision, motionEntry-&gt;yPrecision,</span><br><span class="line">                    motionEntry-&gt;downTime, motionEntry-&gt;eventTime,</span><br><span class="line">                    motionEntry-&gt;pointerCount, motionEntry-&gt;pointerProperties,</span><br><span class="line">                    usingCoords);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure>

                    </article>
                    
    <blockquote class="post-license">
        <p>
            <strong>本文作者&nbsp;:&nbsp;sunwengang</strong>
            <br>
            <strong>
            
                本文使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)</a> 协议
            </strong>
            <br>
            <strong>本文链接&nbsp;:&nbsp;</strong><a href="https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/">https://alonealive.github.io/Blog/2020/05/20/2020/200520_android_input_notifyMotion/</a>
        </p>
    </blockquote>



    <blockquote id="date-expire-notification" class="post-expired-notify">本文最后更新于 <span id="date-expire-num"></span> 天前，文中所描述的信息可能已发生改变</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2021-05-31");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">本文发表于&nbsp;<time datetime="2020-05-20T15:52:00.000Z" itemprop="datePublished">2020-05-20</time>

    , 最后修改于&nbsp;<time datetime="2021-05-31T12:52:52.107Z" itemprop="dateModified">2021-05-31</time>

</p>
<p class="post-footer-info mb-0 pt-2">

<span class="post-categories-list mt-2">

<a class="post-categories-list-item" href='/Blog/categories/android/'>android</a>

</span>



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/Blog/tags/display/" rel="tag">#&nbsp;display</a>

<a class="post-tags-list-item" href="/Blog/tags/input/" rel="tag">#&nbsp;input</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/Blog/2020/06/01/2020/200601_android_rotation/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android 屏幕旋转流程</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/Blog/2020/05/10/2020/200510_android_inputANR/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Android Input事件ANR流程</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                        <div class="card-footer post-comment">
                            <div id="vcomments"></div>

<script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
<script>
    var GUEST_INFO = ['nick','mail','link'];
    var guest_info = 'nick,mail,link'.split(',').filter(function(item){
        return GUEST_INFO.indexOf(item) > -1
    });
    var notify = '' === 'true';
    var verify = '' === 'true';
    new Valine({
        el: '#vcomments',
        notify: notify,
        verify: verify,
        appId: "vhY87VAxwU991O4b7vDREoC7-gzGzoHsz",
        appKey: "CftrDkclI3ylGGjiQeD8C2xz",
        placeholder: "Just go go",
        meta: guest_info,
        pageSize:'10',
        avatar:'identicon',
        lang:'zh-cn',
        guest_info: guest_info,
        visitor: false
    });
</script>

                        </div>
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="https://alonealive.github.io/Blog">sunwengang blog</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};

(function() {
    var copyrightNow = new Date().getFullYear();
    var copyrightContent = document.getElementById('copyright-year');
    var copyrightSince = 2019;
    if (copyrightSince === copyrightNow) {
        copyrightContent.textContent = copyrightNow;
    } else {
        copyrightContent.textContent = copyrightSince + ' - ' + copyrightNow;
    }
})();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/Blog/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->

    
        
    


<!-- ### Custom Footer ### -->

    </body>

</html>